import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, e as element, t as text, c as claim_element, a as children, b as claim_text, f as detach_dev, g as add_location, h as attr_dev, j as insert_dev, k as append_dev, n as noop, l as create_slot, o as onMount, m as onDestroy, p as destroy_each, q as listen_dev, r as space, u as claim_space, v as get_slot_context, w as get_slot_changes, x as transition_in, y as transition_out, z as run_all, A as binding_callbacks, B as assign, C as exclude_internal_props, D as svg_element, E as xlink_attr, F as null_to_empty, G as create_component, H as claim_component, I as mount_component, J as destroy_component, K as createEventDispatcher, L as empty, M as set_attributes, N as toggle_class, O as set_input_value, P as get_spread_update, Q as group_outros, R as check_outros, T as prop_dev, U as set_data_dev } from './index.1e1e7223.js';

/* src/layouts/Footer.svelte generated by Svelte v3.16.7 */

const file = "src/layouts/Footer.svelte";

function create_fragment(ctx) {
	let footer;
	let p;
	let t0;
	let t1_value = new Date().getFullYear() + "";
	let t1;

	const block = {
		c: function create() {
			footer = element("footer");
			p = element("p");
			t0 = text("© 2019 - ");
			t1 = text(t1_value);
			this.h();
		},
		l: function claim(nodes) {
			footer = claim_element(nodes, "FOOTER", { class: true });
			var footer_nodes = children(footer);
			p = claim_element(footer_nodes, "P", {});
			var p_nodes = children(p);
			t0 = claim_text(p_nodes, "© 2019 - ");
			t1 = claim_text(p_nodes, t1_value);
			p_nodes.forEach(detach_dev);
			footer_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(p, file, 5, 4, 34);
			attr_dev(footer, "class", "svelte-hgsupk");
			add_location(footer, file, 4, 0, 21);
		},
		m: function mount(target, anchor) {
			insert_dev(target, footer, anchor);
			append_dev(footer, p);
			append_dev(p, t0);
			append_dev(p, t1);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(footer);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

class Footer extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, null, create_fragment, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Footer",
			options,
			id: create_fragment.name
		});
	}
}

/* src/plugins/Swipe/Swipe.svelte generated by Svelte v3.16.7 */
const file$1 = "src/plugins/Swipe/Swipe.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[18] = list[i];
	child_ctx[35] = i;
	return child_ctx;
}

// (246:4) {#if showIndicators}
function create_if_block(ctx) {
	let div;
	let each_value = /*indicators*/ ctx[2];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div_nodes);
			}

			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "swipe-indicator swipe-indicator-inside svelte-tx0axj");
			add_location(div, file$1, 246, 8, 6498);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*activeIndicator, changeItem, indicators*/ 70) {
				each_value = /*indicators*/ ctx[2];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(246:4) {#if showIndicators}",
		ctx
	});

	return block;
}

// (248:12) {#each indicators as x, i }
function create_each_block(ctx) {
	let span;
	let span_class_value;
	let dispose;

	function click_handler(...args) {
		return /*click_handler*/ ctx[33](/*i*/ ctx[35], ...args);
	}

	const block = {
		c: function create() {
			span = element("span");
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			children(span).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", span_class_value = "dot " + (/*activeIndicator*/ ctx[1] == /*i*/ ctx[35]
			? "is-active"
			: "") + " svelte-tx0axj");

			add_location(span, file$1, 248, 16, 6607);
			dispose = listen_dev(span, "click", click_handler, false, false, false);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty[0] & /*activeIndicator*/ 2 && span_class_value !== (span_class_value = "dot " + (/*activeIndicator*/ ctx[1] == /*i*/ ctx[35]
			? "is-active"
			: "") + " svelte-tx0axj")) {
				attr_dev(span, "class", span_class_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(248:12) {#each indicators as x, i }",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let div4;
	let div2;
	let div1;
	let div0;
	let t0;
	let div3;
	let t1;
	let current;
	let dispose;
	const default_slot_template = /*$$slots*/ ctx[30].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[29], null);
	let if_block = /*showIndicators*/ ctx[0] && create_if_block(ctx);

	const block = {
		c: function create() {
			div4 = element("div");
			div2 = element("div");
			div1 = element("div");
			div0 = element("div");
			if (default_slot) default_slot.c();
			t0 = space();
			div3 = element("div");
			t1 = space();
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			div4 = claim_element(nodes, "DIV", { class: true });
			var div4_nodes = children(div4);
			div2 = claim_element(div4_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			if (default_slot) default_slot.l(div0_nodes);
			div0_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			t0 = claim_space(div4_nodes);
			div3 = claim_element(div4_nodes, "DIV", { class: true });
			children(div3).forEach(detach_dev);
			t1 = claim_space(div4_nodes);
			if (if_block) if_block.l(div4_nodes);
			div4_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "swipeable-slot-wrapper svelte-tx0axj");
			add_location(div0, file$1, 239, 12, 6244);
			attr_dev(div1, "class", "swipeable-items svelte-tx0axj");
			add_location(div1, file$1, 238, 8, 6202);
			attr_dev(div2, "class", "swipe-item-wrapper svelte-tx0axj");
			add_location(div2, file$1, 237, 4, 6136);
			attr_dev(div3, "class", "swipe-handler svelte-tx0axj");
			add_location(div3, file$1, 244, 4, 6355);
			attr_dev(div4, "class", "swipe-panel svelte-tx0axj");
			add_location(div4, file$1, 236, 0, 6106);

			dispose = [
				listen_dev(div3, "touchstart", /*moveStart*/ ctx[5], false, false, false),
				listen_dev(div3, "mousedown", /*moveStart*/ ctx[5], false, false, false)
			];
		},
		m: function mount(target, anchor) {
			insert_dev(target, div4, anchor);
			append_dev(div4, div2);
			append_dev(div2, div1);
			append_dev(div1, div0);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			/*div2_binding*/ ctx[31](div2);
			append_dev(div4, t0);
			append_dev(div4, div3);
			/*div3_binding*/ ctx[32](div3);
			append_dev(div4, t1);
			if (if_block) if_block.m(div4, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot && default_slot.p && dirty[0] & /*$$scope*/ 536870912) {
				default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[29], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[29], dirty, null));
			}

			if (/*showIndicators*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(div4, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div4);
			if (default_slot) default_slot.d(detaching);
			/*div2_binding*/ ctx[31](null);
			/*div3_binding*/ ctx[32](null);
			if (if_block) if_block.d();
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { transitionDuration = 200 } = $$props;
	let { showIndicators = false } = $$props;
	let { autoplay = false } = $$props;
	let { delay = 1000 } = $$props;
	let activeIndicator = 0;
	let indicators;
	let items = 0;
	let availableWidth = 0;
	let topClearence = 0;
	let elems;
	let diff = 0;
	let swipeWrapper;
	let swipeHandler;
	let min = 0;

	let touchingTpl = `
    -webkit-transition-duration: 0s;
    transition-duration: 0s;
    -webkit-transform: translate3d(-{{val}}px, 0, 0);
    -ms-transform: translate3d(-{{val}}px, 0, 0);`;

	let non_touchingTpl = `
    -webkit-transition-duration: ${transitionDuration}ms;
    transition-duration: ${transitionDuration}ms;
    -webkit-transform: translate3d(-{{val}}px, 0, 0);
    -ms-transform: translate3d(-{{val}}px, 0, 0);`;

	let touching = false;
	let posX = 0;
	let dir = 0;
	let x;
	let played = 0;
	let run_interval = false;

	function update() {
		$$invalidate(4, swipeHandler.style.top = topClearence + "px", swipeHandler);
		availableWidth = swipeWrapper.querySelector(".swipeable-items").offsetWidth;

		for (let i = 0; i < items; i++) {
			elems[i].style.transform = "translate3d(" + availableWidth * i + "px, 0, 0)";
		}

		diff = 0;
	}

	function init() {
		elems = swipeWrapper.querySelectorAll(".swipeable-item");
		$$invalidate(10, items = elems.length);
		update();
	}

	onMount(() => {
		init();
		window.addEventListener("resize", update);
	});

	onDestroy(() => {
		window.removeEventListener("resize", update);
	});

	function moveHandler(e) {
		if (touching) {
			e.stopImmediatePropagation();
			e.stopPropagation();
			let max = availableWidth;
			let _x = e.touches ? e.touches[0].pageX : e.pageX;
			let _diff = x - _x + posX;
			let dir = _x > x ? 0 : 1;

			if (!dir) {
				_diff = posX - (_x - x);
			}

			if (_diff <= max * (items - 1) && _diff >= min) {
				for (let i = 0; i < items; i++) {
					let template = i < 0 ? "{{val}}" : "-{{val}}";
					let _value = max * i - _diff;
					elems[i].style.cssText = touchingTpl.replace(template, _value).replace(template, _value);
				}

				diff = _diff;
			}
		}
	}

	function endHandler(e) {
		e && e.stopImmediatePropagation();
		e && e.stopPropagation();
		e && e.preventDefault();
		let max = availableWidth;
		touching = false;
		x = null;
		let delta = 0.05;
		let swipe_threshold = 0.85;
		let d_max = diff / max;
		let deltaDMax = d_max - Math.floor(d_max);

		let _target = deltaDMax > delta && deltaDMax < 0.5
		? Math.ceil(d_max)
		: Math.floor(d_max);

		if (Math.abs(_target - d_max) < swipe_threshold) {
			diff = _target * max;
		} else {
			diff = (dir ? _target - 1 : _target + 1) * max;
		}

		posX = diff;
		$$invalidate(1, activeIndicator = diff / max);

		for (let i = 0; i < items; i++) {
			let template = i < 0 ? "{{val}}" : "-{{val}}";
			let _value = max * i - posX;
			elems[i].style.cssText = non_touchingTpl.replace(template, _value).replace(template, _value);
		}

		window.removeEventListener("mousemove", moveHandler);
		window.removeEventListener("mouseup", endHandler);
		window.removeEventListener("touchmove", moveHandler);
		window.removeEventListener("touchend", endHandler);
	}

	function moveStart(e) {
		e.stopImmediatePropagation();
		e.stopPropagation();
		e.preventDefault();
		touching = true;
		x = e.touches ? e.touches[0].pageX : e.pageX;
		window.addEventListener("mousemove", moveHandler);
		window.addEventListener("mouseup", endHandler);
		window.addEventListener("touchmove", moveHandler);
		window.addEventListener("touchend", endHandler);
	}

	function changeItem(item) {
		let max = availableWidth;
		diff = max * item;
		$$invalidate(1, activeIndicator = item);
		endHandler();
	}

	function changeView() {
		changeItem(played);
		played = played < items - 1 ? ++played : 0;
	}

	const writable_props = ["transitionDuration", "showIndicators", "autoplay", "delay"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Swipe> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;

	function div2_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			$$invalidate(3, swipeWrapper = $$value);
		});
	}

	function div3_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			$$invalidate(4, swipeHandler = $$value);
		});
	}

	const click_handler = i => {
		changeItem(i);
	};

	$$self.$set = $$props => {
		if ("transitionDuration" in $$props) $$invalidate(7, transitionDuration = $$props.transitionDuration);
		if ("showIndicators" in $$props) $$invalidate(0, showIndicators = $$props.showIndicators);
		if ("autoplay" in $$props) $$invalidate(8, autoplay = $$props.autoplay);
		if ("delay" in $$props) $$invalidate(9, delay = $$props.delay);
		if ("$$scope" in $$props) $$invalidate(29, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => {
		return {
			transitionDuration,
			showIndicators,
			autoplay,
			delay,
			activeIndicator,
			indicators,
			items,
			availableWidth,
			topClearence,
			elems,
			diff,
			swipeWrapper,
			swipeHandler,
			min,
			touchingTpl,
			non_touchingTpl,
			touching,
			posX,
			dir,
			x,
			played,
			run_interval
		};
	};

	$$self.$inject_state = $$props => {
		if ("transitionDuration" in $$props) $$invalidate(7, transitionDuration = $$props.transitionDuration);
		if ("showIndicators" in $$props) $$invalidate(0, showIndicators = $$props.showIndicators);
		if ("autoplay" in $$props) $$invalidate(8, autoplay = $$props.autoplay);
		if ("delay" in $$props) $$invalidate(9, delay = $$props.delay);
		if ("activeIndicator" in $$props) $$invalidate(1, activeIndicator = $$props.activeIndicator);
		if ("indicators" in $$props) $$invalidate(2, indicators = $$props.indicators);
		if ("items" in $$props) $$invalidate(10, items = $$props.items);
		if ("availableWidth" in $$props) availableWidth = $$props.availableWidth;
		if ("topClearence" in $$props) topClearence = $$props.topClearence;
		if ("elems" in $$props) elems = $$props.elems;
		if ("diff" in $$props) diff = $$props.diff;
		if ("swipeWrapper" in $$props) $$invalidate(3, swipeWrapper = $$props.swipeWrapper);
		if ("swipeHandler" in $$props) $$invalidate(4, swipeHandler = $$props.swipeHandler);
		if ("min" in $$props) min = $$props.min;
		if ("touchingTpl" in $$props) touchingTpl = $$props.touchingTpl;
		if ("non_touchingTpl" in $$props) non_touchingTpl = $$props.non_touchingTpl;
		if ("touching" in $$props) touching = $$props.touching;
		if ("posX" in $$props) posX = $$props.posX;
		if ("dir" in $$props) dir = $$props.dir;
		if ("x" in $$props) x = $$props.x;
		if ("played" in $$props) played = $$props.played;
		if ("run_interval" in $$props) $$invalidate(17, run_interval = $$props.run_interval);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*items*/ 1024) {
			 $$invalidate(2, indicators = Array(items));
		}

		if ($$self.$$.dirty[0] & /*autoplay, run_interval, delay*/ 131840) {
			 {
				if (autoplay && !run_interval) {
					$$invalidate(17, run_interval = setInterval(changeView, delay));
				}

				if (!autoplay && run_interval) {
					clearInterval(run_interval);
					$$invalidate(17, run_interval = false);
				}
			}
		}
	};

	return [
		showIndicators,
		activeIndicator,
		indicators,
		swipeWrapper,
		swipeHandler,
		moveStart,
		changeItem,
		transitionDuration,
		autoplay,
		delay,
		items,
		availableWidth,
		elems,
		diff,
		touching,
		posX,
		played,
		run_interval,
		x,
		topClearence,
		min,
		touchingTpl,
		non_touchingTpl,
		dir,
		update,
		init,
		moveHandler,
		endHandler,
		changeView,
		$$scope,
		$$slots,
		div2_binding,
		div3_binding,
		click_handler
	];
}

class Swipe extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance,
			create_fragment$1,
			safe_not_equal,
			{
				transitionDuration: 7,
				showIndicators: 0,
				autoplay: 8,
				delay: 9
			},
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Swipe",
			options,
			id: create_fragment$1.name
		});
	}

	get transitionDuration() {
		throw new Error("<Swipe>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set transitionDuration(value) {
		throw new Error("<Swipe>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get showIndicators() {
		throw new Error("<Swipe>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set showIndicators(value) {
		throw new Error("<Swipe>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get autoplay() {
		throw new Error("<Swipe>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set autoplay(value) {
		throw new Error("<Swipe>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get delay() {
		throw new Error("<Swipe>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set delay(value) {
		throw new Error("<Swipe>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/plugins/Swipe/SwipeItem.svelte generated by Svelte v3.16.7 */

const file$2 = "src/plugins/Swipe/SwipeItem.svelte";

function create_fragment$2(ctx) {
	let div;
	let div_class_value;
	let current;
	const default_slot_template = /*$$slots*/ ctx[2].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", div_class_value = "swipeable-item " + /*classes*/ ctx[0] + " svelte-1c0dn3k");
			add_location(div, file$2, 17, 0, 291);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot && default_slot.p && dirty & /*$$scope*/ 2) {
				default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[1], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[1], dirty, null));
			}

			if (!current || dirty & /*classes*/ 1 && div_class_value !== (div_class_value = "swipeable-item " + /*classes*/ ctx[0] + " svelte-1c0dn3k")) {
				attr_dev(div, "class", div_class_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let { classes = "" } = $$props;
	const writable_props = ["classes"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SwipeItem> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;

	$$self.$set = $$props => {
		if ("classes" in $$props) $$invalidate(0, classes = $$props.classes);
		if ("$$scope" in $$props) $$invalidate(1, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => {
		return { classes };
	};

	$$self.$inject_state = $$props => {
		if ("classes" in $$props) $$invalidate(0, classes = $$props.classes);
	};

	return [classes, $$scope, $$slots];
}

class SwipeItem extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$2, safe_not_equal, { classes: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "SwipeItem",
			options,
			id: create_fragment$2.name
		});
	}

	get classes() {
		throw new Error("<SwipeItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set classes(value) {
		throw new Error("<SwipeItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var classnames = createCommonjsModule(function (module) {
/*!
  Copyright (c) 2017 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {

	var hasOwn = {}.hasOwnProperty;

	function classNames () {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg) && arg.length) {
				var inner = classNames.apply(null, arg);
				if (inner) {
					classes.push(inner);
				}
			} else if (argType === 'object') {
				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if ( module.exports) {
		classNames.default = classNames;
		module.exports = classNames;
	} else {
		window.classNames = classNames;
	}
}());
});

const toCSSString = (styles = {}) => Object.entries(styles)
  .filter(([_propName, propValue]) => propValue !== undefined && propValue !== null)
  .reduce((styleString, [propName, propValue]) => {
    propName = propName.replace(/[A-Z]/g, match => `-${match.toLowerCase()}`);
    return `${styleString}${propName}:${propValue};`
  }, '');

/**
 *
 * @function safeGet
 *
 * @description Safe getting of an any value of a nested objects.
 *
 * @param expressionFn {function} - The function with an expression which returns result of the safe getting.
 * @param defaultValue {any} - The default value when result is undefined.
 * @param isDefaultTyped {boolean} - Wheter is the result from an expression must be the same type as the default value.
 *
 * @examples
 * // Some data.
 * const very = {
 *  nested: {
 *   object: [{
 *     with: {
 *       arrays: 'stuff'
 *     }
 *   }]
 *  }
 * }
 *
 * // Getting.
 * 1. safeGet(() => very.nested.object[0].with.arrays);
 * 2. safeGet(() => very.nested.object[0].with.arrays, { default: 'value' });
 * 3. safeGet(() => very.nested.object[0].with.arrays, { default: 'value' }, true);
 *
 * // Return.
 * 1. 'stuff'
 * 2. 'stuff'
 * 3. { default: 'value' }
 */
function safeGet(expressionFn, defaultValue, isDefaultTyped = false) {
  // Check whether a and b have the same type. (util)
  function isSameType(a, b) {
    const rules = [
      (a, b) => typeof a === typeof b,
      (a, b) => (+a === a) === (+b === b),              // whether one is NaN
      (a, b) => (a === null) === (b === null),          // null is object type too
      (a, b) => Array.isArray(a) === Array.isArray(b),  // array is object type too
    ];
    return !rules.some(ruleFn => !ruleFn(a, b))
  }
  // Core of safe getting. Executing a function. Default values.
  function get(expressionFn, defaultValue, isDefaultTyped) {
    try {
      const result = expressionFn.call(this);
      if (isDefaultTyped) {
        return isSameType(result, defaultValue) ? result : defaultValue
      } else {
        return result === undefined ? defaultValue : result
      }
    } catch (e) {
      return defaultValue
    }
  }
  // Safe getting of the expressionFn.
  if (typeof expressionFn === 'function') {
    return get(expressionFn, defaultValue, isDefaultTyped)
  } else {
    console.warn('You need to use a function as the first argument.');
  }
  return defaultValue
}

/* src/components/Icon.svelte generated by Svelte v3.16.7 */
const file$3 = "src/components/Icon.svelte";

function create_fragment$3(ctx) {
	let svg;
	let use;
	let use_xlink_href_value;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			use = svg_element("use");
			this.h();
		},
		l: function claim(nodes) {
			svg = claim_element(
				nodes,
				"svg",
				{
					id: true,
					title: true,
					class: true,
					style: true,
					"aria-label": true
				},
				1
			);

			var svg_nodes = children(svg);
			use = claim_element(svg_nodes, "use", { "xlink:href": true, class: true }, 1);
			children(use).forEach(detach_dev);
			svg_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			xlink_attr(use, "xlink:href", use_xlink_href_value = `#ico-${/*type*/ ctx[0]}`);
			attr_dev(use, "class", "ico-use svelte-1y5h9x9");
			add_location(use, file$3, 26, 4, 745);
			attr_dev(svg, "id", /*id*/ ctx[1]);
			attr_dev(svg, "title", /*titleProp*/ ctx[3]);
			attr_dev(svg, "class", svg_class_value = "" + (null_to_empty(/*classProp*/ ctx[2]) + " svelte-1y5h9x9"));
			attr_dev(svg, "style", /*styleProp*/ ctx[5]);
			attr_dev(svg, "aria-label", /*ariaLabelProp*/ ctx[4]);
			add_location(svg, file$3, 19, 0, 608);
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, use);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*type*/ 1 && use_xlink_href_value !== (use_xlink_href_value = `#ico-${/*type*/ ctx[0]}`)) {
				xlink_attr(use, "xlink:href", use_xlink_href_value);
			}

			if (dirty & /*id*/ 2) {
				attr_dev(svg, "id", /*id*/ ctx[1]);
			}

			if (dirty & /*classProp*/ 4 && svg_class_value !== (svg_class_value = "" + (null_to_empty(/*classProp*/ ctx[2]) + " svelte-1y5h9x9"))) {
				attr_dev(svg, "class", svg_class_value);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	let { type } = $$props;
	let { is } = $$props;
	let { size = "medium" } = $$props;
	let { rotate = 0 } = $$props;
	let { style = undefined } = $$props;
	let { id = undefined } = $$props;
	let { title = undefined } = $$props;
	let { ariaLabel = undefined } = $$props;
	let titleProp = title || ariaLabel;
	let ariaLabelProp = ariaLabel || title;

	let styleProp = toCSSString({
		transform: !!rotate ? `rotateZ(${rotate}deg)` : null,
		...style
	});

	$$self.$set = $$new_props => {
		$$invalidate(12, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("type" in $$new_props) $$invalidate(0, type = $$new_props.type);
		if ("is" in $$new_props) $$invalidate(6, is = $$new_props.is);
		if ("size" in $$new_props) $$invalidate(7, size = $$new_props.size);
		if ("rotate" in $$new_props) $$invalidate(8, rotate = $$new_props.rotate);
		if ("style" in $$new_props) $$invalidate(9, style = $$new_props.style);
		if ("id" in $$new_props) $$invalidate(1, id = $$new_props.id);
		if ("title" in $$new_props) $$invalidate(10, title = $$new_props.title);
		if ("ariaLabel" in $$new_props) $$invalidate(11, ariaLabel = $$new_props.ariaLabel);
	};

	$$self.$capture_state = () => {
		return {
			type,
			is,
			size,
			rotate,
			style,
			id,
			title,
			ariaLabel,
			titleProp,
			ariaLabelProp,
			styleProp,
			classProp
		};
	};

	$$self.$inject_state = $$new_props => {
		$$invalidate(12, $$props = assign(assign({}, $$props), $$new_props));
		if ("type" in $$props) $$invalidate(0, type = $$new_props.type);
		if ("is" in $$props) $$invalidate(6, is = $$new_props.is);
		if ("size" in $$props) $$invalidate(7, size = $$new_props.size);
		if ("rotate" in $$props) $$invalidate(8, rotate = $$new_props.rotate);
		if ("style" in $$props) $$invalidate(9, style = $$new_props.style);
		if ("id" in $$props) $$invalidate(1, id = $$new_props.id);
		if ("title" in $$props) $$invalidate(10, title = $$new_props.title);
		if ("ariaLabel" in $$props) $$invalidate(11, ariaLabel = $$new_props.ariaLabel);
		if ("titleProp" in $$props) $$invalidate(3, titleProp = $$new_props.titleProp);
		if ("ariaLabelProp" in $$props) $$invalidate(4, ariaLabelProp = $$new_props.ariaLabelProp);
		if ("styleProp" in $$props) $$invalidate(5, styleProp = $$new_props.styleProp);
		if ("classProp" in $$props) $$invalidate(2, classProp = $$new_props.classProp);
	};

	let classProp;

	$$self.$$.update = () => {
		 $$invalidate(2, classProp = classnames("ico", is, size, $$props.class));
	};

	$$props = exclude_internal_props($$props);

	return [
		type,
		id,
		classProp,
		titleProp,
		ariaLabelProp,
		styleProp,
		is,
		size,
		rotate,
		style,
		title,
		ariaLabel
	];
}

class Icon extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2, create_fragment$3, safe_not_equal, {
			type: 0,
			is: 6,
			size: 7,
			rotate: 8,
			style: 9,
			id: 1,
			title: 10,
			ariaLabel: 11
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Icon",
			options,
			id: create_fragment$3.name
		});

		const { ctx } = this.$$;
		const props = options.props || ({});

		if (/*type*/ ctx[0] === undefined && !("type" in props)) {
			console.warn("<Icon> was created without expected prop 'type'");
		}

		if (/*is*/ ctx[6] === undefined && !("is" in props)) {
			console.warn("<Icon> was created without expected prop 'is'");
		}
	}

	get type() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set type(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get is() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set is(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get rotate() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set rotate(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get id() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get title() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ariaLabel() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ariaLabel(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/Rate.svelte generated by Svelte v3.16.7 */
const file$4 = "src/components/Rate.svelte";

function create_fragment$4(ctx) {
	let ul;
	let li0;
	let t0;
	let li1;
	let t1;
	let li2;
	let t2;
	let li3;
	let t3;
	let li4;
	let current;

	const icon0 = new Icon({
			props: {
				is: /*is*/ ctx[0],
				size: /*size*/ ctx[1],
				type: "heart-filled"
			},
			$$inline: true
		});

	const icon1 = new Icon({
			props: {
				is: /*is*/ ctx[0],
				size: /*size*/ ctx[1],
				type: "heart-filled"
			},
			$$inline: true
		});

	const icon2 = new Icon({
			props: {
				is: /*is*/ ctx[0],
				size: /*size*/ ctx[1],
				type: "heart-filled"
			},
			$$inline: true
		});

	const icon3 = new Icon({
			props: {
				is: /*is*/ ctx[0],
				size: /*size*/ ctx[1],
				type: "heart-filled"
			},
			$$inline: true
		});

	const icon4 = new Icon({
			props: {
				is: /*is*/ ctx[0],
				size: /*size*/ ctx[1],
				type: "heart-filled"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			ul = element("ul");
			li0 = element("li");
			create_component(icon0.$$.fragment);
			t0 = space();
			li1 = element("li");
			create_component(icon1.$$.fragment);
			t1 = space();
			li2 = element("li");
			create_component(icon2.$$.fragment);
			t2 = space();
			li3 = element("li");
			create_component(icon3.$$.fragment);
			t3 = space();
			li4 = element("li");
			create_component(icon4.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);
			li0 = claim_element(ul_nodes, "LI", { class: true });
			var li0_nodes = children(li0);
			claim_component(icon0.$$.fragment, li0_nodes);
			li0_nodes.forEach(detach_dev);
			t0 = claim_space(ul_nodes);
			li1 = claim_element(ul_nodes, "LI", { class: true });
			var li1_nodes = children(li1);
			claim_component(icon1.$$.fragment, li1_nodes);
			li1_nodes.forEach(detach_dev);
			t1 = claim_space(ul_nodes);
			li2 = claim_element(ul_nodes, "LI", { class: true });
			var li2_nodes = children(li2);
			claim_component(icon2.$$.fragment, li2_nodes);
			li2_nodes.forEach(detach_dev);
			t2 = claim_space(ul_nodes);
			li3 = claim_element(ul_nodes, "LI", { class: true });
			var li3_nodes = children(li3);
			claim_component(icon3.$$.fragment, li3_nodes);
			li3_nodes.forEach(detach_dev);
			t3 = claim_space(ul_nodes);
			li4 = claim_element(ul_nodes, "LI", { class: true });
			var li4_nodes = children(li4);
			claim_component(icon4.$$.fragment, li4_nodes);
			li4_nodes.forEach(detach_dev);
			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(li0, "class", "svelte-9gtglw");
			add_location(li0, file$4, 8, 4, 172);
			attr_dev(li1, "class", "svelte-9gtglw");
			add_location(li1, file$4, 11, 4, 239);
			attr_dev(li2, "class", "svelte-9gtglw");
			add_location(li2, file$4, 14, 4, 306);
			attr_dev(li3, "class", "svelte-9gtglw");
			add_location(li3, file$4, 17, 4, 373);
			attr_dev(li4, "class", "svelte-9gtglw");
			add_location(li4, file$4, 20, 4, 440);
			attr_dev(ul, "class", "rate svelte-9gtglw");
			add_location(ul, file$4, 7, 0, 150);
		},
		m: function mount(target, anchor) {
			insert_dev(target, ul, anchor);
			append_dev(ul, li0);
			mount_component(icon0, li0, null);
			append_dev(ul, t0);
			append_dev(ul, li1);
			mount_component(icon1, li1, null);
			append_dev(ul, t1);
			append_dev(ul, li2);
			mount_component(icon2, li2, null);
			append_dev(ul, t2);
			append_dev(ul, li3);
			mount_component(icon3, li3, null);
			append_dev(ul, t3);
			append_dev(ul, li4);
			mount_component(icon4, li4, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const icon0_changes = {};
			if (dirty & /*is*/ 1) icon0_changes.is = /*is*/ ctx[0];
			if (dirty & /*size*/ 2) icon0_changes.size = /*size*/ ctx[1];
			icon0.$set(icon0_changes);
			const icon1_changes = {};
			if (dirty & /*is*/ 1) icon1_changes.is = /*is*/ ctx[0];
			if (dirty & /*size*/ 2) icon1_changes.size = /*size*/ ctx[1];
			icon1.$set(icon1_changes);
			const icon2_changes = {};
			if (dirty & /*is*/ 1) icon2_changes.is = /*is*/ ctx[0];
			if (dirty & /*size*/ 2) icon2_changes.size = /*size*/ ctx[1];
			icon2.$set(icon2_changes);
			const icon3_changes = {};
			if (dirty & /*is*/ 1) icon3_changes.is = /*is*/ ctx[0];
			if (dirty & /*size*/ 2) icon3_changes.size = /*size*/ ctx[1];
			icon3.$set(icon3_changes);
			const icon4_changes = {};
			if (dirty & /*is*/ 1) icon4_changes.is = /*is*/ ctx[0];
			if (dirty & /*size*/ 2) icon4_changes.size = /*size*/ ctx[1];
			icon4.$set(icon4_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon0.$$.fragment, local);
			transition_in(icon1.$$.fragment, local);
			transition_in(icon2.$$.fragment, local);
			transition_in(icon3.$$.fragment, local);
			transition_in(icon4.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon0.$$.fragment, local);
			transition_out(icon1.$$.fragment, local);
			transition_out(icon2.$$.fragment, local);
			transition_out(icon3.$$.fragment, local);
			transition_out(icon4.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(ul);
			destroy_component(icon0);
			destroy_component(icon1);
			destroy_component(icon2);
			destroy_component(icon3);
			destroy_component(icon4);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3($$self, $$props, $$invalidate) {
	let { is = "danger" } = $$props;
	let { size = "medium" } = $$props;
	const writable_props = ["is", "size"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Rate> was created with unknown prop '${key}'`);
	});

	$$self.$set = $$props => {
		if ("is" in $$props) $$invalidate(0, is = $$props.is);
		if ("size" in $$props) $$invalidate(1, size = $$props.size);
	};

	$$self.$capture_state = () => {
		return { is, size };
	};

	$$self.$inject_state = $$props => {
		if ("is" in $$props) $$invalidate(0, is = $$props.is);
		if ("size" in $$props) $$invalidate(1, size = $$props.size);
	};

	return [is, size];
}

class Rate extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3, create_fragment$4, safe_not_equal, { is: 0, size: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Rate",
			options,
			id: create_fragment$4.name
		});
	}

	get is() {
		throw new Error("<Rate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set is(value) {
		throw new Error("<Rate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<Rate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<Rate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/Input.svelte generated by Svelte v3.16.7 */
const file$5 = "src/components/Input.svelte";

// (78:0) {:else}
function create_else_block(ctx) {
	let input;
	let dispose;

	let input_levels = [
		{ min: /*min*/ ctx[6] },
		{ max: /*max*/ ctx[7] },
		{ name: /*name*/ ctx[1] },
		{ list: /*list*/ ctx[8] },
		{ form: /*form*/ ctx[9] },
		{ align: /*align*/ ctx[2] },
		{ readOnly: /*readonly*/ ctx[10] },
		{ disabled: /*disabled*/ ctx[5] },
		{ required: /*required*/ ctx[11] },
		{ maxlength: /*maxlength*/ ctx[3] },
		{ placeholder: /*placeholder*/ ctx[12] },
		{ id: /*idProp*/ ctx[15] },
		{ class: /*classProp*/ ctx[13] },
		{ title: /*titleProp*/ ctx[17] },
		{ style: /*styleProp*/ ctx[20] },
		{ pattern: /*patternProp*/ ctx[21] },
		{ "aria-label": /*ariaLabelProp*/ ctx[18] },
		{
			autocomplete: /*autocompleteProp*/ ctx[19]
		},
		{ type: /*typeProp*/ ctx[16] }
	];

	let input_data = {};

	for (let i = 0; i < input_levels.length; i += 1) {
		input_data = assign(input_data, input_levels[i]);
	}

	const block = {
		c: function create() {
			input = element("input");
			this.h();
		},
		l: function claim(nodes) {
			input = claim_element(nodes, "INPUT", {
				min: true,
				max: true,
				name: true,
				list: true,
				form: true,
				align: true,
				readonly: true,
				disabled: true,
				required: true,
				maxlength: true,
				placeholder: true,
				id: true,
				class: true,
				title: true,
				style: true,
				pattern: true,
				"aria-label": true,
				autocomplete: true
			});

			this.h();
		},
		h: function hydrate() {
			set_attributes(input, input_data);
			toggle_class(input, "svelte-1vg8tdg", true);
			add_location(input, file$5, 78, 4, 2783);

			dispose = [
				listen_dev(input, "input", /*input_input_handler*/ ctx[36]),
				listen_dev(input, "blur", /*blur_handler_1*/ ctx[37], false, false, false),
				listen_dev(input, "focus", /*focus_handler_1*/ ctx[38], false, false, false),
				listen_dev(input, "click", /*onClick*/ ctx[22], false, false, false)
			];
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			set_input_value(input, /*value*/ ctx[0]);
		},
		p: function update(ctx, dirty) {
			set_attributes(input, get_spread_update(input_levels, [
				dirty[0] & /*min*/ 64 && ({ min: /*min*/ ctx[6] }),
				dirty[0] & /*max*/ 128 && ({ max: /*max*/ ctx[7] }),
				dirty[0] & /*name*/ 2 && ({ name: /*name*/ ctx[1] }),
				dirty[0] & /*list*/ 256 && ({ list: /*list*/ ctx[8] }),
				dirty[0] & /*form*/ 512 && ({ form: /*form*/ ctx[9] }),
				dirty[0] & /*align*/ 4 && ({ align: /*align*/ ctx[2] }),
				dirty[0] & /*readonly*/ 1024 && ({ readOnly: /*readonly*/ ctx[10] }),
				dirty[0] & /*disabled*/ 32 && ({ disabled: /*disabled*/ ctx[5] }),
				dirty[0] & /*required*/ 2048 && ({ required: /*required*/ ctx[11] }),
				dirty[0] & /*maxlength*/ 8 && ({ maxlength: /*maxlength*/ ctx[3] }),
				dirty[0] & /*placeholder*/ 4096 && ({ placeholder: /*placeholder*/ ctx[12] }),
				dirty[0] & /*idProp*/ 32768 && ({ id: /*idProp*/ ctx[15] }),
				dirty[0] & /*classProp*/ 8192 && ({ class: /*classProp*/ ctx[13] }),
				dirty[0] & /*titleProp*/ 131072 && ({ title: /*titleProp*/ ctx[17] }),
				dirty[0] & /*styleProp*/ 1048576 && ({ style: /*styleProp*/ ctx[20] }),
				dirty[0] & /*patternProp*/ 2097152 && ({ pattern: /*patternProp*/ ctx[21] }),
				dirty[0] & /*ariaLabelProp*/ 262144 && ({ "aria-label": /*ariaLabelProp*/ ctx[18] }),
				dirty[0] & /*autocompleteProp*/ 524288 && ({
					autocomplete: /*autocompleteProp*/ ctx[19]
				}),
				dirty[0] & /*typeProp*/ 65536 && ({ type: /*typeProp*/ ctx[16] })
			]));

			if (dirty[0] & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
				set_input_value(input, /*value*/ ctx[0]);
			}

			toggle_class(input, "svelte-1vg8tdg", true);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(78:0) {:else}",
		ctx
	});

	return block;
}

// (52:0) {#if rows}
function create_if_block$1(ctx) {
	let textarea;
	let dispose;

	let textarea_levels = [
		{ min: /*min*/ ctx[6] },
		{ max: /*max*/ ctx[7] },
		{ rows: /*rows*/ ctx[4] },
		{ name: /*name*/ ctx[1] },
		{ form: /*form*/ ctx[9] },
		{ align: /*align*/ ctx[2] },
		{ readOnly: /*readonly*/ ctx[10] },
		{ disabled: /*disabled*/ ctx[5] },
		{ required: /*required*/ ctx[11] },
		{ maxlength: /*maxlength*/ ctx[3] },
		{ placeholder: /*placeholder*/ ctx[12] },
		{ id: /*idProp*/ ctx[15] },
		{ class: /*classProp*/ ctx[13] },
		{ title: /*titleProp*/ ctx[17] },
		{ style: /*styleProp*/ ctx[20] },
		{ pattern: /*patternProp*/ ctx[21] },
		{ "aria-label": /*ariaLabelProp*/ ctx[18] },
		{
			autocomplete: /*autocompleteProp*/ ctx[19]
		},
		{ type: /*typeProp*/ ctx[16] }
	];

	let textarea_data = {};

	for (let i = 0; i < textarea_levels.length; i += 1) {
		textarea_data = assign(textarea_data, textarea_levels[i]);
	}

	const block = {
		c: function create() {
			textarea = element("textarea");
			this.h();
		},
		l: function claim(nodes) {
			textarea = claim_element(nodes, "TEXTAREA", {
				min: true,
				max: true,
				rows: true,
				name: true,
				form: true,
				align: true,
				readonly: true,
				disabled: true,
				required: true,
				maxlength: true,
				placeholder: true,
				id: true,
				class: true,
				title: true,
				style: true,
				pattern: true,
				"aria-label": true,
				autocomplete: true
			});

			children(textarea).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_attributes(textarea, textarea_data);
			toggle_class(textarea, "svelte-1vg8tdg", true);
			add_location(textarea, file$5, 52, 4, 2063);

			dispose = [
				listen_dev(textarea, "input", /*textarea_input_handler*/ ctx[33]),
				listen_dev(textarea, "blur", /*blur_handler*/ ctx[34], false, false, false),
				listen_dev(textarea, "focus", /*focus_handler*/ ctx[35], false, false, false),
				listen_dev(textarea, "click", /*onClick*/ ctx[22], false, false, false)
			];
		},
		m: function mount(target, anchor) {
			insert_dev(target, textarea, anchor);
			set_input_value(textarea, /*value*/ ctx[0]);
		},
		p: function update(ctx, dirty) {
			set_attributes(textarea, get_spread_update(textarea_levels, [
				dirty[0] & /*min*/ 64 && ({ min: /*min*/ ctx[6] }),
				dirty[0] & /*max*/ 128 && ({ max: /*max*/ ctx[7] }),
				dirty[0] & /*rows*/ 16 && ({ rows: /*rows*/ ctx[4] }),
				dirty[0] & /*name*/ 2 && ({ name: /*name*/ ctx[1] }),
				dirty[0] & /*form*/ 512 && ({ form: /*form*/ ctx[9] }),
				dirty[0] & /*align*/ 4 && ({ align: /*align*/ ctx[2] }),
				dirty[0] & /*readonly*/ 1024 && ({ readOnly: /*readonly*/ ctx[10] }),
				dirty[0] & /*disabled*/ 32 && ({ disabled: /*disabled*/ ctx[5] }),
				dirty[0] & /*required*/ 2048 && ({ required: /*required*/ ctx[11] }),
				dirty[0] & /*maxlength*/ 8 && ({ maxlength: /*maxlength*/ ctx[3] }),
				dirty[0] & /*placeholder*/ 4096 && ({ placeholder: /*placeholder*/ ctx[12] }),
				dirty[0] & /*idProp*/ 32768 && ({ id: /*idProp*/ ctx[15] }),
				dirty[0] & /*classProp*/ 8192 && ({ class: /*classProp*/ ctx[13] }),
				dirty[0] & /*titleProp*/ 131072 && ({ title: /*titleProp*/ ctx[17] }),
				dirty[0] & /*styleProp*/ 1048576 && ({ style: /*styleProp*/ ctx[20] }),
				dirty[0] & /*patternProp*/ 2097152 && ({ pattern: /*patternProp*/ ctx[21] }),
				dirty[0] & /*ariaLabelProp*/ 262144 && ({ "aria-label": /*ariaLabelProp*/ ctx[18] }),
				dirty[0] & /*autocompleteProp*/ 524288 && ({
					autocomplete: /*autocompleteProp*/ ctx[19]
				}),
				dirty[0] & /*typeProp*/ 65536 && ({ type: /*typeProp*/ ctx[16] })
			]));

			if (dirty[0] & /*value*/ 1) {
				set_input_value(textarea, /*value*/ ctx[0]);
			}

			toggle_class(textarea, "svelte-1vg8tdg", true);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(textarea);
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(52:0) {#if rows}",
		ctx
	});

	return block;
}

function create_fragment$5(ctx) {
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (/*rows*/ ctx[4]) return create_if_block$1;
		return create_else_block;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$5.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4($$self, $$props, $$invalidate) {
	const dispatch = createEventDispatcher();
	let { name } = $$props;
	let { value = "" } = $$props;
	let { style = {} } = $$props;
	let { type = "text" } = $$props;
	let { id = undefined } = $$props;
	let { align = undefined } = $$props;
	let { maxlength = 1000 } = $$props;
	let { rows = undefined } = $$props;
	let { disabled = false } = $$props;
	let { title = undefined } = $$props;
	let { invalid = undefined } = $$props;
	let { min = undefined } = $$props;
	let { max = undefined } = $$props;
	let { list = undefined } = $$props;
	let { form = undefined } = $$props;
	let { readonly = undefined } = $$props;
	let { required = undefined } = $$props;
	let { pattern = undefined } = $$props;
	let { autocomplete = true } = $$props;
	let { autoselect = false } = $$props;
	let { ariaLabel = undefined } = $$props;
	let { placeholder = undefined } = $$props;
	let idProp = id || name;
	let typeProp = type === "number" ? "text" : type;
	let titleProp = title || ariaLabel || placeholder;
	let ariaLabelProp = ariaLabel || title || placeholder;
	let autocompleteProp = autocomplete ? "on" : "off";
	let styleProp = toCSSString({ ...style, textAlign: align });
	let patternProp = type === "number" && !pattern ? "[0-9]*" : pattern;

	function onClick(e) {
		!disabled && dispatch("click", e);
		!disabled && autoselect && e.target.select();
	}

	function textarea_input_handler() {
		value = this.value;
		$$invalidate(0, value);
	}

	const blur_handler = e => !disabled && dispatch("blur", e);
	const focus_handler = e => !disabled && dispatch("focus", e);

	function input_input_handler() {
		value = this.value;
		$$invalidate(0, value);
	}

	const blur_handler_1 = e => !disabled && dispatch("blur", e);
	const focus_handler_1 = e => !disabled && dispatch("focus", e);

	$$self.$set = $$new_props => {
		$$invalidate(32, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("name" in $$new_props) $$invalidate(1, name = $$new_props.name);
		if ("value" in $$new_props) $$invalidate(0, value = $$new_props.value);
		if ("style" in $$new_props) $$invalidate(23, style = $$new_props.style);
		if ("type" in $$new_props) $$invalidate(24, type = $$new_props.type);
		if ("id" in $$new_props) $$invalidate(25, id = $$new_props.id);
		if ("align" in $$new_props) $$invalidate(2, align = $$new_props.align);
		if ("maxlength" in $$new_props) $$invalidate(3, maxlength = $$new_props.maxlength);
		if ("rows" in $$new_props) $$invalidate(4, rows = $$new_props.rows);
		if ("disabled" in $$new_props) $$invalidate(5, disabled = $$new_props.disabled);
		if ("title" in $$new_props) $$invalidate(26, title = $$new_props.title);
		if ("invalid" in $$new_props) $$invalidate(27, invalid = $$new_props.invalid);
		if ("min" in $$new_props) $$invalidate(6, min = $$new_props.min);
		if ("max" in $$new_props) $$invalidate(7, max = $$new_props.max);
		if ("list" in $$new_props) $$invalidate(8, list = $$new_props.list);
		if ("form" in $$new_props) $$invalidate(9, form = $$new_props.form);
		if ("readonly" in $$new_props) $$invalidate(10, readonly = $$new_props.readonly);
		if ("required" in $$new_props) $$invalidate(11, required = $$new_props.required);
		if ("pattern" in $$new_props) $$invalidate(28, pattern = $$new_props.pattern);
		if ("autocomplete" in $$new_props) $$invalidate(29, autocomplete = $$new_props.autocomplete);
		if ("autoselect" in $$new_props) $$invalidate(30, autoselect = $$new_props.autoselect);
		if ("ariaLabel" in $$new_props) $$invalidate(31, ariaLabel = $$new_props.ariaLabel);
		if ("placeholder" in $$new_props) $$invalidate(12, placeholder = $$new_props.placeholder);
	};

	$$self.$capture_state = () => {
		return {
			name,
			value,
			style,
			type,
			id,
			align,
			maxlength,
			rows,
			disabled,
			title,
			invalid,
			min,
			max,
			list,
			form,
			readonly,
			required,
			pattern,
			autocomplete,
			autoselect,
			ariaLabel,
			placeholder,
			idProp,
			typeProp,
			titleProp,
			ariaLabelProp,
			autocompleteProp,
			styleProp,
			patternProp,
			classProp
		};
	};

	$$self.$inject_state = $$new_props => {
		$$invalidate(32, $$props = assign(assign({}, $$props), $$new_props));
		if ("name" in $$props) $$invalidate(1, name = $$new_props.name);
		if ("value" in $$props) $$invalidate(0, value = $$new_props.value);
		if ("style" in $$props) $$invalidate(23, style = $$new_props.style);
		if ("type" in $$props) $$invalidate(24, type = $$new_props.type);
		if ("id" in $$props) $$invalidate(25, id = $$new_props.id);
		if ("align" in $$props) $$invalidate(2, align = $$new_props.align);
		if ("maxlength" in $$props) $$invalidate(3, maxlength = $$new_props.maxlength);
		if ("rows" in $$props) $$invalidate(4, rows = $$new_props.rows);
		if ("disabled" in $$props) $$invalidate(5, disabled = $$new_props.disabled);
		if ("title" in $$props) $$invalidate(26, title = $$new_props.title);
		if ("invalid" in $$props) $$invalidate(27, invalid = $$new_props.invalid);
		if ("min" in $$props) $$invalidate(6, min = $$new_props.min);
		if ("max" in $$props) $$invalidate(7, max = $$new_props.max);
		if ("list" in $$props) $$invalidate(8, list = $$new_props.list);
		if ("form" in $$props) $$invalidate(9, form = $$new_props.form);
		if ("readonly" in $$props) $$invalidate(10, readonly = $$new_props.readonly);
		if ("required" in $$props) $$invalidate(11, required = $$new_props.required);
		if ("pattern" in $$props) $$invalidate(28, pattern = $$new_props.pattern);
		if ("autocomplete" in $$props) $$invalidate(29, autocomplete = $$new_props.autocomplete);
		if ("autoselect" in $$props) $$invalidate(30, autoselect = $$new_props.autoselect);
		if ("ariaLabel" in $$props) $$invalidate(31, ariaLabel = $$new_props.ariaLabel);
		if ("placeholder" in $$props) $$invalidate(12, placeholder = $$new_props.placeholder);
		if ("idProp" in $$props) $$invalidate(15, idProp = $$new_props.idProp);
		if ("typeProp" in $$props) $$invalidate(16, typeProp = $$new_props.typeProp);
		if ("titleProp" in $$props) $$invalidate(17, titleProp = $$new_props.titleProp);
		if ("ariaLabelProp" in $$props) $$invalidate(18, ariaLabelProp = $$new_props.ariaLabelProp);
		if ("autocompleteProp" in $$props) $$invalidate(19, autocompleteProp = $$new_props.autocompleteProp);
		if ("styleProp" in $$props) $$invalidate(20, styleProp = $$new_props.styleProp);
		if ("patternProp" in $$props) $$invalidate(21, patternProp = $$new_props.patternProp);
		if ("classProp" in $$props) $$invalidate(13, classProp = $$new_props.classProp);
	};

	let classProp;

	$$self.$$.update = () => {
		 $$invalidate(13, classProp = classnames("inp", $$props.class, { disabled, readonly, required, invalid }));
	};

	$$props = exclude_internal_props($$props);

	return [
		value,
		name,
		align,
		maxlength,
		rows,
		disabled,
		min,
		max,
		list,
		form,
		readonly,
		required,
		placeholder,
		classProp,
		dispatch,
		idProp,
		typeProp,
		titleProp,
		ariaLabelProp,
		autocompleteProp,
		styleProp,
		patternProp,
		onClick,
		style,
		type,
		id,
		title,
		invalid,
		pattern,
		autocomplete,
		autoselect,
		ariaLabel,
		$$props,
		textarea_input_handler,
		blur_handler,
		focus_handler,
		input_input_handler,
		blur_handler_1,
		focus_handler_1
	];
}

class Input extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$4,
			create_fragment$5,
			safe_not_equal,
			{
				name: 1,
				value: 0,
				style: 23,
				type: 24,
				id: 25,
				align: 2,
				maxlength: 3,
				rows: 4,
				disabled: 5,
				title: 26,
				invalid: 27,
				min: 6,
				max: 7,
				list: 8,
				form: 9,
				readonly: 10,
				required: 11,
				pattern: 28,
				autocomplete: 29,
				autoselect: 30,
				ariaLabel: 31,
				placeholder: 12
			},
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Input",
			options,
			id: create_fragment$5.name
		});

		const { ctx } = this.$$;
		const props = options.props || ({});

		if (/*name*/ ctx[1] === undefined && !("name" in props)) {
			console.warn("<Input> was created without expected prop 'name'");
		}
	}

	get name() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set name(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get type() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set type(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get id() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get align() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set align(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get maxlength() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set maxlength(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get rows() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set rows(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get title() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get invalid() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set invalid(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get min() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set min(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get max() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set max(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get list() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set list(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get form() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set form(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get readonly() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set readonly(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get required() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set required(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get pattern() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set pattern(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get autocomplete() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set autocomplete(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get autoselect() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set autoselect(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ariaLabel() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ariaLabel(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get placeholder() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set placeholder(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/Picture.svelte generated by Svelte v3.16.7 */
const file$6 = "src/components/Picture.svelte";

function create_fragment$6(ctx) {
	let figure;
	let img;
	let img_src_value;
	let t;
	let figcaption;
	let figure_class_value;
	let current;
	let dispose;
	const default_slot_template = /*$$slots*/ ctx[13].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], null);

	const block = {
		c: function create() {
			figure = element("figure");
			img = element("img");
			t = space();
			figcaption = element("figcaption");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			figure = claim_element(nodes, "FIGURE", { class: true });
			var figure_nodes = children(figure);

			img = claim_element(figure_nodes, "IMG", {
				id: true,
				alt: true,
				src: true,
				width: true,
				height: true,
				class: true
			});

			t = claim_space(figure_nodes);
			figcaption = claim_element(figure_nodes, "FIGCAPTION", {});
			var figcaption_nodes = children(figcaption);
			if (default_slot) default_slot.l(figcaption_nodes);
			figcaption_nodes.forEach(detach_dev);
			figure_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(img, "id", /*id*/ ctx[2]);
			attr_dev(img, "alt", /*alt*/ ctx[1]);
			if (img.src !== (img_src_value = /*src*/ ctx[0])) attr_dev(img, "src", img_src_value);
			attr_dev(img, "width", /*width*/ ctx[3]);
			attr_dev(img, "height", /*height*/ ctx[4]);
			attr_dev(img, "class", "pic svelte-1rkw8xk");
			add_location(img, file$6, 30, 4, 654);
			add_location(figcaption, file$6, 41, 4, 849);
			attr_dev(figure, "class", figure_class_value = "" + (null_to_empty(/*wrapClassProp*/ ctx[5]) + " svelte-1rkw8xk"));
			add_location(figure, file$6, 29, 0, 619);

			dispose = [
				listen_dev(img, "load", /*onLoad*/ ctx[6], false, false, false),
				listen_dev(img, "error", /*onError*/ ctx[7], false, false, false)
			];
		},
		m: function mount(target, anchor) {
			insert_dev(target, figure, anchor);
			append_dev(figure, img);
			append_dev(figure, t);
			append_dev(figure, figcaption);

			if (default_slot) {
				default_slot.m(figcaption, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (!current || dirty & /*id*/ 4) {
				attr_dev(img, "id", /*id*/ ctx[2]);
			}

			if (!current || dirty & /*alt*/ 2) {
				attr_dev(img, "alt", /*alt*/ ctx[1]);
			}

			if (!current || dirty & /*src*/ 1 && img.src !== (img_src_value = /*src*/ ctx[0])) {
				attr_dev(img, "src", img_src_value);
			}

			if (!current || dirty & /*width*/ 8) {
				attr_dev(img, "width", /*width*/ ctx[3]);
			}

			if (!current || dirty & /*height*/ 16) {
				attr_dev(img, "height", /*height*/ ctx[4]);
			}

			if (default_slot && default_slot.p && dirty & /*$$scope*/ 4096) {
				default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[12], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[12], dirty, null));
			}

			if (!current || dirty & /*wrapClassProp*/ 32 && figure_class_value !== (figure_class_value = "" + (null_to_empty(/*wrapClassProp*/ ctx[5]) + " svelte-1rkw8xk"))) {
				attr_dev(figure, "class", figure_class_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(figure);
			if (default_slot) default_slot.d(detaching);
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$6.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$5($$self, $$props, $$invalidate) {
	const dispatch = createEventDispatcher();
	let { src } = $$props;
	let { alt } = $$props;
	let { id = undefined } = $$props;
	let { width = undefined } = $$props;
	let { height = undefined } = $$props;
	let loading = true;
	let isError = false;

	function onLoad(e) {
		$$invalidate(8, loading = false);
		dispatch("load", e);
	}

	function onError(e) {
		$$invalidate(8, loading = false);
		$$invalidate(9, isError = true);
		dispatch("error", e);
	}

	let { $$slots = {}, $$scope } = $$props;

	$$self.$set = $$new_props => {
		$$invalidate(11, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("src" in $$new_props) $$invalidate(0, src = $$new_props.src);
		if ("alt" in $$new_props) $$invalidate(1, alt = $$new_props.alt);
		if ("id" in $$new_props) $$invalidate(2, id = $$new_props.id);
		if ("width" in $$new_props) $$invalidate(3, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(4, height = $$new_props.height);
		if ("$$scope" in $$new_props) $$invalidate(12, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => {
		return {
			src,
			alt,
			id,
			width,
			height,
			loading,
			isError,
			wrapClassProp
		};
	};

	$$self.$inject_state = $$new_props => {
		$$invalidate(11, $$props = assign(assign({}, $$props), $$new_props));
		if ("src" in $$props) $$invalidate(0, src = $$new_props.src);
		if ("alt" in $$props) $$invalidate(1, alt = $$new_props.alt);
		if ("id" in $$props) $$invalidate(2, id = $$new_props.id);
		if ("width" in $$props) $$invalidate(3, width = $$new_props.width);
		if ("height" in $$props) $$invalidate(4, height = $$new_props.height);
		if ("loading" in $$props) $$invalidate(8, loading = $$new_props.loading);
		if ("isError" in $$props) $$invalidate(9, isError = $$new_props.isError);
		if ("wrapClassProp" in $$props) $$invalidate(5, wrapClassProp = $$new_props.wrapClassProp);
	};

	let wrapClassProp;

	$$self.$$.update = () => {
		 $$invalidate(5, wrapClassProp = classnames("picture", $$props.class, { loading, isError }));
	};

	$$props = exclude_internal_props($$props);

	return [
		src,
		alt,
		id,
		width,
		height,
		wrapClassProp,
		onLoad,
		onError,
		loading,
		isError,
		dispatch,
		$$props,
		$$scope,
		$$slots
	];
}

class Picture extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$5, create_fragment$6, safe_not_equal, {
			src: 0,
			alt: 1,
			id: 2,
			width: 3,
			height: 4
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Picture",
			options,
			id: create_fragment$6.name
		});

		const { ctx } = this.$$;
		const props = options.props || ({});

		if (/*src*/ ctx[0] === undefined && !("src" in props)) {
			console.warn("<Picture> was created without expected prop 'src'");
		}

		if (/*alt*/ ctx[1] === undefined && !("alt" in props)) {
			console.warn("<Picture> was created without expected prop 'alt'");
		}
	}

	get src() {
		throw new Error("<Picture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set src(value) {
		throw new Error("<Picture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get alt() {
		throw new Error("<Picture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set alt(value) {
		throw new Error("<Picture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get id() {
		throw new Error("<Picture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<Picture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<Picture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<Picture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get height() {
		throw new Error("<Picture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set height(value) {
		throw new Error("<Picture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/Avatar.svelte generated by Svelte v3.16.7 */
const file$7 = "src/components/Avatar.svelte";

function create_fragment$7(ctx) {
	let div;
	let div_class_value;
	let current;

	const picture = new Picture({
			props: { src: /*src*/ ctx[0], alt: /*alt*/ ctx[1] },
			$$inline: true
		});

	const block = {
		c: function create() {
			div = element("div");
			create_component(picture.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			claim_component(picture.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", div_class_value = "" + (null_to_empty(/*classProp*/ ctx[2]) + " svelte-ow3g6r"));
			add_location(div, file$7, 11, 0, 254);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(picture, div, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const picture_changes = {};
			if (dirty & /*src*/ 1) picture_changes.src = /*src*/ ctx[0];
			if (dirty & /*alt*/ 2) picture_changes.alt = /*alt*/ ctx[1];
			picture.$set(picture_changes);

			if (!current || dirty & /*classProp*/ 4 && div_class_value !== (div_class_value = "" + (null_to_empty(/*classProp*/ ctx[2]) + " svelte-ow3g6r"))) {
				attr_dev(div, "class", div_class_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(picture.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(picture.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(picture);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$7.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$6($$self, $$props, $$invalidate) {
	let { src } = $$props;
	let { alt } = $$props;
	let { size = "medium" } = $$props;

	$$self.$set = $$new_props => {
		$$invalidate(4, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("src" in $$new_props) $$invalidate(0, src = $$new_props.src);
		if ("alt" in $$new_props) $$invalidate(1, alt = $$new_props.alt);
		if ("size" in $$new_props) $$invalidate(3, size = $$new_props.size);
	};

	$$self.$capture_state = () => {
		return { src, alt, size, classProp };
	};

	$$self.$inject_state = $$new_props => {
		$$invalidate(4, $$props = assign(assign({}, $$props), $$new_props));
		if ("src" in $$props) $$invalidate(0, src = $$new_props.src);
		if ("alt" in $$props) $$invalidate(1, alt = $$new_props.alt);
		if ("size" in $$props) $$invalidate(3, size = $$new_props.size);
		if ("classProp" in $$props) $$invalidate(2, classProp = $$new_props.classProp);
	};

	let classProp;

	$$self.$$.update = () => {
		 $$invalidate(2, classProp = classnames("ava", size, $$props.class));
	};

	$$props = exclude_internal_props($$props);
	return [src, alt, classProp, size];
}

class Avatar extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$6, create_fragment$7, safe_not_equal, { src: 0, alt: 1, size: 3 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Avatar",
			options,
			id: create_fragment$7.name
		});

		const { ctx } = this.$$;
		const props = options.props || ({});

		if (/*src*/ ctx[0] === undefined && !("src" in props)) {
			console.warn("<Avatar> was created without expected prop 'src'");
		}

		if (/*alt*/ ctx[1] === undefined && !("alt" in props)) {
			console.warn("<Avatar> was created without expected prop 'alt'");
		}
	}

	get src() {
		throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set src(value) {
		throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get alt() {
		throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set alt(value) {
		throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/Button.svelte generated by Svelte v3.16.7 */
const file$8 = "src/components/Button.svelte";

// (53:0) {:else}
function create_else_block$1(ctx) {
	let button;
	let button_class_value;
	let current;
	let dispose;
	const default_slot_template = /*$$slots*/ ctx[17].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], null);

	const block = {
		c: function create() {
			button = element("button");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", {
				id: true,
				type: true,
				disabled: true,
				title: true,
				class: true,
				"aria-label": true
			});

			var button_nodes = children(button);
			if (default_slot) default_slot.l(button_nodes);
			button_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(button, "id", /*id*/ ctx[0]);
			attr_dev(button, "type", /*type*/ ctx[2]);
			button.disabled = /*disabled*/ ctx[4];
			attr_dev(button, "title", /*titleProp*/ ctx[7]);
			attr_dev(button, "class", button_class_value = "" + (null_to_empty(/*classProp*/ ctx[5]) + " svelte-1tdzxp7"));
			attr_dev(button, "aria-label", /*ariaLabelProp*/ ctx[8]);
			add_location(button, file$8, 53, 4, 1385);
			dispose = listen_dev(button, "click", /*click_handler_1*/ ctx[19], false, false, false);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);

			if (default_slot) {
				default_slot.m(button, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot && default_slot.p && dirty & /*$$scope*/ 65536) {
				default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[16], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[16], dirty, null));
			}

			if (!current || dirty & /*id*/ 1) {
				attr_dev(button, "id", /*id*/ ctx[0]);
			}

			if (!current || dirty & /*type*/ 4) {
				attr_dev(button, "type", /*type*/ ctx[2]);
			}

			if (!current || dirty & /*disabled*/ 16) {
				prop_dev(button, "disabled", /*disabled*/ ctx[4]);
			}

			if (!current || dirty & /*classProp*/ 32 && button_class_value !== (button_class_value = "" + (null_to_empty(/*classProp*/ ctx[5]) + " svelte-1tdzxp7"))) {
				attr_dev(button, "class", button_class_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (default_slot) default_slot.d(detaching);
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$1.name,
		type: "else",
		source: "(53:0) {:else}",
		ctx
	});

	return block;
}

// (41:18) 
function create_if_block_1(ctx) {
	let label;
	let label_class_value;
	let current;
	let dispose;
	const default_slot_template = /*$$slots*/ ctx[17].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], null);

	const block = {
		c: function create() {
			label = element("label");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			label = claim_element(nodes, "LABEL", {
				id: true,
				disabled: true,
				for: true,
				title: true,
				class: true,
				"aria-label": true
			});

			var label_nodes = children(label);
			if (default_slot) default_slot.l(label_nodes);
			label_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(label, "id", /*id*/ ctx[0]);
			attr_dev(label, "disabled", /*disabled*/ ctx[4]);
			attr_dev(label, "for", /*htmlFor*/ ctx[3]);
			attr_dev(label, "title", /*titleProp*/ ctx[7]);
			attr_dev(label, "class", label_class_value = "" + (null_to_empty(/*classProp*/ ctx[5]) + " svelte-1tdzxp7"));
			attr_dev(label, "aria-label", /*ariaLabelProp*/ ctx[8]);
			add_location(label, file$8, 41, 4, 1124);
			dispose = listen_dev(label, "click", /*onLabelClick*/ ctx[9], false, false, false);
		},
		m: function mount(target, anchor) {
			insert_dev(target, label, anchor);

			if (default_slot) {
				default_slot.m(label, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot && default_slot.p && dirty & /*$$scope*/ 65536) {
				default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[16], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[16], dirty, null));
			}

			if (!current || dirty & /*id*/ 1) {
				attr_dev(label, "id", /*id*/ ctx[0]);
			}

			if (!current || dirty & /*disabled*/ 16) {
				attr_dev(label, "disabled", /*disabled*/ ctx[4]);
			}

			if (!current || dirty & /*htmlFor*/ 8) {
				attr_dev(label, "for", /*htmlFor*/ ctx[3]);
			}

			if (!current || dirty & /*classProp*/ 32 && label_class_value !== (label_class_value = "" + (null_to_empty(/*classProp*/ ctx[5]) + " svelte-1tdzxp7"))) {
				attr_dev(label, "class", label_class_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(label);
			if (default_slot) default_slot.d(detaching);
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(41:18) ",
		ctx
	});

	return block;
}

// (30:0) {#if href}
function create_if_block$2(ctx) {
	let a;
	let a_class_value;
	let current;
	let dispose;
	const default_slot_template = /*$$slots*/ ctx[17].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], null);

	const block = {
		c: function create() {
			a = element("a");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			a = claim_element(nodes, "A", {
				id: true,
				href: true,
				title: true,
				class: true,
				"aria-label": true
			});

			var a_nodes = children(a);
			if (default_slot) default_slot.l(a_nodes);
			a_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a, "id", /*id*/ ctx[0]);
			attr_dev(a, "href", /*href*/ ctx[1]);
			attr_dev(a, "title", /*titleProp*/ ctx[7]);
			attr_dev(a, "class", a_class_value = "" + (null_to_empty(/*classProp*/ ctx[5]) + " svelte-1tdzxp7"));
			attr_dev(a, "aria-label", /*ariaLabelProp*/ ctx[8]);
			add_location(a, file$8, 30, 4, 862);
			dispose = listen_dev(a, "click", /*click_handler*/ ctx[18], false, false, false);
		},
		m: function mount(target, anchor) {
			insert_dev(target, a, anchor);

			if (default_slot) {
				default_slot.m(a, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot && default_slot.p && dirty & /*$$scope*/ 65536) {
				default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[16], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[16], dirty, null));
			}

			if (!current || dirty & /*id*/ 1) {
				attr_dev(a, "id", /*id*/ ctx[0]);
			}

			if (!current || dirty & /*href*/ 2) {
				attr_dev(a, "href", /*href*/ ctx[1]);
			}

			if (!current || dirty & /*classProp*/ 32 && a_class_value !== (a_class_value = "" + (null_to_empty(/*classProp*/ ctx[5]) + " svelte-1tdzxp7"))) {
				attr_dev(a, "class", a_class_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(a);
			if (default_slot) default_slot.d(detaching);
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$2.name,
		type: "if",
		source: "(30:0) {#if href}",
		ctx
	});

	return block;
}

function create_fragment$8(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$2, create_if_block_1, create_else_block$1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*href*/ ctx[1]) return 0;
		if (/*htmlFor*/ ctx[3]) return 1;
		return 2;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$8.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$7($$self, $$props, $$invalidate) {
	const dispatch = createEventDispatcher();
	let { is = undefined } = $$props;
	let { id = undefined } = $$props;
	let { href = undefined } = $$props;
	let { auto = false } = $$props;
	let { type = "button" } = $$props;
	let { size = "medium" } = $$props;
	let { title = undefined } = $$props;
	let { htmlFor = undefined } = $$props;
	let { disabled = false } = $$props;
	let { ariaLabel = undefined } = $$props;
	let titleProp = title || ariaLabel;
	let ariaLabelProp = ariaLabel || title;

	function onLabelClick(e) {
		document.getElementById(htmlFor).click();
		!disabled && dispatch("click", e);
	}

	let { $$slots = {}, $$scope } = $$props;
	const click_handler = e => !disabled && dispatch("click", e);
	const click_handler_1 = e => !disabled && dispatch("click", e);

	$$self.$set = $$new_props => {
		$$invalidate(15, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("is" in $$new_props) $$invalidate(10, is = $$new_props.is);
		if ("id" in $$new_props) $$invalidate(0, id = $$new_props.id);
		if ("href" in $$new_props) $$invalidate(1, href = $$new_props.href);
		if ("auto" in $$new_props) $$invalidate(11, auto = $$new_props.auto);
		if ("type" in $$new_props) $$invalidate(2, type = $$new_props.type);
		if ("size" in $$new_props) $$invalidate(12, size = $$new_props.size);
		if ("title" in $$new_props) $$invalidate(13, title = $$new_props.title);
		if ("htmlFor" in $$new_props) $$invalidate(3, htmlFor = $$new_props.htmlFor);
		if ("disabled" in $$new_props) $$invalidate(4, disabled = $$new_props.disabled);
		if ("ariaLabel" in $$new_props) $$invalidate(14, ariaLabel = $$new_props.ariaLabel);
		if ("$$scope" in $$new_props) $$invalidate(16, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => {
		return {
			is,
			id,
			href,
			auto,
			type,
			size,
			title,
			htmlFor,
			disabled,
			ariaLabel,
			titleProp,
			ariaLabelProp,
			classProp
		};
	};

	$$self.$inject_state = $$new_props => {
		$$invalidate(15, $$props = assign(assign({}, $$props), $$new_props));
		if ("is" in $$props) $$invalidate(10, is = $$new_props.is);
		if ("id" in $$props) $$invalidate(0, id = $$new_props.id);
		if ("href" in $$props) $$invalidate(1, href = $$new_props.href);
		if ("auto" in $$props) $$invalidate(11, auto = $$new_props.auto);
		if ("type" in $$props) $$invalidate(2, type = $$new_props.type);
		if ("size" in $$props) $$invalidate(12, size = $$new_props.size);
		if ("title" in $$props) $$invalidate(13, title = $$new_props.title);
		if ("htmlFor" in $$props) $$invalidate(3, htmlFor = $$new_props.htmlFor);
		if ("disabled" in $$props) $$invalidate(4, disabled = $$new_props.disabled);
		if ("ariaLabel" in $$props) $$invalidate(14, ariaLabel = $$new_props.ariaLabel);
		if ("titleProp" in $$props) $$invalidate(7, titleProp = $$new_props.titleProp);
		if ("ariaLabelProp" in $$props) $$invalidate(8, ariaLabelProp = $$new_props.ariaLabelProp);
		if ("classProp" in $$props) $$invalidate(5, classProp = $$new_props.classProp);
	};

	let classProp;

	$$self.$$.update = () => {
		 $$invalidate(5, classProp = classnames("btn", is, size, $$props.class, { auto, disabled }));
	};

	$$props = exclude_internal_props($$props);

	return [
		id,
		href,
		type,
		htmlFor,
		disabled,
		classProp,
		dispatch,
		titleProp,
		ariaLabelProp,
		onLabelClick,
		is,
		auto,
		size,
		title,
		ariaLabel,
		$$props,
		$$scope,
		$$slots,
		click_handler,
		click_handler_1
	];
}

class Button extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$7, create_fragment$8, safe_not_equal, {
			is: 10,
			id: 0,
			href: 1,
			auto: 11,
			type: 2,
			size: 12,
			title: 13,
			htmlFor: 3,
			disabled: 4,
			ariaLabel: 14
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Button",
			options,
			id: create_fragment$8.name
		});
	}

	get is() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set is(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get id() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get href() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set href(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get auto() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set auto(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get type() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set type(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get title() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get htmlFor() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set htmlFor(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ariaLabel() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ariaLabel(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/Divider.svelte generated by Svelte v3.16.7 */
const file$9 = "src/components/Divider.svelte";

function create_fragment$9(ctx) {
	let hr;
	let hr_class_value;

	const block = {
		c: function create() {
			hr = element("hr");
			this.h();
		},
		l: function claim(nodes) {
			hr = claim_element(nodes, "HR", { class: true, style: true });
			this.h();
		},
		h: function hydrate() {
			attr_dev(hr, "class", hr_class_value = "" + (null_to_empty(/*classProp*/ ctx[0]) + " svelte-10708ut"));
			attr_dev(hr, "style", /*styleProp*/ ctx[1]);
			add_location(hr, file$9, 11, 0, 298);
		},
		m: function mount(target, anchor) {
			insert_dev(target, hr, anchor);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*classProp*/ 1 && hr_class_value !== (hr_class_value = "" + (null_to_empty(/*classProp*/ ctx[0]) + " svelte-10708ut"))) {
				attr_dev(hr, "class", hr_class_value);
			}

			if (dirty & /*styleProp*/ 2) {
				attr_dev(hr, "style", /*styleProp*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(hr);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$9.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$8($$self, $$props, $$invalidate) {
	let { is = "info" } = $$props;
	let { size = 0 } = $$props;
	let { width = 2 } = $$props;

	$$self.$set = $$new_props => {
		$$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("is" in $$new_props) $$invalidate(2, is = $$new_props.is);
		if ("size" in $$new_props) $$invalidate(3, size = $$new_props.size);
		if ("width" in $$new_props) $$invalidate(4, width = $$new_props.width);
	};

	$$self.$capture_state = () => {
		return { is, size, width, classProp, styleProp };
	};

	$$self.$inject_state = $$new_props => {
		$$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
		if ("is" in $$props) $$invalidate(2, is = $$new_props.is);
		if ("size" in $$props) $$invalidate(3, size = $$new_props.size);
		if ("width" in $$props) $$invalidate(4, width = $$new_props.width);
		if ("classProp" in $$props) $$invalidate(0, classProp = $$new_props.classProp);
		if ("styleProp" in $$props) $$invalidate(1, styleProp = $$new_props.styleProp);
	};

	let classProp;
	let styleProp;

	$$self.$$.update = () => {
		 $$invalidate(0, classProp = classnames("divider", is, $$props.class));

		if ($$self.$$.dirty & /*size, width*/ 24) {
			 $$invalidate(1, styleProp = toCSSString({
				padding: `${size / 2}px 0`,
				height: `${width}px`
			}));
		}
	};

	$$props = exclude_internal_props($$props);
	return [classProp, styleProp, is, size, width];
}

class Divider extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$8, create_fragment$9, safe_not_equal, { is: 2, size: 3, width: 4 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Divider",
			options,
			id: create_fragment$9.name
		});
	}

	get is() {
		throw new Error("<Divider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set is(value) {
		throw new Error("<Divider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<Divider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<Divider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<Divider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<Divider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/Progress.svelte generated by Svelte v3.16.7 */
const file$a = "src/components/Progress.svelte";

function create_fragment$a(ctx) {
	let div2;
	let div1;
	let div0;
	let div0_style_value;
	let div2_class_value;
	let div2_style_value;

	const block = {
		c: function create() {
			div2 = element("div");
			div1 = element("div");
			div0 = element("div");
			this.h();
		},
		l: function claim(nodes) {
			div2 = claim_element(nodes, "DIV", {
				id: true,
				class: true,
				title: true,
				"aria-label": true,
				role: true,
				"aria-valuemin": true,
				"aria-valuemax": true,
				"aria-valuenow": true,
				style: true
			});

			var div2_nodes = children(div2);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true, style: true });
			children(div0).forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "progress-core svelte-we6n45");
			attr_dev(div0, "style", div0_style_value = `width:${/*val*/ ctx[2]}%`);
			add_location(div0, file$a, 44, 8, 1381);
			attr_dev(div1, "class", "progress-inner-frame svelte-we6n45");
			add_location(div1, file$a, 43, 4, 1338);
			attr_dev(div2, "id", /*id*/ ctx[0]);
			attr_dev(div2, "class", div2_class_value = "" + (null_to_empty(/*classProp*/ ctx[5]) + " svelte-we6n45"));
			attr_dev(div2, "title", /*titleProp*/ ctx[3]);
			attr_dev(div2, "aria-label", /*ariaLabelProp*/ ctx[4]);
			attr_dev(div2, "role", "progressbar");
			attr_dev(div2, "aria-valuemin", "0");
			attr_dev(div2, "aria-valuemax", "100");
			attr_dev(div2, "aria-valuenow", /*val*/ ctx[2]);
			attr_dev(div2, "style", div2_style_value = `${getBorderRadius(/*borderRadius*/ ctx[1])}`);
			add_location(div2, file$a, 32, 0, 1067);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);
			append_dev(div2, div1);
			append_dev(div1, div0);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*val*/ 4 && div0_style_value !== (div0_style_value = `width:${/*val*/ ctx[2]}%`)) {
				attr_dev(div0, "style", div0_style_value);
			}

			if (dirty & /*id*/ 1) {
				attr_dev(div2, "id", /*id*/ ctx[0]);
			}

			if (dirty & /*classProp*/ 32 && div2_class_value !== (div2_class_value = "" + (null_to_empty(/*classProp*/ ctx[5]) + " svelte-we6n45"))) {
				attr_dev(div2, "class", div2_class_value);
			}

			if (dirty & /*titleProp*/ 8) {
				attr_dev(div2, "title", /*titleProp*/ ctx[3]);
			}

			if (dirty & /*ariaLabelProp*/ 16) {
				attr_dev(div2, "aria-label", /*ariaLabelProp*/ ctx[4]);
			}

			if (dirty & /*val*/ 4) {
				attr_dev(div2, "aria-valuenow", /*val*/ ctx[2]);
			}

			if (dirty & /*borderRadius*/ 2 && div2_style_value !== (div2_style_value = `${getBorderRadius(/*borderRadius*/ ctx[1])}`)) {
				attr_dev(div2, "style", div2_style_value);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div2);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$a.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function getBorderRadius(borders, defaults = "99999px") {
	const brDefault = new Array(4).fill(defaults);
	const bds = safeGet(() => borders.split(" "), [], true);
	const rule = "border-radius";
	return `${rule}:${brDefault.map((def, i) => `${bds[i] || def}`).join(" ")}`;
}

function instance$9($$self, $$props, $$invalidate) {
	const dispatch = createEventDispatcher();
	let { id = undefined } = $$props;
	let { value = 0 } = $$props;
	let { size = "medium" } = $$props;
	let { title = undefined } = $$props;
	let { ariaLabel = undefined } = $$props;
	let { borderRadius = undefined } = $$props;

	onMount(() => {
		setTimeout(
			() => $$invalidate(2, val = Number.isFinite(+value)
			? Math.max(0, Math.min(+value, 100))
			: 0),
			0
		);
	});

	$$self.$set = $$new_props => {
		$$invalidate(11, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("id" in $$new_props) $$invalidate(0, id = $$new_props.id);
		if ("value" in $$new_props) $$invalidate(6, value = $$new_props.value);
		if ("size" in $$new_props) $$invalidate(7, size = $$new_props.size);
		if ("title" in $$new_props) $$invalidate(8, title = $$new_props.title);
		if ("ariaLabel" in $$new_props) $$invalidate(9, ariaLabel = $$new_props.ariaLabel);
		if ("borderRadius" in $$new_props) $$invalidate(1, borderRadius = $$new_props.borderRadius);
	};

	$$self.$capture_state = () => {
		return {
			id,
			value,
			size,
			title,
			ariaLabel,
			borderRadius,
			val,
			titleProp,
			ariaLabelProp,
			classProp
		};
	};

	$$self.$inject_state = $$new_props => {
		$$invalidate(11, $$props = assign(assign({}, $$props), $$new_props));
		if ("id" in $$props) $$invalidate(0, id = $$new_props.id);
		if ("value" in $$props) $$invalidate(6, value = $$new_props.value);
		if ("size" in $$props) $$invalidate(7, size = $$new_props.size);
		if ("title" in $$props) $$invalidate(8, title = $$new_props.title);
		if ("ariaLabel" in $$props) $$invalidate(9, ariaLabel = $$new_props.ariaLabel);
		if ("borderRadius" in $$props) $$invalidate(1, borderRadius = $$new_props.borderRadius);
		if ("val" in $$props) $$invalidate(2, val = $$new_props.val);
		if ("titleProp" in $$props) $$invalidate(3, titleProp = $$new_props.titleProp);
		if ("ariaLabelProp" in $$props) $$invalidate(4, ariaLabelProp = $$new_props.ariaLabelProp);
		if ("classProp" in $$props) $$invalidate(5, classProp = $$new_props.classProp);
	};

	let val;
	let titleProp;
	let ariaLabelProp;
	let classProp;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*title, val*/ 260) {
			 $$invalidate(3, titleProp = title || `Progress - ${val}%`);
		}

		if ($$self.$$.dirty & /*ariaLabel, val*/ 516) {
			 $$invalidate(4, ariaLabelProp = ariaLabel || `Progress - ${val}%`);
		}

		 $$invalidate(5, classProp = classnames("progress", size, $$props.class));
	};

	 $$invalidate(2, val = 0);
	$$props = exclude_internal_props($$props);

	return [
		id,
		borderRadius,
		val,
		titleProp,
		ariaLabelProp,
		classProp,
		value,
		size,
		title,
		ariaLabel
	];
}

class Progress extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$9, create_fragment$a, safe_not_equal, {
			id: 0,
			value: 6,
			size: 7,
			title: 8,
			ariaLabel: 9,
			borderRadius: 1
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Progress",
			options,
			id: create_fragment$a.name
		});
	}

	get id() {
		throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get title() {
		throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ariaLabel() {
		throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ariaLabel(value) {
		throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get borderRadius() {
		throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set borderRadius(value) {
		throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/layouts/Carousel.svelte generated by Svelte v3.16.7 */
const file$b = "src/layouts/Carousel.svelte";

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[2] = list[i];
	return child_ctx;
}

// (21:12) <SwipeItem>
function create_default_slot_1(ctx) {
	let t;
	let current;

	const picture = new Picture({
			props: {
				src: /*img*/ ctx[2].src,
				alt: /*img*/ ctx[2].alt
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(picture.$$.fragment);
			t = space();
		},
		l: function claim(nodes) {
			claim_component(picture.$$.fragment, nodes);
			t = claim_space(nodes);
		},
		m: function mount(target, anchor) {
			mount_component(picture, target, anchor);
			insert_dev(target, t, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const picture_changes = {};
			if (dirty & /*imagesArr*/ 1) picture_changes.src = /*img*/ ctx[2].src;
			if (dirty & /*imagesArr*/ 1) picture_changes.alt = /*img*/ ctx[2].alt;
			picture.$set(picture_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(picture.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(picture.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(picture, detaching);
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1.name,
		type: "slot",
		source: "(21:12) <SwipeItem>",
		ctx
	});

	return block;
}

// (20:8) {#each imagesArr as img}
function create_each_block$1(ctx) {
	let current;

	const swipeitem = new SwipeItem({
			props: {
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(swipeitem.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(swipeitem.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(swipeitem, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const swipeitem_changes = {};

			if (dirty & /*$$scope, imagesArr*/ 33) {
				swipeitem_changes.$$scope = { dirty, ctx };
			}

			swipeitem.$set(swipeitem_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(swipeitem.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(swipeitem.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(swipeitem, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$1.name,
		type: "each",
		source: "(20:8) {#each imagesArr as img}",
		ctx
	});

	return block;
}

// (19:4) <Swipe>
function create_default_slot(ctx) {
	let each_1_anchor;
	let current;
	let each_value = /*imagesArr*/ ctx[0];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty & /*imagesArr*/ 1) {
				each_value = /*imagesArr*/ ctx[0];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(19:4) <Swipe>",
		ctx
	});

	return block;
}

function create_fragment$b(ctx) {
	let section;
	let current;

	const swipe = new Swipe({
			props: {
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			section = element("section");
			create_component(swipe.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { class: true });
			var section_nodes = children(section);
			claim_component(swipe.$$.fragment, section_nodes);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(section, "class", "svelte-f86mtu");
			add_location(section, file$b, 17, 0, 374);
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			mount_component(swipe, section, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const swipe_changes = {};

			if (dirty & /*$$scope, imagesArr*/ 33) {
				swipe_changes.$$scope = { dirty, ctx };
			}

			swipe.$set(swipe_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(swipe.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(swipe.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			destroy_component(swipe);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$b.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$a($$self, $$props, $$invalidate) {
	let { images = undefined } = $$props;
	const writable_props = ["images"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Carousel> was created with unknown prop '${key}'`);
	});

	$$self.$set = $$props => {
		if ("images" in $$props) $$invalidate(1, images = $$props.images);
	};

	$$self.$capture_state = () => {
		return { images, imagesArr };
	};

	$$self.$inject_state = $$props => {
		if ("images" in $$props) $$invalidate(1, images = $$props.images);
		if ("imagesArr" in $$props) $$invalidate(0, imagesArr = $$props.imagesArr);
	};

	let imagesArr;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*images*/ 2) {
			 $$invalidate(0, imagesArr = [].concat(images).map(img => typeof img === "string" ? { src: img } : img));
		}
	};

	return [imagesArr, images];
}

class Carousel extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$a, create_fragment$b, safe_not_equal, { images: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Carousel",
			options,
			id: create_fragment$b.name
		});
	}

	get images() {
		throw new Error("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set images(value) {
		throw new Error("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/layouts/AvatarAndName.svelte generated by Svelte v3.16.7 */
const file$c = "src/layouts/AvatarAndName.svelte";

function create_fragment$c(ctx) {
	let section;
	let t0;
	let span;
	let h5;
	let t1;
	let t2;
	let h6;
	let t3;
	let current;

	const avatar = new Avatar({
			props: {
				src: /*src*/ ctx[0],
				alt: /*title*/ ctx[1]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			section = element("section");
			create_component(avatar.$$.fragment);
			t0 = space();
			span = element("span");
			h5 = element("h5");
			t1 = text(/*title*/ ctx[1]);
			t2 = space();
			h6 = element("h6");
			t3 = text(/*subTitle*/ ctx[2]);
			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { class: true });
			var section_nodes = children(section);
			claim_component(avatar.$$.fragment, section_nodes);
			t0 = claim_space(section_nodes);
			span = claim_element(section_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			h5 = claim_element(span_nodes, "H5", { class: true });
			var h5_nodes = children(h5);
			t1 = claim_text(h5_nodes, /*title*/ ctx[1]);
			h5_nodes.forEach(detach_dev);
			t2 = claim_space(span_nodes);
			h6 = claim_element(span_nodes, "H6", { class: true });
			var h6_nodes = children(h6);
			t3 = claim_text(h6_nodes, /*subTitle*/ ctx[2]);
			h6_nodes.forEach(detach_dev);
			span_nodes.forEach(detach_dev);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(h5, "class", "svelte-158fepf");
			add_location(h5, file$c, 12, 8, 230);
			attr_dev(h6, "class", "svelte-158fepf");
			add_location(h6, file$c, 13, 8, 255);
			attr_dev(span, "class", "svelte-158fepf");
			add_location(span, file$c, 11, 4, 215);
			attr_dev(section, "class", "svelte-158fepf");
			add_location(section, file$c, 8, 0, 164);
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			mount_component(avatar, section, null);
			append_dev(section, t0);
			append_dev(section, span);
			append_dev(span, h5);
			append_dev(h5, t1);
			append_dev(span, t2);
			append_dev(span, h6);
			append_dev(h6, t3);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const avatar_changes = {};
			if (dirty & /*src*/ 1) avatar_changes.src = /*src*/ ctx[0];
			if (dirty & /*title*/ 2) avatar_changes.alt = /*title*/ ctx[1];
			avatar.$set(avatar_changes);
			if (!current || dirty & /*title*/ 2) set_data_dev(t1, /*title*/ ctx[1]);
			if (!current || dirty & /*subTitle*/ 4) set_data_dev(t3, /*subTitle*/ ctx[2]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(avatar.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(avatar.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			destroy_component(avatar);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$c.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$b($$self, $$props, $$invalidate) {
	let { src = undefined } = $$props;
	let { title = undefined } = $$props;
	let { subTitle = undefined } = $$props;
	const writable_props = ["src", "title", "subTitle"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AvatarAndName> was created with unknown prop '${key}'`);
	});

	$$self.$set = $$props => {
		if ("src" in $$props) $$invalidate(0, src = $$props.src);
		if ("title" in $$props) $$invalidate(1, title = $$props.title);
		if ("subTitle" in $$props) $$invalidate(2, subTitle = $$props.subTitle);
	};

	$$self.$capture_state = () => {
		return { src, title, subTitle };
	};

	$$self.$inject_state = $$props => {
		if ("src" in $$props) $$invalidate(0, src = $$props.src);
		if ("title" in $$props) $$invalidate(1, title = $$props.title);
		if ("subTitle" in $$props) $$invalidate(2, subTitle = $$props.subTitle);
	};

	return [src, title, subTitle];
}

class AvatarAndName extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$b, create_fragment$c, safe_not_equal, { src: 0, title: 1, subTitle: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "AvatarAndName",
			options,
			id: create_fragment$c.name
		});
	}

	get src() {
		throw new Error("<AvatarAndName>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set src(value) {
		throw new Error("<AvatarAndName>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get title() {
		throw new Error("<AvatarAndName>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<AvatarAndName>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get subTitle() {
		throw new Error("<AvatarAndName>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set subTitle(value) {
		throw new Error("<AvatarAndName>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/layouts/CharityCard.svelte generated by Svelte v3.16.7 */
const file$d = "src/layouts/CharityCard.svelte";

function create_fragment$d(ctx) {
	let section;
	let div0;
	let t0;
	let t1;
	let h4;
	let t2;
	let t3;
	let div1;
	let t4;
	let footer;
	let current;

	const carousel = new Carousel({
			props: { images: /*src*/ ctx[0] },
			$$inline: true
		});

	const progress = new Progress({
			props: {
				value: /*percent*/ ctx[2],
				borderRadius: "0 0"
			},
			$$inline: true
		});

	const rate = new Rate({ props: { size: "small" }, $$inline: true });

	const avatarandname = new AvatarAndName({
			props: {
				src: /*orgHeadSrc*/ ctx[4],
				title: /*orgHead*/ ctx[3],
				subTitle: /*organization*/ ctx[5]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			section = element("section");
			div0 = element("div");
			create_component(carousel.$$.fragment);
			t0 = space();
			create_component(progress.$$.fragment);
			t1 = space();
			h4 = element("h4");
			t2 = text(/*title*/ ctx[1]);
			t3 = space();
			div1 = element("div");
			create_component(rate.$$.fragment);
			t4 = space();
			footer = element("footer");
			create_component(avatarandname.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { class: true });
			var section_nodes = children(section);
			div0 = claim_element(section_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			claim_component(carousel.$$.fragment, div0_nodes);
			div0_nodes.forEach(detach_dev);
			t0 = claim_space(section_nodes);
			claim_component(progress.$$.fragment, section_nodes);
			t1 = claim_space(section_nodes);
			h4 = claim_element(section_nodes, "H4", { class: true });
			var h4_nodes = children(h4);
			t2 = claim_text(h4_nodes, /*title*/ ctx[1]);
			h4_nodes.forEach(detach_dev);
			t3 = claim_space(section_nodes);
			div1 = claim_element(section_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			claim_component(rate.$$.fragment, div1_nodes);
			div1_nodes.forEach(detach_dev);
			t4 = claim_space(section_nodes);
			footer = claim_element(section_nodes, "FOOTER", {});
			var footer_nodes = children(footer);
			claim_component(avatarandname.$$.fragment, footer_nodes);
			footer_nodes.forEach(detach_dev);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "images-wrap svelte-do16pj");
			add_location(div0, file$d, 14, 4, 419);
			attr_dev(h4, "class", "svelte-do16pj");
			add_location(h4, file$d, 20, 4, 546);
			attr_dev(div1, "class", "rate-wrap svelte-do16pj");
			add_location(div1, file$d, 22, 4, 568);
			add_location(footer, file$d, 26, 4, 637);
			attr_dev(section, "class", "card svelte-do16pj");
			add_location(section, file$d, 13, 0, 392);
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			append_dev(section, div0);
			mount_component(carousel, div0, null);
			append_dev(section, t0);
			mount_component(progress, section, null);
			append_dev(section, t1);
			append_dev(section, h4);
			append_dev(h4, t2);
			append_dev(section, t3);
			append_dev(section, div1);
			mount_component(rate, div1, null);
			append_dev(section, t4);
			append_dev(section, footer);
			mount_component(avatarandname, footer, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const carousel_changes = {};
			if (dirty & /*src*/ 1) carousel_changes.images = /*src*/ ctx[0];
			carousel.$set(carousel_changes);
			const progress_changes = {};
			if (dirty & /*percent*/ 4) progress_changes.value = /*percent*/ ctx[2];
			progress.$set(progress_changes);
			if (!current || dirty & /*title*/ 2) set_data_dev(t2, /*title*/ ctx[1]);
			const avatarandname_changes = {};
			if (dirty & /*orgHeadSrc*/ 16) avatarandname_changes.src = /*orgHeadSrc*/ ctx[4];
			if (dirty & /*orgHead*/ 8) avatarandname_changes.title = /*orgHead*/ ctx[3];
			if (dirty & /*organization*/ 32) avatarandname_changes.subTitle = /*organization*/ ctx[5];
			avatarandname.$set(avatarandname_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(carousel.$$.fragment, local);
			transition_in(progress.$$.fragment, local);
			transition_in(rate.$$.fragment, local);
			transition_in(avatarandname.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(carousel.$$.fragment, local);
			transition_out(progress.$$.fragment, local);
			transition_out(rate.$$.fragment, local);
			transition_out(avatarandname.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			destroy_component(carousel);
			destroy_component(progress);
			destroy_component(rate);
			destroy_component(avatarandname);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$d.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$c($$self, $$props, $$invalidate) {
	let { src = undefined } = $$props;
	let { title = undefined } = $$props;
	let { percent = undefined } = $$props;
	let { orgHead = undefined } = $$props;
	let { orgHeadSrc = undefined } = $$props;
	let { organization = undefined } = $$props;
	const writable_props = ["src", "title", "percent", "orgHead", "orgHeadSrc", "organization"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<CharityCard> was created with unknown prop '${key}'`);
	});

	$$self.$set = $$props => {
		if ("src" in $$props) $$invalidate(0, src = $$props.src);
		if ("title" in $$props) $$invalidate(1, title = $$props.title);
		if ("percent" in $$props) $$invalidate(2, percent = $$props.percent);
		if ("orgHead" in $$props) $$invalidate(3, orgHead = $$props.orgHead);
		if ("orgHeadSrc" in $$props) $$invalidate(4, orgHeadSrc = $$props.orgHeadSrc);
		if ("organization" in $$props) $$invalidate(5, organization = $$props.organization);
	};

	$$self.$capture_state = () => {
		return {
			src,
			title,
			percent,
			orgHead,
			orgHeadSrc,
			organization
		};
	};

	$$self.$inject_state = $$props => {
		if ("src" in $$props) $$invalidate(0, src = $$props.src);
		if ("title" in $$props) $$invalidate(1, title = $$props.title);
		if ("percent" in $$props) $$invalidate(2, percent = $$props.percent);
		if ("orgHead" in $$props) $$invalidate(3, orgHead = $$props.orgHead);
		if ("orgHeadSrc" in $$props) $$invalidate(4, orgHeadSrc = $$props.orgHeadSrc);
		if ("organization" in $$props) $$invalidate(5, organization = $$props.organization);
	};

	return [src, title, percent, orgHead, orgHeadSrc, organization];
}

class CharityCard extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$c, create_fragment$d, safe_not_equal, {
			src: 0,
			title: 1,
			percent: 2,
			orgHead: 3,
			orgHeadSrc: 4,
			organization: 5
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "CharityCard",
			options,
			id: create_fragment$d.name
		});
	}

	get src() {
		throw new Error("<CharityCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set src(value) {
		throw new Error("<CharityCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get title() {
		throw new Error("<CharityCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<CharityCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get percent() {
		throw new Error("<CharityCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set percent(value) {
		throw new Error("<CharityCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get orgHead() {
		throw new Error("<CharityCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set orgHead(value) {
		throw new Error("<CharityCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get orgHeadSrc() {
		throw new Error("<CharityCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set orgHeadSrc(value) {
		throw new Error("<CharityCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get organization() {
		throw new Error("<CharityCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set organization(value) {
		throw new Error("<CharityCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/layouts/NavigationBar.svelte generated by Svelte v3.16.7 */
const file$e = "src/layouts/NavigationBar.svelte";

// (36:12) <Button on:click={changeTheme} auto size="small">
function create_default_slot_1$1(ctx) {
	let current;

	const icon = new Icon({
			props: { type: "moon", class: "theme-svg-fill" },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(icon.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$1.name,
		type: "slot",
		source: "(36:12) <Button on:click={changeTheme} auto size=\\\"small\\\">",
		ctx
	});

	return block;
}

// (42:12) <Button on:click={changeTheme} auto size="small">
function create_default_slot$1(ctx) {
	let current;

	const avatar = new Avatar({
			props: {
				size: "small",
				src: "https://placeimg.com/300/300/people"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(avatar.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(avatar.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(avatar, target, anchor);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(avatar.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(avatar.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(avatar, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$1.name,
		type: "slot",
		source: "(42:12) <Button on:click={changeTheme} auto size=\\\"small\\\">",
		ctx
	});

	return block;
}

function create_fragment$e(ctx) {
	let nav;
	let ul0;
	let li0;
	let a0;
	let t0;
	let t1;
	let li1;
	let a1;
	let t2;
	let t3;
	let li2;
	let a2;
	let t4;
	let t5;
	let li3;
	let a3;
	let t6;
	let t7;
	let ul1;
	let li4;
	let select;
	let option0;
	let t8;
	let option1;
	let t9;
	let option2;
	let t10;
	let select_value_value;
	let t11;
	let li5;
	let t12;
	let li6;
	let current;

	const button0 = new Button({
			props: {
				auto: true,
				size: "small",
				$$slots: { default: [create_default_slot_1$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button0.$on("click", /*changeTheme*/ ctx[2]);

	const button1 = new Button({
			props: {
				auto: true,
				size: "small",
				$$slots: { default: [create_default_slot$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button1.$on("click", /*changeTheme*/ ctx[2]);

	const block = {
		c: function create() {
			nav = element("nav");
			ul0 = element("ul");
			li0 = element("li");
			a0 = element("a");
			t0 = text("home");
			t1 = space();
			li1 = element("li");
			a1 = element("a");
			t2 = text("list");
			t3 = space();
			li2 = element("li");
			a2 = element("a");
			t4 = text("charity");
			t5 = space();
			li3 = element("li");
			a3 = element("a");
			t6 = text("about");
			t7 = space();
			ul1 = element("ul");
			li4 = element("li");
			select = element("select");
			option0 = element("option");
			t8 = text("Ua");
			option1 = element("option");
			t9 = text("Ru");
			option2 = element("option");
			t10 = text("En");
			t11 = space();
			li5 = element("li");
			create_component(button0.$$.fragment);
			t12 = space();
			li6 = element("li");
			create_component(button1.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			nav = claim_element(nodes, "NAV", { class: true });
			var nav_nodes = children(nav);
			ul0 = claim_element(nav_nodes, "UL", {});
			var ul0_nodes = children(ul0);
			li0 = claim_element(ul0_nodes, "LI", {});
			var li0_nodes = children(li0);
			a0 = claim_element(li0_nodes, "A", { href: true, class: true });
			var a0_nodes = children(a0);
			t0 = claim_text(a0_nodes, "home");
			a0_nodes.forEach(detach_dev);
			li0_nodes.forEach(detach_dev);
			t1 = claim_space(ul0_nodes);
			li1 = claim_element(ul0_nodes, "LI", {});
			var li1_nodes = children(li1);
			a1 = claim_element(li1_nodes, "A", { href: true, class: true });
			var a1_nodes = children(a1);
			t2 = claim_text(a1_nodes, "list");
			a1_nodes.forEach(detach_dev);
			li1_nodes.forEach(detach_dev);
			t3 = claim_space(ul0_nodes);
			li2 = claim_element(ul0_nodes, "LI", {});
			var li2_nodes = children(li2);
			a2 = claim_element(li2_nodes, "A", { rel: true, href: true, class: true });
			var a2_nodes = children(a2);
			t4 = claim_text(a2_nodes, "charity");
			a2_nodes.forEach(detach_dev);
			li2_nodes.forEach(detach_dev);
			t5 = claim_space(ul0_nodes);
			li3 = claim_element(ul0_nodes, "LI", {});
			var li3_nodes = children(li3);
			a3 = claim_element(li3_nodes, "A", { href: true, class: true });
			var a3_nodes = children(a3);
			t6 = claim_text(a3_nodes, "about");
			a3_nodes.forEach(detach_dev);
			li3_nodes.forEach(detach_dev);
			ul0_nodes.forEach(detach_dev);
			t7 = claim_space(nav_nodes);
			ul1 = claim_element(nav_nodes, "UL", { class: true });
			var ul1_nodes = children(ul1);
			li4 = claim_element(ul1_nodes, "LI", { class: true });
			var li4_nodes = children(li4);

			select = claim_element(li4_nodes, "SELECT", {
				value: true,
				name: true,
				id: true,
				class: true
			});

			var select_nodes = children(select);
			option0 = claim_element(select_nodes, "OPTION", { value: true });
			var option0_nodes = children(option0);
			t8 = claim_text(option0_nodes, "Ua");
			option0_nodes.forEach(detach_dev);
			option1 = claim_element(select_nodes, "OPTION", { value: true });
			var option1_nodes = children(option1);
			t9 = claim_text(option1_nodes, "Ru");
			option1_nodes.forEach(detach_dev);
			option2 = claim_element(select_nodes, "OPTION", { value: true });
			var option2_nodes = children(option2);
			t10 = claim_text(option2_nodes, "En");
			option2_nodes.forEach(detach_dev);
			select_nodes.forEach(detach_dev);
			li4_nodes.forEach(detach_dev);
			t11 = claim_space(ul1_nodes);
			li5 = claim_element(ul1_nodes, "LI", { class: true });
			var li5_nodes = children(li5);
			claim_component(button0.$$.fragment, li5_nodes);
			li5_nodes.forEach(detach_dev);
			t12 = claim_space(ul1_nodes);
			li6 = claim_element(ul1_nodes, "LI", { class: true });
			var li6_nodes = children(li6);
			claim_component(button1.$$.fragment, li6_nodes);
			li6_nodes.forEach(detach_dev);
			ul1_nodes.forEach(detach_dev);
			nav_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a0, "href", ".");
			attr_dev(a0, "class", "svelte-iotsi1");
			toggle_class(a0, "selected", /*segment*/ ctx[0] === undefined);
			add_location(a0, file$e, 19, 12, 464);
			add_location(li0, file$e, 19, 8, 460);
			attr_dev(a1, "href", "list");
			attr_dev(a1, "class", "svelte-iotsi1");
			toggle_class(a1, "selected", /*segment*/ ctx[0] === "list");
			add_location(a1, file$e, 20, 12, 543);
			add_location(li1, file$e, 20, 8, 539);
			attr_dev(a2, "rel", "prefetch");
			attr_dev(a2, "href", "charity");
			attr_dev(a2, "class", "svelte-iotsi1");
			toggle_class(a2, "selected", /*segment*/ ctx[0] === "charity");
			add_location(a2, file$e, 21, 12, 622);
			add_location(li2, file$e, 21, 8, 618);
			attr_dev(a3, "href", "about");
			attr_dev(a3, "class", "svelte-iotsi1");
			toggle_class(a3, "selected", /*segment*/ ctx[0] === "about");
			add_location(a3, file$e, 22, 12, 723);
			add_location(li3, file$e, 22, 8, 719);
			add_location(ul0, file$e, 18, 4, 447);
			option0.__value = "ua";
			option0.value = option0.__value;
			add_location(option0, file$e, 28, 16, 943);
			option1.__value = "ru";
			option1.value = option1.__value;
			add_location(option1, file$e, 29, 16, 990);
			option2.__value = "en";
			option2.value = option2.__value;
			add_location(option2, file$e, 30, 16, 1037);
			attr_dev(select, "name", "lang");
			attr_dev(select, "id", "lang");
			attr_dev(select, "class", "btn small lang-select svelte-iotsi1");
			add_location(select, file$e, 27, 12, 858);
			attr_dev(li4, "class", "svelte-iotsi1");
			add_location(li4, file$e, 26, 8, 841);
			attr_dev(li5, "class", "svelte-iotsi1");
			add_location(li5, file$e, 34, 8, 1113);
			attr_dev(li6, "class", "svelte-iotsi1");
			add_location(li6, file$e, 40, 8, 1284);
			attr_dev(ul1, "class", "nav-actions svelte-iotsi1");
			add_location(ul1, file$e, 25, 4, 808);
			attr_dev(nav, "class", "theme-bg container svelte-iotsi1");
			add_location(nav, file$e, 17, 0, 410);
		},
		m: function mount(target, anchor) {
			insert_dev(target, nav, anchor);
			append_dev(nav, ul0);
			append_dev(ul0, li0);
			append_dev(li0, a0);
			append_dev(a0, t0);
			append_dev(ul0, t1);
			append_dev(ul0, li1);
			append_dev(li1, a1);
			append_dev(a1, t2);
			append_dev(ul0, t3);
			append_dev(ul0, li2);
			append_dev(li2, a2);
			append_dev(a2, t4);
			append_dev(ul0, t5);
			append_dev(ul0, li3);
			append_dev(li3, a3);
			append_dev(a3, t6);
			append_dev(nav, t7);
			append_dev(nav, ul1);
			append_dev(ul1, li4);
			append_dev(li4, select);
			append_dev(select, option0);
			append_dev(option0, t8);
			append_dev(select, option1);
			append_dev(option1, t9);
			append_dev(select, option2);
			append_dev(option2, t10);
			select_value_value = /*value*/ ctx[1];

			for (var i = 0; i < select.options.length; i += 1) {
				var option = select.options[i];

				if (option.__value === select_value_value) {
					option.selected = true;
					break;
				}
			}

			append_dev(ul1, t11);
			append_dev(ul1, li5);
			mount_component(button0, li5, null);
			append_dev(ul1, t12);
			append_dev(ul1, li6);
			mount_component(button1, li6, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*segment, undefined*/ 1) {
				toggle_class(a0, "selected", /*segment*/ ctx[0] === undefined);
			}

			if (dirty & /*segment*/ 1) {
				toggle_class(a1, "selected", /*segment*/ ctx[0] === "list");
			}

			if (dirty & /*segment*/ 1) {
				toggle_class(a2, "selected", /*segment*/ ctx[0] === "charity");
			}

			if (dirty & /*segment*/ 1) {
				toggle_class(a3, "selected", /*segment*/ ctx[0] === "about");
			}

			const button0_changes = {};

			if (dirty & /*$$scope*/ 16) {
				button0_changes.$$scope = { dirty, ctx };
			}

			button0.$set(button0_changes);
			const button1_changes = {};

			if (dirty & /*$$scope*/ 16) {
				button1_changes.$$scope = { dirty, ctx };
			}

			button1.$set(button1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(nav);
			destroy_component(button0);
			destroy_component(button1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$e.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$d($$self, $$props, $$invalidate) {
	let { segment } = $$props;
	let isDarkTheme = false;
	let value = "ua";

	function changeTheme() {
		isDarkTheme = !isDarkTheme;
		document.body.classList.remove("theme-dark");
		document.body.classList.remove("theme-light");
		document.body.classList.add(isDarkTheme ? "theme-dark" : "theme-light");
	}

	const writable_props = ["segment"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<NavigationBar> was created with unknown prop '${key}'`);
	});

	$$self.$set = $$props => {
		if ("segment" in $$props) $$invalidate(0, segment = $$props.segment);
	};

	$$self.$capture_state = () => {
		return { segment, isDarkTheme, value };
	};

	$$self.$inject_state = $$props => {
		if ("segment" in $$props) $$invalidate(0, segment = $$props.segment);
		if ("isDarkTheme" in $$props) isDarkTheme = $$props.isDarkTheme;
		if ("value" in $$props) $$invalidate(1, value = $$props.value);
	};

	return [segment, value, changeTheme];
}

class NavigationBar extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$d, create_fragment$e, safe_not_equal, { segment: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "NavigationBar",
			options,
			id: create_fragment$e.name
		});

		const { ctx } = this.$$;
		const props = options.props || ({});

		if (/*segment*/ ctx[0] === undefined && !("segment" in props)) {
			console.warn("<NavigationBar> was created without expected prop 'segment'");
		}
	}

	get segment() {
		throw new Error("<NavigationBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set segment(value) {
		throw new Error("<NavigationBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/layouts/TitleSubTitle.svelte generated by Svelte v3.16.7 */

const file$f = "src/layouts/TitleSubTitle.svelte";

function create_fragment$f(ctx) {
	let section;
	let h1;
	let t0;
	let t1;
	let br;
	let t2;
	let p;
	let t3;

	const block = {
		c: function create() {
			section = element("section");
			h1 = element("h1");
			t0 = text("The main title that explains everything.");
			t1 = space();
			br = element("br");
			t2 = space();
			p = element("p");
			t3 = text("A small description that describes the title above and just makes text longer.");
			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { class: true });
			var section_nodes = children(section);
			h1 = claim_element(section_nodes, "H1", {});
			var h1_nodes = children(h1);
			t0 = claim_text(h1_nodes, "The main title that explains everything.");
			h1_nodes.forEach(detach_dev);
			t1 = claim_space(section_nodes);
			br = claim_element(section_nodes, "BR", {});
			t2 = claim_space(section_nodes);
			p = claim_element(section_nodes, "P", {});
			var p_nodes = children(p);
			t3 = claim_text(p_nodes, "A small description that describes the title above and just makes text longer.");
			p_nodes.forEach(detach_dev);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(h1, file$f, 5, 4, 35);
			add_location(br, file$f, 6, 4, 89);
			add_location(p, file$f, 7, 4, 98);
			attr_dev(section, "class", "svelte-1qydgyt");
			add_location(section, file$f, 4, 0, 21);
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			append_dev(section, h1);
			append_dev(h1, t0);
			append_dev(section, t1);
			append_dev(section, br);
			append_dev(section, t2);
			append_dev(section, p);
			append_dev(p, t3);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$f.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

class TitleSubTitle extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, null, create_fragment$f, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "TitleSubTitle",
			options,
			id: create_fragment$f.name
		});
	}
}

/* src/layouts/DonatingGroup.svelte generated by Svelte v3.16.7 */
const file$g = "src/layouts/DonatingGroup.svelte";

// (7:8) <Button is="success" on:click="{e => console.log(e)}">
function create_default_slot_3(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("test1");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "test1");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3.name,
		type: "slot",
		source: "(7:8) <Button is=\\\"success\\\" on:click=\\\"{e => console.log(e)}\\\">",
		ctx
	});

	return block;
}

// (10:8) <Button is="success" on:click="{e => console.log(e)}">
function create_default_slot_2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("test12");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "test12");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2.name,
		type: "slot",
		source: "(10:8) <Button is=\\\"success\\\" on:click=\\\"{e => console.log(e)}\\\">",
		ctx
	});

	return block;
}

// (13:8) <Button is="success" on:click="{e => console.log(e)}">
function create_default_slot_1$2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("test123");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "test123");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$2.name,
		type: "slot",
		source: "(13:8) <Button is=\\\"success\\\" on:click=\\\"{e => console.log(e)}\\\">",
		ctx
	});

	return block;
}

// (33:8) <Button is="warning" on:click="{e => console.log(e)}">
function create_default_slot$2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Submit");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Submit");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$2.name,
		type: "slot",
		source: "(33:8) <Button is=\\\"warning\\\" on:click=\\\"{e => console.log(e)}\\\">",
		ctx
	});

	return block;
}

function create_fragment$g(ctx) {
	let ul;
	let li0;
	let t0;
	let li1;
	let t1;
	let li2;
	let t2;
	let li3;
	let br;
	let t3;
	let t4;
	let datalist;
	let option0;
	let option1;
	let option2;
	let t5;
	let li4;
	let current;

	const button0 = new Button({
			props: {
				is: "success",
				$$slots: { default: [create_default_slot_3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button0.$on("click", /*click_handler*/ ctx[0]);

	const button1 = new Button({
			props: {
				is: "success",
				$$slots: { default: [create_default_slot_2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button1.$on("click", /*click_handler_1*/ ctx[1]);

	const button2 = new Button({
			props: {
				is: "success",
				$$slots: { default: [create_default_slot_1$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button2.$on("click", /*click_handler_2*/ ctx[2]);

	const input = new Input({
			props: {
				type: "number",
				name: "num",
				list: "sum-suggestions",
				placeholder: "Num",
				autoselect: true,
				align: "right"
			},
			$$inline: true
		});

	const button3 = new Button({
			props: {
				is: "warning",
				$$slots: { default: [create_default_slot$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button3.$on("click", /*click_handler_3*/ ctx[3]);

	const block = {
		c: function create() {
			ul = element("ul");
			li0 = element("li");
			create_component(button0.$$.fragment);
			t0 = space();
			li1 = element("li");
			create_component(button1.$$.fragment);
			t1 = space();
			li2 = element("li");
			create_component(button2.$$.fragment);
			t2 = space();
			li3 = element("li");
			br = element("br");
			t3 = space();
			create_component(input.$$.fragment);
			t4 = space();
			datalist = element("datalist");
			option0 = element("option");
			option1 = element("option");
			option2 = element("option");
			t5 = space();
			li4 = element("li");
			create_component(button3.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);
			li0 = claim_element(ul_nodes, "LI", { class: true });
			var li0_nodes = children(li0);
			claim_component(button0.$$.fragment, li0_nodes);
			li0_nodes.forEach(detach_dev);
			t0 = claim_space(ul_nodes);
			li1 = claim_element(ul_nodes, "LI", { class: true });
			var li1_nodes = children(li1);
			claim_component(button1.$$.fragment, li1_nodes);
			li1_nodes.forEach(detach_dev);
			t1 = claim_space(ul_nodes);
			li2 = claim_element(ul_nodes, "LI", { class: true });
			var li2_nodes = children(li2);
			claim_component(button2.$$.fragment, li2_nodes);
			li2_nodes.forEach(detach_dev);
			t2 = claim_space(ul_nodes);
			li3 = claim_element(ul_nodes, "LI", { class: true });
			var li3_nodes = children(li3);
			br = claim_element(li3_nodes, "BR", {});
			t3 = claim_space(li3_nodes);
			claim_component(input.$$.fragment, li3_nodes);
			t4 = claim_space(li3_nodes);
			datalist = claim_element(li3_nodes, "DATALIST", { id: true });
			var datalist_nodes = children(datalist);
			option0 = claim_element(datalist_nodes, "OPTION", { value: true });
			var option0_nodes = children(option0);
			option0_nodes.forEach(detach_dev);
			option1 = claim_element(datalist_nodes, "OPTION", { value: true });
			var option1_nodes = children(option1);
			option1_nodes.forEach(detach_dev);
			option2 = claim_element(datalist_nodes, "OPTION", { value: true });
			var option2_nodes = children(option2);
			option2_nodes.forEach(detach_dev);
			datalist_nodes.forEach(detach_dev);
			li3_nodes.forEach(detach_dev);
			t5 = claim_space(ul_nodes);
			li4 = claim_element(ul_nodes, "LI", { class: true });
			var li4_nodes = children(li4);
			claim_component(button3.$$.fragment, li4_nodes);
			li4_nodes.forEach(detach_dev);
			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(li0, "class", "svelte-1k5eog2");
			add_location(li0, file$g, 5, 4, 79);
			attr_dev(li1, "class", "svelte-1k5eog2");
			add_location(li1, file$g, 8, 4, 175);
			attr_dev(li2, "class", "svelte-1k5eog2");
			add_location(li2, file$g, 11, 4, 272);
			add_location(br, file$g, 15, 8, 383);
			option0.__value = "20";
			option0.value = option0.__value;
			add_location(option0, file$g, 26, 12, 654);
			option1.__value = "500";
			option1.value = option1.__value;
			add_location(option1, file$g, 27, 12, 686);
			option2.__value = "1000";
			option2.value = option2.__value;
			add_location(option2, file$g, 28, 12, 719);
			attr_dev(datalist, "id", "sum-suggestions");
			add_location(datalist, file$g, 25, 8, 610);
			attr_dev(li3, "class", "svelte-1k5eog2");
			add_location(li3, file$g, 14, 4, 370);
			attr_dev(li4, "class", "svelte-1k5eog2");
			add_location(li4, file$g, 31, 4, 775);
			attr_dev(ul, "class", "svelte-1k5eog2");
			add_location(ul, file$g, 4, 0, 70);
		},
		m: function mount(target, anchor) {
			insert_dev(target, ul, anchor);
			append_dev(ul, li0);
			mount_component(button0, li0, null);
			append_dev(ul, t0);
			append_dev(ul, li1);
			mount_component(button1, li1, null);
			append_dev(ul, t1);
			append_dev(ul, li2);
			mount_component(button2, li2, null);
			append_dev(ul, t2);
			append_dev(ul, li3);
			append_dev(li3, br);
			append_dev(li3, t3);
			mount_component(input, li3, null);
			append_dev(li3, t4);
			append_dev(li3, datalist);
			append_dev(datalist, option0);
			append_dev(datalist, option1);
			append_dev(datalist, option2);
			append_dev(ul, t5);
			append_dev(ul, li4);
			mount_component(button3, li4, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const button0_changes = {};

			if (dirty & /*$$scope*/ 16) {
				button0_changes.$$scope = { dirty, ctx };
			}

			button0.$set(button0_changes);
			const button1_changes = {};

			if (dirty & /*$$scope*/ 16) {
				button1_changes.$$scope = { dirty, ctx };
			}

			button1.$set(button1_changes);
			const button2_changes = {};

			if (dirty & /*$$scope*/ 16) {
				button2_changes.$$scope = { dirty, ctx };
			}

			button2.$set(button2_changes);
			const button3_changes = {};

			if (dirty & /*$$scope*/ 16) {
				button3_changes.$$scope = { dirty, ctx };
			}

			button3.$set(button3_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			transition_in(button2.$$.fragment, local);
			transition_in(input.$$.fragment, local);
			transition_in(button3.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			transition_out(button2.$$.fragment, local);
			transition_out(input.$$.fragment, local);
			transition_out(button3.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(ul);
			destroy_component(button0);
			destroy_component(button1);
			destroy_component(button2);
			destroy_component(input);
			destroy_component(button3);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$g.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$e($$self) {
	const click_handler = e => console.log(e);
	const click_handler_1 = e => console.log(e);
	const click_handler_2 = e => console.log(e);
	const click_handler_3 = e => console.log(e);

	$$self.$capture_state = () => {
		return {};
	};

	$$self.$inject_state = $$props => {
		
	};

	return [click_handler, click_handler_1, click_handler_2, click_handler_3];
}

class DonatingGroup extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$e, create_fragment$g, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "DonatingGroup",
			options,
			id: create_fragment$g.name
		});
	}
}

export { AvatarAndName as A, Carousel as C, Divider as D, Footer as F, NavigationBar as N, Progress as P, Rate as R, TitleSubTitle as T, CharityCard as a, DonatingGroup as b };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguZTJkYTYwZmMuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9sYXlvdXRzL0Zvb3Rlci5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvcGx1Z2lucy9Td2lwZS9Td2lwZS5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvcGx1Z2lucy9Td2lwZS9Td2lwZUl0ZW0uc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NsYXNzbmFtZXMvaW5kZXguanMiLCIuLi8uLi8uLi9zcmMvdXRpbHMuanMiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9JY29uLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL1JhdGUuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvSW5wdXQuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvUGljdHVyZS5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9BdmF0YXIuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvQnV0dG9uLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL0RpdmlkZXIuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvUHJvZ3Jlc3Muc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2xheW91dHMvQ2Fyb3VzZWwuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2xheW91dHMvQXZhdGFyQW5kTmFtZS5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvbGF5b3V0cy9DaGFyaXR5Q2FyZC5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvbGF5b3V0cy9OYXZpZ2F0aW9uQmFyLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9sYXlvdXRzL0RvbmF0aW5nR3JvdXAuc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzY3JpcHQ+XG5cbjwvc2NyaXB0PlxuXG48Zm9vdGVyPlxuICAgIDxwPsKpIDIwMTkgLSB7bmV3IERhdGUoKS5nZXRGdWxsWWVhcigpfTwvcD5cbjwvZm9vdGVyPlxuXG48c3R5bGU+XG4gICAgZm9vdGVyIHtcbiAgICAgICAgcGFkZGluZzogY2FsYyh2YXIoLS1zY3JlZW4tcGFkZGluZykgKiAyKSB2YXIoLS1zY3JlZW4tcGFkZGluZyk7XG4gICAgICAgIGJveC1zaGFkb3c6IGluc2V0IHZhcigtLXNoYWRvdy1wcmltYXJ5KTtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSh2YXIoLS10aGVtZS1iZy1jb2xvcikpO1xuICAgIH1cbjwvc3R5bGU+XG4iLCI8c2NyaXB0PlxuXG4gICAgaW1wb3J0IHsgb25Nb3VudCwgb25EZXN0cm95IH0gZnJvbSAnc3ZlbHRlJztcblxuXG4gICAgZXhwb3J0IGxldCB0cmFuc2l0aW9uRHVyYXRpb24gPSAyMDA7XG4gICAgZXhwb3J0IGxldCBzaG93SW5kaWNhdG9ycyA9IGZhbHNlO1xuICAgIGV4cG9ydCBsZXQgYXV0b3BsYXkgPSBmYWxzZTtcbiAgICBleHBvcnQgbGV0IGRlbGF5ID0gMTAwMDtcblxuXG5cbiAgICBsZXQgYWN0aXZlSW5kaWNhdG9yID0gMDtcbiAgICBsZXQgaW5kaWNhdG9ycztcbiAgICBsZXQgaXRlbXMgPSAwO1xuICAgIGxldCBhdmFpbGFibGVXaWR0aCA9IDA7XG4gICAgbGV0IHRvcENsZWFyZW5jZSA9IDA7XG5cbiAgICBsZXQgZWxlbXM7XG4gICAgbGV0IGRpZmYgPSAwO1xuXG4gICAgbGV0IHN3aXBlV3JhcHBlcjtcbiAgICBsZXQgc3dpcGVIYW5kbGVyO1xuXG4gICAgbGV0IG1pbiA9IDA7XG4gICAgbGV0IHRvdWNoaW5nVHBsID0gYFxuICAgIC13ZWJraXQtdHJhbnNpdGlvbi1kdXJhdGlvbjogMHM7XG4gICAgdHJhbnNpdGlvbi1kdXJhdGlvbjogMHM7XG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKC17e3ZhbH19cHgsIDAsIDApO1xuICAgIC1tcy10cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKC17e3ZhbH19cHgsIDAsIDApO2A7XG4gICAgbGV0IG5vbl90b3VjaGluZ1RwbCA9IGBcbiAgICAtd2Via2l0LXRyYW5zaXRpb24tZHVyYXRpb246ICR7dHJhbnNpdGlvbkR1cmF0aW9ufW1zO1xuICAgIHRyYW5zaXRpb24tZHVyYXRpb246ICR7dHJhbnNpdGlvbkR1cmF0aW9ufW1zO1xuICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgte3t2YWx9fXB4LCAwLCAwKTtcbiAgICAtbXMtdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgte3t2YWx9fXB4LCAwLCAwKTtgO1xuICAgIGxldCB0b3VjaGluZyA9IGZhbHNlO1xuICAgIGxldCBwb3NYID0gMDtcbiAgICBsZXQgZGlyID0gMDtcbiAgICBsZXQgeDtcblxuXG5cbiAgICBsZXQgcGxheWVkID0gMDtcbiAgICBsZXQgcnVuX2ludGVydmFsID0gZmFsc2U7XG5cbiAgICAkOiBpbmRpY2F0b3JzID0gQXJyYXkoaXRlbXMpO1xuXG4gICAgJDoge1xuICAgICAgICBpZihhdXRvcGxheSAmJiAhcnVuX2ludGVydmFsKXtcbiAgICAgICAgICAgIHJ1bl9pbnRlcnZhbCA9IHNldEludGVydmFsKGNoYW5nZVZpZXcgLCBkZWxheSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZighYXV0b3BsYXkgJiYgcnVuX2ludGVydmFsKXtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwocnVuX2ludGVydmFsKVxuICAgICAgICAgICAgcnVuX2ludGVydmFsID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZSgpe1xuICAgICAgICBzd2lwZUhhbmRsZXIuc3R5bGUudG9wID0gdG9wQ2xlYXJlbmNlICsgJ3B4JztcbiAgICAgICAgYXZhaWxhYmxlV2lkdGggPSBzd2lwZVdyYXBwZXIucXVlcnlTZWxlY3RvcignLnN3aXBlYWJsZS1pdGVtcycpLm9mZnNldFdpZHRoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zOyBpKyspIHtcbiAgICAgICAgICAgIGVsZW1zW2ldLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUzZCgnICsgKGF2YWlsYWJsZVdpZHRoICogaSkgKyAncHgsIDAsIDApJztcbiAgICAgICAgfVxuICAgICAgICBkaWZmID0gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbml0KCl7XG4gICAgICAgIGVsZW1zID0gc3dpcGVXcmFwcGVyLnF1ZXJ5U2VsZWN0b3JBbGwoJy5zd2lwZWFibGUtaXRlbScpO1xuICAgICAgICBpdGVtcyA9IGVsZW1zLmxlbmd0aDtcbiAgICAgICAgdXBkYXRlKCk7XG4gICAgfVxuXG4gICAgb25Nb3VudCgoKSA9PiB7XG4gICAgICAgIGluaXQoKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHVwZGF0ZSk7XG4gICAgfSk7XG5cblxuXG4gICAgb25EZXN0cm95KCgpPT57XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB1cGRhdGUpO1xuICAgIH0pXG5cbiAgICBmdW5jdGlvbiBtb3ZlSGFuZGxlcihlKXtcbiAgICAgICAgaWYgKHRvdWNoaW5nKSB7XG4gICAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuXG4gICAgICAgICAgICBsZXQgbWF4ID0gYXZhaWxhYmxlV2lkdGg7XG5cbiAgICAgICAgICAgIGxldCBfeCA9IGUudG91Y2hlcyA/IGUudG91Y2hlc1swXS5wYWdlWCA6IGUucGFnZVg7XG4gICAgICAgICAgICBsZXQgX2RpZmYgPSAoeCAtIF94KSArIHBvc1g7XG4gICAgICAgICAgICBsZXQgZGlyID0gX3ggPiB4ID8gMCA6IDE7XG4gICAgICAgICAgICBpZiAoIWRpcikgeyBfZGlmZiA9IHBvc1ggLSAoX3ggLSB4KSB9XG4gICAgICAgICAgICBpZiAoX2RpZmYgPD0gKG1heCAqIChpdGVtcyAtIDEpKSAmJiBfZGlmZiA+PSBtaW4pIHtcblxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbXM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdGVtcGxhdGUgPSBpIDwgMCA/ICd7e3ZhbH19JyA6ICcte3t2YWx9fSc7XG4gICAgICAgICAgICAgICAgICAgIGxldCBfdmFsdWUgPSAobWF4ICogaSkgLSBfZGlmZjtcbiAgICAgICAgICAgICAgICAgICAgZWxlbXNbaV0uc3R5bGUuY3NzVGV4dCA9IHRvdWNoaW5nVHBsLnJlcGxhY2UodGVtcGxhdGUsIF92YWx1ZSkucmVwbGFjZSh0ZW1wbGF0ZSwgX3ZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkaWZmID0gX2RpZmY7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVuZEhhbmRsZXIoZSkge1xuICAgICAgICBlICYmIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGUgJiYgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZSAmJiBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgbGV0IG1heCA9IGF2YWlsYWJsZVdpZHRoO1xuXG4gICAgICAgIHRvdWNoaW5nID0gZmFsc2U7XG4gICAgICAgIHggPSBudWxsO1xuXG4gICAgICAgIGxldCBkZWx0YSA9IC4wNVxuICAgICAgICBsZXQgc3dpcGVfdGhyZXNob2xkID0gMC44NTtcbiAgICAgICAgbGV0IGRfbWF4ID0gKGRpZmYgLyBtYXgpO1xuICAgICAgICBsZXQgZGVsdGFETWF4ID0gZF9tYXggLSBNYXRoLmZsb29yKGRfbWF4KSAvLyBjdXN0b20gZGVsdGFcbiAgICAgICAgbGV0IF90YXJnZXQgPSBkZWx0YURNYXggPiBkZWx0YSAmJiBkZWx0YURNYXggPCAuNSA/IE1hdGguY2VpbChkX21heCkgOiBNYXRoLmZsb29yKGRfbWF4KTsgLy8gTWF0aC5yb3VuZChkX21heCk7XG5cbiAgICAgICAgaWYoTWF0aC5hYnMoX3RhcmdldCAtIGRfbWF4KSA8IHN3aXBlX3RocmVzaG9sZCApe1xuICAgICAgICAgICAgZGlmZiA9IF90YXJnZXQgKiBtYXg7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgZGlmZiA9IChkaXIgPyAoX3RhcmdldCAtIDEpIDogKF90YXJnZXQgKyAxKSkgKiBtYXg7XG4gICAgICAgIH1cblxuICAgICAgICBwb3NYID0gZGlmZjtcbiAgICAgICAgYWN0aXZlSW5kaWNhdG9yID0gKGRpZmYgLyBtYXgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB0ZW1wbGF0ZSA9IGkgPCAwID8gJ3t7dmFsfX0nIDogJy17e3ZhbH19JztcbiAgICAgICAgICAgIGxldCBfdmFsdWUgPSAobWF4ICogaSkgLSBwb3NYO1xuICAgICAgICAgICAgZWxlbXNbaV0uc3R5bGUuY3NzVGV4dCA9IG5vbl90b3VjaGluZ1RwbC5yZXBsYWNlKHRlbXBsYXRlLCBfdmFsdWUpLnJlcGxhY2UodGVtcGxhdGUsIF92YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgbW92ZUhhbmRsZXIpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGVuZEhhbmRsZXIpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgbW92ZUhhbmRsZXIpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBlbmRIYW5kbGVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb3ZlU3RhcnQoZSl7XG4gICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICBsZXQgbWF4ID0gYXZhaWxhYmxlV2lkdGg7XG5cbiAgICAgICAgdG91Y2hpbmcgPSB0cnVlO1xuICAgICAgICB4ID0gZS50b3VjaGVzID8gZS50b3VjaGVzWzBdLnBhZ2VYIDogZS5wYWdlWDtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG1vdmVIYW5kbGVyKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBlbmRIYW5kbGVyKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG1vdmVIYW5kbGVyKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgZW5kSGFuZGxlcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hhbmdlSXRlbShpdGVtKSB7XG4gICAgICAgIGxldCBtYXggPSBhdmFpbGFibGVXaWR0aDtcbiAgICAgICAgZGlmZiA9IG1heCAqIGl0ZW07XG4gICAgICAgIGFjdGl2ZUluZGljYXRvciA9IGl0ZW07XG4gICAgICAgIGVuZEhhbmRsZXIoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGFuZ2VWaWV3KCkge1xuICAgICAgICBjaGFuZ2VJdGVtKHBsYXllZCk7XG4gICAgICAgIHBsYXllZCA9IHBsYXllZCA8IChpdGVtcyAtIDEpID8gKytwbGF5ZWQgOiAwO1xuICAgIH1cblxuPC9zY3JpcHQ+XG5cbjxzdHlsZT5cblxuICAgIC5zd2lwZS1wYW5lbCB7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgaGVpZ2h0OiB2YXIoLS1zdi1zd2lwZS1wYW5lbC1oZWlnaHQsIDEwMCUpO1xuICAgICAgICB3aWR0aDogdmFyKC0tc3Ytc3dpcGUtcGFuZWwtd2lkdGgsIGluaGVyaXQpO1xuICAgIH1cbiAgICAuc3dpcGUtaXRlbS13cmFwcGVye1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBhbGlnbi1zZWxmOiBzdHJldGNoO1xuICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIGhlaWdodDogaW5oZXJpdDtcbiAgICAgICAgei1pbmRleDogdmFyKC0tc3Ytc3dpcGUtcGFuZWwtd3JhcHBlci1pbmRleCwgMik7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgIH1cblxuICAgIC5zd2lwZWFibGUtaXRlbXMsXG4gICAgLnN3aXBlYWJsZS1zbG90LXdyYXBwZXIge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBhbGlnbi1zZWxmOiBzdHJldGNoO1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgIH1cblxuICAgIC5zd2lwZS1oYW5kbGVyIHtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgdG9wOiA0MHB4O1xuICAgICAgICBib3R0b206IDBweDtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgICAgcmlnaHQ6IDA7XG4gICAgICAgIGJhY2tncm91bmQ6IHJnYmEoMCwwLDAsMCk7XG4gICAgfVxuICAgIC5zd2lwZS1pbmRpY2F0b3Ige1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIGJvdHRvbTogMS41cmVtO1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgei1pbmRleDogdmFyKC0tc3Ytc3dpcGUtcGFuZWwtd3JhcHBlci1pbmRleCwgMik7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgIH1cblxuICAgIC5kb3Qge1xuICAgICAgICBoZWlnaHQ6IDEwcHg7XG4gICAgICAgIHdpZHRoOiAxMHB4O1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgZ3JleTtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogNTAlO1xuICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgICAgIG1hcmdpbjogMHB4IDJweDtcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgICBwb2ludGVyLWV2ZW50czogZmlsbDtcbiAgICB9XG4gICAgLnN3aXBlLWluZGljYXRvciAuaXMtYWN0aXZlIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tc3Ytc3dpcGUtaW5kaWNhdG9yLWFjdGl2ZS1jb2xvciwgZ3JleSk7XG4gICAgfVxuXG48L3N0eWxlPlxuXG48ZGl2IGNsYXNzPVwic3dpcGUtcGFuZWxcIj5cbiAgICA8ZGl2IGNsYXNzPVwic3dpcGUtaXRlbS13cmFwcGVyXCIgYmluZDp0aGlzPXtzd2lwZVdyYXBwZXJ9PlxuICAgICAgICA8ZGl2IGNsYXNzPVwic3dpcGVhYmxlLWl0ZW1zXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwic3dpcGVhYmxlLXNsb3Qtd3JhcHBlclwiPlxuICAgICAgICAgICAgICAgIDxzbG90IC8+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cInN3aXBlLWhhbmRsZXJcIiBiaW5kOnRoaXM9e3N3aXBlSGFuZGxlcn0gb246dG91Y2hzdGFydD17bW92ZVN0YXJ0fSBvbjptb3VzZWRvd249e21vdmVTdGFydH0+PC9kaXY+XG4gICAgeyNpZiBzaG93SW5kaWNhdG9yc31cbiAgICAgICAgPGRpdiBjbGFzcz1cInN3aXBlLWluZGljYXRvciBzd2lwZS1pbmRpY2F0b3ItaW5zaWRlXCI+XG4gICAgICAgICAgICB7I2VhY2ggaW5kaWNhdG9ycyBhcyB4LCBpIH1cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImRvdCB7YWN0aXZlSW5kaWNhdG9yID09IGkgPyAnaXMtYWN0aXZlJyA6ICcnfVwiIG9uOmNsaWNrPXsoKSA9PiB7Y2hhbmdlSXRlbShpKX19Pjwvc3Bhbj5cbiAgICAgICAgICAgIHsvZWFjaH1cbiAgICAgICAgPC9kaXY+XG4gICAgey9pZn1cblxuPC9kaXY+XG4iLCI8c2NyaXB0PlxuICAgIGV4cG9ydCBsZXQgY2xhc3NlcyA9ICcnO1xuPC9zY3JpcHQ+XG5cbjxzdHlsZT5cbiAgICAuc3dpcGVhYmxlLWl0ZW0ge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBhbGlnbi1zZWxmOiBzdHJldGNoO1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogMDtcbiAgICAgICAgYm90dG9tOiAwO1xuICAgICAgICBsZWZ0OiAwO1xuICAgICAgICByaWdodDogMDtcbiAgICAgICAgdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246IGVhc2Utb3V0O1xuICAgIH1cbjwvc3R5bGU+XG5cbjxkaXYgY2xhc3M9XCJzd2lwZWFibGUtaXRlbSB7Y2xhc3Nlc31cIj5cbiAgICA8c2xvdCAvPlxuPC9kaXY+XG4iLCIvKiFcbiAgQ29weXJpZ2h0IChjKSAyMDE3IEplZCBXYXRzb24uXG4gIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZSAoTUlUKSwgc2VlXG4gIGh0dHA6Ly9qZWR3YXRzb24uZ2l0aHViLmlvL2NsYXNzbmFtZXNcbiovXG4vKiBnbG9iYWwgZGVmaW5lICovXG5cbihmdW5jdGlvbiAoKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgaGFzT3duID0ge30uaGFzT3duUHJvcGVydHk7XG5cblx0ZnVuY3Rpb24gY2xhc3NOYW1lcyAoKSB7XG5cdFx0dmFyIGNsYXNzZXMgPSBbXTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgYXJnID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0aWYgKCFhcmcpIGNvbnRpbnVlO1xuXG5cdFx0XHR2YXIgYXJnVHlwZSA9IHR5cGVvZiBhcmc7XG5cblx0XHRcdGlmIChhcmdUeXBlID09PSAnc3RyaW5nJyB8fCBhcmdUeXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHRjbGFzc2VzLnB1c2goYXJnKTtcblx0XHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmcpICYmIGFyZy5sZW5ndGgpIHtcblx0XHRcdFx0dmFyIGlubmVyID0gY2xhc3NOYW1lcy5hcHBseShudWxsLCBhcmcpO1xuXHRcdFx0XHRpZiAoaW5uZXIpIHtcblx0XHRcdFx0XHRjbGFzc2VzLnB1c2goaW5uZXIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKGFyZ1R5cGUgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdGZvciAodmFyIGtleSBpbiBhcmcpIHtcblx0XHRcdFx0XHRpZiAoaGFzT3duLmNhbGwoYXJnLCBrZXkpICYmIGFyZ1trZXldKSB7XG5cdFx0XHRcdFx0XHRjbGFzc2VzLnB1c2goa2V5KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gY2xhc3Nlcy5qb2luKCcgJyk7XG5cdH1cblxuXHRpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcblx0XHRjbGFzc05hbWVzLmRlZmF1bHQgPSBjbGFzc05hbWVzO1xuXHRcdG1vZHVsZS5leHBvcnRzID0gY2xhc3NOYW1lcztcblx0fSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkZWZpbmUuYW1kID09PSAnb2JqZWN0JyAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gcmVnaXN0ZXIgYXMgJ2NsYXNzbmFtZXMnLCBjb25zaXN0ZW50IHdpdGggbnBtIHBhY2thZ2UgbmFtZVxuXHRcdGRlZmluZSgnY2xhc3NuYW1lcycsIFtdLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gY2xhc3NOYW1lcztcblx0XHR9KTtcblx0fSBlbHNlIHtcblx0XHR3aW5kb3cuY2xhc3NOYW1lcyA9IGNsYXNzTmFtZXM7XG5cdH1cbn0oKSk7XG4iLCJleHBvcnQgeyBkZWZhdWx0IGFzIGNsYXNzbmFtZXMgfSBmcm9tICdjbGFzc25hbWVzJ1xuXG5leHBvcnQgY29uc3QgdG9DU1NTdHJpbmcgPSAoc3R5bGVzID0ge30pID0+IE9iamVjdC5lbnRyaWVzKHN0eWxlcylcbiAgLmZpbHRlcigoW19wcm9wTmFtZSwgcHJvcFZhbHVlXSkgPT4gcHJvcFZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcFZhbHVlICE9PSBudWxsKVxuICAucmVkdWNlKChzdHlsZVN0cmluZywgW3Byb3BOYW1lLCBwcm9wVmFsdWVdKSA9PiB7XG4gICAgcHJvcE5hbWUgPSBwcm9wTmFtZS5yZXBsYWNlKC9bQS1aXS9nLCBtYXRjaCA9PiBgLSR7bWF0Y2gudG9Mb3dlckNhc2UoKX1gKVxuICAgIHJldHVybiBgJHtzdHlsZVN0cmluZ30ke3Byb3BOYW1lfToke3Byb3BWYWx1ZX07YFxuICB9LCAnJylcblxuLyoqXG4gKlxuICogQGZ1bmN0aW9uIHNhZmVHZXRcbiAqXG4gKiBAZGVzY3JpcHRpb24gU2FmZSBnZXR0aW5nIG9mIGFuIGFueSB2YWx1ZSBvZiBhIG5lc3RlZCBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSBleHByZXNzaW9uRm4ge2Z1bmN0aW9ufSAtIFRoZSBmdW5jdGlvbiB3aXRoIGFuIGV4cHJlc3Npb24gd2hpY2ggcmV0dXJucyByZXN1bHQgb2YgdGhlIHNhZmUgZ2V0dGluZy5cbiAqIEBwYXJhbSBkZWZhdWx0VmFsdWUge2FueX0gLSBUaGUgZGVmYXVsdCB2YWx1ZSB3aGVuIHJlc3VsdCBpcyB1bmRlZmluZWQuXG4gKiBAcGFyYW0gaXNEZWZhdWx0VHlwZWQge2Jvb2xlYW59IC0gV2hldGVyIGlzIHRoZSByZXN1bHQgZnJvbSBhbiBleHByZXNzaW9uIG11c3QgYmUgdGhlIHNhbWUgdHlwZSBhcyB0aGUgZGVmYXVsdCB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZXNcbiAqIC8vIFNvbWUgZGF0YS5cbiAqIGNvbnN0IHZlcnkgPSB7XG4gKiAgbmVzdGVkOiB7XG4gKiAgIG9iamVjdDogW3tcbiAqICAgICB3aXRoOiB7XG4gKiAgICAgICBhcnJheXM6ICdzdHVmZidcbiAqICAgICB9XG4gKiAgIH1dXG4gKiAgfVxuICogfVxuICpcbiAqIC8vIEdldHRpbmcuXG4gKiAxLiBzYWZlR2V0KCgpID0+IHZlcnkubmVzdGVkLm9iamVjdFswXS53aXRoLmFycmF5cyk7XG4gKiAyLiBzYWZlR2V0KCgpID0+IHZlcnkubmVzdGVkLm9iamVjdFswXS53aXRoLmFycmF5cywgeyBkZWZhdWx0OiAndmFsdWUnIH0pO1xuICogMy4gc2FmZUdldCgoKSA9PiB2ZXJ5Lm5lc3RlZC5vYmplY3RbMF0ud2l0aC5hcnJheXMsIHsgZGVmYXVsdDogJ3ZhbHVlJyB9LCB0cnVlKTtcbiAqXG4gKiAvLyBSZXR1cm4uXG4gKiAxLiAnc3R1ZmYnXG4gKiAyLiAnc3R1ZmYnXG4gKiAzLiB7IGRlZmF1bHQ6ICd2YWx1ZScgfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2FmZUdldChleHByZXNzaW9uRm4sIGRlZmF1bHRWYWx1ZSwgaXNEZWZhdWx0VHlwZWQgPSBmYWxzZSkge1xuICAvLyBDaGVjayB3aGV0aGVyIGEgYW5kIGIgaGF2ZSB0aGUgc2FtZSB0eXBlLiAodXRpbClcbiAgZnVuY3Rpb24gaXNTYW1lVHlwZShhLCBiKSB7XG4gICAgY29uc3QgcnVsZXMgPSBbXG4gICAgICAoYSwgYikgPT4gdHlwZW9mIGEgPT09IHR5cGVvZiBiLFxuICAgICAgKGEsIGIpID0+ICgrYSA9PT0gYSkgPT09ICgrYiA9PT0gYiksICAgICAgICAgICAgICAvLyB3aGV0aGVyIG9uZSBpcyBOYU5cbiAgICAgIChhLCBiKSA9PiAoYSA9PT0gbnVsbCkgPT09IChiID09PSBudWxsKSwgICAgICAgICAgLy8gbnVsbCBpcyBvYmplY3QgdHlwZSB0b29cbiAgICAgIChhLCBiKSA9PiBBcnJheS5pc0FycmF5KGEpID09PSBBcnJheS5pc0FycmF5KGIpLCAgLy8gYXJyYXkgaXMgb2JqZWN0IHR5cGUgdG9vXG4gICAgXVxuICAgIHJldHVybiAhcnVsZXMuc29tZShydWxlRm4gPT4gIXJ1bGVGbihhLCBiKSlcbiAgfVxuICAvLyBDb3JlIG9mIHNhZmUgZ2V0dGluZy4gRXhlY3V0aW5nIGEgZnVuY3Rpb24uIERlZmF1bHQgdmFsdWVzLlxuICBmdW5jdGlvbiBnZXQoZXhwcmVzc2lvbkZuLCBkZWZhdWx0VmFsdWUsIGlzRGVmYXVsdFR5cGVkKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGV4cHJlc3Npb25Gbi5jYWxsKHRoaXMpXG4gICAgICBpZiAoaXNEZWZhdWx0VHlwZWQpIHtcbiAgICAgICAgcmV0dXJuIGlzU2FtZVR5cGUocmVzdWx0LCBkZWZhdWx0VmFsdWUpID8gcmVzdWx0IDogZGVmYXVsdFZhbHVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0VmFsdWUgOiByZXN1bHRcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdFZhbHVlXG4gICAgfVxuICB9XG4gIC8vIFNhZmUgZ2V0dGluZyBvZiB0aGUgZXhwcmVzc2lvbkZuLlxuICBpZiAodHlwZW9mIGV4cHJlc3Npb25GbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBnZXQoZXhwcmVzc2lvbkZuLCBkZWZhdWx0VmFsdWUsIGlzRGVmYXVsdFR5cGVkKVxuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUud2FybignWW91IG5lZWQgdG8gdXNlIGEgZnVuY3Rpb24gYXMgdGhlIGZpcnN0IGFyZ3VtZW50LicpXG4gIH1cbiAgcmV0dXJuIGRlZmF1bHRWYWx1ZVxufVxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBjbGFzc25hbWVzLCB0b0NTU1N0cmluZyB9IGZyb20gJy4uL3V0aWxzJ1xuXG4gICAgZXhwb3J0IGxldCB0eXBlXG4gICAgZXhwb3J0IGxldCBpcyAvLyBwcmltYXJ5fHdhcm5pbmd8ZGFuZ2VyfGxpZ2h0fGRhcmtcbiAgICBleHBvcnQgbGV0IHNpemUgPSAnbWVkaXVtJyAvLyBzbWFsbHxtZWRpdW18YmlnXG4gICAgZXhwb3J0IGxldCByb3RhdGUgPSAwXG4gICAgZXhwb3J0IGxldCBzdHlsZSA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgaWQgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IHRpdGxlID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCBhcmlhTGFiZWwgPSB1bmRlZmluZWRcblxuICAgIGxldCB0aXRsZVByb3AgPSB0aXRsZSB8fCBhcmlhTGFiZWxcbiAgICBsZXQgYXJpYUxhYmVsUHJvcCA9IGFyaWFMYWJlbCB8fCB0aXRsZVxuICAgIGxldCBzdHlsZVByb3AgPSB0b0NTU1N0cmluZyh7IHRyYW5zZm9ybTogISFyb3RhdGUgPyBgcm90YXRlWigke3JvdGF0ZX1kZWcpYCA6IG51bGwsIC4uLnN0eWxlIH0pXG5cbiAgICAkOiAgY2xhc3NQcm9wID0gY2xhc3NuYW1lcygnaWNvJywgaXMsIHNpemUsICQkcHJvcHMuY2xhc3MpXG48L3NjcmlwdD5cblxuPHN2Z1xuICAgICAgICB7aWR9XG4gICAgICAgIHRpdGxlPXt0aXRsZVByb3B9XG4gICAgICAgIGNsYXNzPXtjbGFzc1Byb3B9XG4gICAgICAgIHN0eWxlPXtzdHlsZVByb3B9XG4gICAgICAgIGFyaWEtbGFiZWw9e2FyaWFMYWJlbFByb3B9XG4+XG4gICAgPHVzZSB4bGluazpocmVmPXtgI2ljby0ke3R5cGV9YH0gY2xhc3M9XCJpY28tdXNlXCIvPlxuPC9zdmc+XG5cbjxzdHlsZT5cbiAgICBzdmcge1xuICAgICAgICBkaXNwbGF5OiBpbmhlcml0O1xuICAgIH1cblxuICAgIHN2Zywgc3ZnICoge1xuICAgICAgICBmaWxsOiByZ2JhKHZhcigtLXRoZW1lLXN2Zy1maWxsKSk7XG4gICAgICAgIHN0cm9rZTogcmdiYSh2YXIoLS10aGVtZS1zdmctZmlsbCkpO1xuICAgIH1cblxuICAgIC8qIC0tLS0tLS0tLS0tLT09PT09PT09PSggU2l6ZSApPT09PT09PT09LS0tLS0tLS0tLS0tICovXG4gICAgLnNtYWxsIHtcbiAgICAgICAgd2lkdGg6IDE1cHg7XG4gICAgICAgIGhlaWdodDogMTVweDtcbiAgICB9XG5cbiAgICAubWVkaXVtIHtcbiAgICAgICAgd2lkdGg6IDIycHg7XG4gICAgICAgIGhlaWdodDogMjJweDtcbiAgICB9XG5cbiAgICAuYmlnIHtcbiAgICAgICAgd2lkdGg6IDM1cHg7XG4gICAgICAgIGhlaWdodDogMzVweDtcbiAgICB9XG5cbiAgICAvKiAtLS0tLS0tLS0tLS09PT09PT09PT0oIENvbG9yICk9PT09PT09PT0tLS0tLS0tLS0tLS0gKi9cbiAgICAucHJpbWFyeSwgLnByaW1hcnkgKiB7XG4gICAgICAgIGZpbGw6IHJnYih2YXIoLS1jb2xvci1zdWNjZXNzKSk7XG4gICAgICAgIHN0cm9rZTogcmdiKHZhcigtLWNvbG9yLXN1Y2Nlc3MpKTtcbiAgICB9XG5cbiAgICAud2FybmluZywgLndhcm5pbmcgKiB7XG4gICAgICAgIGZpbGw6IHJnYih2YXIoLS1jb2xvci13YXJuaW5nKSk7XG4gICAgICAgIHN0cm9rZTogcmdiKHZhcigtLWNvbG9yLXdhcm5pbmcpKTtcbiAgICB9XG5cbiAgICAuZGFuZ2VyLCAuZGFuZ2VyICoge1xuICAgICAgICBmaWxsOiByZ2IodmFyKC0tY29sb3ItZGFuZ2VyKSk7XG4gICAgICAgIHN0cm9rZTogcmdiKHZhcigtLWNvbG9yLWRhbmdlcikpO1xuICAgIH1cblxuICAgIC5pbmZvLCAuaW5mbyAqIHtcbiAgICAgICAgZmlsbDogcmdiKHZhcigtLWNvbG9yLWluZm8pKTtcbiAgICAgICAgc3Ryb2tlOiByZ2IodmFyKC0tY29sb3ItaW5mbykpO1xuICAgIH1cblxuICAgIC5saWdodCwgLmxpZ2h0ICoge1xuICAgICAgICBmaWxsOiB2YXIoLS1jb2xvci1saWdodC0xKTtcbiAgICAgICAgc3Ryb2tlOiB2YXIoLS1jb2xvci1saWdodC0xKTtcbiAgICB9XG5cbiAgICAuZGFyaywgLmRhcmsgKiB7XG4gICAgICAgIGZpbGw6IHZhcigtLWNvbG9yLWRhcmstMSk7XG4gICAgICAgIHN0cm9rZTogdmFyKC0tY29sb3ItZGFyay0xKTtcbiAgICB9XG48L3N0eWxlPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgSWNvbiBmcm9tICcuLi9jb21wb25lbnRzL0ljb24uc3ZlbHRlJ1xuXG4gICAgZXhwb3J0IGxldCBpcyA9ICdkYW5nZXInXG4gICAgZXhwb3J0IGxldCBzaXplID0gJ21lZGl1bScgLy8gc21hbGx8bWVkaXVtfG1pZ1xuPC9zY3JpcHQ+XG5cbjx1bCBjbGFzcz1cInJhdGVcIj5cbiAgICA8bGk+XG4gICAgICAgIDxJY29uIHtpc30ge3NpemV9IHR5cGU9XCJoZWFydC1maWxsZWRcIi8+XG4gICAgPC9saT5cbiAgICA8bGk+XG4gICAgICAgIDxJY29uIHtpc30ge3NpemV9IHR5cGU9XCJoZWFydC1maWxsZWRcIi8+XG4gICAgPC9saT5cbiAgICA8bGk+XG4gICAgICAgIDxJY29uIHtpc30ge3NpemV9IHR5cGU9XCJoZWFydC1maWxsZWRcIi8+XG4gICAgPC9saT5cbiAgICA8bGk+XG4gICAgICAgIDxJY29uIHtpc30ge3NpemV9IHR5cGU9XCJoZWFydC1maWxsZWRcIi8+XG4gICAgPC9saT5cbiAgICA8bGk+XG4gICAgICAgIDxJY29uIHtpc30ge3NpemV9IHR5cGU9XCJoZWFydC1maWxsZWRcIi8+XG4gICAgPC9saT5cbjwvdWw+XG5cbjxzdHlsZT5cbiAgICAucmF0ZSB7XG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1mbGV4O1xuICAgICAgICBtYXJnaW46IGNhbGModmFyKC0tc2NyZWVuLXBhZGRpbmcpICogLTEgLyAzKTtcbiAgICB9XG5cbiAgICBsaSB7XG4gICAgICAgIHBhZGRpbmc6IGNhbGModmFyKC0tc2NyZWVuLXBhZGRpbmcpIC8gMyk7XG4gICAgfVxuXG4gICAgLnJhdGUgbGkge1xuICAgICAgICAtd2Via2l0LWZpbHRlcjogZHJvcC1zaGFkb3coLTFweCAycHggMXB4IHJnYmEodmFyKC0tY29sb3ItYmxhY2spLCAuMjUpKTtcbiAgICAgICAgZmlsdGVyOiBkcm9wLXNoYWRvdygtMXB4IDJweCAxcHggcmdiYSh2YXIoLS1jb2xvci1ibGFjayksIC4yNSkpO1xuICAgIH1cbjwvc3R5bGU+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJ3N2ZWx0ZSdcbiAgICBpbXBvcnQgeyBjbGFzc25hbWVzLCB0b0NTU1N0cmluZyB9IGZyb20gJy4uL3V0aWxzJ1xuXG4gICAgY29uc3QgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXIoKVxuXG4gICAgZXhwb3J0IGxldCBuYW1lXG4gICAgZXhwb3J0IGxldCB2YWx1ZSA9ICcnXG4gICAgZXhwb3J0IGxldCBzdHlsZSA9IHt9XG4gICAgZXhwb3J0IGxldCB0eXBlID0gJ3RleHQnXG4gICAgZXhwb3J0IGxldCBpZCA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgYWxpZ24gPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IG1heGxlbmd0aCA9IDEwMDBcbiAgICBleHBvcnQgbGV0IHJvd3MgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IGRpc2FibGVkID0gZmFsc2VcbiAgICBleHBvcnQgbGV0IHRpdGxlID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCBpbnZhbGlkID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCBtaW4gPSB1bmRlZmluZWQgLy8gU3BlY2lmaWVzIGEgbWluaW11bSB2YWx1ZSBmb3IgYW4gPGlucHV0PiBlbGVtZW50XG4gICAgZXhwb3J0IGxldCBtYXggPSB1bmRlZmluZWQgLy8gU3BlY2lmaWVzIHRoZSBtYXhpbXVtIHZhbHVlIGZvciBhbiA8aW5wdXQ+IGVsZW1lbnRcbiAgICBleHBvcnQgbGV0IGxpc3QgPSB1bmRlZmluZWQgLy8gUmVmZXJzIHRvIGEgPGRhdGFsaXN0PiBlbGVtZW50IHRoYXQgY29udGFpbnMgcHJlLWRlZmluZWQgb3B0aW9ucyBmb3IgYW4gPGlucHV0PiBlbGVtZW50XG4gICAgZXhwb3J0IGxldCBmb3JtID0gdW5kZWZpbmVkIC8vIFNwZWNpZmllcyB0aGUgZm9ybSB0aGUgPGlucHV0PiBlbGVtZW50IGJlbG9uZ3MgdG9cbiAgICBleHBvcnQgbGV0IHJlYWRvbmx5ID0gdW5kZWZpbmVkIC8vIHVuZGVmaW5lZHxyZWFkb25seVxuICAgIGV4cG9ydCBsZXQgcmVxdWlyZWQgPSB1bmRlZmluZWQgLy8gdW5kZWZpbmVkfHJlcXVpcmVkXG4gICAgZXhwb3J0IGxldCBwYXR0ZXJuID0gdW5kZWZpbmVkIC8vIFNwZWNpZmllcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiB0aGF0IGFuIDxpbnB1dD4gZWxlbWVudCdzIHZhbHVlIGlzIGNoZWNrZWQgYWdhaW5zdCAocmVnZXhwKVxuICAgIGV4cG9ydCBsZXQgYXV0b2NvbXBsZXRlID0gdHJ1ZSAvLyBvbnxvZmZcbiAgICBleHBvcnQgbGV0IGF1dG9zZWxlY3QgPSBmYWxzZVxuICAgIGV4cG9ydCBsZXQgYXJpYUxhYmVsID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCBwbGFjZWhvbGRlciA9IHVuZGVmaW5lZFxuXG4gICAgbGV0IGlkUHJvcCA9IGlkIHx8IG5hbWVcbiAgICBsZXQgdHlwZVByb3AgPSB0eXBlID09PSAnbnVtYmVyJyA/ICd0ZXh0JyA6IHR5cGVcbiAgICBsZXQgdGl0bGVQcm9wID0gdGl0bGUgfHwgYXJpYUxhYmVsIHx8IHBsYWNlaG9sZGVyXG4gICAgbGV0IGFyaWFMYWJlbFByb3AgPSBhcmlhTGFiZWwgfHwgdGl0bGUgfHwgcGxhY2Vob2xkZXJcbiAgICBsZXQgYXV0b2NvbXBsZXRlUHJvcCA9IGF1dG9jb21wbGV0ZSA/ICdvbicgOiAnb2ZmJ1xuICAgIGxldCBzdHlsZVByb3AgPSB0b0NTU1N0cmluZyh7IC4uLnN0eWxlLCB0ZXh0QWxpZ246IGFsaWduIH0pXG4gICAgbGV0IHBhdHRlcm5Qcm9wID0gdHlwZSA9PT0gJ251bWJlcicgJiYgIXBhdHRlcm4gPyAnWzAtOV0qJyA6IHBhdHRlcm5cblxuICAgICQ6IGNsYXNzUHJvcCA9IGNsYXNzbmFtZXMoJ2lucCcsICQkcHJvcHMuY2xhc3MsIHsgZGlzYWJsZWQsIHJlYWRvbmx5LCByZXF1aXJlZCwgaW52YWxpZCB9KVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb24gRW1pdCBjbGljayBhbmQgc2VsZWN0IGNvbnRlbnQgd2hlbiBcImF1dG9zZWxlY3RcIiBpcyBlbmFibGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBlIC0gTmF0aXZlIG1vdXNlIGV2ZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uQ2xpY2soZSkge1xuICAgICAgICAhZGlzYWJsZWQgJiYgZGlzcGF0Y2goXCJjbGlja1wiLCBlKVxuICAgICAgICAhZGlzYWJsZWQgJiYgYXV0b3NlbGVjdCAmJiBlLnRhcmdldC5zZWxlY3QoKVxuICAgIH1cbjwvc2NyaXB0PlxuXG57I2lmIHJvd3N9XG4gICAgPHRleHRhcmVhXG4gICAgICAgICAgICB7bWlufVxuICAgICAgICAgICAge21heH1cbiAgICAgICAgICAgIHtyb3dzfVxuICAgICAgICAgICAge25hbWV9XG4gICAgICAgICAgICB7Zm9ybX1cbiAgICAgICAgICAgIHthbGlnbn1cbiAgICAgICAgICAgIHtyZWFkb25seX1cbiAgICAgICAgICAgIHtkaXNhYmxlZH1cbiAgICAgICAgICAgIHtyZXF1aXJlZH1cbiAgICAgICAgICAgIHttYXhsZW5ndGh9XG4gICAgICAgICAgICB7cGxhY2Vob2xkZXJ9XG4gICAgICAgICAgICBpZD17aWRQcm9wfVxuICAgICAgICAgICAgY2xhc3M9e2NsYXNzUHJvcH1cbiAgICAgICAgICAgIHRpdGxlPXt0aXRsZVByb3B9XG4gICAgICAgICAgICBzdHlsZT17c3R5bGVQcm9wfVxuICAgICAgICAgICAgcGF0dGVybj17cGF0dGVyblByb3B9XG4gICAgICAgICAgICBhcmlhLWxhYmVsPXthcmlhTGFiZWxQcm9wfVxuICAgICAgICAgICAgYXV0b2NvbXBsZXRlPXthdXRvY29tcGxldGVQcm9wfVxuICAgICAgICAgICAgey4uLnsgdHlwZTogdHlwZVByb3AgfX1cbiAgICAgICAgICAgIGJpbmQ6dmFsdWVcbiAgICAgICAgICAgIG9uOmJsdXI9J3tlID0+ICFkaXNhYmxlZCAmJiBkaXNwYXRjaChcImJsdXJcIiwgZSl9J1xuICAgICAgICAgICAgb246Zm9jdXM9J3tlID0+ICFkaXNhYmxlZCAmJiBkaXNwYXRjaChcImZvY3VzXCIsIGUpfSdcbiAgICAgICAgICAgIG9uOmNsaWNrPSd7b25DbGlja30nXG4gICAgPjwvdGV4dGFyZWE+XG57OmVsc2V9XG4gICAgPGlucHV0XG4gICAgICAgICAgICB7bWlufVxuICAgICAgICAgICAge21heH1cbiAgICAgICAgICAgIHtuYW1lfVxuICAgICAgICAgICAge2xpc3R9XG4gICAgICAgICAgICB7Zm9ybX1cbiAgICAgICAgICAgIHthbGlnbn1cbiAgICAgICAgICAgIHtyZWFkb25seX1cbiAgICAgICAgICAgIHtkaXNhYmxlZH1cbiAgICAgICAgICAgIHtyZXF1aXJlZH1cbiAgICAgICAgICAgIHttYXhsZW5ndGh9XG4gICAgICAgICAgICB7cGxhY2Vob2xkZXJ9XG4gICAgICAgICAgICBpZD17aWRQcm9wfVxuICAgICAgICAgICAgY2xhc3M9e2NsYXNzUHJvcH1cbiAgICAgICAgICAgIHRpdGxlPXt0aXRsZVByb3B9XG4gICAgICAgICAgICBzdHlsZT17c3R5bGVQcm9wfVxuICAgICAgICAgICAgcGF0dGVybj17cGF0dGVyblByb3B9XG4gICAgICAgICAgICBhcmlhLWxhYmVsPXthcmlhTGFiZWxQcm9wfVxuICAgICAgICAgICAgYXV0b2NvbXBsZXRlPXthdXRvY29tcGxldGVQcm9wfVxuICAgICAgICAgICAgey4uLnsgdHlwZTogdHlwZVByb3AgfX1cbiAgICAgICAgICAgIGJpbmQ6dmFsdWVcbiAgICAgICAgICAgIG9uOmJsdXI9J3tlID0+ICFkaXNhYmxlZCAmJiBkaXNwYXRjaChcImJsdXJcIiwgZSl9J1xuICAgICAgICAgICAgb246Zm9jdXM9J3tlID0+ICFkaXNhYmxlZCAmJiBkaXNwYXRjaChcImZvY3VzXCIsIGUpfSdcbiAgICAgICAgICAgIG9uOmNsaWNrPSd7b25DbGlja30nXG4gICAgLz5cbnsvaWZ9XG5cbjxzdHlsZT5cbiAgICAuaW5wIHtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIGZsZXg6IDEgMSAwO1xuICAgICAgICBjb2xvcjogaW5oZXJpdDtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogdmFyKC0tYm9yZGVyLXJhZGl1cyk7XG4gICAgICAgIG1pbi13aWR0aDogdmFyKC0tbWluLWludGVyYWN0aXZlLXNpemUpO1xuICAgICAgICBtaW4taGVpZ2h0OiB2YXIoLS1taW4taW50ZXJhY3RpdmUtc2l6ZSk7XG4gICAgICAgIGJvcmRlcjogMXB4IHNvbGlkIHJnYmEodmFyKC0tY29sb3ItYmxhY2spLCAuMjUpO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKHZhcigtLXRoZW1lLWJnLWNvbG9yKSk7XG4gICAgICAgIGJveC1zaGFkb3c6IGluc2V0IHZhcigtLXNoYWRvdy1wcmltYXJ5KSwgdmFyKC0tc2hhZG93LXNlY29uZGFyeS1pbnNldCk7XG4gICAgfVxuXG4gICAgLmlucDpmb2N1cyB7XG4gICAgICAgIGJvcmRlci1jb2xvcjogcmdiKHZhcigtLWNvbG9yLXN1Y2Nlc3MpKTtcbiAgICB9XG5cbiAgICAuaW5wOmludmFsaWQsIC5pbnAuaW52YWxpZCB7XG4gICAgICAgIGJvcmRlci1jb2xvcjogcmdiKHZhcigtLWNvbG9yLWRhbmdlcikpO1xuICAgIH1cbjwvc3R5bGU+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJ3N2ZWx0ZSdcbiAgICBpbXBvcnQgeyBjbGFzc25hbWVzIH0gZnJvbSAnLi4vdXRpbHMnXG5cbiAgICBjb25zdCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpXG5cbiAgICBleHBvcnQgbGV0IHNyY1xuICAgIGV4cG9ydCBsZXQgYWx0XG4gICAgZXhwb3J0IGxldCBpZCA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgd2lkdGggPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IGhlaWdodCA9IHVuZGVmaW5lZFxuXG4gICAgbGV0IGxvYWRpbmcgPSB0cnVlXG4gICAgbGV0IGlzRXJyb3IgPSBmYWxzZVxuXG4gICAgJDogd3JhcENsYXNzUHJvcCA9IGNsYXNzbmFtZXMoJ3BpY3R1cmUnLCAkJHByb3BzLmNsYXNzLCB7IGxvYWRpbmcsIGlzRXJyb3IgfSlcblxuICAgIGZ1bmN0aW9uIG9uTG9hZChlKSB7XG4gICAgICAgIGxvYWRpbmcgPSBmYWxzZVxuICAgICAgICBkaXNwYXRjaCgnbG9hZCcsIGUpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25FcnJvcihlKSB7XG4gICAgICAgIGxvYWRpbmcgPSBmYWxzZVxuICAgICAgICBpc0Vycm9yID0gdHJ1ZVxuICAgICAgICBkaXNwYXRjaCgnZXJyb3InLCBlKVxuICAgIH1cbjwvc2NyaXB0PlxuXG48ZmlndXJlIGNsYXNzPXt3cmFwQ2xhc3NQcm9wfT5cbiAgICA8aW1nXG4gICAgICAgICAgICB7aWR9XG4gICAgICAgICAgICB7YWx0fVxuICAgICAgICAgICAge3NyY31cbiAgICAgICAgICAgIHt3aWR0aH1cbiAgICAgICAgICAgIHtoZWlnaHR9XG4gICAgICAgICAgICBjbGFzcz1cInBpY1wiXG4gICAgICAgICAgICBvbjpsb2FkPXtvbkxvYWR9XG4gICAgICAgICAgICBvbjplcnJvcj17b25FcnJvcn1cbiAgICAvPlxuXG4gICAgPGZpZ2NhcHRpb24+XG4gICAgICAgIDxzbG90Pjwvc2xvdD5cbiAgICA8L2ZpZ2NhcHRpb24+XG48L2ZpZ3VyZT5cblxuPHN0eWxlPlxuICAgIC5waWN0dXJlIHtcbiAgICAgICAgZmxleC1ncm93OiAxO1xuICAgICAgICBhbGlnbi1zZWxmOiBzdHJldGNoO1xuICAgICAgICBkaXNwbGF5OiBpbmxpbmUtZmxleDtcbiAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAgYWxpZ24taXRlbXM6IHN0cmV0Y2g7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogc3RyZXRjaDtcbiAgICB9XG5cbiAgICAucGljdHVyZSAucGljIHtcbiAgICAgICAgZmxleC1ncm93OiAxO1xuICAgICAgICBhbGlnbi1zZWxmOiBzdHJldGNoO1xuICAgICAgICBvYmplY3QtZml0OiBjb3ZlcjtcbiAgICAgICAgb2JqZWN0LXBvc2l0aW9uOiBjZW50ZXI7XG4gICAgICAgIHRyYW5zaXRpb246IG9wYWNpdHkgLjNzIGVhc2UtaW47XG4gICAgfVxuXG4gICAgLnBpY3R1cmUubG9hZGluZyAucGljIHtcbiAgICAgICAgb3BhY2l0eTogMDtcbiAgICB9XG48L3N0eWxlPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBjbGFzc25hbWVzIH0gZnJvbSAnLi4vdXRpbHMnXG4gICAgaW1wb3J0IFBpY3R1cmUgZnJvbSAnLi9QaWN0dXJlLnN2ZWx0ZSdcblxuICAgIGV4cG9ydCBsZXQgc3JjXG4gICAgZXhwb3J0IGxldCBhbHRcbiAgICBleHBvcnQgbGV0IHNpemUgPSAnbWVkaXVtJyAvLyBzbWFsbHxtZWRpdW18YmlnXG5cbiAgICAkOiBjbGFzc1Byb3AgPSBjbGFzc25hbWVzKCdhdmEnLCBzaXplLCAkJHByb3BzLmNsYXNzKVxuPC9zY3JpcHQ+XG5cbjxkaXYgY2xhc3M9e2NsYXNzUHJvcH0+XG4gICAgPFBpY3R1cmUge3NyY30ge2FsdH0vPlxuPC9kaXY+XG5cbjxzdHlsZT5cbiAgICAuYXZhIHtcbiAgICAgICAgZmxleDogbm9uZTtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogNTAlO1xuICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICBib3gtc2hhZG93OiB2YXIoLS1zaGFkb3ctcHJpbWFyeSk7XG4gICAgfVxuXG4gICAgLnNtYWxsIHtcbiAgICAgICAgd2lkdGg6IDI1cHg7XG4gICAgICAgIGhlaWdodDogMjVweDtcbiAgICB9XG4gICAgLm1lZGl1bSB7XG4gICAgICAgIHdpZHRoOiAzNXB4O1xuICAgICAgICBoZWlnaHQ6IDM1cHg7XG4gICAgfVxuICAgIC5iaWcge1xuICAgICAgICB3aWR0aDogNDVweDtcbiAgICAgICAgaGVpZ2h0OiA0NXB4O1xuICAgIH1cbjwvc3R5bGU+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJ3N2ZWx0ZSdcbiAgICBpbXBvcnQgeyBjbGFzc25hbWVzIH0gZnJvbSAnLi4vdXRpbHMnXG5cbiAgICBjb25zdCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpXG5cbiAgICBleHBvcnQgbGV0IGlzID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCBpZCA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgaHJlZiA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgYXV0byA9IGZhbHNlXG4gICAgZXhwb3J0IGxldCB0eXBlID0gJ2J1dHRvbidcbiAgICBleHBvcnQgbGV0IHNpemUgPSAnbWVkaXVtJ1xuICAgIGV4cG9ydCBsZXQgdGl0bGUgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IGh0bWxGb3IgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IGRpc2FibGVkID0gZmFsc2VcbiAgICBleHBvcnQgbGV0IGFyaWFMYWJlbCA9IHVuZGVmaW5lZFxuXG4gICAgbGV0IHRpdGxlUHJvcCA9IHRpdGxlIHx8IGFyaWFMYWJlbFxuICAgIGxldCBhcmlhTGFiZWxQcm9wID0gYXJpYUxhYmVsIHx8IHRpdGxlXG5cbiAgICAkOiBjbGFzc1Byb3AgPSBjbGFzc25hbWVzKCdidG4nLCBpcywgc2l6ZSwgJCRwcm9wcy5jbGFzcywgeyBhdXRvLCBkaXNhYmxlZCB9KVxuXG4gICAgZnVuY3Rpb24gb25MYWJlbENsaWNrKGUpIHtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaHRtbEZvcikuY2xpY2soKVxuICAgICAgICAvLyB0cnkgeyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChodG1sRm9yKS5jbGljaygpIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICFkaXNhYmxlZCAmJiBkaXNwYXRjaChcImNsaWNrXCIsIGUpXG4gICAgfVxuPC9zY3JpcHQ+XG5cbnsjaWYgaHJlZn1cbiAgICA8YVxuICAgICAgICAgICAge2lkfVxuICAgICAgICAgICAge2hyZWZ9XG4gICAgICAgICAgICB0aXRsZT17dGl0bGVQcm9wfVxuICAgICAgICAgICAgY2xhc3M9e2NsYXNzUHJvcH1cbiAgICAgICAgICAgIGFyaWEtbGFiZWw9e2FyaWFMYWJlbFByb3B9XG4gICAgICAgICAgICBvbjpjbGljaz0ne2UgPT4gIWRpc2FibGVkICYmIGRpc3BhdGNoKFwiY2xpY2tcIiwgZSl9J1xuICAgID5cbiAgICAgICAgPHNsb3Q+PC9zbG90PlxuICAgIDwvYT5cbns6ZWxzZSBpZiBodG1sRm9yfVxuICAgIDxsYWJlbFxuICAgICAgICAgICAge2lkfVxuICAgICAgICAgICAge2Rpc2FibGVkfVxuICAgICAgICAgICAgZm9yPXtodG1sRm9yfVxuICAgICAgICAgICAgdGl0bGU9e3RpdGxlUHJvcH1cbiAgICAgICAgICAgIGNsYXNzPXtjbGFzc1Byb3B9XG4gICAgICAgICAgICBhcmlhLWxhYmVsPXthcmlhTGFiZWxQcm9wfVxuICAgICAgICAgICAgb246Y2xpY2s9e29uTGFiZWxDbGlja31cbiAgICA+XG4gICAgICAgIDxzbG90Pjwvc2xvdD5cbiAgICA8L2xhYmVsPlxuezplbHNlfVxuICAgIDxidXR0b25cbiAgICAgICAgICAgIHtpZH1cbiAgICAgICAgICAgIHt0eXBlfVxuICAgICAgICAgICAge2Rpc2FibGVkfVxuICAgICAgICAgICAgdGl0bGU9e3RpdGxlUHJvcH1cbiAgICAgICAgICAgIGNsYXNzPXtjbGFzc1Byb3B9XG4gICAgICAgICAgICBhcmlhLWxhYmVsPXthcmlhTGFiZWxQcm9wfVxuICAgICAgICAgICAgb246Y2xpY2s9J3tlID0+ICFkaXNhYmxlZCAmJiBkaXNwYXRjaChcImNsaWNrXCIsIGUpfSdcbiAgICA+XG4gICAgICAgIDxzbG90Pjwvc2xvdD5cbiAgICA8L2J1dHRvbj5cbnsvaWZ9XG5cbjxzdHlsZT5cbiAgICAuYnRuOm5vdCguYXV0bykge1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICB9XG5cbiAgICA6Z2xvYmFsKC5idG4pIHtcbiAgICAgICAgZmxleDogbm9uZTtcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgICBtYXgtd2lkdGg6IDEwMCU7XG4gICAgICAgIHVzZXItc2VsZWN0OiBub25lO1xuICAgICAgICBwYWRkaW5nOiA1cHggMTVweDtcbiAgICAgICAgbWFyZ2luLWJvdHRvbTogM3B4O1xuICAgICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICBkaXNwbGF5OiBpbmxpbmUtZmxleDtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IHZhcigtLWJvcmRlci1yYWRpdXMpO1xuICAgICAgICBjb2xvcjogcmdiYSh2YXIoLS10aGVtZS1mb250LWNvbG9yKSk7XG4gICAgICAgIHRleHQtc2hhZG93OiAxcHggMXB4IHJnYmEodmFyKC0tY29sb3ItYmxhY2spLCAuMyk7XG4gICAgfVxuXG4gICAgOmdsb2JhbCguYnRuLnNtYWxsKSB7XG4gICAgICAgIHBhZGRpbmc6IDVweDtcbiAgICAgICAgbWluLXdpZHRoOiBjYWxjKHZhcigtLW1pbi1pbnRlcmFjdGl2ZS1zaXplKSAvIDEuNSk7XG4gICAgICAgIG1pbi1oZWlnaHQ6IGNhbGModmFyKC0tbWluLWludGVyYWN0aXZlLXNpemUpIC8gMS41KTtcbiAgICB9XG5cbiAgICA6Z2xvYmFsKC5idG4ubWVkaXVtKSB7XG4gICAgICAgIHBhZGRpbmc6IDVweCAxMHB4O1xuICAgICAgICBtaW4td2lkdGg6IHZhcigtLW1pbi1pbnRlcmFjdGl2ZS1zaXplKTtcbiAgICAgICAgbWluLWhlaWdodDogdmFyKC0tbWluLWludGVyYWN0aXZlLXNpemUpO1xuICAgIH1cblxuICAgIDpnbG9iYWwoLmJ0bi5iaWcpIHtcbiAgICAgICAgcGFkZGluZzogNXB4IDE1cHg7XG4gICAgICAgIG1pbi13aWR0aDogY2FsYyh2YXIoLS1taW4taW50ZXJhY3RpdmUtc2l6ZSkgKiAxLjUpO1xuICAgICAgICBtaW4taGVpZ2h0OiBjYWxjKHZhcigtLW1pbi1pbnRlcmFjdGl2ZS1zaXplKSAqIDEuNSk7XG4gICAgfVxuXG4gICAgOmdsb2JhbCguYnRuOmZvY3VzKSB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEodmFyKC0tY29sb3ItYmxhY2spLCAwLjEpO1xuICAgIH1cblxuICAgIDpnbG9iYWwoLmJ0bjpob3Zlcikge1xuICAgICAgICBib3gtc2hhZG93OiAwIDJweCByZ2JhKHZhcigtLWNvbG9yLWJsYWNrKSwgMC4yKTtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSh2YXIoLS1jb2xvci1ibGFjayksIDAuMSk7XG4gICAgfVxuXG4gICAgOmdsb2JhbCguYnRuOmFjdGl2ZSkge1xuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMXB4KTtcbiAgICAgICAgYm94LXNoYWRvdzogMCAxcHggcmdiYSh2YXIoLS1jb2xvci1ibGFjayksIDAuMik7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEodmFyKC0tY29sb3ItYmxhY2spLCAwLjEpO1xuICAgIH1cblxuICAgIC8qIFN1Y2Nlc3MgKi9cblxuICAgIC5idG4uc3VjY2VzcyB7XG4gICAgICAgIGNvbG9yOiByZ2JhKHZhcigtLWNvbG9yLWZvbnQtbGlnaHQpKTtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSh2YXIoLS1jb2xvci1zdWNjZXNzKSk7XG4gICAgICAgIGJveC1zaGFkb3c6IDAgMnB4IHJnYmEodmFyKC0tY29sb3Itc3VjY2Vzcy1kYXJrKSksIHZhcigtLXNoYWRvdy1zZWNvbmRhcnkpLCB2YXIoLS1zaGFkb3ctcHJpbWFyeSk7XG4gICAgfVxuXG4gICAgLmJ0bi5zdWNjZXNzOmZvY3VzIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSh2YXIoLS1jb2xvci1zdWNjZXNzKSwgLjg1KTtcbiAgICB9XG5cbiAgICAuYnRuLnN1Y2Nlc3M6aG92ZXIge1xuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMXB4KTtcbiAgICAgICAgYm94LXNoYWRvdzogMCAycHggcmdiYSh2YXIoLS1jb2xvci1zdWNjZXNzLWRhcmspKSwgdmFyKC0tc2hhZG93LXNlY29uZGFyeSksIHZhcigtLXNoYWRvdy1wcmltYXJ5KTtcbiAgICB9XG5cbiAgICAuYnRuLnN1Y2Nlc3M6YWN0aXZlIHtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDJweCk7XG4gICAgICAgIGJveC1zaGFkb3c6IDAgMXB4IHJnYmEodmFyKC0tY29sb3Itc3VjY2Vzcy1kYXJrKSksIHZhcigtLXNoYWRvdy1zZWNvbmRhcnkpO1xuICAgIH1cblxuICAgIC8qIFdhcm5pbmcgKi9cblxuICAgIC5idG4ud2FybmluZyB7XG4gICAgICAgIGNvbG9yOiByZ2JhKHZhcigtLWNvbG9yLWZvbnQtbGlnaHQpKTtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSh2YXIoLS1jb2xvci13YXJuaW5nKSk7XG4gICAgICAgIGJveC1zaGFkb3c6IDAgMnB4IHJnYmEodmFyKC0tY29sb3Itd2FybmluZy1kYXJrKSksIHZhcigtLXNoYWRvdy1zZWNvbmRhcnkpLCB2YXIoLS1zaGFkb3ctcHJpbWFyeSk7XG4gICAgfVxuXG4gICAgLmJ0bi53YXJuaW5nOmZvY3VzIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSh2YXIoLS1jb2xvci13YXJuaW5nKSwgLjg1KTtcbiAgICB9XG5cbiAgICAuYnRuLndhcm5pbmc6aG92ZXIge1xuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMXB4KTtcbiAgICAgICAgYm94LXNoYWRvdzogMCAycHggcmdiYSh2YXIoLS1jb2xvci13YXJuaW5nLWRhcmspKSwgdmFyKC0tc2hhZG93LXNlY29uZGFyeSksIHZhcigtLXNoYWRvdy1wcmltYXJ5KTtcbiAgICB9XG5cbiAgICAuYnRuLndhcm5pbmc6YWN0aXZlIHtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDJweCk7XG4gICAgICAgIGJveC1zaGFkb3c6IDAgMXB4IHJnYmEodmFyKC0tY29sb3Itd2FybmluZy1kYXJrKSksIHZhcigtLXNoYWRvdy1zZWNvbmRhcnkpO1xuICAgIH1cblxuICAgIC8qIERhbmdlciAqL1xuXG4gICAgLmJ0bi5kYW5nZXIge1xuICAgICAgICBjb2xvcjogcmdiYSh2YXIoLS1jb2xvci1mb250LWxpZ2h0KSk7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEodmFyKC0tY29sb3ItZGFuZ2VyKSk7XG4gICAgICAgIGJveC1zaGFkb3c6IDAgMnB4IHJnYmEodmFyKC0tY29sb3ItZGFuZ2VyLWRhcmspKSwgdmFyKC0tc2hhZG93LXNlY29uZGFyeSksIHZhcigtLXNoYWRvdy1wcmltYXJ5KTtcbiAgICB9XG5cbiAgICAuYnRuLmRhbmdlcjpmb2N1cyB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEodmFyKC0tY29sb3ItZGFuZ2VyKSwgLjg1KTtcbiAgICB9XG5cbiAgICAuYnRuLmRhbmdlcjpob3ZlciB7XG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgxcHgpO1xuICAgICAgICBib3gtc2hhZG93OiAwIDJweCByZ2JhKHZhcigtLWNvbG9yLWRhbmdlci1kYXJrKSksIHZhcigtLXNoYWRvdy1zZWNvbmRhcnkpLCB2YXIoLS1zaGFkb3ctcHJpbWFyeSk7XG4gICAgfVxuXG4gICAgLmJ0bi5kYW5nZXI6YWN0aXZlIHtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDJweCk7XG4gICAgICAgIGJveC1zaGFkb3c6IDAgMXB4IHJnYmEodmFyKC0tY29sb3ItZGFuZ2VyLWRhcmspKSwgdmFyKC0tc2hhZG93LXNlY29uZGFyeSk7XG4gICAgfVxuXG5cbiAgICBAbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOiA3NjlweCkge1xuICAgICAgICA6Z2xvYmFsKC5idG4pIHtcbiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDJweDtcbiAgICAgICAgfVxuICAgICAgICAuYnRuLnN1Y2Nlc3Mge1xuICAgICAgICAgICAgYm94LXNoYWRvdzogMCAzcHggcmdiYSh2YXIoLS1jb2xvci1zdWNjZXNzLWRhcmspKSwgdmFyKC0tc2hhZG93LXNlY29uZGFyeSksIHZhcigtLXNoYWRvdy1wcmltYXJ5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC5idG4ud2FybmluZyB7XG4gICAgICAgICAgICBib3gtc2hhZG93OiAwIDNweCByZ2JhKHZhcigtLWNvbG9yLXdhcm5pbmctZGFyaykpLCB2YXIoLS1zaGFkb3ctc2Vjb25kYXJ5KSwgdmFyKC0tc2hhZG93LXByaW1hcnkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLmJ0bi5kYW5nZXIge1xuICAgICAgICAgICAgYm94LXNoYWRvdzogMCAzcHggcmdiYSh2YXIoLS1jb2xvci1kYW5nZXItZGFyaykpLCB2YXIoLS1zaGFkb3ctc2Vjb25kYXJ5KSwgdmFyKC0tc2hhZG93LXByaW1hcnkpO1xuICAgICAgICB9XG4gICAgfVxuPC9zdHlsZT5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgdG9DU1NTdHJpbmcsIGNsYXNzbmFtZXMgfSBmcm9tICcuLi91dGlscydcblxuICAgIGV4cG9ydCBsZXQgaXMgPSAnaW5mbydcbiAgICBleHBvcnQgbGV0IHNpemUgPSAwXG4gICAgZXhwb3J0IGxldCB3aWR0aCA9IDJcblxuICAgICQ6IGNsYXNzUHJvcCA9IGNsYXNzbmFtZXMoJ2RpdmlkZXInLCBpcywgJCRwcm9wcy5jbGFzcylcbiAgICAkOiBzdHlsZVByb3AgPSB0b0NTU1N0cmluZyh7IHBhZGRpbmc6IGAke3NpemUgLyAyfXB4IDBgLCBoZWlnaHQ6IGAke3dpZHRofXB4YCB9KVxuPC9zY3JpcHQ+XG5cbjxociBjbGFzcz17Y2xhc3NQcm9wfSBzdHlsZT17c3R5bGVQcm9wfT5cblxuPHN0eWxlPlxuICAgIC5kaXZpZGVyIHtcbiAgICAgICAgbWFyZ2luOiAwO1xuICAgICAgICBib3JkZXI6IG5vbmU7XG4gICAgICAgIGJveC1zaXppbmc6IGNvbnRlbnQtYm94O1xuICAgICAgICBiYWNrZ3JvdW5kLWNsaXA6IGNvbnRlbnQtYm94O1xuICAgIH1cblxuICAgIC5pbmZvIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiKHZhcigtLWNvbG9yLWluZm8pKTtcbiAgICB9XG5cbiAgICAuc3VjY2VzcyB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYih2YXIoLS1jb2xvci1zdWNjZXNzKSk7XG4gICAgfVxuXG4gICAgLndhcm5pbmcge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IodmFyKC0tY29sb3Itd2FybmluZykpO1xuICAgIH1cblxuICAgIC5kYW5nZXIge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IodmFyKC0tY29sb3ItZGFuZ2VyKSk7XG4gICAgfVxuPC9zdHlsZT5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgY3JlYXRlRXZlbnREaXNwYXRjaGVyLCBvbk1vdW50IH0gZnJvbSAnc3ZlbHRlJ1xuICAgIGltcG9ydCB7IGNsYXNzbmFtZXMsIHNhZmVHZXQgfSBmcm9tICcuLi91dGlscydcblxuICAgIGNvbnN0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKClcblxuICAgIGV4cG9ydCBsZXQgaWQgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IHZhbHVlID0gMCAvLyAwIC0gMTAwXG4gICAgZXhwb3J0IGxldCBzaXplID0gJ21lZGl1bSdcbiAgICBleHBvcnQgbGV0IHRpdGxlID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCBhcmlhTGFiZWwgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IGJvcmRlclJhZGl1cyA9IHVuZGVmaW5lZFxuXG4gICAgJDogdmFsID0gMFxuICAgICQ6IHRpdGxlUHJvcCA9IHRpdGxlIHx8IGBQcm9ncmVzcyAtICR7dmFsfSVgXG4gICAgJDogYXJpYUxhYmVsUHJvcCA9IGFyaWFMYWJlbCB8fCBgUHJvZ3Jlc3MgLSAke3ZhbH0lYFxuICAgICQ6IGNsYXNzUHJvcCA9IGNsYXNzbmFtZXMoJ3Byb2dyZXNzJywgc2l6ZSwgJCRwcm9wcy5jbGFzcylcblxuICAgIG9uTW91bnQoKCkgPT4ge1xuICAgICAgICAvLyBNYWtlIGxvYWRpbmcgcHJvZ3Jlc3MgZWZmZWN0IG9uIG1vdW50IGNvbXBvbmVudC5cbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB2YWwgPSBOdW1iZXIuaXNGaW5pdGUoK3ZhbHVlKSA/IE1hdGgubWF4KDAsIE1hdGgubWluKCt2YWx1ZSwgMTAwKSkgOiAwLCAwKVxuICAgIH0pXG5cbiAgICBmdW5jdGlvbiBnZXRCb3JkZXJSYWRpdXMoYm9yZGVycywgZGVmYXVsdHMgPSAnOTk5OTlweCcpIHtcbiAgICAgICAgY29uc3QgYnJEZWZhdWx0ID0gbmV3IEFycmF5KDQpLmZpbGwoZGVmYXVsdHMpXG4gICAgICAgIGNvbnN0IGJkcyA9IHNhZmVHZXQoKCkgPT4gYm9yZGVycy5zcGxpdCgnICcpLCBbXSwgdHJ1ZSlcbiAgICAgICAgY29uc3QgcnVsZSA9ICdib3JkZXItcmFkaXVzJ1xuICAgICAgICByZXR1cm4gYCR7cnVsZX06JHtickRlZmF1bHQubWFwKChkZWYsIGkpID0+IGAke2Jkc1tpXSB8fCBkZWZ9YCkuam9pbignICcpfWBcbiAgICB9XG48L3NjcmlwdD5cblxuXG48ZGl2XG4gICAgICAgIHtpZH1cbiAgICAgICAgY2xhc3M9e2NsYXNzUHJvcH1cbiAgICAgICAgdGl0bGU9e3RpdGxlUHJvcH1cbiAgICAgICAgYXJpYS1sYWJlbD17YXJpYUxhYmVsUHJvcH1cbiAgICAgICAgcm9sZT1cInByb2dyZXNzYmFyXCJcbiAgICAgICAgYXJpYS12YWx1ZW1pbj1cIjBcIlxuICAgICAgICBhcmlhLXZhbHVlbWF4PVwiMTAwXCJcbiAgICAgICAgYXJpYS12YWx1ZW5vdz17dmFsfVxuICAgICAgICBzdHlsZT17YCR7Z2V0Qm9yZGVyUmFkaXVzKGJvcmRlclJhZGl1cyl9YH1cbj5cbiAgICA8ZGl2IGNsYXNzPVwicHJvZ3Jlc3MtaW5uZXItZnJhbWVcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInByb2dyZXNzLWNvcmVcIiBzdHlsZT17YHdpZHRoOiR7dmFsfSVgfT48L2Rpdj5cbiAgICA8L2Rpdj5cbjwvZGl2PlxuXG48c3R5bGU+XG4gICAgLnByb2dyZXNzIHtcbiAgICAgICAgLS1wcm9ncmVzcy1oZWlnaHQ6IDIwcHg7XG4gICAgICAgIC0tcHJvZ3Jlc3MtcGFkZGluZy1wb2ludDogMztcbiAgICB9XG5cbiAgICAucHJvZ3Jlc3Muc21hbGwge1xuICAgICAgICAtLXByb2dyZXNzLWhlaWdodDogMTVweDtcbiAgICAgICAgLS1wcm9ncmVzcy1wYWRkaW5nLXBvaW50OiAzO1xuICAgIH1cblxuICAgIC5wcm9ncmVzcy5tZWRpdW0ge1xuICAgICAgICAtLXByb2dyZXNzLWhlaWdodDogMjBweDtcbiAgICAgICAgLS1wcm9ncmVzcy1wYWRkaW5nLXBvaW50OiAzLjU7XG4gICAgfVxuXG4gICAgLnByb2dyZXNzLmJpZyB7XG4gICAgICAgIC0tcHJvZ3Jlc3MtaGVpZ2h0OiAzMHB4O1xuICAgICAgICAtLXByb2dyZXNzLXBhZGRpbmctcG9pbnQ6IDQ7XG4gICAgfVxuXG4gICAgLnByb2dyZXNzIHtcbiAgICAgICAgZmxleDogMDtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDk5OTlweDtcbiAgICAgICAgaGVpZ2h0OiB2YXIoLS1wcm9ncmVzcy1oZWlnaHQpO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKHZhcigtLXRoZW1lLWJnLWNvbG9yKSk7XG4gICAgICAgIHBhZGRpbmc6IGNhbGModmFyKC0tcHJvZ3Jlc3MtaGVpZ2h0KSAvIHZhcigtLXByb2dyZXNzLXBhZGRpbmctcG9pbnQpKTtcbiAgICAgICAgYm94LXNoYWRvdzogaW5zZXQgdmFyKC0tc2hhZG93LXByaW1hcnkpLCB2YXIoLS1zaGFkb3ctc2Vjb25kYXJ5LWluc2V0KTtcbiAgICB9XG5cbiAgICAucHJvZ3Jlc3MtaW5uZXItZnJhbWUge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICBib3JkZXItcmFkaXVzOiA5OTk5cHg7XG4gICAgfVxuXG4gICAgLnByb2dyZXNzLWNvcmUge1xuICAgICAgICBmbGV4OiBub25lO1xuICAgICAgICBhbGlnbi1zZWxmOiBzdHJldGNoO1xuICAgICAgICB0cmFuc2l0aW9uOiAxcyBlYXNlLWluLW91dDtcbiAgICAgICAgbWFyZ2luLWJvdHRvbTogMnB4O1xuICAgICAgICBib3gtc2hhZG93OiB2YXIoLS1zaGFkb3ctcHJpbWFyeSk7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IHZhcigtLWJvcmRlci1yYWRpdXMpO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKHZhcigtLWNvbG9yLXN1Y2Nlc3MpKTtcbiAgICB9XG48L3N0eWxlPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBTd2lwZSwgU3dpcGVJdGVtIH0gZnJvbSAnLi4vcGx1Z2lucydcbiAgICBpbXBvcnQgeyBQaWN0dXJlIH0gZnJvbSAnLi4vY29tcG9uZW50cydcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHR5cGUge3tcbiAgICAgKiAgICAgc3JjOiBzdHJpbmcsXG4gICAgICogICAgIGFsdDogc3RyaW5nLFxuICAgICAqICAgICBvbkNsaWNrPzogZnVuY3Rpb24sXG4gICAgICogfVtdfVxuICAgICAqL1xuICAgIGV4cG9ydCBsZXQgaW1hZ2VzID0gdW5kZWZpbmVkXG5cbiAgICAkOiBpbWFnZXNBcnIgPSBbXS5jb25jYXQoaW1hZ2VzKS5tYXAoaW1nID0+IHR5cGVvZiBpbWcgPT09ICdzdHJpbmcnID8geyBzcmM6IGltZyB9IDogaW1nKVxuPC9zY3JpcHQ+XG5cbjxzZWN0aW9uPlxuICAgIDxTd2lwZT5cbiAgICAgICAgeyNlYWNoIGltYWdlc0FyciBhcyBpbWd9XG4gICAgICAgICAgICA8U3dpcGVJdGVtPlxuICAgICAgICAgICAgICAgIDxQaWN0dXJlIHNyYz17aW1nLnNyY30gYWx0PXtpbWcuYWx0fS8+XG4gICAgICAgICAgICA8L1N3aXBlSXRlbT5cbiAgICAgICAgey9lYWNofVxuICAgIDwvU3dpcGU+XG48L3NlY3Rpb24+XG5cbjxzdHlsZT5cbiAgICBzZWN0aW9uIHtcbiAgICAgICAgei1pbmRleDogMDtcbiAgICAgICAgZmxleC1ncm93OiAxO1xuICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICBtYXJnaW4tYm90dG9tOiAycHg7XG4gICAgICAgIGJveC1zaGFkb3c6IHZhcigtLXNoYWRvdy1wcmltYXJ5KTtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogdmFyKC0tYm9yZGVyLXJhZGl1cyk7XG4gICAgfVxuPC9zdHlsZT5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgQXZhdGFyIH0gZnJvbSAnLi4vY29tcG9uZW50cydcblxuICAgIGV4cG9ydCBsZXQgc3JjID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCB0aXRsZSA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgc3ViVGl0bGUgPSB1bmRlZmluZWRcbjwvc2NyaXB0PlxuXG48c2VjdGlvbj5cbiAgICA8QXZhdGFyIHNyYz17c3JjfSBhbHQ9e3RpdGxlfS8+XG5cbiAgICA8c3Bhbj5cbiAgICAgICAgPGg1Pnt0aXRsZX08L2g1PlxuICAgICAgICA8aDY+e3N1YlRpdGxlfTwvaDY+XG4gICAgPC9zcGFuPlxuPC9zZWN0aW9uPlxuXG48c3R5bGU+XG4gICAgc2VjdGlvbiB7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBmbGV4LWdyb3c6IDE7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGFsaWduLXNlbGY6IHN0cmV0Y2g7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgfVxuXG4gICAgc3BhbiB7XG4gICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICAgIHBhZGRpbmc6IDAgOHB4O1xuICAgIH1cblxuICAgIHNwYW4gaDYge1xuICAgICAgICBmb250LXdlaWdodDogbm9ybWFsO1xuICAgIH1cblxuICAgIHNwYW4gaDYsXG4gICAgc3BhbiBoNSB7XG4gICAgICAgIG1heC13aWR0aDogMTAwJTtcbiAgICAgICAgbGluZS1oZWlnaHQ6IDEuNDtcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcbiAgICAgICAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XG4gICAgfVxuPC9zdHlsZT5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgUmF0ZSwgUHJvZ3Jlc3MsIEF2YXRhciB9IGZyb20gJy4uL2NvbXBvbmVudHMnXG4gICAgaW1wb3J0IENhcm91c2VsIGZyb20gJy4vQ2Fyb3VzZWwuc3ZlbHRlJ1xuICAgIGltcG9ydCBBdmF0YXJBbmROYW1lIGZyb20gJy4vQXZhdGFyQW5kTmFtZS5zdmVsdGUnXG5cbiAgICBleHBvcnQgbGV0IHNyYyA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgdGl0bGUgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IHBlcmNlbnQgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IG9yZ0hlYWQgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IG9yZ0hlYWRTcmMgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IG9yZ2FuaXphdGlvbiA9IHVuZGVmaW5lZFxuPC9zY3JpcHQ+XG5cbjxzZWN0aW9uIGNsYXNzPVwiY2FyZFwiPlxuICAgIDxkaXYgY2xhc3M9XCJpbWFnZXMtd3JhcFwiPlxuICAgICAgICA8Q2Fyb3VzZWwgaW1hZ2VzPXtzcmN9Lz5cbiAgICA8L2Rpdj5cblxuICAgIDxQcm9ncmVzcyB2YWx1ZT17cGVyY2VudH0gYm9yZGVyUmFkaXVzPVwiMCAwXCIvPlxuXG4gICAgPGg0Pnt0aXRsZX08L2g0PlxuXG4gICAgPGRpdiBjbGFzcz1cInJhdGUtd3JhcFwiPlxuICAgICAgICA8UmF0ZSBzaXplPVwic21hbGxcIi8+XG4gICAgPC9kaXY+XG5cbiAgICA8Zm9vdGVyPlxuICAgICAgICA8QXZhdGFyQW5kTmFtZSBzcmM9e29yZ0hlYWRTcmN9IHRpdGxlPXtvcmdIZWFkfSBzdWJUaXRsZT17b3JnYW5pemF0aW9ufS8+XG4gICAgPC9mb290ZXI+XG48L3NlY3Rpb24+XG5cbjxzdHlsZT5cbiAgICAuY2FyZCB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICAgIGZsZXg6IG5vbmU7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBtYXgtd2lkdGg6IDEwMCU7XG4gICAgfVxuXG4gICAgLnJhdGUtd3JhcCB7XG4gICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgcGFkZGluZy10b3A6IDZweDtcbiAgICB9XG5cbiAgICAuaW1hZ2VzLXdyYXAge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBoZWlnaHQ6IDEwMHB4O1xuICAgIH1cblxuICAgIGg0IHtcbiAgICAgICAgLS1jYXJkLWxpbmUtaGVpZ2h0OiAxLjQ7XG5cbiAgICAgICAgZm9udC1zaXplOiAuOGVtO1xuICAgICAgICBsaW5lLWhlaWdodDogdmFyKC0tY2FyZC1saW5lLWhlaWdodCk7XG4gICAgICAgIGhlaWdodDogY2FsYyh2YXIoLS1mb250LXNpemUpICogKHZhcigtLWNhcmQtbGluZS1oZWlnaHQpIC8gMS4yKSAqIDIpO1xuICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgIH1cbjwvc3R5bGU+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IEljb24sIEJ1dHRvbiwgQXZhdGFyIH0gZnJvbSAnLi4vY29tcG9uZW50cydcblxuICAgIGV4cG9ydCBsZXQgc2VnbWVudFxuXG4gICAgbGV0IGlzRGFya1RoZW1lID0gZmFsc2VcblxuICAgIGxldCB2YWx1ZSA9ICd1YSdcblxuICAgIGZ1bmN0aW9uIGNoYW5nZVRoZW1lKCkge1xuICAgICAgICBpc0RhcmtUaGVtZSA9ICFpc0RhcmtUaGVtZVxuICAgICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoJ3RoZW1lLWRhcmsnKVxuICAgICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoJ3RoZW1lLWxpZ2h0JylcbiAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKGlzRGFya1RoZW1lID8gJ3RoZW1lLWRhcmsnIDogJ3RoZW1lLWxpZ2h0JylcbiAgICB9XG48L3NjcmlwdD5cblxuPG5hdiBjbGFzcz1cInRoZW1lLWJnIGNvbnRhaW5lclwiPlxuICAgIDx1bD5cbiAgICAgICAgPGxpPjxhIGNsYXNzOnNlbGVjdGVkPSd7c2VnbWVudCA9PT0gdW5kZWZpbmVkfScgaHJlZj0nLic+aG9tZTwvYT48L2xpPlxuICAgICAgICA8bGk+PGEgY2xhc3M6c2VsZWN0ZWQ9J3tzZWdtZW50ID09PSBcImxpc3RcIn0nIGhyZWY9J2xpc3QnPmxpc3Q8L2E+PC9saT5cbiAgICAgICAgPGxpPjxhIHJlbD1wcmVmZXRjaCBjbGFzczpzZWxlY3RlZD0ne3NlZ21lbnQgPT09IFwiY2hhcml0eVwifScgaHJlZj0nY2hhcml0eSc+Y2hhcml0eTwvYT48L2xpPlxuICAgICAgICA8bGk+PGEgY2xhc3M6c2VsZWN0ZWQ9J3tzZWdtZW50ID09PSBcImFib3V0XCJ9JyBocmVmPSdhYm91dCc+YWJvdXQ8L2E+PC9saT5cbiAgICA8L3VsPlxuXG4gICAgPHVsIGNsYXNzPVwibmF2LWFjdGlvbnNcIj5cbiAgICAgICAgPGxpPlxuICAgICAgICAgICAgPHNlbGVjdCB7dmFsdWV9IG5hbWU9XCJsYW5nXCIgaWQ9XCJsYW5nXCIgY2xhc3M9XCJidG4gc21hbGwgbGFuZy1zZWxlY3RcIj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwidWFcIj5VYTwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJydVwiPlJ1PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cImVuXCI+RW48L29wdGlvbj5cbiAgICAgICAgICAgIDwvc2VsZWN0PlxuICAgICAgICA8L2xpPlxuXG4gICAgICAgIDxsaT5cbiAgICAgICAgICAgIDxCdXR0b24gb246Y2xpY2s9e2NoYW5nZVRoZW1lfSBhdXRvIHNpemU9XCJzbWFsbFwiPlxuICAgICAgICAgICAgICAgIDxJY29uIHR5cGU9XCJtb29uXCIgY2xhc3M9XCJ0aGVtZS1zdmctZmlsbFwiLz5cbiAgICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICA8L2xpPlxuXG4gICAgICAgIDxsaT5cbiAgICAgICAgICAgIDxCdXR0b24gb246Y2xpY2s9e2NoYW5nZVRoZW1lfSBhdXRvIHNpemU9XCJzbWFsbFwiPlxuICAgICAgICAgICAgICAgIDxBdmF0YXIgc2l6ZT1cInNtYWxsXCIgc3JjPVwiaHR0cHM6Ly9wbGFjZWltZy5jb20vMzAwLzMwMC9wZW9wbGVcIi8+XG4gICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgPC9saT5cbiAgICA8L3VsPlxuPC9uYXY+XG5cbjxzdHlsZT5cbiAgICBuYXYge1xuICAgICAgICBwb3NpdGlvbjogc3RpY2t5O1xuICAgICAgICB0b3A6IDA7XG4gICAgICAgIHotaW5kZXg6IDEwO1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgICAgIGJveC1zaGFkb3c6IHZhcigtLXNoYWRvdy1zZWNvbmRhcnkpO1xuICAgICAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgcmdiYSh2YXIoLS1jb2xvci1kYW5nZXIpLCAuMSk7XG4gICAgfVxuXG4gICAgLnNlbGVjdGVkIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgfVxuXG4gICAgLnNlbGVjdGVkOjphZnRlciB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgY29udGVudDogXCJcIjtcbiAgICAgICAgd2lkdGg6IGNhbGMoMTAwJSAtIDFlbSk7XG4gICAgICAgIGhlaWdodDogMnB4O1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IodmFyKC0tY29sb3ItZGFuZ2VyKSk7XG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICBib3R0b206IC0xcHg7XG4gICAgfVxuXG4gICAgYSB7XG4gICAgICAgIHBhZGRpbmc6IC44ZW0gMC41ZW07XG4gICAgfVxuXG4gICAgLm5hdi1hY3Rpb25zIHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgbWFyZ2luOiAtM3B4O1xuICAgIH1cblxuICAgIC5uYXYtYWN0aW9ucyBsaSB7XG4gICAgICAgIHBhZGRpbmc6IDNweDtcbiAgICB9XG5cbiAgICAubGFuZy1zZWxlY3Qge1xuICAgICAgICBwYWRkaW5nOiA1cHg7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuICAgIH1cblxuICAgIC5sYW5nLXNlbGVjdDpob3ZlcixcbiAgICAubGFuZy1zZWxlY3Q6Zm9jdXMge1xuICAgICAgICBib3gtc2hhZG93OiBub25lO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKHZhcigtLWNvbG9yLWJsYWNrKSwgMC4xKTtcbiAgICB9XG48L3N0eWxlPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBJbnB1dCwgQnV0dG9uIH0gZnJvbSAnLi4vY29tcG9uZW50cydcbjwvc2NyaXB0PlxuXG48dWw+XG4gICAgPGxpPlxuICAgICAgICA8QnV0dG9uIGlzPVwic3VjY2Vzc1wiIG9uOmNsaWNrPVwie2UgPT4gY29uc29sZS5sb2coZSl9XCI+dGVzdDE8L0J1dHRvbj5cbiAgICA8L2xpPlxuICAgIDxsaT5cbiAgICAgICAgPEJ1dHRvbiBpcz1cInN1Y2Nlc3NcIiBvbjpjbGljaz1cIntlID0+IGNvbnNvbGUubG9nKGUpfVwiPnRlc3QxMjwvQnV0dG9uPlxuICAgIDwvbGk+XG4gICAgPGxpPlxuICAgICAgICA8QnV0dG9uIGlzPVwic3VjY2Vzc1wiIG9uOmNsaWNrPVwie2UgPT4gY29uc29sZS5sb2coZSl9XCI+dGVzdDEyMzwvQnV0dG9uPlxuICAgIDwvbGk+XG4gICAgPGxpPlxuICAgICAgICA8YnI+XG4gICAgICAgIDxJbnB1dFxuICAgICAgICAgICAgICAgIHR5cGU9XCJudW1iZXJcIlxuICAgICAgICAgICAgICAgIG5hbWU9XCJudW1cIlxuICAgICAgICAgICAgICAgIGxpc3Q9XCJzdW0tc3VnZ2VzdGlvbnNcIlxuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiTnVtXCJcbiAgICAgICAgICAgICAgICBhdXRvc2VsZWN0XG4gICAgICAgICAgICAgICAgYWxpZ249XCJyaWdodFwiXG4gICAgICAgIC8+XG5cbiAgICAgICAgPGRhdGFsaXN0IGlkPVwic3VtLXN1Z2dlc3Rpb25zXCI+XG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiMjBcIj5cbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCI1MDBcIj5cbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIxMDAwXCI+XG4gICAgICAgIDwvZGF0YWxpc3Q+XG4gICAgPC9saT5cbiAgICA8bGk+XG4gICAgICAgIDxCdXR0b24gaXM9XCJ3YXJuaW5nXCIgb246Y2xpY2s9XCJ7ZSA9PiBjb25zb2xlLmxvZyhlKX1cIj5TdWJtaXQ8L0J1dHRvbj5cbiAgICA8L2xpPlxuPC91bD5cblxuPHN0eWxlPlxuICAgIHVsIHtcbiAgICAgICAgZmxleDogMDtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAgbWFyZ2luOiBjYWxjKHZhcigtLXNjcmVlbi1wYWRkaW5nKSAqIC0xIC8gMikgMDtcbiAgICAgICAgcGFkZGluZzogMCAwIDAgdmFyKC0tc2NyZWVuLXBhZGRpbmcpO1xuICAgIH1cblxuICAgIHVsIGxpIHtcbiAgICAgICAgZmxleDogbm9uZTtcbiAgICAgICAgbWFyZ2luOiBjYWxjKHZhcigtLXNjcmVlbi1wYWRkaW5nKSAvIDIpIDA7XG4gICAgfVxuPC9zdHlsZT5cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O29CQUtxQixJQUFJLEdBQUcsV0FBVzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztpQ0NrUHBCLEdBQVU7OztnQ0FBZixNQUFJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztnQ0FBQyxHQUFVOzs7K0JBQWYsTUFBSTs7Ozs7Ozs7Ozs7Ozs7OztvQ0FBSixNQUFJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs0RUFDZ0IsR0FBZSxhQUFJLEdBQUM7S0FBRyxXQUFXO0tBQUcsRUFBRTs7Ozs7Ozs7Ozs7a0hBQXZDLEdBQWUsYUFBSSxHQUFDO0tBQUcsV0FBVztLQUFHLEVBQUU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzttQ0FIaEUsR0FBYzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztpREFEZ0QsR0FBUztnREFBZ0IsR0FBUzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MEJBQ2hHLEdBQWM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BaFBSLGtCQUFrQixHQUFHLEdBQUc7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
