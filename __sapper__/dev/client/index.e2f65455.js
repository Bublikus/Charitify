import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, e as element, t as text, c as claim_element, a as children, b as claim_text, f as detach_dev, g as add_location, h as attr_dev, j as insert_dev, k as append_dev, n as noop, l as create_slot, o as onMount, m as onDestroy, p as destroy_each, q as listen_dev, r as space, u as claim_space, v as get_slot_context, w as get_slot_changes, x as transition_in, y as transition_out, z as run_all, A as binding_callbacks, B as empty, C as assign, D as exclude_internal_props, E as svg_element, F as xlink_attr, G as null_to_empty, H as create_component, I as claim_component, J as mount_component, K as destroy_component, L as createEventDispatcher, M as set_attributes, N as toggle_class, O as set_input_value, P as get_spread_update, Q as group_outros, R as check_outros, T as prop_dev, U as set_data_dev, V as get_spread_object, W as set_style } from './index.f1512f61.js';

/* src/layouts/Footer.svelte generated by Svelte v3.16.7 */

const file = "src/layouts/Footer.svelte";

function create_fragment(ctx) {
	let footer;
	let p;
	let t0;
	let t1_value = new Date().getFullYear() + "";
	let t1;

	const block = {
		c: function create() {
			footer = element("footer");
			p = element("p");
			t0 = text("© 2019 - ");
			t1 = text(t1_value);
			this.h();
		},
		l: function claim(nodes) {
			footer = claim_element(nodes, "FOOTER", { class: true });
			var footer_nodes = children(footer);
			p = claim_element(footer_nodes, "P", {});
			var p_nodes = children(p);
			t0 = claim_text(p_nodes, "© 2019 - ");
			t1 = claim_text(p_nodes, t1_value);
			p_nodes.forEach(detach_dev);
			footer_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(p, file, 5, 4, 34);
			attr_dev(footer, "class", "svelte-hgsupk");
			add_location(footer, file, 4, 0, 21);
		},
		m: function mount(target, anchor) {
			insert_dev(target, footer, anchor);
			append_dev(footer, p);
			append_dev(p, t0);
			append_dev(p, t1);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(footer);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

class Footer extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, null, create_fragment, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Footer",
			options,
			id: create_fragment.name
		});
	}
}

/* src/plugins/Swipe/Swipe.svelte generated by Svelte v3.16.7 */
const file$1 = "src/plugins/Swipe/Swipe.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[18] = list[i];
	child_ctx[35] = i;
	return child_ctx;
}

// (246:4) {#if showIndicators}
function create_if_block(ctx) {
	let div;
	let each_value = /*indicators*/ ctx[2];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div_nodes);
			}

			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "swipe-indicator swipe-indicator-inside svelte-tx0axj");
			add_location(div, file$1, 246, 8, 6498);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*activeIndicator, changeItem, indicators*/ 70) {
				each_value = /*indicators*/ ctx[2];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(246:4) {#if showIndicators}",
		ctx
	});

	return block;
}

// (248:12) {#each indicators as x, i }
function create_each_block(ctx) {
	let span;
	let span_class_value;
	let dispose;

	function click_handler(...args) {
		return /*click_handler*/ ctx[33](/*i*/ ctx[35], ...args);
	}

	const block = {
		c: function create() {
			span = element("span");
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			children(span).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", span_class_value = "dot " + (/*activeIndicator*/ ctx[1] == /*i*/ ctx[35]
			? "is-active"
			: "") + " svelte-tx0axj");

			add_location(span, file$1, 248, 16, 6607);
			dispose = listen_dev(span, "click", click_handler, false, false, false);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty[0] & /*activeIndicator*/ 2 && span_class_value !== (span_class_value = "dot " + (/*activeIndicator*/ ctx[1] == /*i*/ ctx[35]
			? "is-active"
			: "") + " svelte-tx0axj")) {
				attr_dev(span, "class", span_class_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(248:12) {#each indicators as x, i }",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let div4;
	let div2;
	let div1;
	let div0;
	let t0;
	let div3;
	let t1;
	let current;
	let dispose;
	const default_slot_template = /*$$slots*/ ctx[30].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[29], null);
	let if_block = /*showIndicators*/ ctx[0] && create_if_block(ctx);

	const block = {
		c: function create() {
			div4 = element("div");
			div2 = element("div");
			div1 = element("div");
			div0 = element("div");
			if (default_slot) default_slot.c();
			t0 = space();
			div3 = element("div");
			t1 = space();
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			div4 = claim_element(nodes, "DIV", { class: true });
			var div4_nodes = children(div4);
			div2 = claim_element(div4_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			if (default_slot) default_slot.l(div0_nodes);
			div0_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			t0 = claim_space(div4_nodes);
			div3 = claim_element(div4_nodes, "DIV", { class: true });
			children(div3).forEach(detach_dev);
			t1 = claim_space(div4_nodes);
			if (if_block) if_block.l(div4_nodes);
			div4_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "swipeable-slot-wrapper svelte-tx0axj");
			add_location(div0, file$1, 239, 12, 6244);
			attr_dev(div1, "class", "swipeable-items svelte-tx0axj");
			add_location(div1, file$1, 238, 8, 6202);
			attr_dev(div2, "class", "swipe-item-wrapper svelte-tx0axj");
			add_location(div2, file$1, 237, 4, 6136);
			attr_dev(div3, "class", "swipe-handler svelte-tx0axj");
			add_location(div3, file$1, 244, 4, 6355);
			attr_dev(div4, "class", "swipe-panel svelte-tx0axj");
			add_location(div4, file$1, 236, 0, 6106);

			dispose = [
				listen_dev(div3, "touchstart", /*moveStart*/ ctx[5], false, false, false),
				listen_dev(div3, "mousedown", /*moveStart*/ ctx[5], false, false, false)
			];
		},
		m: function mount(target, anchor) {
			insert_dev(target, div4, anchor);
			append_dev(div4, div2);
			append_dev(div2, div1);
			append_dev(div1, div0);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			/*div2_binding*/ ctx[31](div2);
			append_dev(div4, t0);
			append_dev(div4, div3);
			/*div3_binding*/ ctx[32](div3);
			append_dev(div4, t1);
			if (if_block) if_block.m(div4, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot && default_slot.p && dirty[0] & /*$$scope*/ 536870912) {
				default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[29], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[29], dirty, null));
			}

			if (/*showIndicators*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(div4, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div4);
			if (default_slot) default_slot.d(detaching);
			/*div2_binding*/ ctx[31](null);
			/*div3_binding*/ ctx[32](null);
			if (if_block) if_block.d();
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { transitionDuration = 200 } = $$props;
	let { showIndicators = false } = $$props;
	let { autoplay = false } = $$props;
	let { delay = 1000 } = $$props;
	let activeIndicator = 0;
	let indicators;
	let items = 0;
	let availableWidth = 0;
	let topClearence = 0;
	let elems;
	let diff = 0;
	let swipeWrapper;
	let swipeHandler;
	let min = 0;

	let touchingTpl = `
    -webkit-transition-duration: 0s;
    transition-duration: 0s;
    -webkit-transform: translate3d(-{{val}}px, 0, 0);
    -ms-transform: translate3d(-{{val}}px, 0, 0);`;

	let non_touchingTpl = `
    -webkit-transition-duration: ${transitionDuration}ms;
    transition-duration: ${transitionDuration}ms;
    -webkit-transform: translate3d(-{{val}}px, 0, 0);
    -ms-transform: translate3d(-{{val}}px, 0, 0);`;

	let touching = false;
	let posX = 0;
	let dir = 0;
	let x;
	let played = 0;
	let run_interval = false;

	function update() {
		$$invalidate(4, swipeHandler.style.top = topClearence + "px", swipeHandler);
		availableWidth = swipeWrapper.querySelector(".swipeable-items").offsetWidth;

		for (let i = 0; i < items; i++) {
			elems[i].style.transform = "translate3d(" + availableWidth * i + "px, 0, 0)";
		}

		diff = 0;
	}

	function init() {
		elems = swipeWrapper.querySelectorAll(".swipeable-item");
		$$invalidate(10, items = elems.length);
		update();
	}

	onMount(() => {
		init();
		window.addEventListener("resize", update);
	});

	onDestroy(() => {
		window.removeEventListener("resize", update);
	});

	function moveHandler(e) {
		if (touching) {
			e.stopImmediatePropagation();
			e.stopPropagation();
			let max = availableWidth;
			let _x = e.touches ? e.touches[0].pageX : e.pageX;
			let _diff = x - _x + posX;
			let dir = _x > x ? 0 : 1;

			if (!dir) {
				_diff = posX - (_x - x);
			}

			if (_diff <= max * (items - 1) && _diff >= min) {
				for (let i = 0; i < items; i++) {
					let template = i < 0 ? "{{val}}" : "-{{val}}";
					let _value = max * i - _diff;
					elems[i].style.cssText = touchingTpl.replace(template, _value).replace(template, _value);
				}

				diff = _diff;
			}
		}
	}

	function endHandler(e) {
		e && e.stopImmediatePropagation();
		e && e.stopPropagation();
		e && e.preventDefault();
		let max = availableWidth;
		touching = false;
		x = null;
		let delta = 0.05;
		let swipe_threshold = 0.85;
		let d_max = diff / max;
		let deltaDMax = d_max - Math.floor(d_max);

		let _target = deltaDMax > delta && deltaDMax < 0.5
		? Math.ceil(d_max)
		: Math.floor(d_max);

		if (Math.abs(_target - d_max) < swipe_threshold) {
			diff = _target * max;
		} else {
			diff = (dir ? _target - 1 : _target + 1) * max;
		}

		posX = diff;
		$$invalidate(1, activeIndicator = diff / max);

		for (let i = 0; i < items; i++) {
			let template = i < 0 ? "{{val}}" : "-{{val}}";
			let _value = max * i - posX;
			elems[i].style.cssText = non_touchingTpl.replace(template, _value).replace(template, _value);
		}

		window.removeEventListener("mousemove", moveHandler);
		window.removeEventListener("mouseup", endHandler);
		window.removeEventListener("touchmove", moveHandler);
		window.removeEventListener("touchend", endHandler);
	}

	function moveStart(e) {
		e.stopImmediatePropagation();
		e.stopPropagation();
		e.preventDefault();
		touching = true;
		x = e.touches ? e.touches[0].pageX : e.pageX;
		window.addEventListener("mousemove", moveHandler);
		window.addEventListener("mouseup", endHandler);
		window.addEventListener("touchmove", moveHandler);
		window.addEventListener("touchend", endHandler);
	}

	function changeItem(item) {
		let max = availableWidth;
		diff = max * item;
		$$invalidate(1, activeIndicator = item);
		endHandler();
	}

	function changeView() {
		changeItem(played);
		played = played < items - 1 ? ++played : 0;
	}

	const writable_props = ["transitionDuration", "showIndicators", "autoplay", "delay"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Swipe> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;

	function div2_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			$$invalidate(3, swipeWrapper = $$value);
		});
	}

	function div3_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			$$invalidate(4, swipeHandler = $$value);
		});
	}

	const click_handler = i => {
		changeItem(i);
	};

	$$self.$set = $$props => {
		if ("transitionDuration" in $$props) $$invalidate(7, transitionDuration = $$props.transitionDuration);
		if ("showIndicators" in $$props) $$invalidate(0, showIndicators = $$props.showIndicators);
		if ("autoplay" in $$props) $$invalidate(8, autoplay = $$props.autoplay);
		if ("delay" in $$props) $$invalidate(9, delay = $$props.delay);
		if ("$$scope" in $$props) $$invalidate(29, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => {
		return {
			transitionDuration,
			showIndicators,
			autoplay,
			delay,
			activeIndicator,
			indicators,
			items,
			availableWidth,
			topClearence,
			elems,
			diff,
			swipeWrapper,
			swipeHandler,
			min,
			touchingTpl,
			non_touchingTpl,
			touching,
			posX,
			dir,
			x,
			played,
			run_interval
		};
	};

	$$self.$inject_state = $$props => {
		if ("transitionDuration" in $$props) $$invalidate(7, transitionDuration = $$props.transitionDuration);
		if ("showIndicators" in $$props) $$invalidate(0, showIndicators = $$props.showIndicators);
		if ("autoplay" in $$props) $$invalidate(8, autoplay = $$props.autoplay);
		if ("delay" in $$props) $$invalidate(9, delay = $$props.delay);
		if ("activeIndicator" in $$props) $$invalidate(1, activeIndicator = $$props.activeIndicator);
		if ("indicators" in $$props) $$invalidate(2, indicators = $$props.indicators);
		if ("items" in $$props) $$invalidate(10, items = $$props.items);
		if ("availableWidth" in $$props) availableWidth = $$props.availableWidth;
		if ("topClearence" in $$props) topClearence = $$props.topClearence;
		if ("elems" in $$props) elems = $$props.elems;
		if ("diff" in $$props) diff = $$props.diff;
		if ("swipeWrapper" in $$props) $$invalidate(3, swipeWrapper = $$props.swipeWrapper);
		if ("swipeHandler" in $$props) $$invalidate(4, swipeHandler = $$props.swipeHandler);
		if ("min" in $$props) min = $$props.min;
		if ("touchingTpl" in $$props) touchingTpl = $$props.touchingTpl;
		if ("non_touchingTpl" in $$props) non_touchingTpl = $$props.non_touchingTpl;
		if ("touching" in $$props) touching = $$props.touching;
		if ("posX" in $$props) posX = $$props.posX;
		if ("dir" in $$props) dir = $$props.dir;
		if ("x" in $$props) x = $$props.x;
		if ("played" in $$props) played = $$props.played;
		if ("run_interval" in $$props) $$invalidate(17, run_interval = $$props.run_interval);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*items*/ 1024) {
			 $$invalidate(2, indicators = Array(items));
		}

		if ($$self.$$.dirty[0] & /*autoplay, run_interval, delay*/ 131840) {
			 {
				if (autoplay && !run_interval) {
					$$invalidate(17, run_interval = setInterval(changeView, delay));
				}

				if (!autoplay && run_interval) {
					clearInterval(run_interval);
					$$invalidate(17, run_interval = false);
				}
			}
		}
	};

	return [
		showIndicators,
		activeIndicator,
		indicators,
		swipeWrapper,
		swipeHandler,
		moveStart,
		changeItem,
		transitionDuration,
		autoplay,
		delay,
		items,
		availableWidth,
		elems,
		diff,
		touching,
		posX,
		played,
		run_interval,
		x,
		topClearence,
		min,
		touchingTpl,
		non_touchingTpl,
		dir,
		update,
		init,
		moveHandler,
		endHandler,
		changeView,
		$$scope,
		$$slots,
		div2_binding,
		div3_binding,
		click_handler
	];
}

class Swipe extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance,
			create_fragment$1,
			safe_not_equal,
			{
				transitionDuration: 7,
				showIndicators: 0,
				autoplay: 8,
				delay: 9
			},
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Swipe",
			options,
			id: create_fragment$1.name
		});
	}

	get transitionDuration() {
		throw new Error("<Swipe>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set transitionDuration(value) {
		throw new Error("<Swipe>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get showIndicators() {
		throw new Error("<Swipe>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set showIndicators(value) {
		throw new Error("<Swipe>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get autoplay() {
		throw new Error("<Swipe>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set autoplay(value) {
		throw new Error("<Swipe>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get delay() {
		throw new Error("<Swipe>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set delay(value) {
		throw new Error("<Swipe>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/plugins/Swipe/SwipeItem.svelte generated by Svelte v3.16.7 */

const file$2 = "src/plugins/Swipe/SwipeItem.svelte";

function create_fragment$2(ctx) {
	let div;
	let div_class_value;
	let current;
	const default_slot_template = /*$$slots*/ ctx[2].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", div_class_value = "swipeable-item " + /*classes*/ ctx[0] + " svelte-1c0dn3k");
			add_location(div, file$2, 17, 0, 291);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot && default_slot.p && dirty & /*$$scope*/ 2) {
				default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[1], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[1], dirty, null));
			}

			if (!current || dirty & /*classes*/ 1 && div_class_value !== (div_class_value = "swipeable-item " + /*classes*/ ctx[0] + " svelte-1c0dn3k")) {
				attr_dev(div, "class", div_class_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let { classes = "" } = $$props;
	const writable_props = ["classes"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SwipeItem> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;

	$$self.$set = $$props => {
		if ("classes" in $$props) $$invalidate(0, classes = $$props.classes);
		if ("$$scope" in $$props) $$invalidate(1, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => {
		return { classes };
	};

	$$self.$inject_state = $$props => {
		if ("classes" in $$props) $$invalidate(0, classes = $$props.classes);
	};

	return [classes, $$scope, $$slots];
}

class SwipeItem extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$2, safe_not_equal, { classes: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "SwipeItem",
			options,
			id: create_fragment$2.name
		});
	}

	get classes() {
		throw new Error("<SwipeItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set classes(value) {
		throw new Error("<SwipeItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/Br.svelte generated by Svelte v3.16.7 */

const file$3 = "src/components/Br.svelte";

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[2] = list[i];
	return child_ctx;
}

// (7:0) {#each brArr as _i}
function create_each_block$1(ctx) {
	let br;

	const block = {
		c: function create() {
			br = element("br");
			this.h();
		},
		l: function claim(nodes) {
			br = claim_element(nodes, "BR", {});
			this.h();
		},
		h: function hydrate() {
			add_location(br, file$3, 7, 4, 147);
		},
		m: function mount(target, anchor) {
			insert_dev(target, br, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(br);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$1.name,
		type: "each",
		source: "(7:0) {#each brArr as _i}",
		ctx
	});

	return block;
}

function create_fragment$3(ctx) {
	let each_1_anchor;
	let each_value = /*brArr*/ ctx[0];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*brArr*/ 1) {
				const old_length = each_value.length;
				each_value = /*brArr*/ ctx[0];
				let i;

				for (i = old_length; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (!each_blocks[i]) {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (i = each_value.length; i < old_length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	let { amount = 1 } = $$props;
	const writable_props = ["amount"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Br> was created with unknown prop '${key}'`);
	});

	$$self.$set = $$props => {
		if ("amount" in $$props) $$invalidate(1, amount = $$props.amount);
	};

	$$self.$capture_state = () => {
		return { amount, brArr };
	};

	$$self.$inject_state = $$props => {
		if ("amount" in $$props) $$invalidate(1, amount = $$props.amount);
		if ("brArr" in $$props) $$invalidate(0, brArr = $$props.brArr);
	};

	let brArr;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*amount*/ 2) {
			 $$invalidate(0, brArr = new Array(Number.isFinite(+amount) ? +amount : 1).fill(null));
		}
	};

	return [brArr, amount];
}

class Br extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$3, safe_not_equal, { amount: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Br",
			options,
			id: create_fragment$3.name
		});
	}

	get amount() {
		throw new Error("<Br>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set amount(value) {
		throw new Error("<Br>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var classnames = createCommonjsModule(function (module) {
/*!
  Copyright (c) 2017 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {

	var hasOwn = {}.hasOwnProperty;

	function classNames () {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg) && arg.length) {
				var inner = classNames.apply(null, arg);
				if (inner) {
					classes.push(inner);
				}
			} else if (argType === 'object') {
				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if ( module.exports) {
		classNames.default = classNames;
		module.exports = classNames;
	} else {
		window.classNames = classNames;
	}
}());
});

const toCSSString = (styles = {}) => Object.entries(styles)
  .filter(([_propName, propValue]) => propValue !== undefined && propValue !== null)
  .reduce((styleString, [propName, propValue]) => {
    propName = propName.replace(/[A-Z]/g, match => `-${match.toLowerCase()}`);
    return `${styleString}${propName}:${propValue};`
  }, '');

/**
 *
 * @function safeGet
 *
 * @description Safe getting of an any value of a nested objects.
 *
 * @param expressionFn {function} - The function with an expression which returns result of the safe getting.
 * @param defaultValue {any} - The default value when result is undefined.
 * @param isDefaultTyped {boolean} - Wheter is the result from an expression must be the same type as the default value.
 *
 * @examples
 * // Some data.
 * const very = {
 *  nested: {
 *   object: [{
 *     with: {
 *       arrays: 'stuff'
 *     }
 *   }]
 *  }
 * }
 *
 * // Getting.
 * 1. safeGet(() => very.nested.object[0].with.arrays);
 * 2. safeGet(() => very.nested.object[0].with.arrays, { default: 'value' });
 * 3. safeGet(() => very.nested.object[0].with.arrays, { default: 'value' }, true);
 *
 * // Return.
 * 1. 'stuff'
 * 2. 'stuff'
 * 3. { default: 'value' }
 */
function safeGet(expressionFn, defaultValue, isDefaultTyped = false) {
  // Check whether a and b have the same type. (util)
  function isSameType(a, b) {
    const rules = [
      (a, b) => typeof a === typeof b,
      (a, b) => (+a === a) === (+b === b),              // whether one is NaN
      (a, b) => (a === null) === (b === null),          // null is object type too
      (a, b) => Array.isArray(a) === Array.isArray(b),  // array is object type too
    ];
    return !rules.some(ruleFn => !ruleFn(a, b))
  }
  // Core of safe getting. Executing a function. Default values.
  function get(expressionFn, defaultValue, isDefaultTyped) {
    try {
      const result = expressionFn.call(this);
      if (isDefaultTyped) {
        return isSameType(result, defaultValue) ? result : defaultValue
      } else {
        return result === undefined ? defaultValue : result
      }
    } catch (e) {
      return defaultValue
    }
  }
  // Safe getting of the expressionFn.
  if (typeof expressionFn === 'function') {
    return get(expressionFn, defaultValue, isDefaultTyped)
  } else {
    console.warn('You need to use a function as the first argument.');
  }
  return defaultValue
}

/* src/components/Icon.svelte generated by Svelte v3.16.7 */
const file$4 = "src/components/Icon.svelte";

function create_fragment$4(ctx) {
	let svg;
	let use;
	let use_xlink_href_value;
	let svg_class_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			use = svg_element("use");
			this.h();
		},
		l: function claim(nodes) {
			svg = claim_element(
				nodes,
				"svg",
				{
					id: true,
					title: true,
					class: true,
					style: true,
					"aria-label": true
				},
				1
			);

			var svg_nodes = children(svg);
			use = claim_element(svg_nodes, "use", { "xlink:href": true, class: true }, 1);
			children(use).forEach(detach_dev);
			svg_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			xlink_attr(use, "xlink:href", use_xlink_href_value = `#ico-${/*type*/ ctx[0]}`);
			attr_dev(use, "class", "ico-use svelte-1y5h9x9");
			add_location(use, file$4, 26, 4, 745);
			attr_dev(svg, "id", /*id*/ ctx[1]);
			attr_dev(svg, "title", /*titleProp*/ ctx[3]);
			attr_dev(svg, "class", svg_class_value = "" + (null_to_empty(/*classProp*/ ctx[2]) + " svelte-1y5h9x9"));
			attr_dev(svg, "style", /*styleProp*/ ctx[5]);
			attr_dev(svg, "aria-label", /*ariaLabelProp*/ ctx[4]);
			add_location(svg, file$4, 19, 0, 608);
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, use);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*type*/ 1 && use_xlink_href_value !== (use_xlink_href_value = `#ico-${/*type*/ ctx[0]}`)) {
				xlink_attr(use, "xlink:href", use_xlink_href_value);
			}

			if (dirty & /*id*/ 2) {
				attr_dev(svg, "id", /*id*/ ctx[1]);
			}

			if (dirty & /*classProp*/ 4 && svg_class_value !== (svg_class_value = "" + (null_to_empty(/*classProp*/ ctx[2]) + " svelte-1y5h9x9"))) {
				attr_dev(svg, "class", svg_class_value);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3($$self, $$props, $$invalidate) {
	let { type } = $$props;
	let { is } = $$props;
	let { size = "medium" } = $$props;
	let { rotate = 0 } = $$props;
	let { style = undefined } = $$props;
	let { id = undefined } = $$props;
	let { title = undefined } = $$props;
	let { ariaLabel = undefined } = $$props;
	let titleProp = title || ariaLabel;
	let ariaLabelProp = ariaLabel || title;

	let styleProp = toCSSString({
		transform: !!rotate ? `rotateZ(${rotate}deg)` : null,
		...style
	});

	$$self.$set = $$new_props => {
		$$invalidate(12, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("type" in $$new_props) $$invalidate(0, type = $$new_props.type);
		if ("is" in $$new_props) $$invalidate(6, is = $$new_props.is);
		if ("size" in $$new_props) $$invalidate(7, size = $$new_props.size);
		if ("rotate" in $$new_props) $$invalidate(8, rotate = $$new_props.rotate);
		if ("style" in $$new_props) $$invalidate(9, style = $$new_props.style);
		if ("id" in $$new_props) $$invalidate(1, id = $$new_props.id);
		if ("title" in $$new_props) $$invalidate(10, title = $$new_props.title);
		if ("ariaLabel" in $$new_props) $$invalidate(11, ariaLabel = $$new_props.ariaLabel);
	};

	$$self.$capture_state = () => {
		return {
			type,
			is,
			size,
			rotate,
			style,
			id,
			title,
			ariaLabel,
			titleProp,
			ariaLabelProp,
			styleProp,
			classProp
		};
	};

	$$self.$inject_state = $$new_props => {
		$$invalidate(12, $$props = assign(assign({}, $$props), $$new_props));
		if ("type" in $$props) $$invalidate(0, type = $$new_props.type);
		if ("is" in $$props) $$invalidate(6, is = $$new_props.is);
		if ("size" in $$props) $$invalidate(7, size = $$new_props.size);
		if ("rotate" in $$props) $$invalidate(8, rotate = $$new_props.rotate);
		if ("style" in $$props) $$invalidate(9, style = $$new_props.style);
		if ("id" in $$props) $$invalidate(1, id = $$new_props.id);
		if ("title" in $$props) $$invalidate(10, title = $$new_props.title);
		if ("ariaLabel" in $$props) $$invalidate(11, ariaLabel = $$new_props.ariaLabel);
		if ("titleProp" in $$props) $$invalidate(3, titleProp = $$new_props.titleProp);
		if ("ariaLabelProp" in $$props) $$invalidate(4, ariaLabelProp = $$new_props.ariaLabelProp);
		if ("styleProp" in $$props) $$invalidate(5, styleProp = $$new_props.styleProp);
		if ("classProp" in $$props) $$invalidate(2, classProp = $$new_props.classProp);
	};

	let classProp;

	$$self.$$.update = () => {
		 $$invalidate(2, classProp = classnames("ico", is, size, $$props.class));
	};

	$$props = exclude_internal_props($$props);

	return [
		type,
		id,
		classProp,
		titleProp,
		ariaLabelProp,
		styleProp,
		is,
		size,
		rotate,
		style,
		title,
		ariaLabel
	];
}

class Icon extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3, create_fragment$4, safe_not_equal, {
			type: 0,
			is: 6,
			size: 7,
			rotate: 8,
			style: 9,
			id: 1,
			title: 10,
			ariaLabel: 11
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Icon",
			options,
			id: create_fragment$4.name
		});

		const { ctx } = this.$$;
		const props = options.props || ({});

		if (/*type*/ ctx[0] === undefined && !("type" in props)) {
			console.warn("<Icon> was created without expected prop 'type'");
		}

		if (/*is*/ ctx[6] === undefined && !("is" in props)) {
			console.warn("<Icon> was created without expected prop 'is'");
		}
	}

	get type() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set type(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get is() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set is(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get rotate() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set rotate(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get id() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get title() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ariaLabel() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ariaLabel(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/Rate.svelte generated by Svelte v3.16.7 */
const file$5 = "src/components/Rate.svelte";

function create_fragment$5(ctx) {
	let ul;
	let li0;
	let t0;
	let li1;
	let t1;
	let li2;
	let t2;
	let li3;
	let t3;
	let li4;
	let current;

	const icon0 = new Icon({
			props: {
				is: /*is*/ ctx[0],
				size: /*size*/ ctx[1],
				type: "heart-filled"
			},
			$$inline: true
		});

	const icon1 = new Icon({
			props: {
				is: /*is*/ ctx[0],
				size: /*size*/ ctx[1],
				type: "heart-filled"
			},
			$$inline: true
		});

	const icon2 = new Icon({
			props: {
				is: /*is*/ ctx[0],
				size: /*size*/ ctx[1],
				type: "heart-filled"
			},
			$$inline: true
		});

	const icon3 = new Icon({
			props: {
				is: /*is*/ ctx[0],
				size: /*size*/ ctx[1],
				type: "heart-filled"
			},
			$$inline: true
		});

	const icon4 = new Icon({
			props: {
				is: /*is*/ ctx[0],
				size: /*size*/ ctx[1],
				type: "heart-filled"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			ul = element("ul");
			li0 = element("li");
			create_component(icon0.$$.fragment);
			t0 = space();
			li1 = element("li");
			create_component(icon1.$$.fragment);
			t1 = space();
			li2 = element("li");
			create_component(icon2.$$.fragment);
			t2 = space();
			li3 = element("li");
			create_component(icon3.$$.fragment);
			t3 = space();
			li4 = element("li");
			create_component(icon4.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);
			li0 = claim_element(ul_nodes, "LI", { class: true });
			var li0_nodes = children(li0);
			claim_component(icon0.$$.fragment, li0_nodes);
			li0_nodes.forEach(detach_dev);
			t0 = claim_space(ul_nodes);
			li1 = claim_element(ul_nodes, "LI", { class: true });
			var li1_nodes = children(li1);
			claim_component(icon1.$$.fragment, li1_nodes);
			li1_nodes.forEach(detach_dev);
			t1 = claim_space(ul_nodes);
			li2 = claim_element(ul_nodes, "LI", { class: true });
			var li2_nodes = children(li2);
			claim_component(icon2.$$.fragment, li2_nodes);
			li2_nodes.forEach(detach_dev);
			t2 = claim_space(ul_nodes);
			li3 = claim_element(ul_nodes, "LI", { class: true });
			var li3_nodes = children(li3);
			claim_component(icon3.$$.fragment, li3_nodes);
			li3_nodes.forEach(detach_dev);
			t3 = claim_space(ul_nodes);
			li4 = claim_element(ul_nodes, "LI", { class: true });
			var li4_nodes = children(li4);
			claim_component(icon4.$$.fragment, li4_nodes);
			li4_nodes.forEach(detach_dev);
			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(li0, "class", "svelte-9gtglw");
			add_location(li0, file$5, 8, 4, 172);
			attr_dev(li1, "class", "svelte-9gtglw");
			add_location(li1, file$5, 11, 4, 239);
			attr_dev(li2, "class", "svelte-9gtglw");
			add_location(li2, file$5, 14, 4, 306);
			attr_dev(li3, "class", "svelte-9gtglw");
			add_location(li3, file$5, 17, 4, 373);
			attr_dev(li4, "class", "svelte-9gtglw");
			add_location(li4, file$5, 20, 4, 440);
			attr_dev(ul, "class", "rate svelte-9gtglw");
			add_location(ul, file$5, 7, 0, 150);
		},
		m: function mount(target, anchor) {
			insert_dev(target, ul, anchor);
			append_dev(ul, li0);
			mount_component(icon0, li0, null);
			append_dev(ul, t0);
			append_dev(ul, li1);
			mount_component(icon1, li1, null);
			append_dev(ul, t1);
			append_dev(ul, li2);
			mount_component(icon2, li2, null);
			append_dev(ul, t2);
			append_dev(ul, li3);
			mount_component(icon3, li3, null);
			append_dev(ul, t3);
			append_dev(ul, li4);
			mount_component(icon4, li4, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const icon0_changes = {};
			if (dirty & /*is*/ 1) icon0_changes.is = /*is*/ ctx[0];
			if (dirty & /*size*/ 2) icon0_changes.size = /*size*/ ctx[1];
			icon0.$set(icon0_changes);
			const icon1_changes = {};
			if (dirty & /*is*/ 1) icon1_changes.is = /*is*/ ctx[0];
			if (dirty & /*size*/ 2) icon1_changes.size = /*size*/ ctx[1];
			icon1.$set(icon1_changes);
			const icon2_changes = {};
			if (dirty & /*is*/ 1) icon2_changes.is = /*is*/ ctx[0];
			if (dirty & /*size*/ 2) icon2_changes.size = /*size*/ ctx[1];
			icon2.$set(icon2_changes);
			const icon3_changes = {};
			if (dirty & /*is*/ 1) icon3_changes.is = /*is*/ ctx[0];
			if (dirty & /*size*/ 2) icon3_changes.size = /*size*/ ctx[1];
			icon3.$set(icon3_changes);
			const icon4_changes = {};
			if (dirty & /*is*/ 1) icon4_changes.is = /*is*/ ctx[0];
			if (dirty & /*size*/ 2) icon4_changes.size = /*size*/ ctx[1];
			icon4.$set(icon4_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon0.$$.fragment, local);
			transition_in(icon1.$$.fragment, local);
			transition_in(icon2.$$.fragment, local);
			transition_in(icon3.$$.fragment, local);
			transition_in(icon4.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon0.$$.fragment, local);
			transition_out(icon1.$$.fragment, local);
			transition_out(icon2.$$.fragment, local);
			transition_out(icon3.$$.fragment, local);
			transition_out(icon4.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(ul);
			destroy_component(icon0);
			destroy_component(icon1);
			destroy_component(icon2);
			destroy_component(icon3);
			destroy_component(icon4);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$5.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4($$self, $$props, $$invalidate) {
	let { is = "danger" } = $$props;
	let { size = "medium" } = $$props;
	const writable_props = ["is", "size"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Rate> was created with unknown prop '${key}'`);
	});

	$$self.$set = $$props => {
		if ("is" in $$props) $$invalidate(0, is = $$props.is);
		if ("size" in $$props) $$invalidate(1, size = $$props.size);
	};

	$$self.$capture_state = () => {
		return { is, size };
	};

	$$self.$inject_state = $$props => {
		if ("is" in $$props) $$invalidate(0, is = $$props.is);
		if ("size" in $$props) $$invalidate(1, size = $$props.size);
	};

	return [is, size];
}

class Rate extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4, create_fragment$5, safe_not_equal, { is: 0, size: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Rate",
			options,
			id: create_fragment$5.name
		});
	}

	get is() {
		throw new Error("<Rate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set is(value) {
		throw new Error("<Rate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<Rate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<Rate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/Input.svelte generated by Svelte v3.16.7 */
const file$6 = "src/components/Input.svelte";

// (78:0) {:else}
function create_else_block(ctx) {
	let input;
	let dispose;

	let input_levels = [
		{ min: /*min*/ ctx[6] },
		{ max: /*max*/ ctx[7] },
		{ name: /*name*/ ctx[1] },
		{ list: /*list*/ ctx[8] },
		{ form: /*form*/ ctx[9] },
		{ align: /*align*/ ctx[2] },
		{ readOnly: /*readonly*/ ctx[10] },
		{ disabled: /*disabled*/ ctx[5] },
		{ required: /*required*/ ctx[11] },
		{ maxlength: /*maxlength*/ ctx[3] },
		{ placeholder: /*placeholder*/ ctx[12] },
		{ id: /*idProp*/ ctx[15] },
		{ class: /*classProp*/ ctx[13] },
		{ title: /*titleProp*/ ctx[17] },
		{ style: /*styleProp*/ ctx[20] },
		{ pattern: /*patternProp*/ ctx[21] },
		{ "aria-label": /*ariaLabelProp*/ ctx[18] },
		{
			autocomplete: /*autocompleteProp*/ ctx[19]
		},
		{ type: /*typeProp*/ ctx[16] }
	];

	let input_data = {};

	for (let i = 0; i < input_levels.length; i += 1) {
		input_data = assign(input_data, input_levels[i]);
	}

	const block = {
		c: function create() {
			input = element("input");
			this.h();
		},
		l: function claim(nodes) {
			input = claim_element(nodes, "INPUT", {
				min: true,
				max: true,
				name: true,
				list: true,
				form: true,
				align: true,
				readonly: true,
				disabled: true,
				required: true,
				maxlength: true,
				placeholder: true,
				id: true,
				class: true,
				title: true,
				style: true,
				pattern: true,
				"aria-label": true,
				autocomplete: true
			});

			this.h();
		},
		h: function hydrate() {
			set_attributes(input, input_data);
			toggle_class(input, "svelte-1vg8tdg", true);
			add_location(input, file$6, 78, 4, 2783);

			dispose = [
				listen_dev(input, "input", /*input_input_handler*/ ctx[36]),
				listen_dev(input, "blur", /*blur_handler_1*/ ctx[37], false, false, false),
				listen_dev(input, "focus", /*focus_handler_1*/ ctx[38], false, false, false),
				listen_dev(input, "click", /*onClick*/ ctx[22], false, false, false)
			];
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			set_input_value(input, /*value*/ ctx[0]);
		},
		p: function update(ctx, dirty) {
			set_attributes(input, get_spread_update(input_levels, [
				dirty[0] & /*min*/ 64 && ({ min: /*min*/ ctx[6] }),
				dirty[0] & /*max*/ 128 && ({ max: /*max*/ ctx[7] }),
				dirty[0] & /*name*/ 2 && ({ name: /*name*/ ctx[1] }),
				dirty[0] & /*list*/ 256 && ({ list: /*list*/ ctx[8] }),
				dirty[0] & /*form*/ 512 && ({ form: /*form*/ ctx[9] }),
				dirty[0] & /*align*/ 4 && ({ align: /*align*/ ctx[2] }),
				dirty[0] & /*readonly*/ 1024 && ({ readOnly: /*readonly*/ ctx[10] }),
				dirty[0] & /*disabled*/ 32 && ({ disabled: /*disabled*/ ctx[5] }),
				dirty[0] & /*required*/ 2048 && ({ required: /*required*/ ctx[11] }),
				dirty[0] & /*maxlength*/ 8 && ({ maxlength: /*maxlength*/ ctx[3] }),
				dirty[0] & /*placeholder*/ 4096 && ({ placeholder: /*placeholder*/ ctx[12] }),
				dirty[0] & /*idProp*/ 32768 && ({ id: /*idProp*/ ctx[15] }),
				dirty[0] & /*classProp*/ 8192 && ({ class: /*classProp*/ ctx[13] }),
				dirty[0] & /*titleProp*/ 131072 && ({ title: /*titleProp*/ ctx[17] }),
				dirty[0] & /*styleProp*/ 1048576 && ({ style: /*styleProp*/ ctx[20] }),
				dirty[0] & /*patternProp*/ 2097152 && ({ pattern: /*patternProp*/ ctx[21] }),
				dirty[0] & /*ariaLabelProp*/ 262144 && ({ "aria-label": /*ariaLabelProp*/ ctx[18] }),
				dirty[0] & /*autocompleteProp*/ 524288 && ({
					autocomplete: /*autocompleteProp*/ ctx[19]
				}),
				dirty[0] & /*typeProp*/ 65536 && ({ type: /*typeProp*/ ctx[16] })
			]));

			if (dirty[0] & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
				set_input_value(input, /*value*/ ctx[0]);
			}

			toggle_class(input, "svelte-1vg8tdg", true);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(78:0) {:else}",
		ctx
	});

	return block;
}

// (52:0) {#if rows}
function create_if_block$1(ctx) {
	let textarea;
	let dispose;

	let textarea_levels = [
		{ min: /*min*/ ctx[6] },
		{ max: /*max*/ ctx[7] },
		{ rows: /*rows*/ ctx[4] },
		{ name: /*name*/ ctx[1] },
		{ form: /*form*/ ctx[9] },
		{ align: /*align*/ ctx[2] },
		{ readOnly: /*readonly*/ ctx[10] },
		{ disabled: /*disabled*/ ctx[5] },
		{ required: /*required*/ ctx[11] },
		{ maxlength: /*maxlength*/ ctx[3] },
		{ placeholder: /*placeholder*/ ctx[12] },
		{ id: /*idProp*/ ctx[15] },
		{ class: /*classProp*/ ctx[13] },
		{ title: /*titleProp*/ ctx[17] },
		{ style: /*styleProp*/ ctx[20] },
		{ pattern: /*patternProp*/ ctx[21] },
		{ "aria-label": /*ariaLabelProp*/ ctx[18] },
		{
			autocomplete: /*autocompleteProp*/ ctx[19]
		},
		{ type: /*typeProp*/ ctx[16] }
	];

	let textarea_data = {};

	for (let i = 0; i < textarea_levels.length; i += 1) {
		textarea_data = assign(textarea_data, textarea_levels[i]);
	}

	const block = {
		c: function create() {
			textarea = element("textarea");
			this.h();
		},
		l: function claim(nodes) {
			textarea = claim_element(nodes, "TEXTAREA", {
				min: true,
				max: true,
				rows: true,
				name: true,
				form: true,
				align: true,
				readonly: true,
				disabled: true,
				required: true,
				maxlength: true,
				placeholder: true,
				id: true,
				class: true,
				title: true,
				style: true,
				pattern: true,
				"aria-label": true,
				autocomplete: true
			});

			children(textarea).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_attributes(textarea, textarea_data);
			toggle_class(textarea, "svelte-1vg8tdg", true);
			add_location(textarea, file$6, 52, 4, 2063);

			dispose = [
				listen_dev(textarea, "input", /*textarea_input_handler*/ ctx[33]),
				listen_dev(textarea, "blur", /*blur_handler*/ ctx[34], false, false, false),
				listen_dev(textarea, "focus", /*focus_handler*/ ctx[35], false, false, false),
				listen_dev(textarea, "click", /*onClick*/ ctx[22], false, false, false)
			];
		},
		m: function mount(target, anchor) {
			insert_dev(target, textarea, anchor);
			set_input_value(textarea, /*value*/ ctx[0]);
		},
		p: function update(ctx, dirty) {
			set_attributes(textarea, get_spread_update(textarea_levels, [
				dirty[0] & /*min*/ 64 && ({ min: /*min*/ ctx[6] }),
				dirty[0] & /*max*/ 128 && ({ max: /*max*/ ctx[7] }),
				dirty[0] & /*rows*/ 16 && ({ rows: /*rows*/ ctx[4] }),
				dirty[0] & /*name*/ 2 && ({ name: /*name*/ ctx[1] }),
				dirty[0] & /*form*/ 512 && ({ form: /*form*/ ctx[9] }),
				dirty[0] & /*align*/ 4 && ({ align: /*align*/ ctx[2] }),
				dirty[0] & /*readonly*/ 1024 && ({ readOnly: /*readonly*/ ctx[10] }),
				dirty[0] & /*disabled*/ 32 && ({ disabled: /*disabled*/ ctx[5] }),
				dirty[0] & /*required*/ 2048 && ({ required: /*required*/ ctx[11] }),
				dirty[0] & /*maxlength*/ 8 && ({ maxlength: /*maxlength*/ ctx[3] }),
				dirty[0] & /*placeholder*/ 4096 && ({ placeholder: /*placeholder*/ ctx[12] }),
				dirty[0] & /*idProp*/ 32768 && ({ id: /*idProp*/ ctx[15] }),
				dirty[0] & /*classProp*/ 8192 && ({ class: /*classProp*/ ctx[13] }),
				dirty[0] & /*titleProp*/ 131072 && ({ title: /*titleProp*/ ctx[17] }),
				dirty[0] & /*styleProp*/ 1048576 && ({ style: /*styleProp*/ ctx[20] }),
				dirty[0] & /*patternProp*/ 2097152 && ({ pattern: /*patternProp*/ ctx[21] }),
				dirty[0] & /*ariaLabelProp*/ 262144 && ({ "aria-label": /*ariaLabelProp*/ ctx[18] }),
				dirty[0] & /*autocompleteProp*/ 524288 && ({
					autocomplete: /*autocompleteProp*/ ctx[19]
				}),
				dirty[0] & /*typeProp*/ 65536 && ({ type: /*typeProp*/ ctx[16] })
			]));

			if (dirty[0] & /*value*/ 1) {
				set_input_value(textarea, /*value*/ ctx[0]);
			}

			toggle_class(textarea, "svelte-1vg8tdg", true);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(textarea);
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(52:0) {#if rows}",
		ctx
	});

	return block;
}

function create_fragment$6(ctx) {
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (/*rows*/ ctx[4]) return create_if_block$1;
		return create_else_block;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$6.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$5($$self, $$props, $$invalidate) {
	const dispatch = createEventDispatcher();
	let { name } = $$props;
	let { value = "" } = $$props;
	let { style = {} } = $$props;
	let { type = "text" } = $$props;
	let { id = undefined } = $$props;
	let { align = undefined } = $$props;
	let { maxlength = 1000 } = $$props;
	let { rows = undefined } = $$props;
	let { disabled = false } = $$props;
	let { title = undefined } = $$props;
	let { invalid = undefined } = $$props;
	let { min = undefined } = $$props;
	let { max = undefined } = $$props;
	let { list = undefined } = $$props;
	let { form = undefined } = $$props;
	let { readonly = undefined } = $$props;
	let { required = undefined } = $$props;
	let { pattern = undefined } = $$props;
	let { autocomplete = true } = $$props;
	let { autoselect = false } = $$props;
	let { ariaLabel = undefined } = $$props;
	let { placeholder = undefined } = $$props;
	let idProp = id || name;
	let typeProp = type === "number" ? "text" : type;
	let titleProp = title || ariaLabel || placeholder;
	let ariaLabelProp = ariaLabel || title || placeholder;
	let autocompleteProp = autocomplete ? "on" : "off";
	let styleProp = toCSSString({ ...style, textAlign: align });
	let patternProp = type === "number" && !pattern ? "[0-9]*" : pattern;

	function onClick(e) {
		!disabled && dispatch("click", e);
		!disabled && autoselect && e.target.select();
	}

	function textarea_input_handler() {
		value = this.value;
		$$invalidate(0, value);
	}

	const blur_handler = e => !disabled && dispatch("blur", e);
	const focus_handler = e => !disabled && dispatch("focus", e);

	function input_input_handler() {
		value = this.value;
		$$invalidate(0, value);
	}

	const blur_handler_1 = e => !disabled && dispatch("blur", e);
	const focus_handler_1 = e => !disabled && dispatch("focus", e);

	$$self.$set = $$new_props => {
		$$invalidate(32, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("name" in $$new_props) $$invalidate(1, name = $$new_props.name);
		if ("value" in $$new_props) $$invalidate(0, value = $$new_props.value);
		if ("style" in $$new_props) $$invalidate(23, style = $$new_props.style);
		if ("type" in $$new_props) $$invalidate(24, type = $$new_props.type);
		if ("id" in $$new_props) $$invalidate(25, id = $$new_props.id);
		if ("align" in $$new_props) $$invalidate(2, align = $$new_props.align);
		if ("maxlength" in $$new_props) $$invalidate(3, maxlength = $$new_props.maxlength);
		if ("rows" in $$new_props) $$invalidate(4, rows = $$new_props.rows);
		if ("disabled" in $$new_props) $$invalidate(5, disabled = $$new_props.disabled);
		if ("title" in $$new_props) $$invalidate(26, title = $$new_props.title);
		if ("invalid" in $$new_props) $$invalidate(27, invalid = $$new_props.invalid);
		if ("min" in $$new_props) $$invalidate(6, min = $$new_props.min);
		if ("max" in $$new_props) $$invalidate(7, max = $$new_props.max);
		if ("list" in $$new_props) $$invalidate(8, list = $$new_props.list);
		if ("form" in $$new_props) $$invalidate(9, form = $$new_props.form);
		if ("readonly" in $$new_props) $$invalidate(10, readonly = $$new_props.readonly);
		if ("required" in $$new_props) $$invalidate(11, required = $$new_props.required);
		if ("pattern" in $$new_props) $$invalidate(28, pattern = $$new_props.pattern);
		if ("autocomplete" in $$new_props) $$invalidate(29, autocomplete = $$new_props.autocomplete);
		if ("autoselect" in $$new_props) $$invalidate(30, autoselect = $$new_props.autoselect);
		if ("ariaLabel" in $$new_props) $$invalidate(31, ariaLabel = $$new_props.ariaLabel);
		if ("placeholder" in $$new_props) $$invalidate(12, placeholder = $$new_props.placeholder);
	};

	$$self.$capture_state = () => {
		return {
			name,
			value,
			style,
			type,
			id,
			align,
			maxlength,
			rows,
			disabled,
			title,
			invalid,
			min,
			max,
			list,
			form,
			readonly,
			required,
			pattern,
			autocomplete,
			autoselect,
			ariaLabel,
			placeholder,
			idProp,
			typeProp,
			titleProp,
			ariaLabelProp,
			autocompleteProp,
			styleProp,
			patternProp,
			classProp
		};
	};

	$$self.$inject_state = $$new_props => {
		$$invalidate(32, $$props = assign(assign({}, $$props), $$new_props));
		if ("name" in $$props) $$invalidate(1, name = $$new_props.name);
		if ("value" in $$props) $$invalidate(0, value = $$new_props.value);
		if ("style" in $$props) $$invalidate(23, style = $$new_props.style);
		if ("type" in $$props) $$invalidate(24, type = $$new_props.type);
		if ("id" in $$props) $$invalidate(25, id = $$new_props.id);
		if ("align" in $$props) $$invalidate(2, align = $$new_props.align);
		if ("maxlength" in $$props) $$invalidate(3, maxlength = $$new_props.maxlength);
		if ("rows" in $$props) $$invalidate(4, rows = $$new_props.rows);
		if ("disabled" in $$props) $$invalidate(5, disabled = $$new_props.disabled);
		if ("title" in $$props) $$invalidate(26, title = $$new_props.title);
		if ("invalid" in $$props) $$invalidate(27, invalid = $$new_props.invalid);
		if ("min" in $$props) $$invalidate(6, min = $$new_props.min);
		if ("max" in $$props) $$invalidate(7, max = $$new_props.max);
		if ("list" in $$props) $$invalidate(8, list = $$new_props.list);
		if ("form" in $$props) $$invalidate(9, form = $$new_props.form);
		if ("readonly" in $$props) $$invalidate(10, readonly = $$new_props.readonly);
		if ("required" in $$props) $$invalidate(11, required = $$new_props.required);
		if ("pattern" in $$props) $$invalidate(28, pattern = $$new_props.pattern);
		if ("autocomplete" in $$props) $$invalidate(29, autocomplete = $$new_props.autocomplete);
		if ("autoselect" in $$props) $$invalidate(30, autoselect = $$new_props.autoselect);
		if ("ariaLabel" in $$props) $$invalidate(31, ariaLabel = $$new_props.ariaLabel);
		if ("placeholder" in $$props) $$invalidate(12, placeholder = $$new_props.placeholder);
		if ("idProp" in $$props) $$invalidate(15, idProp = $$new_props.idProp);
		if ("typeProp" in $$props) $$invalidate(16, typeProp = $$new_props.typeProp);
		if ("titleProp" in $$props) $$invalidate(17, titleProp = $$new_props.titleProp);
		if ("ariaLabelProp" in $$props) $$invalidate(18, ariaLabelProp = $$new_props.ariaLabelProp);
		if ("autocompleteProp" in $$props) $$invalidate(19, autocompleteProp = $$new_props.autocompleteProp);
		if ("styleProp" in $$props) $$invalidate(20, styleProp = $$new_props.styleProp);
		if ("patternProp" in $$props) $$invalidate(21, patternProp = $$new_props.patternProp);
		if ("classProp" in $$props) $$invalidate(13, classProp = $$new_props.classProp);
	};

	let classProp;

	$$self.$$.update = () => {
		 $$invalidate(13, classProp = classnames("inp", $$props.class, { disabled, readonly, required, invalid }));
	};

	$$props = exclude_internal_props($$props);

	return [
		value,
		name,
		align,
		maxlength,
		rows,
		disabled,
		min,
		max,
		list,
		form,
		readonly,
		required,
		placeholder,
		classProp,
		dispatch,
		idProp,
		typeProp,
		titleProp,
		ariaLabelProp,
		autocompleteProp,
		styleProp,
		patternProp,
		onClick,
		style,
		type,
		id,
		title,
		invalid,
		pattern,
		autocomplete,
		autoselect,
		ariaLabel,
		$$props,
		textarea_input_handler,
		blur_handler,
		focus_handler,
		input_input_handler,
		blur_handler_1,
		focus_handler_1
	];
}

class Input extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$5,
			create_fragment$6,
			safe_not_equal,
			{
				name: 1,
				value: 0,
				style: 23,
				type: 24,
				id: 25,
				align: 2,
				maxlength: 3,
				rows: 4,
				disabled: 5,
				title: 26,
				invalid: 27,
				min: 6,
				max: 7,
				list: 8,
				form: 9,
				readonly: 10,
				required: 11,
				pattern: 28,
				autocomplete: 29,
				autoselect: 30,
				ariaLabel: 31,
				placeholder: 12
			},
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Input",
			options,
			id: create_fragment$6.name
		});

		const { ctx } = this.$$;
		const props = options.props || ({});

		if (/*name*/ ctx[1] === undefined && !("name" in props)) {
			console.warn("<Input> was created without expected prop 'name'");
		}
	}

	get name() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set name(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get type() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set type(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get id() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get align() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set align(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get maxlength() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set maxlength(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get rows() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set rows(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get title() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get invalid() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set invalid(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get min() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set min(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get max() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set max(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get list() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set list(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get form() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set form(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get readonly() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set readonly(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get required() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set required(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get pattern() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set pattern(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get autocomplete() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set autocomplete(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get autoselect() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set autoselect(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ariaLabel() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ariaLabel(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get placeholder() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set placeholder(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/Picture.svelte generated by Svelte v3.16.7 */
const file$7 = "src/components/Picture.svelte";

function create_fragment$7(ctx) {
	let figure;
	let img;
	let img_src_value;
	let t;
	let figcaption;
	let figure_class_value;
	let current;
	let dispose;
	const default_slot_template = /*$$slots*/ ctx[13].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], null);

	const block = {
		c: function create() {
			figure = element("figure");
			img = element("img");
			t = space();
			figcaption = element("figcaption");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			figure = claim_element(nodes, "FIGURE", { class: true });
			var figure_nodes = children(figure);

			img = claim_element(figure_nodes, "IMG", {
				id: true,
				alt: true,
				src: true,
				width: true,
				height: true,
				class: true
			});

			t = claim_space(figure_nodes);
			figcaption = claim_element(figure_nodes, "FIGCAPTION", {});
			var figcaption_nodes = children(figcaption);
			if (default_slot) default_slot.l(figcaption_nodes);
			figcaption_nodes.forEach(detach_dev);
			figure_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(img, "id", /*id*/ ctx[2]);
			attr_dev(img, "alt", /*alt*/ ctx[1]);
			if (img.src !== (img_src_value = /*src*/ ctx[0])) attr_dev(img, "src", img_src_value);
			attr_dev(img, "width", /*width*/ ctx[3]);
			attr_dev(img, "height", /*height*/ ctx[4]);
			attr_dev(img, "class", "pic svelte-1rkw8xk");
			add_location(img, file$7, 30, 4, 654);
			add_location(figcaption, file$7, 41, 4, 849);
			attr_dev(figure, "class", figure_class_value = "" + (null_to_empty(/*wrapClassProp*/ ctx[5]) + " svelte-1rkw8xk"));
			add_location(figure, file$7, 29, 0, 619);

			dispose = [
				listen_dev(img, "load", /*onLoad*/ ctx[6], false, false, false),
				listen_dev(img, "error", /*onError*/ ctx[7], false, false, false)
			];
		},
		m: function mount(target, anchor) {
			insert_dev(target, figure, anchor);
			append_dev(figure, img);
			append_dev(figure, t);
			append_dev(figure, figcaption);

			if (default_slot) {
				default_slot.m(figcaption, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (!current || dirty & /*id*/ 4) {
				attr_dev(img, "id", /*id*/ ctx[2]);
			}

			if (!current || dirty & /*alt*/ 2) {
				attr_dev(img, "alt", /*alt*/ ctx[1]);
			}

			if (!current || dirty & /*src*/ 1 && img.src !== (img_src_value = /*src*/ ctx[0])) {
				attr_dev(img, "src", img_src_value);
			}

			if (!current || dirty & /*width*/ 8) {
				attr_dev(img, "width", /*width*/ ctx[3]);
			}

			if (!current || dirty & /*height*/ 16) {
				attr_dev(img, "height", /*height*/ ctx[4]);
			}

			if (default_slot && default_slot.p && dirty & /*$$scope*/ 4096) {
				default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[12], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[12], dirty, null));
			}

			if (!current || dirty & /*wrapClassProp*/ 32 && figure_class_value !== (figure_class_value = "" + (null_to_empty(/*wrapClassProp*/ ctx[5]) + " svelte-1rkw8xk"))) {
				attr_dev(figure, "class", figure_class_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(figure);
			if (default_slot) default_slot.d(detaching);
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$7.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$6($$self, $$props, $$invalidate) {
	const dispatch = createEventDispatcher();
	let { src } = $$props;
	let { alt } = $$props;
	let { id = undefined } = $$props;
	let { width = undefined } = $$props;
	let { height = undefined } = $$props;
	let loading = true;
	let isError = false;

	function onLoad(e) {
		$$invalidate(8, loading = false);
		dispatch("load", e);
	}

	function onError(e) {
		$$invalidate(8, loading = false);
		$$invalidate(9, isError = true);
		dispatch("error", e);
	}

	let { $$slots = {}, $$scope } = $$props;

	$$self.$set = $$new_props => {
		$$invalidate(11, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("src" in $$new_props) $$invalidate(0, src = $$new_props.src);
		if ("alt" in $$new_props) $$invalidate(1, alt = $$new_props.alt);
		if ("id" in $$new_props) $$invalidate(2, id = $$new_props.id);
		if ("width" in $$new_props) $$invalidate(3, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(4, height = $$new_props.height);
		if ("$$scope" in $$new_props) $$invalidate(12, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => {
		return {
			src,
			alt,
			id,
			width,
			height,
			loading,
			isError,
			wrapClassProp
		};
	};

	$$self.$inject_state = $$new_props => {
		$$invalidate(11, $$props = assign(assign({}, $$props), $$new_props));
		if ("src" in $$props) $$invalidate(0, src = $$new_props.src);
		if ("alt" in $$props) $$invalidate(1, alt = $$new_props.alt);
		if ("id" in $$props) $$invalidate(2, id = $$new_props.id);
		if ("width" in $$props) $$invalidate(3, width = $$new_props.width);
		if ("height" in $$props) $$invalidate(4, height = $$new_props.height);
		if ("loading" in $$props) $$invalidate(8, loading = $$new_props.loading);
		if ("isError" in $$props) $$invalidate(9, isError = $$new_props.isError);
		if ("wrapClassProp" in $$props) $$invalidate(5, wrapClassProp = $$new_props.wrapClassProp);
	};

	let wrapClassProp;

	$$self.$$.update = () => {
		 $$invalidate(5, wrapClassProp = classnames("picture", $$props.class, { loading, isError }));
	};

	$$props = exclude_internal_props($$props);

	return [
		src,
		alt,
		id,
		width,
		height,
		wrapClassProp,
		onLoad,
		onError,
		loading,
		isError,
		dispatch,
		$$props,
		$$scope,
		$$slots
	];
}

class Picture extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$6, create_fragment$7, safe_not_equal, {
			src: 0,
			alt: 1,
			id: 2,
			width: 3,
			height: 4
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Picture",
			options,
			id: create_fragment$7.name
		});

		const { ctx } = this.$$;
		const props = options.props || ({});

		if (/*src*/ ctx[0] === undefined && !("src" in props)) {
			console.warn("<Picture> was created without expected prop 'src'");
		}

		if (/*alt*/ ctx[1] === undefined && !("alt" in props)) {
			console.warn("<Picture> was created without expected prop 'alt'");
		}
	}

	get src() {
		throw new Error("<Picture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set src(value) {
		throw new Error("<Picture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get alt() {
		throw new Error("<Picture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set alt(value) {
		throw new Error("<Picture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get id() {
		throw new Error("<Picture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<Picture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<Picture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<Picture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get height() {
		throw new Error("<Picture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set height(value) {
		throw new Error("<Picture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/Avatar.svelte generated by Svelte v3.16.7 */
const file$8 = "src/components/Avatar.svelte";

function create_fragment$8(ctx) {
	let div;
	let div_class_value;
	let current;

	const picture = new Picture({
			props: { src: /*src*/ ctx[0], alt: /*alt*/ ctx[1] },
			$$inline: true
		});

	const block = {
		c: function create() {
			div = element("div");
			create_component(picture.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			claim_component(picture.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", div_class_value = "" + (null_to_empty(/*classProp*/ ctx[2]) + " svelte-ow3g6r"));
			add_location(div, file$8, 11, 0, 254);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(picture, div, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const picture_changes = {};
			if (dirty & /*src*/ 1) picture_changes.src = /*src*/ ctx[0];
			if (dirty & /*alt*/ 2) picture_changes.alt = /*alt*/ ctx[1];
			picture.$set(picture_changes);

			if (!current || dirty & /*classProp*/ 4 && div_class_value !== (div_class_value = "" + (null_to_empty(/*classProp*/ ctx[2]) + " svelte-ow3g6r"))) {
				attr_dev(div, "class", div_class_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(picture.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(picture.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(picture);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$8.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$7($$self, $$props, $$invalidate) {
	let { src } = $$props;
	let { alt } = $$props;
	let { size = "medium" } = $$props;

	$$self.$set = $$new_props => {
		$$invalidate(4, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("src" in $$new_props) $$invalidate(0, src = $$new_props.src);
		if ("alt" in $$new_props) $$invalidate(1, alt = $$new_props.alt);
		if ("size" in $$new_props) $$invalidate(3, size = $$new_props.size);
	};

	$$self.$capture_state = () => {
		return { src, alt, size, classProp };
	};

	$$self.$inject_state = $$new_props => {
		$$invalidate(4, $$props = assign(assign({}, $$props), $$new_props));
		if ("src" in $$props) $$invalidate(0, src = $$new_props.src);
		if ("alt" in $$props) $$invalidate(1, alt = $$new_props.alt);
		if ("size" in $$props) $$invalidate(3, size = $$new_props.size);
		if ("classProp" in $$props) $$invalidate(2, classProp = $$new_props.classProp);
	};

	let classProp;

	$$self.$$.update = () => {
		 $$invalidate(2, classProp = classnames("ava", size, $$props.class));
	};

	$$props = exclude_internal_props($$props);
	return [src, alt, classProp, size];
}

class Avatar extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$7, create_fragment$8, safe_not_equal, { src: 0, alt: 1, size: 3 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Avatar",
			options,
			id: create_fragment$8.name
		});

		const { ctx } = this.$$;
		const props = options.props || ({});

		if (/*src*/ ctx[0] === undefined && !("src" in props)) {
			console.warn("<Avatar> was created without expected prop 'src'");
		}

		if (/*alt*/ ctx[1] === undefined && !("alt" in props)) {
			console.warn("<Avatar> was created without expected prop 'alt'");
		}
	}

	get src() {
		throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set src(value) {
		throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get alt() {
		throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set alt(value) {
		throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/Button.svelte generated by Svelte v3.16.7 */
const file$9 = "src/components/Button.svelte";

// (53:0) {:else}
function create_else_block$1(ctx) {
	let button;
	let button_class_value;
	let current;
	let dispose;
	const default_slot_template = /*$$slots*/ ctx[17].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], null);

	const block = {
		c: function create() {
			button = element("button");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", {
				id: true,
				type: true,
				disabled: true,
				title: true,
				class: true,
				"aria-label": true
			});

			var button_nodes = children(button);
			if (default_slot) default_slot.l(button_nodes);
			button_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(button, "id", /*id*/ ctx[0]);
			attr_dev(button, "type", /*type*/ ctx[2]);
			button.disabled = /*disabled*/ ctx[4];
			attr_dev(button, "title", /*titleProp*/ ctx[7]);
			attr_dev(button, "class", button_class_value = "" + (null_to_empty(/*classProp*/ ctx[5]) + " svelte-1tdzxp7"));
			attr_dev(button, "aria-label", /*ariaLabelProp*/ ctx[8]);
			add_location(button, file$9, 53, 4, 1385);
			dispose = listen_dev(button, "click", /*click_handler_1*/ ctx[19], false, false, false);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);

			if (default_slot) {
				default_slot.m(button, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot && default_slot.p && dirty & /*$$scope*/ 65536) {
				default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[16], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[16], dirty, null));
			}

			if (!current || dirty & /*id*/ 1) {
				attr_dev(button, "id", /*id*/ ctx[0]);
			}

			if (!current || dirty & /*type*/ 4) {
				attr_dev(button, "type", /*type*/ ctx[2]);
			}

			if (!current || dirty & /*disabled*/ 16) {
				prop_dev(button, "disabled", /*disabled*/ ctx[4]);
			}

			if (!current || dirty & /*classProp*/ 32 && button_class_value !== (button_class_value = "" + (null_to_empty(/*classProp*/ ctx[5]) + " svelte-1tdzxp7"))) {
				attr_dev(button, "class", button_class_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (default_slot) default_slot.d(detaching);
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$1.name,
		type: "else",
		source: "(53:0) {:else}",
		ctx
	});

	return block;
}

// (41:18) 
function create_if_block_1(ctx) {
	let label;
	let label_class_value;
	let current;
	let dispose;
	const default_slot_template = /*$$slots*/ ctx[17].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], null);

	const block = {
		c: function create() {
			label = element("label");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			label = claim_element(nodes, "LABEL", {
				id: true,
				disabled: true,
				for: true,
				title: true,
				class: true,
				"aria-label": true
			});

			var label_nodes = children(label);
			if (default_slot) default_slot.l(label_nodes);
			label_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(label, "id", /*id*/ ctx[0]);
			attr_dev(label, "disabled", /*disabled*/ ctx[4]);
			attr_dev(label, "for", /*htmlFor*/ ctx[3]);
			attr_dev(label, "title", /*titleProp*/ ctx[7]);
			attr_dev(label, "class", label_class_value = "" + (null_to_empty(/*classProp*/ ctx[5]) + " svelte-1tdzxp7"));
			attr_dev(label, "aria-label", /*ariaLabelProp*/ ctx[8]);
			add_location(label, file$9, 41, 4, 1124);
			dispose = listen_dev(label, "click", /*onLabelClick*/ ctx[9], false, false, false);
		},
		m: function mount(target, anchor) {
			insert_dev(target, label, anchor);

			if (default_slot) {
				default_slot.m(label, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot && default_slot.p && dirty & /*$$scope*/ 65536) {
				default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[16], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[16], dirty, null));
			}

			if (!current || dirty & /*id*/ 1) {
				attr_dev(label, "id", /*id*/ ctx[0]);
			}

			if (!current || dirty & /*disabled*/ 16) {
				attr_dev(label, "disabled", /*disabled*/ ctx[4]);
			}

			if (!current || dirty & /*htmlFor*/ 8) {
				attr_dev(label, "for", /*htmlFor*/ ctx[3]);
			}

			if (!current || dirty & /*classProp*/ 32 && label_class_value !== (label_class_value = "" + (null_to_empty(/*classProp*/ ctx[5]) + " svelte-1tdzxp7"))) {
				attr_dev(label, "class", label_class_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(label);
			if (default_slot) default_slot.d(detaching);
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(41:18) ",
		ctx
	});

	return block;
}

// (30:0) {#if href}
function create_if_block$2(ctx) {
	let a;
	let a_class_value;
	let current;
	let dispose;
	const default_slot_template = /*$$slots*/ ctx[17].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], null);

	const block = {
		c: function create() {
			a = element("a");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			a = claim_element(nodes, "A", {
				id: true,
				href: true,
				title: true,
				class: true,
				"aria-label": true
			});

			var a_nodes = children(a);
			if (default_slot) default_slot.l(a_nodes);
			a_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a, "id", /*id*/ ctx[0]);
			attr_dev(a, "href", /*href*/ ctx[1]);
			attr_dev(a, "title", /*titleProp*/ ctx[7]);
			attr_dev(a, "class", a_class_value = "" + (null_to_empty(/*classProp*/ ctx[5]) + " svelte-1tdzxp7"));
			attr_dev(a, "aria-label", /*ariaLabelProp*/ ctx[8]);
			add_location(a, file$9, 30, 4, 862);
			dispose = listen_dev(a, "click", /*click_handler*/ ctx[18], false, false, false);
		},
		m: function mount(target, anchor) {
			insert_dev(target, a, anchor);

			if (default_slot) {
				default_slot.m(a, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot && default_slot.p && dirty & /*$$scope*/ 65536) {
				default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[16], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[16], dirty, null));
			}

			if (!current || dirty & /*id*/ 1) {
				attr_dev(a, "id", /*id*/ ctx[0]);
			}

			if (!current || dirty & /*href*/ 2) {
				attr_dev(a, "href", /*href*/ ctx[1]);
			}

			if (!current || dirty & /*classProp*/ 32 && a_class_value !== (a_class_value = "" + (null_to_empty(/*classProp*/ ctx[5]) + " svelte-1tdzxp7"))) {
				attr_dev(a, "class", a_class_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(a);
			if (default_slot) default_slot.d(detaching);
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$2.name,
		type: "if",
		source: "(30:0) {#if href}",
		ctx
	});

	return block;
}

function create_fragment$9(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$2, create_if_block_1, create_else_block$1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*href*/ ctx[1]) return 0;
		if (/*htmlFor*/ ctx[3]) return 1;
		return 2;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$9.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$8($$self, $$props, $$invalidate) {
	const dispatch = createEventDispatcher();
	let { is = undefined } = $$props;
	let { id = undefined } = $$props;
	let { href = undefined } = $$props;
	let { auto = false } = $$props;
	let { type = "button" } = $$props;
	let { size = "medium" } = $$props;
	let { title = undefined } = $$props;
	let { htmlFor = undefined } = $$props;
	let { disabled = false } = $$props;
	let { ariaLabel = undefined } = $$props;
	let titleProp = title || ariaLabel;
	let ariaLabelProp = ariaLabel || title;

	function onLabelClick(e) {
		document.getElementById(htmlFor).click();
		!disabled && dispatch("click", e);
	}

	let { $$slots = {}, $$scope } = $$props;
	const click_handler = e => !disabled && dispatch("click", e);
	const click_handler_1 = e => !disabled && dispatch("click", e);

	$$self.$set = $$new_props => {
		$$invalidate(15, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("is" in $$new_props) $$invalidate(10, is = $$new_props.is);
		if ("id" in $$new_props) $$invalidate(0, id = $$new_props.id);
		if ("href" in $$new_props) $$invalidate(1, href = $$new_props.href);
		if ("auto" in $$new_props) $$invalidate(11, auto = $$new_props.auto);
		if ("type" in $$new_props) $$invalidate(2, type = $$new_props.type);
		if ("size" in $$new_props) $$invalidate(12, size = $$new_props.size);
		if ("title" in $$new_props) $$invalidate(13, title = $$new_props.title);
		if ("htmlFor" in $$new_props) $$invalidate(3, htmlFor = $$new_props.htmlFor);
		if ("disabled" in $$new_props) $$invalidate(4, disabled = $$new_props.disabled);
		if ("ariaLabel" in $$new_props) $$invalidate(14, ariaLabel = $$new_props.ariaLabel);
		if ("$$scope" in $$new_props) $$invalidate(16, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => {
		return {
			is,
			id,
			href,
			auto,
			type,
			size,
			title,
			htmlFor,
			disabled,
			ariaLabel,
			titleProp,
			ariaLabelProp,
			classProp
		};
	};

	$$self.$inject_state = $$new_props => {
		$$invalidate(15, $$props = assign(assign({}, $$props), $$new_props));
		if ("is" in $$props) $$invalidate(10, is = $$new_props.is);
		if ("id" in $$props) $$invalidate(0, id = $$new_props.id);
		if ("href" in $$props) $$invalidate(1, href = $$new_props.href);
		if ("auto" in $$props) $$invalidate(11, auto = $$new_props.auto);
		if ("type" in $$props) $$invalidate(2, type = $$new_props.type);
		if ("size" in $$props) $$invalidate(12, size = $$new_props.size);
		if ("title" in $$props) $$invalidate(13, title = $$new_props.title);
		if ("htmlFor" in $$props) $$invalidate(3, htmlFor = $$new_props.htmlFor);
		if ("disabled" in $$props) $$invalidate(4, disabled = $$new_props.disabled);
		if ("ariaLabel" in $$props) $$invalidate(14, ariaLabel = $$new_props.ariaLabel);
		if ("titleProp" in $$props) $$invalidate(7, titleProp = $$new_props.titleProp);
		if ("ariaLabelProp" in $$props) $$invalidate(8, ariaLabelProp = $$new_props.ariaLabelProp);
		if ("classProp" in $$props) $$invalidate(5, classProp = $$new_props.classProp);
	};

	let classProp;

	$$self.$$.update = () => {
		 $$invalidate(5, classProp = classnames("btn", is, size, $$props.class, { auto, disabled }));
	};

	$$props = exclude_internal_props($$props);

	return [
		id,
		href,
		type,
		htmlFor,
		disabled,
		classProp,
		dispatch,
		titleProp,
		ariaLabelProp,
		onLabelClick,
		is,
		auto,
		size,
		title,
		ariaLabel,
		$$props,
		$$scope,
		$$slots,
		click_handler,
		click_handler_1
	];
}

class Button extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$8, create_fragment$9, safe_not_equal, {
			is: 10,
			id: 0,
			href: 1,
			auto: 11,
			type: 2,
			size: 12,
			title: 13,
			htmlFor: 3,
			disabled: 4,
			ariaLabel: 14
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Button",
			options,
			id: create_fragment$9.name
		});
	}

	get is() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set is(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get id() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get href() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set href(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get auto() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set auto(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get type() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set type(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get title() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get htmlFor() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set htmlFor(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ariaLabel() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ariaLabel(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/Divider.svelte generated by Svelte v3.16.7 */
const file$a = "src/components/Divider.svelte";

function create_fragment$a(ctx) {
	let hr;
	let hr_class_value;

	const block = {
		c: function create() {
			hr = element("hr");
			this.h();
		},
		l: function claim(nodes) {
			hr = claim_element(nodes, "HR", { class: true, style: true });
			this.h();
		},
		h: function hydrate() {
			attr_dev(hr, "class", hr_class_value = "" + (null_to_empty(/*classProp*/ ctx[0]) + " svelte-10708ut"));
			attr_dev(hr, "style", /*styleProp*/ ctx[1]);
			add_location(hr, file$a, 11, 0, 298);
		},
		m: function mount(target, anchor) {
			insert_dev(target, hr, anchor);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*classProp*/ 1 && hr_class_value !== (hr_class_value = "" + (null_to_empty(/*classProp*/ ctx[0]) + " svelte-10708ut"))) {
				attr_dev(hr, "class", hr_class_value);
			}

			if (dirty & /*styleProp*/ 2) {
				attr_dev(hr, "style", /*styleProp*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(hr);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$a.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$9($$self, $$props, $$invalidate) {
	let { is = "info" } = $$props;
	let { size = 0 } = $$props;
	let { width = 2 } = $$props;

	$$self.$set = $$new_props => {
		$$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("is" in $$new_props) $$invalidate(2, is = $$new_props.is);
		if ("size" in $$new_props) $$invalidate(3, size = $$new_props.size);
		if ("width" in $$new_props) $$invalidate(4, width = $$new_props.width);
	};

	$$self.$capture_state = () => {
		return { is, size, width, classProp, styleProp };
	};

	$$self.$inject_state = $$new_props => {
		$$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
		if ("is" in $$props) $$invalidate(2, is = $$new_props.is);
		if ("size" in $$props) $$invalidate(3, size = $$new_props.size);
		if ("width" in $$props) $$invalidate(4, width = $$new_props.width);
		if ("classProp" in $$props) $$invalidate(0, classProp = $$new_props.classProp);
		if ("styleProp" in $$props) $$invalidate(1, styleProp = $$new_props.styleProp);
	};

	let classProp;
	let styleProp;

	$$self.$$.update = () => {
		 $$invalidate(0, classProp = classnames("divider", is, $$props.class));

		if ($$self.$$.dirty & /*size, width*/ 24) {
			 $$invalidate(1, styleProp = toCSSString({
				padding: `${size / 2}px 0`,
				height: `${width}px`
			}));
		}
	};

	$$props = exclude_internal_props($$props);
	return [classProp, styleProp, is, size, width];
}

class Divider extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$9, create_fragment$a, safe_not_equal, { is: 2, size: 3, width: 4 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Divider",
			options,
			id: create_fragment$a.name
		});
	}

	get is() {
		throw new Error("<Divider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set is(value) {
		throw new Error("<Divider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<Divider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<Divider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<Divider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<Divider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/Progress.svelte generated by Svelte v3.16.7 */
const file$b = "src/components/Progress.svelte";

function create_fragment$b(ctx) {
	let div2;
	let div1;
	let div0;
	let div0_style_value;
	let div2_class_value;
	let div2_style_value;

	const block = {
		c: function create() {
			div2 = element("div");
			div1 = element("div");
			div0 = element("div");
			this.h();
		},
		l: function claim(nodes) {
			div2 = claim_element(nodes, "DIV", {
				id: true,
				class: true,
				title: true,
				"aria-label": true,
				role: true,
				"aria-valuemin": true,
				"aria-valuemax": true,
				"aria-valuenow": true,
				style: true
			});

			var div2_nodes = children(div2);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true, style: true });
			children(div0).forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "progress-core svelte-we6n45");
			attr_dev(div0, "style", div0_style_value = `width:${/*val*/ ctx[2]}%`);
			add_location(div0, file$b, 44, 8, 1381);
			attr_dev(div1, "class", "progress-inner-frame svelte-we6n45");
			add_location(div1, file$b, 43, 4, 1338);
			attr_dev(div2, "id", /*id*/ ctx[0]);
			attr_dev(div2, "class", div2_class_value = "" + (null_to_empty(/*classProp*/ ctx[5]) + " svelte-we6n45"));
			attr_dev(div2, "title", /*titleProp*/ ctx[3]);
			attr_dev(div2, "aria-label", /*ariaLabelProp*/ ctx[4]);
			attr_dev(div2, "role", "progressbar");
			attr_dev(div2, "aria-valuemin", "0");
			attr_dev(div2, "aria-valuemax", "100");
			attr_dev(div2, "aria-valuenow", /*val*/ ctx[2]);
			attr_dev(div2, "style", div2_style_value = `${getBorderRadius(/*borderRadius*/ ctx[1])}`);
			add_location(div2, file$b, 32, 0, 1067);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);
			append_dev(div2, div1);
			append_dev(div1, div0);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*val*/ 4 && div0_style_value !== (div0_style_value = `width:${/*val*/ ctx[2]}%`)) {
				attr_dev(div0, "style", div0_style_value);
			}

			if (dirty & /*id*/ 1) {
				attr_dev(div2, "id", /*id*/ ctx[0]);
			}

			if (dirty & /*classProp*/ 32 && div2_class_value !== (div2_class_value = "" + (null_to_empty(/*classProp*/ ctx[5]) + " svelte-we6n45"))) {
				attr_dev(div2, "class", div2_class_value);
			}

			if (dirty & /*titleProp*/ 8) {
				attr_dev(div2, "title", /*titleProp*/ ctx[3]);
			}

			if (dirty & /*ariaLabelProp*/ 16) {
				attr_dev(div2, "aria-label", /*ariaLabelProp*/ ctx[4]);
			}

			if (dirty & /*val*/ 4) {
				attr_dev(div2, "aria-valuenow", /*val*/ ctx[2]);
			}

			if (dirty & /*borderRadius*/ 2 && div2_style_value !== (div2_style_value = `${getBorderRadius(/*borderRadius*/ ctx[1])}`)) {
				attr_dev(div2, "style", div2_style_value);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div2);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$b.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function getBorderRadius(borders, defaults = "99999px") {
	const brDefault = new Array(4).fill(defaults);
	const bds = safeGet(() => borders.split(" "), [], true);
	const rule = "border-radius";
	return `${rule}:${brDefault.map((def, i) => `${bds[i] || def}`).join(" ")}`;
}

function instance$a($$self, $$props, $$invalidate) {
	const dispatch = createEventDispatcher();
	let { id = undefined } = $$props;
	let { value = 0 } = $$props;
	let { size = "medium" } = $$props;
	let { title = undefined } = $$props;
	let { ariaLabel = undefined } = $$props;
	let { borderRadius = undefined } = $$props;

	onMount(() => {
		setTimeout(
			() => $$invalidate(2, val = Number.isFinite(+value)
			? Math.max(0, Math.min(+value, 100))
			: 0),
			0
		);
	});

	$$self.$set = $$new_props => {
		$$invalidate(11, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("id" in $$new_props) $$invalidate(0, id = $$new_props.id);
		if ("value" in $$new_props) $$invalidate(6, value = $$new_props.value);
		if ("size" in $$new_props) $$invalidate(7, size = $$new_props.size);
		if ("title" in $$new_props) $$invalidate(8, title = $$new_props.title);
		if ("ariaLabel" in $$new_props) $$invalidate(9, ariaLabel = $$new_props.ariaLabel);
		if ("borderRadius" in $$new_props) $$invalidate(1, borderRadius = $$new_props.borderRadius);
	};

	$$self.$capture_state = () => {
		return {
			id,
			value,
			size,
			title,
			ariaLabel,
			borderRadius,
			val,
			titleProp,
			ariaLabelProp,
			classProp
		};
	};

	$$self.$inject_state = $$new_props => {
		$$invalidate(11, $$props = assign(assign({}, $$props), $$new_props));
		if ("id" in $$props) $$invalidate(0, id = $$new_props.id);
		if ("value" in $$props) $$invalidate(6, value = $$new_props.value);
		if ("size" in $$props) $$invalidate(7, size = $$new_props.size);
		if ("title" in $$props) $$invalidate(8, title = $$new_props.title);
		if ("ariaLabel" in $$props) $$invalidate(9, ariaLabel = $$new_props.ariaLabel);
		if ("borderRadius" in $$props) $$invalidate(1, borderRadius = $$new_props.borderRadius);
		if ("val" in $$props) $$invalidate(2, val = $$new_props.val);
		if ("titleProp" in $$props) $$invalidate(3, titleProp = $$new_props.titleProp);
		if ("ariaLabelProp" in $$props) $$invalidate(4, ariaLabelProp = $$new_props.ariaLabelProp);
		if ("classProp" in $$props) $$invalidate(5, classProp = $$new_props.classProp);
	};

	let val;
	let titleProp;
	let ariaLabelProp;
	let classProp;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*title, val*/ 260) {
			 $$invalidate(3, titleProp = title || `Progress - ${val}%`);
		}

		if ($$self.$$.dirty & /*ariaLabel, val*/ 516) {
			 $$invalidate(4, ariaLabelProp = ariaLabel || `Progress - ${val}%`);
		}

		 $$invalidate(5, classProp = classnames("progress", size, $$props.class));
	};

	 $$invalidate(2, val = 0);
	$$props = exclude_internal_props($$props);

	return [
		id,
		borderRadius,
		val,
		titleProp,
		ariaLabelProp,
		classProp,
		value,
		size,
		title,
		ariaLabel
	];
}

class Progress extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$a, create_fragment$b, safe_not_equal, {
			id: 0,
			value: 6,
			size: 7,
			title: 8,
			ariaLabel: 9,
			borderRadius: 1
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Progress",
			options,
			id: create_fragment$b.name
		});
	}

	get id() {
		throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get title() {
		throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ariaLabel() {
		throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ariaLabel(value) {
		throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get borderRadius() {
		throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set borderRadius(value) {
		throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/layouts/Carousel.svelte generated by Svelte v3.16.7 */
const file$c = "src/layouts/Carousel.svelte";

function get_each_context$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[4] = list[i];
	return child_ctx;
}

// (61:12) <SwipeItem>
function create_default_slot_1(ctx) {
	let t;
	let current;

	const picture = new Picture({
			props: {
				src: /*img*/ ctx[4].src,
				alt: /*img*/ ctx[4].alt
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(picture.$$.fragment);
			t = space();
		},
		l: function claim(nodes) {
			claim_component(picture.$$.fragment, nodes);
			t = claim_space(nodes);
		},
		m: function mount(target, anchor) {
			mount_component(picture, target, anchor);
			insert_dev(target, t, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const picture_changes = {};
			if (dirty & /*imagesArr*/ 1) picture_changes.src = /*img*/ ctx[4].src;
			if (dirty & /*imagesArr*/ 1) picture_changes.alt = /*img*/ ctx[4].alt;
			picture.$set(picture_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(picture.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(picture.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(picture, detaching);
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1.name,
		type: "slot",
		source: "(61:12) <SwipeItem>",
		ctx
	});

	return block;
}

// (60:8) {#each imagesArr as img}
function create_each_block$2(ctx) {
	let current;

	const swipeitem = new SwipeItem({
			props: {
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(swipeitem.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(swipeitem.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(swipeitem, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const swipeitem_changes = {};

			if (dirty & /*$$scope, imagesArr*/ 129) {
				swipeitem_changes.$$scope = { dirty, ctx };
			}

			swipeitem.$set(swipeitem_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(swipeitem.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(swipeitem.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(swipeitem, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$2.name,
		type: "each",
		source: "(60:8) {#each imagesArr as img}",
		ctx
	});

	return block;
}

// (59:4) <Swipe>
function create_default_slot(ctx) {
	let each_1_anchor;
	let current;
	let each_value = /*imagesArr*/ ctx[0];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty & /*imagesArr*/ 1) {
				each_value = /*imagesArr*/ ctx[0];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$2(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$2(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(59:4) <Swipe>",
		ctx
	});

	return block;
}

function create_fragment$c(ctx) {
	let section;
	let current;

	const swipe = new Swipe({
			props: {
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			section = element("section");
			create_component(swipe.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { class: true });
			var section_nodes = children(section);
			claim_component(swipe.$$.fragment, section_nodes);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(section, "class", "svelte-f86mtu");
			add_location(section, file$c, 57, 0, 1875);
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			mount_component(swipe, section, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const swipe_changes = {};

			if (dirty & /*$$scope, imagesArr*/ 129) {
				swipe_changes.$$scope = { dirty, ctx };
			}

			swipe.$set(swipe_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(swipe.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(swipe.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			destroy_component(swipe);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$c.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$b($$self, $$props, $$invalidate) {
	const cards = [
		{
			src: "https://placeimg.com/300/300/tech",
			title: "The main title and short description.",
			percent: 45,
			orgHead: "Tina Kandelaki",
			orgHeadSrc: "https://placeimg.com/300/300/people",
			organization: "ORG charity of Charitify."
		},
		{
			src: "https://placeimg.com/300/300/arch",
			title: "Second bigger major card title line with a bit longer description.",
			percent: 65,
			orgHead: "Tina Kandelaki",
			orgHeadSrc: "https://placeimg.com/300/300/people",
			organization: "ORG charity of Charitify."
		},
		{
			src: "https://placeimg.com/300/300/any",
			title: "The main title and short description.",
			percent: 5,
			orgHead: "Tinaramisimuss Kandelakinuskas",
			orgHeadSrc: "https://placeimg.com/300/300/people",
			organization: "ORG charity of Charitify."
		},
		{
			src: "https://placeimg.com/300/300/nature",
			title: "The main title and short description.",
			percent: 95,
			orgHead: "Tina Kandelaki",
			orgHeadSrc: "https://placeimg.com/300/300/people",
			organization: "ORG giant charity organization of big Charitify company."
		}
	];

	const imagesDefault = cards.map(card => ({
		src: [card.src, card.src, card.src],
		alt: card.title
	}));

	let { images = imagesDefault } = $$props;
	const writable_props = ["images"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Carousel> was created with unknown prop '${key}'`);
	});

	$$self.$set = $$props => {
		if ("images" in $$props) $$invalidate(1, images = $$props.images);
	};

	$$self.$capture_state = () => {
		return { images, imagesArr };
	};

	$$self.$inject_state = $$props => {
		if ("images" in $$props) $$invalidate(1, images = $$props.images);
		if ("imagesArr" in $$props) $$invalidate(0, imagesArr = $$props.imagesArr);
	};

	let imagesArr;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*images*/ 2) {
			 $$invalidate(0, imagesArr = [].concat(images).map(img => typeof img === "string" ? { src: img } : img));
		}
	};

	return [imagesArr, images];
}

class Carousel extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$b, create_fragment$c, safe_not_equal, { images: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Carousel",
			options,
			id: create_fragment$c.name
		});
	}

	get images() {
		throw new Error("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set images(value) {
		throw new Error("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/layouts/AvatarAndName.svelte generated by Svelte v3.16.7 */
const file$d = "src/layouts/AvatarAndName.svelte";

function create_fragment$d(ctx) {
	let section;
	let t0;
	let span;
	let h4;
	let t1;
	let t2;
	let p;
	let t3;
	let current;

	const avatar = new Avatar({
			props: {
				src: /*src*/ ctx[0],
				alt: /*title*/ ctx[1]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			section = element("section");
			create_component(avatar.$$.fragment);
			t0 = space();
			span = element("span");
			h4 = element("h4");
			t1 = text(/*title*/ ctx[1]);
			t2 = space();
			p = element("p");
			t3 = text(/*subtitle*/ ctx[2]);
			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { class: true });
			var section_nodes = children(section);
			claim_component(avatar.$$.fragment, section_nodes);
			t0 = claim_space(section_nodes);
			span = claim_element(section_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			h4 = claim_element(span_nodes, "H4", { class: true });
			var h4_nodes = children(h4);
			t1 = claim_text(h4_nodes, /*title*/ ctx[1]);
			h4_nodes.forEach(detach_dev);
			t2 = claim_space(span_nodes);
			p = claim_element(span_nodes, "P", { class: true });
			var p_nodes = children(p);
			t3 = claim_text(p_nodes, /*subtitle*/ ctx[2]);
			p_nodes.forEach(detach_dev);
			span_nodes.forEach(detach_dev);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(h4, "class", "svelte-15elxnh");
			add_location(h4, file$d, 12, 8, 230);
			attr_dev(p, "class", "svelte-15elxnh");
			add_location(p, file$d, 13, 8, 255);
			attr_dev(span, "class", "svelte-15elxnh");
			add_location(span, file$d, 11, 4, 215);
			attr_dev(section, "class", "svelte-15elxnh");
			add_location(section, file$d, 8, 0, 164);
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			mount_component(avatar, section, null);
			append_dev(section, t0);
			append_dev(section, span);
			append_dev(span, h4);
			append_dev(h4, t1);
			append_dev(span, t2);
			append_dev(span, p);
			append_dev(p, t3);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const avatar_changes = {};
			if (dirty & /*src*/ 1) avatar_changes.src = /*src*/ ctx[0];
			if (dirty & /*title*/ 2) avatar_changes.alt = /*title*/ ctx[1];
			avatar.$set(avatar_changes);
			if (!current || dirty & /*title*/ 2) set_data_dev(t1, /*title*/ ctx[1]);
			if (!current || dirty & /*subtitle*/ 4) set_data_dev(t3, /*subtitle*/ ctx[2]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(avatar.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(avatar.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			destroy_component(avatar);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$d.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$c($$self, $$props, $$invalidate) {
	let { src = undefined } = $$props;
	let { title = undefined } = $$props;
	let { subtitle = undefined } = $$props;
	const writable_props = ["src", "title", "subtitle"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AvatarAndName> was created with unknown prop '${key}'`);
	});

	$$self.$set = $$props => {
		if ("src" in $$props) $$invalidate(0, src = $$props.src);
		if ("title" in $$props) $$invalidate(1, title = $$props.title);
		if ("subtitle" in $$props) $$invalidate(2, subtitle = $$props.subtitle);
	};

	$$self.$capture_state = () => {
		return { src, title, subtitle };
	};

	$$self.$inject_state = $$props => {
		if ("src" in $$props) $$invalidate(0, src = $$props.src);
		if ("title" in $$props) $$invalidate(1, title = $$props.title);
		if ("subtitle" in $$props) $$invalidate(2, subtitle = $$props.subtitle);
	};

	return [src, title, subtitle];
}

class AvatarAndName extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$c, create_fragment$d, safe_not_equal, { src: 0, title: 1, subtitle: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "AvatarAndName",
			options,
			id: create_fragment$d.name
		});
	}

	get src() {
		throw new Error("<AvatarAndName>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set src(value) {
		throw new Error("<AvatarAndName>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get title() {
		throw new Error("<AvatarAndName>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<AvatarAndName>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get subtitle() {
		throw new Error("<AvatarAndName>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set subtitle(value) {
		throw new Error("<AvatarAndName>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/layouts/CharityCard.svelte generated by Svelte v3.16.7 */
const file$e = "src/layouts/CharityCard.svelte";

function create_fragment$e(ctx) {
	let section;
	let div0;
	let t0;
	let t1;
	let h4;
	let t2;
	let t3;
	let div1;
	let t4;
	let footer;
	let current;

	const carousel = new Carousel({
			props: { images: /*src*/ ctx[0] },
			$$inline: true
		});

	const progress = new Progress({
			props: {
				value: /*percent*/ ctx[2],
				borderRadius: "0 0"
			},
			$$inline: true
		});

	const rate = new Rate({ props: { size: "small" }, $$inline: true });

	const avatarandname = new AvatarAndName({
			props: {
				src: /*orgHeadSrc*/ ctx[4],
				title: /*orgHead*/ ctx[3],
				subtitle: /*organization*/ ctx[5]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			section = element("section");
			div0 = element("div");
			create_component(carousel.$$.fragment);
			t0 = space();
			create_component(progress.$$.fragment);
			t1 = space();
			h4 = element("h4");
			t2 = text(/*title*/ ctx[1]);
			t3 = space();
			div1 = element("div");
			create_component(rate.$$.fragment);
			t4 = space();
			footer = element("footer");
			create_component(avatarandname.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { class: true });
			var section_nodes = children(section);
			div0 = claim_element(section_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			claim_component(carousel.$$.fragment, div0_nodes);
			div0_nodes.forEach(detach_dev);
			t0 = claim_space(section_nodes);
			claim_component(progress.$$.fragment, section_nodes);
			t1 = claim_space(section_nodes);
			h4 = claim_element(section_nodes, "H4", { class: true });
			var h4_nodes = children(h4);
			t2 = claim_text(h4_nodes, /*title*/ ctx[1]);
			h4_nodes.forEach(detach_dev);
			t3 = claim_space(section_nodes);
			div1 = claim_element(section_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			claim_component(rate.$$.fragment, div1_nodes);
			div1_nodes.forEach(detach_dev);
			t4 = claim_space(section_nodes);
			footer = claim_element(section_nodes, "FOOTER", {});
			var footer_nodes = children(footer);
			claim_component(avatarandname.$$.fragment, footer_nodes);
			footer_nodes.forEach(detach_dev);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "images-wrap svelte-do16pj");
			add_location(div0, file$e, 14, 4, 419);
			attr_dev(h4, "class", "svelte-do16pj");
			add_location(h4, file$e, 20, 4, 546);
			attr_dev(div1, "class", "rate-wrap svelte-do16pj");
			add_location(div1, file$e, 22, 4, 568);
			add_location(footer, file$e, 26, 4, 637);
			attr_dev(section, "class", "card svelte-do16pj");
			add_location(section, file$e, 13, 0, 392);
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			append_dev(section, div0);
			mount_component(carousel, div0, null);
			append_dev(section, t0);
			mount_component(progress, section, null);
			append_dev(section, t1);
			append_dev(section, h4);
			append_dev(h4, t2);
			append_dev(section, t3);
			append_dev(section, div1);
			mount_component(rate, div1, null);
			append_dev(section, t4);
			append_dev(section, footer);
			mount_component(avatarandname, footer, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const carousel_changes = {};
			if (dirty & /*src*/ 1) carousel_changes.images = /*src*/ ctx[0];
			carousel.$set(carousel_changes);
			const progress_changes = {};
			if (dirty & /*percent*/ 4) progress_changes.value = /*percent*/ ctx[2];
			progress.$set(progress_changes);
			if (!current || dirty & /*title*/ 2) set_data_dev(t2, /*title*/ ctx[1]);
			const avatarandname_changes = {};
			if (dirty & /*orgHeadSrc*/ 16) avatarandname_changes.src = /*orgHeadSrc*/ ctx[4];
			if (dirty & /*orgHead*/ 8) avatarandname_changes.title = /*orgHead*/ ctx[3];
			if (dirty & /*organization*/ 32) avatarandname_changes.subtitle = /*organization*/ ctx[5];
			avatarandname.$set(avatarandname_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(carousel.$$.fragment, local);
			transition_in(progress.$$.fragment, local);
			transition_in(rate.$$.fragment, local);
			transition_in(avatarandname.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(carousel.$$.fragment, local);
			transition_out(progress.$$.fragment, local);
			transition_out(rate.$$.fragment, local);
			transition_out(avatarandname.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			destroy_component(carousel);
			destroy_component(progress);
			destroy_component(rate);
			destroy_component(avatarandname);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$e.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$d($$self, $$props, $$invalidate) {
	let { src = undefined } = $$props;
	let { title = undefined } = $$props;
	let { percent = undefined } = $$props;
	let { orgHead = undefined } = $$props;
	let { orgHeadSrc = undefined } = $$props;
	let { organization = undefined } = $$props;
	const writable_props = ["src", "title", "percent", "orgHead", "orgHeadSrc", "organization"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<CharityCard> was created with unknown prop '${key}'`);
	});

	$$self.$set = $$props => {
		if ("src" in $$props) $$invalidate(0, src = $$props.src);
		if ("title" in $$props) $$invalidate(1, title = $$props.title);
		if ("percent" in $$props) $$invalidate(2, percent = $$props.percent);
		if ("orgHead" in $$props) $$invalidate(3, orgHead = $$props.orgHead);
		if ("orgHeadSrc" in $$props) $$invalidate(4, orgHeadSrc = $$props.orgHeadSrc);
		if ("organization" in $$props) $$invalidate(5, organization = $$props.organization);
	};

	$$self.$capture_state = () => {
		return {
			src,
			title,
			percent,
			orgHead,
			orgHeadSrc,
			organization
		};
	};

	$$self.$inject_state = $$props => {
		if ("src" in $$props) $$invalidate(0, src = $$props.src);
		if ("title" in $$props) $$invalidate(1, title = $$props.title);
		if ("percent" in $$props) $$invalidate(2, percent = $$props.percent);
		if ("orgHead" in $$props) $$invalidate(3, orgHead = $$props.orgHead);
		if ("orgHeadSrc" in $$props) $$invalidate(4, orgHeadSrc = $$props.orgHeadSrc);
		if ("organization" in $$props) $$invalidate(5, organization = $$props.organization);
	};

	return [src, title, percent, orgHead, orgHeadSrc, organization];
}

class CharityCard extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$d, create_fragment$e, safe_not_equal, {
			src: 0,
			title: 1,
			percent: 2,
			orgHead: 3,
			orgHeadSrc: 4,
			organization: 5
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "CharityCard",
			options,
			id: create_fragment$e.name
		});
	}

	get src() {
		throw new Error("<CharityCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set src(value) {
		throw new Error("<CharityCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get title() {
		throw new Error("<CharityCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<CharityCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get percent() {
		throw new Error("<CharityCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set percent(value) {
		throw new Error("<CharityCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get orgHead() {
		throw new Error("<CharityCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set orgHead(value) {
		throw new Error("<CharityCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get orgHeadSrc() {
		throw new Error("<CharityCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set orgHeadSrc(value) {
		throw new Error("<CharityCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get organization() {
		throw new Error("<CharityCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set organization(value) {
		throw new Error("<CharityCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/layouts/CharityCards.svelte generated by Svelte v3.16.7 */
const file$f = "src/layouts/CharityCards.svelte";

function get_each_context$3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[3] = list[i];
	return child_ctx;
}

// (53:4) {#each cards as card}
function create_each_block$3(ctx) {
	let li;
	let t;
	let current;
	const charitycard_spread_levels = [/*card*/ ctx[3]];
	let charitycard_props = {};

	for (let i = 0; i < charitycard_spread_levels.length; i += 1) {
		charitycard_props = assign(charitycard_props, charitycard_spread_levels[i]);
	}

	const charitycard = new CharityCard({ props: charitycard_props, $$inline: true });

	const block = {
		c: function create() {
			li = element("li");
			create_component(charitycard.$$.fragment);
			t = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true });
			var li_nodes = children(li);
			claim_component(charitycard.$$.fragment, li_nodes);
			t = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(li, "class", "svelte-1k1p6bw");
			add_location(li, file$f, 53, 8, 1833);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			mount_component(charitycard, li, null);
			append_dev(li, t);
			current = true;
		},
		p: function update(ctx, dirty) {
			const charitycard_changes = (dirty & /*cards*/ 1)
			? get_spread_update(charitycard_spread_levels, [get_spread_object(/*card*/ ctx[3])])
			: {};

			charitycard.$set(charitycard_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(charitycard.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(charitycard.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			destroy_component(charitycard);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$3.name,
		type: "each",
		source: "(53:4) {#each cards as card}",
		ctx
	});

	return block;
}

function create_fragment$f(ctx) {
	let t0;
	let h2;
	let t1;
	let t2;
	let t3;
	let br;
	let t4;
	let ul;
	let current;
	const divider0 = new Divider({ props: { size: "16" }, $$inline: true });
	const divider1 = new Divider({ props: { size: "20" }, $$inline: true });
	let each_value = /*cards*/ ctx[0];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			create_component(divider0.$$.fragment);
			t0 = space();
			h2 = element("h2");
			t1 = text("The second list:");
			t2 = space();
			create_component(divider1.$$.fragment);
			t3 = space();
			br = element("br");
			t4 = space();
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			claim_component(divider0.$$.fragment, nodes);
			t0 = claim_space(nodes);
			h2 = claim_element(nodes, "H2", { style: true });
			var h2_nodes = children(h2);
			t1 = claim_text(h2_nodes, "The second list:");
			h2_nodes.forEach(detach_dev);
			t2 = claim_space(nodes);
			claim_component(divider1.$$.fragment, nodes);
			t3 = claim_space(nodes);
			br = claim_element(nodes, "BR", {});
			t4 = claim_space(nodes);
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(ul_nodes);
			}

			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_style(h2, "text-align", "right");
			add_location(h2, file$f, 48, 0, 1702);
			add_location(br, file$f, 50, 0, 1775);
			attr_dev(ul, "class", "cards svelte-1k1p6bw");
			add_location(ul, file$f, 51, 0, 1780);
		},
		m: function mount(target, anchor) {
			mount_component(divider0, target, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, h2, anchor);
			append_dev(h2, t1);
			insert_dev(target, t2, anchor);
			mount_component(divider1, target, anchor);
			insert_dev(target, t3, anchor);
			insert_dev(target, br, anchor);
			insert_dev(target, t4, anchor);
			insert_dev(target, ul, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*cards*/ 1) {
				each_value = /*cards*/ ctx[0];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$3(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$3(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(ul, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(divider0.$$.fragment, local);
			transition_in(divider1.$$.fragment, local);

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			transition_out(divider0.$$.fragment, local);
			transition_out(divider1.$$.fragment, local);
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(divider0, detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(h2);
			if (detaching) detach_dev(t2);
			destroy_component(divider1, detaching);
			if (detaching) detach_dev(t3);
			if (detaching) detach_dev(br);
			if (detaching) detach_dev(t4);
			if (detaching) detach_dev(ul);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$f.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$e($$self, $$props, $$invalidate) {
	let { amount = 2 } = $$props;
	const writable_props = ["amount"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<CharityCards> was created with unknown prop '${key}'`);
	});

	$$self.$set = $$props => {
		if ("amount" in $$props) $$invalidate(1, amount = $$props.amount);
	};

	$$self.$capture_state = () => {
		return { amount, cards, images };
	};

	$$self.$inject_state = $$props => {
		if ("amount" in $$props) $$invalidate(1, amount = $$props.amount);
		if ("cards" in $$props) $$invalidate(0, cards = $$props.cards);
		if ("images" in $$props) images = $$props.images;
	};

	let cards;
	let images;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*amount*/ 2) {
			 $$invalidate(0, cards = [
				{
					src: "https://placeimg.com/300/300/tech",
					title: "The main title and short description.",
					percent: 45,
					orgHead: "Tina Kandelaki",
					orgHeadSrc: "https://placeimg.com/300/300/people",
					organization: "ORG charity of Charitify."
				},
				{
					src: "https://placeimg.com/300/300/arch",
					title: "Second bigger major card title line with a bit longer description.",
					percent: 65,
					orgHead: "Tina Kandelaki",
					orgHeadSrc: "https://placeimg.com/300/300/people",
					organization: "ORG charity of Charitify."
				},
				{
					src: "https://placeimg.com/300/300/any",
					title: "The main title and short description.",
					percent: 5,
					orgHead: "Tinaramisimuss Kandelakinuskas",
					orgHeadSrc: "https://placeimg.com/300/300/people",
					organization: "ORG charity of Charitify."
				},
				{
					src: "https://placeimg.com/300/300/nature",
					title: "The main title and short description.",
					percent: 95,
					orgHead: "Tina Kandelaki",
					orgHeadSrc: "https://placeimg.com/300/300/people",
					organization: "ORG giant charity organization of big Charitify company."
				}
			].slice(Number.isFinite(+amount) ? +amount : 0));
		}

		if ($$self.$$.dirty & /*cards*/ 1) {
			 images = cards.map(card => ({
				src: [card.src, card.src, card.src],
				alt: card.title
			}));
		}
	};

	return [cards, amount];
}

class CharityCards extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$e, create_fragment$f, safe_not_equal, { amount: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "CharityCards",
			options,
			id: create_fragment$f.name
		});
	}

	get amount() {
		throw new Error("<CharityCards>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set amount(value) {
		throw new Error("<CharityCards>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/layouts/NavigationBar.svelte generated by Svelte v3.16.7 */
const file$g = "src/layouts/NavigationBar.svelte";

// (36:12) <Button on:click={changeTheme} auto size="small">
function create_default_slot_1$1(ctx) {
	let current;

	const icon = new Icon({
			props: { type: "moon", class: "theme-svg-fill" },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(icon.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$1.name,
		type: "slot",
		source: "(36:12) <Button on:click={changeTheme} auto size=\\\"small\\\">",
		ctx
	});

	return block;
}

// (42:12) <Button on:click={changeTheme} auto size="small">
function create_default_slot$1(ctx) {
	let current;

	const avatar = new Avatar({
			props: {
				size: "small",
				src: "https://placeimg.com/300/300/people"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(avatar.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(avatar.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(avatar, target, anchor);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(avatar.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(avatar.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(avatar, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$1.name,
		type: "slot",
		source: "(42:12) <Button on:click={changeTheme} auto size=\\\"small\\\">",
		ctx
	});

	return block;
}

function create_fragment$g(ctx) {
	let nav;
	let ul0;
	let li0;
	let a0;
	let t0;
	let t1;
	let li1;
	let a1;
	let t2;
	let t3;
	let li2;
	let a2;
	let t4;
	let t5;
	let li3;
	let a3;
	let t6;
	let t7;
	let ul1;
	let li4;
	let select;
	let option0;
	let t8;
	let option1;
	let t9;
	let option2;
	let t10;
	let select_value_value;
	let t11;
	let li5;
	let t12;
	let li6;
	let current;

	const button0 = new Button({
			props: {
				auto: true,
				size: "small",
				$$slots: { default: [create_default_slot_1$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button0.$on("click", /*changeTheme*/ ctx[2]);

	const button1 = new Button({
			props: {
				auto: true,
				size: "small",
				$$slots: { default: [create_default_slot$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button1.$on("click", /*changeTheme*/ ctx[2]);

	const block = {
		c: function create() {
			nav = element("nav");
			ul0 = element("ul");
			li0 = element("li");
			a0 = element("a");
			t0 = text("home");
			t1 = space();
			li1 = element("li");
			a1 = element("a");
			t2 = text("list");
			t3 = space();
			li2 = element("li");
			a2 = element("a");
			t4 = text("charity");
			t5 = space();
			li3 = element("li");
			a3 = element("a");
			t6 = text("about");
			t7 = space();
			ul1 = element("ul");
			li4 = element("li");
			select = element("select");
			option0 = element("option");
			t8 = text("Ua");
			option1 = element("option");
			t9 = text("Ru");
			option2 = element("option");
			t10 = text("En");
			t11 = space();
			li5 = element("li");
			create_component(button0.$$.fragment);
			t12 = space();
			li6 = element("li");
			create_component(button1.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			nav = claim_element(nodes, "NAV", { class: true });
			var nav_nodes = children(nav);
			ul0 = claim_element(nav_nodes, "UL", {});
			var ul0_nodes = children(ul0);
			li0 = claim_element(ul0_nodes, "LI", {});
			var li0_nodes = children(li0);
			a0 = claim_element(li0_nodes, "A", { href: true, class: true });
			var a0_nodes = children(a0);
			t0 = claim_text(a0_nodes, "home");
			a0_nodes.forEach(detach_dev);
			li0_nodes.forEach(detach_dev);
			t1 = claim_space(ul0_nodes);
			li1 = claim_element(ul0_nodes, "LI", {});
			var li1_nodes = children(li1);
			a1 = claim_element(li1_nodes, "A", { href: true, class: true });
			var a1_nodes = children(a1);
			t2 = claim_text(a1_nodes, "list");
			a1_nodes.forEach(detach_dev);
			li1_nodes.forEach(detach_dev);
			t3 = claim_space(ul0_nodes);
			li2 = claim_element(ul0_nodes, "LI", {});
			var li2_nodes = children(li2);
			a2 = claim_element(li2_nodes, "A", { rel: true, href: true, class: true });
			var a2_nodes = children(a2);
			t4 = claim_text(a2_nodes, "charity");
			a2_nodes.forEach(detach_dev);
			li2_nodes.forEach(detach_dev);
			t5 = claim_space(ul0_nodes);
			li3 = claim_element(ul0_nodes, "LI", {});
			var li3_nodes = children(li3);
			a3 = claim_element(li3_nodes, "A", { href: true, class: true });
			var a3_nodes = children(a3);
			t6 = claim_text(a3_nodes, "about");
			a3_nodes.forEach(detach_dev);
			li3_nodes.forEach(detach_dev);
			ul0_nodes.forEach(detach_dev);
			t7 = claim_space(nav_nodes);
			ul1 = claim_element(nav_nodes, "UL", { class: true });
			var ul1_nodes = children(ul1);
			li4 = claim_element(ul1_nodes, "LI", { class: true });
			var li4_nodes = children(li4);

			select = claim_element(li4_nodes, "SELECT", {
				value: true,
				name: true,
				id: true,
				class: true
			});

			var select_nodes = children(select);
			option0 = claim_element(select_nodes, "OPTION", { value: true });
			var option0_nodes = children(option0);
			t8 = claim_text(option0_nodes, "Ua");
			option0_nodes.forEach(detach_dev);
			option1 = claim_element(select_nodes, "OPTION", { value: true });
			var option1_nodes = children(option1);
			t9 = claim_text(option1_nodes, "Ru");
			option1_nodes.forEach(detach_dev);
			option2 = claim_element(select_nodes, "OPTION", { value: true });
			var option2_nodes = children(option2);
			t10 = claim_text(option2_nodes, "En");
			option2_nodes.forEach(detach_dev);
			select_nodes.forEach(detach_dev);
			li4_nodes.forEach(detach_dev);
			t11 = claim_space(ul1_nodes);
			li5 = claim_element(ul1_nodes, "LI", { class: true });
			var li5_nodes = children(li5);
			claim_component(button0.$$.fragment, li5_nodes);
			li5_nodes.forEach(detach_dev);
			t12 = claim_space(ul1_nodes);
			li6 = claim_element(ul1_nodes, "LI", { class: true });
			var li6_nodes = children(li6);
			claim_component(button1.$$.fragment, li6_nodes);
			li6_nodes.forEach(detach_dev);
			ul1_nodes.forEach(detach_dev);
			nav_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a0, "href", ".");
			attr_dev(a0, "class", "svelte-iotsi1");
			toggle_class(a0, "selected", /*segment*/ ctx[0] === undefined);
			add_location(a0, file$g, 19, 12, 464);
			add_location(li0, file$g, 19, 8, 460);
			attr_dev(a1, "href", "list");
			attr_dev(a1, "class", "svelte-iotsi1");
			toggle_class(a1, "selected", /*segment*/ ctx[0] === "list");
			add_location(a1, file$g, 20, 12, 543);
			add_location(li1, file$g, 20, 8, 539);
			attr_dev(a2, "rel", "prefetch");
			attr_dev(a2, "href", "charity");
			attr_dev(a2, "class", "svelte-iotsi1");
			toggle_class(a2, "selected", /*segment*/ ctx[0] === "charity");
			add_location(a2, file$g, 21, 12, 622);
			add_location(li2, file$g, 21, 8, 618);
			attr_dev(a3, "href", "about");
			attr_dev(a3, "class", "svelte-iotsi1");
			toggle_class(a3, "selected", /*segment*/ ctx[0] === "about");
			add_location(a3, file$g, 22, 12, 723);
			add_location(li3, file$g, 22, 8, 719);
			add_location(ul0, file$g, 18, 4, 447);
			option0.__value = "ua";
			option0.value = option0.__value;
			add_location(option0, file$g, 28, 16, 943);
			option1.__value = "ru";
			option1.value = option1.__value;
			add_location(option1, file$g, 29, 16, 990);
			option2.__value = "en";
			option2.value = option2.__value;
			add_location(option2, file$g, 30, 16, 1037);
			attr_dev(select, "name", "lang");
			attr_dev(select, "id", "lang");
			attr_dev(select, "class", "btn small lang-select svelte-iotsi1");
			add_location(select, file$g, 27, 12, 858);
			attr_dev(li4, "class", "svelte-iotsi1");
			add_location(li4, file$g, 26, 8, 841);
			attr_dev(li5, "class", "svelte-iotsi1");
			add_location(li5, file$g, 34, 8, 1113);
			attr_dev(li6, "class", "svelte-iotsi1");
			add_location(li6, file$g, 40, 8, 1284);
			attr_dev(ul1, "class", "nav-actions svelte-iotsi1");
			add_location(ul1, file$g, 25, 4, 808);
			attr_dev(nav, "class", "theme-bg container svelte-iotsi1");
			add_location(nav, file$g, 17, 0, 410);
		},
		m: function mount(target, anchor) {
			insert_dev(target, nav, anchor);
			append_dev(nav, ul0);
			append_dev(ul0, li0);
			append_dev(li0, a0);
			append_dev(a0, t0);
			append_dev(ul0, t1);
			append_dev(ul0, li1);
			append_dev(li1, a1);
			append_dev(a1, t2);
			append_dev(ul0, t3);
			append_dev(ul0, li2);
			append_dev(li2, a2);
			append_dev(a2, t4);
			append_dev(ul0, t5);
			append_dev(ul0, li3);
			append_dev(li3, a3);
			append_dev(a3, t6);
			append_dev(nav, t7);
			append_dev(nav, ul1);
			append_dev(ul1, li4);
			append_dev(li4, select);
			append_dev(select, option0);
			append_dev(option0, t8);
			append_dev(select, option1);
			append_dev(option1, t9);
			append_dev(select, option2);
			append_dev(option2, t10);
			select_value_value = /*value*/ ctx[1];

			for (var i = 0; i < select.options.length; i += 1) {
				var option = select.options[i];

				if (option.__value === select_value_value) {
					option.selected = true;
					break;
				}
			}

			append_dev(ul1, t11);
			append_dev(ul1, li5);
			mount_component(button0, li5, null);
			append_dev(ul1, t12);
			append_dev(ul1, li6);
			mount_component(button1, li6, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*segment, undefined*/ 1) {
				toggle_class(a0, "selected", /*segment*/ ctx[0] === undefined);
			}

			if (dirty & /*segment*/ 1) {
				toggle_class(a1, "selected", /*segment*/ ctx[0] === "list");
			}

			if (dirty & /*segment*/ 1) {
				toggle_class(a2, "selected", /*segment*/ ctx[0] === "charity");
			}

			if (dirty & /*segment*/ 1) {
				toggle_class(a3, "selected", /*segment*/ ctx[0] === "about");
			}

			const button0_changes = {};

			if (dirty & /*$$scope*/ 16) {
				button0_changes.$$scope = { dirty, ctx };
			}

			button0.$set(button0_changes);
			const button1_changes = {};

			if (dirty & /*$$scope*/ 16) {
				button1_changes.$$scope = { dirty, ctx };
			}

			button1.$set(button1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(nav);
			destroy_component(button0);
			destroy_component(button1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$g.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$f($$self, $$props, $$invalidate) {
	let { segment } = $$props;
	let isDarkTheme = false;
	let value = "ua";

	function changeTheme() {
		isDarkTheme = !isDarkTheme;
		document.body.classList.remove("theme-dark");
		document.body.classList.remove("theme-light");
		document.body.classList.add(isDarkTheme ? "theme-dark" : "theme-light");
	}

	const writable_props = ["segment"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<NavigationBar> was created with unknown prop '${key}'`);
	});

	$$self.$set = $$props => {
		if ("segment" in $$props) $$invalidate(0, segment = $$props.segment);
	};

	$$self.$capture_state = () => {
		return { segment, isDarkTheme, value };
	};

	$$self.$inject_state = $$props => {
		if ("segment" in $$props) $$invalidate(0, segment = $$props.segment);
		if ("isDarkTheme" in $$props) isDarkTheme = $$props.isDarkTheme;
		if ("value" in $$props) $$invalidate(1, value = $$props.value);
	};

	return [segment, value, changeTheme];
}

class NavigationBar extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$f, create_fragment$g, safe_not_equal, { segment: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "NavigationBar",
			options,
			id: create_fragment$g.name
		});

		const { ctx } = this.$$;
		const props = options.props || ({});

		if (/*segment*/ ctx[0] === undefined && !("segment" in props)) {
			console.warn("<NavigationBar> was created without expected prop 'segment'");
		}
	}

	get segment() {
		throw new Error("<NavigationBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set segment(value) {
		throw new Error("<NavigationBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/layouts/TitleSubTitle.svelte generated by Svelte v3.16.7 */

const file$h = "src/layouts/TitleSubTitle.svelte";

function create_fragment$h(ctx) {
	let section;
	let h1;
	let t0;
	let t1;
	let br;
	let t2;
	let p;
	let t3;

	const block = {
		c: function create() {
			section = element("section");
			h1 = element("h1");
			t0 = text("The main title that explains everything.");
			t1 = space();
			br = element("br");
			t2 = space();
			p = element("p");
			t3 = text("A small description that describes the title above and just makes text longer.");
			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { class: true });
			var section_nodes = children(section);
			h1 = claim_element(section_nodes, "H1", {});
			var h1_nodes = children(h1);
			t0 = claim_text(h1_nodes, "The main title that explains everything.");
			h1_nodes.forEach(detach_dev);
			t1 = claim_space(section_nodes);
			br = claim_element(section_nodes, "BR", {});
			t2 = claim_space(section_nodes);
			p = claim_element(section_nodes, "P", {});
			var p_nodes = children(p);
			t3 = claim_text(p_nodes, "A small description that describes the title above and just makes text longer.");
			p_nodes.forEach(detach_dev);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(h1, file$h, 5, 4, 35);
			add_location(br, file$h, 6, 4, 89);
			add_location(p, file$h, 7, 4, 98);
			attr_dev(section, "class", "svelte-1qydgyt");
			add_location(section, file$h, 4, 0, 21);
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			append_dev(section, h1);
			append_dev(h1, t0);
			append_dev(section, t1);
			append_dev(section, br);
			append_dev(section, t2);
			append_dev(section, p);
			append_dev(p, t3);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$h.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

class TitleSubTitle extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, null, create_fragment$h, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "TitleSubTitle",
			options,
			id: create_fragment$h.name
		});
	}
}

/* src/layouts/DonatingGroup.svelte generated by Svelte v3.16.7 */
const file$i = "src/layouts/DonatingGroup.svelte";

// (7:8) <Button is="success" on:click="{e => console.log(e)}">
function create_default_slot_3(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("test1");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "test1");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3.name,
		type: "slot",
		source: "(7:8) <Button is=\\\"success\\\" on:click=\\\"{e => console.log(e)}\\\">",
		ctx
	});

	return block;
}

// (10:8) <Button is="success" on:click="{e => console.log(e)}">
function create_default_slot_2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("test12");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "test12");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2.name,
		type: "slot",
		source: "(10:8) <Button is=\\\"success\\\" on:click=\\\"{e => console.log(e)}\\\">",
		ctx
	});

	return block;
}

// (13:8) <Button is="success" on:click="{e => console.log(e)}">
function create_default_slot_1$2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("test123");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "test123");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$2.name,
		type: "slot",
		source: "(13:8) <Button is=\\\"success\\\" on:click=\\\"{e => console.log(e)}\\\">",
		ctx
	});

	return block;
}

// (33:8) <Button is="warning" on:click="{e => console.log(e)}">
function create_default_slot$2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Submit");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Submit");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$2.name,
		type: "slot",
		source: "(33:8) <Button is=\\\"warning\\\" on:click=\\\"{e => console.log(e)}\\\">",
		ctx
	});

	return block;
}

function create_fragment$i(ctx) {
	let ul;
	let li0;
	let t0;
	let li1;
	let t1;
	let li2;
	let t2;
	let li3;
	let br;
	let t3;
	let t4;
	let datalist;
	let option0;
	let option1;
	let option2;
	let t5;
	let li4;
	let current;

	const button0 = new Button({
			props: {
				is: "success",
				$$slots: { default: [create_default_slot_3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button0.$on("click", /*click_handler*/ ctx[0]);

	const button1 = new Button({
			props: {
				is: "success",
				$$slots: { default: [create_default_slot_2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button1.$on("click", /*click_handler_1*/ ctx[1]);

	const button2 = new Button({
			props: {
				is: "success",
				$$slots: { default: [create_default_slot_1$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button2.$on("click", /*click_handler_2*/ ctx[2]);

	const input = new Input({
			props: {
				type: "number",
				name: "num",
				list: "sum-suggestions",
				placeholder: "Num",
				autoselect: true,
				align: "right"
			},
			$$inline: true
		});

	const button3 = new Button({
			props: {
				is: "warning",
				$$slots: { default: [create_default_slot$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button3.$on("click", /*click_handler_3*/ ctx[3]);

	const block = {
		c: function create() {
			ul = element("ul");
			li0 = element("li");
			create_component(button0.$$.fragment);
			t0 = space();
			li1 = element("li");
			create_component(button1.$$.fragment);
			t1 = space();
			li2 = element("li");
			create_component(button2.$$.fragment);
			t2 = space();
			li3 = element("li");
			br = element("br");
			t3 = space();
			create_component(input.$$.fragment);
			t4 = space();
			datalist = element("datalist");
			option0 = element("option");
			option1 = element("option");
			option2 = element("option");
			t5 = space();
			li4 = element("li");
			create_component(button3.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);
			li0 = claim_element(ul_nodes, "LI", { class: true });
			var li0_nodes = children(li0);
			claim_component(button0.$$.fragment, li0_nodes);
			li0_nodes.forEach(detach_dev);
			t0 = claim_space(ul_nodes);
			li1 = claim_element(ul_nodes, "LI", { class: true });
			var li1_nodes = children(li1);
			claim_component(button1.$$.fragment, li1_nodes);
			li1_nodes.forEach(detach_dev);
			t1 = claim_space(ul_nodes);
			li2 = claim_element(ul_nodes, "LI", { class: true });
			var li2_nodes = children(li2);
			claim_component(button2.$$.fragment, li2_nodes);
			li2_nodes.forEach(detach_dev);
			t2 = claim_space(ul_nodes);
			li3 = claim_element(ul_nodes, "LI", { class: true });
			var li3_nodes = children(li3);
			br = claim_element(li3_nodes, "BR", {});
			t3 = claim_space(li3_nodes);
			claim_component(input.$$.fragment, li3_nodes);
			t4 = claim_space(li3_nodes);
			datalist = claim_element(li3_nodes, "DATALIST", { id: true });
			var datalist_nodes = children(datalist);
			option0 = claim_element(datalist_nodes, "OPTION", { value: true });
			var option0_nodes = children(option0);
			option0_nodes.forEach(detach_dev);
			option1 = claim_element(datalist_nodes, "OPTION", { value: true });
			var option1_nodes = children(option1);
			option1_nodes.forEach(detach_dev);
			option2 = claim_element(datalist_nodes, "OPTION", { value: true });
			var option2_nodes = children(option2);
			option2_nodes.forEach(detach_dev);
			datalist_nodes.forEach(detach_dev);
			li3_nodes.forEach(detach_dev);
			t5 = claim_space(ul_nodes);
			li4 = claim_element(ul_nodes, "LI", { class: true });
			var li4_nodes = children(li4);
			claim_component(button3.$$.fragment, li4_nodes);
			li4_nodes.forEach(detach_dev);
			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(li0, "class", "svelte-1k5eog2");
			add_location(li0, file$i, 5, 4, 79);
			attr_dev(li1, "class", "svelte-1k5eog2");
			add_location(li1, file$i, 8, 4, 175);
			attr_dev(li2, "class", "svelte-1k5eog2");
			add_location(li2, file$i, 11, 4, 272);
			add_location(br, file$i, 15, 8, 383);
			option0.__value = "20";
			option0.value = option0.__value;
			add_location(option0, file$i, 26, 12, 654);
			option1.__value = "500";
			option1.value = option1.__value;
			add_location(option1, file$i, 27, 12, 686);
			option2.__value = "1000";
			option2.value = option2.__value;
			add_location(option2, file$i, 28, 12, 719);
			attr_dev(datalist, "id", "sum-suggestions");
			add_location(datalist, file$i, 25, 8, 610);
			attr_dev(li3, "class", "svelte-1k5eog2");
			add_location(li3, file$i, 14, 4, 370);
			attr_dev(li4, "class", "svelte-1k5eog2");
			add_location(li4, file$i, 31, 4, 775);
			attr_dev(ul, "class", "svelte-1k5eog2");
			add_location(ul, file$i, 4, 0, 70);
		},
		m: function mount(target, anchor) {
			insert_dev(target, ul, anchor);
			append_dev(ul, li0);
			mount_component(button0, li0, null);
			append_dev(ul, t0);
			append_dev(ul, li1);
			mount_component(button1, li1, null);
			append_dev(ul, t1);
			append_dev(ul, li2);
			mount_component(button2, li2, null);
			append_dev(ul, t2);
			append_dev(ul, li3);
			append_dev(li3, br);
			append_dev(li3, t3);
			mount_component(input, li3, null);
			append_dev(li3, t4);
			append_dev(li3, datalist);
			append_dev(datalist, option0);
			append_dev(datalist, option1);
			append_dev(datalist, option2);
			append_dev(ul, t5);
			append_dev(ul, li4);
			mount_component(button3, li4, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const button0_changes = {};

			if (dirty & /*$$scope*/ 16) {
				button0_changes.$$scope = { dirty, ctx };
			}

			button0.$set(button0_changes);
			const button1_changes = {};

			if (dirty & /*$$scope*/ 16) {
				button1_changes.$$scope = { dirty, ctx };
			}

			button1.$set(button1_changes);
			const button2_changes = {};

			if (dirty & /*$$scope*/ 16) {
				button2_changes.$$scope = { dirty, ctx };
			}

			button2.$set(button2_changes);
			const button3_changes = {};

			if (dirty & /*$$scope*/ 16) {
				button3_changes.$$scope = { dirty, ctx };
			}

			button3.$set(button3_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			transition_in(button2.$$.fragment, local);
			transition_in(input.$$.fragment, local);
			transition_in(button3.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			transition_out(button2.$$.fragment, local);
			transition_out(input.$$.fragment, local);
			transition_out(button3.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(ul);
			destroy_component(button0);
			destroy_component(button1);
			destroy_component(button2);
			destroy_component(input);
			destroy_component(button3);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$i.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$g($$self) {
	const click_handler = e => console.log(e);
	const click_handler_1 = e => console.log(e);
	const click_handler_2 = e => console.log(e);
	const click_handler_3 = e => console.log(e);

	$$self.$capture_state = () => {
		return {};
	};

	$$self.$inject_state = $$props => {
		
	};

	return [click_handler, click_handler_1, click_handler_2, click_handler_3];
}

class DonatingGroup extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$g, create_fragment$i, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "DonatingGroup",
			options,
			id: create_fragment$i.name
		});
	}
}

/* src/layouts/ContentHolder.svelte generated by Svelte v3.16.7 */

const file$j = "src/layouts/ContentHolder.svelte";

function create_fragment$j(ctx) {
	let h1;
	let t0;
	let t1;
	let br0;
	let t2;
	let br1;
	let t3;
	let p0;
	let t4;
	let t5;
	let br2;
	let t6;
	let p1;
	let t7;

	const block = {
		c: function create() {
			h1 = element("h1");
			t0 = text("About this project");
			t1 = space();
			br0 = element("br");
			t2 = space();
			br1 = element("br");
			t3 = space();
			p0 = element("p");
			t4 = text("This is the 'about' page. There's not much here. This is the 'about' page. There's not much here.");
			t5 = space();
			br2 = element("br");
			t6 = space();
			p1 = element("p");
			t7 = text("This is the 'about' page. There's not much here. This is the 'about' page. There's not much here.");
			this.h();
		},
		l: function claim(nodes) {
			h1 = claim_element(nodes, "H1", { class: true });
			var h1_nodes = children(h1);
			t0 = claim_text(h1_nodes, "About this project");
			h1_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			br0 = claim_element(nodes, "BR", {});
			t2 = claim_space(nodes);
			br1 = claim_element(nodes, "BR", {});
			t3 = claim_space(nodes);
			p0 = claim_element(nodes, "P", {});
			var p0_nodes = children(p0);
			t4 = claim_text(p0_nodes, "This is the 'about' page. There's not much here. This is the 'about' page. There's not much here.");
			p0_nodes.forEach(detach_dev);
			t5 = claim_space(nodes);
			br2 = claim_element(nodes, "BR", {});
			t6 = claim_space(nodes);
			p1 = claim_element(nodes, "P", {});
			var p1_nodes = children(p1);
			t7 = claim_text(p1_nodes, "This is the 'about' page. There's not much here. This is the 'about' page. There's not much here.");
			p1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(h1, "class", "text-center");
			add_location(h1, file$j, 4, 0, 21);
			add_location(br0, file$j, 5, 0, 69);
			add_location(br1, file$j, 6, 0, 74);
			add_location(p0, file$j, 7, 0, 79);
			add_location(br2, file$j, 8, 0, 184);
			add_location(p1, file$j, 9, 0, 189);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h1, anchor);
			append_dev(h1, t0);
			insert_dev(target, t1, anchor);
			insert_dev(target, br0, anchor);
			insert_dev(target, t2, anchor);
			insert_dev(target, br1, anchor);
			insert_dev(target, t3, anchor);
			insert_dev(target, p0, anchor);
			append_dev(p0, t4);
			insert_dev(target, t5, anchor);
			insert_dev(target, br2, anchor);
			insert_dev(target, t6, anchor);
			insert_dev(target, p1, anchor);
			append_dev(p1, t7);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(h1);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(br0);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(br1);
			if (detaching) detach_dev(t3);
			if (detaching) detach_dev(p0);
			if (detaching) detach_dev(t5);
			if (detaching) detach_dev(br2);
			if (detaching) detach_dev(t6);
			if (detaching) detach_dev(p1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$j.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

class ContentHolder extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, null, create_fragment$j, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ContentHolder",
			options,
			id: create_fragment$j.name
		});
	}
}

export { AvatarAndName as A, Br as B, Carousel as C, DonatingGroup as D, Footer as F, NavigationBar as N, Progress as P, Rate as R, TitleSubTitle as T, CharityCards as a, ContentHolder as b };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguZTJmNjU0NTUuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9sYXlvdXRzL0Zvb3Rlci5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvcGx1Z2lucy9Td2lwZS9Td2lwZS5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvcGx1Z2lucy9Td2lwZS9Td2lwZUl0ZW0uc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvQnIuc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NsYXNzbmFtZXMvaW5kZXguanMiLCIuLi8uLi8uLi9zcmMvdXRpbHMuanMiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9JY29uLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL1JhdGUuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvSW5wdXQuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvUGljdHVyZS5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9BdmF0YXIuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvQnV0dG9uLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL0RpdmlkZXIuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvUHJvZ3Jlc3Muc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2xheW91dHMvQ2Fyb3VzZWwuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2xheW91dHMvQXZhdGFyQW5kTmFtZS5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvbGF5b3V0cy9DaGFyaXR5Q2FyZC5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvbGF5b3V0cy9DaGFyaXR5Q2FyZHMuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2xheW91dHMvTmF2aWdhdGlvbkJhci5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvbGF5b3V0cy9Eb25hdGluZ0dyb3VwLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0PlxuXG48L3NjcmlwdD5cblxuPGZvb3Rlcj5cbiAgICA8cD7CqSAyMDE5IC0ge25ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKX08L3A+XG48L2Zvb3Rlcj5cblxuPHN0eWxlPlxuICAgIGZvb3RlciB7XG4gICAgICAgIHBhZGRpbmc6IGNhbGModmFyKC0tc2NyZWVuLXBhZGRpbmcpICogMikgdmFyKC0tc2NyZWVuLXBhZGRpbmcpO1xuICAgICAgICBib3gtc2hhZG93OiBpbnNldCB2YXIoLS1zaGFkb3ctcHJpbWFyeSk7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEodmFyKC0tdGhlbWUtYmctY29sb3IpKTtcbiAgICB9XG48L3N0eWxlPlxuIiwiPHNjcmlwdD5cblxuICAgIGltcG9ydCB7IG9uTW91bnQsIG9uRGVzdHJveSB9IGZyb20gJ3N2ZWx0ZSc7XG5cblxuICAgIGV4cG9ydCBsZXQgdHJhbnNpdGlvbkR1cmF0aW9uID0gMjAwO1xuICAgIGV4cG9ydCBsZXQgc2hvd0luZGljYXRvcnMgPSBmYWxzZTtcbiAgICBleHBvcnQgbGV0IGF1dG9wbGF5ID0gZmFsc2U7XG4gICAgZXhwb3J0IGxldCBkZWxheSA9IDEwMDA7XG5cblxuXG4gICAgbGV0IGFjdGl2ZUluZGljYXRvciA9IDA7XG4gICAgbGV0IGluZGljYXRvcnM7XG4gICAgbGV0IGl0ZW1zID0gMDtcbiAgICBsZXQgYXZhaWxhYmxlV2lkdGggPSAwO1xuICAgIGxldCB0b3BDbGVhcmVuY2UgPSAwO1xuXG4gICAgbGV0IGVsZW1zO1xuICAgIGxldCBkaWZmID0gMDtcblxuICAgIGxldCBzd2lwZVdyYXBwZXI7XG4gICAgbGV0IHN3aXBlSGFuZGxlcjtcblxuICAgIGxldCBtaW4gPSAwO1xuICAgIGxldCB0b3VjaGluZ1RwbCA9IGBcbiAgICAtd2Via2l0LXRyYW5zaXRpb24tZHVyYXRpb246IDBzO1xuICAgIHRyYW5zaXRpb24tZHVyYXRpb246IDBzO1xuICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgte3t2YWx9fXB4LCAwLCAwKTtcbiAgICAtbXMtdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgte3t2YWx9fXB4LCAwLCAwKTtgO1xuICAgIGxldCBub25fdG91Y2hpbmdUcGwgPSBgXG4gICAgLXdlYmtpdC10cmFuc2l0aW9uLWR1cmF0aW9uOiAke3RyYW5zaXRpb25EdXJhdGlvbn1tcztcbiAgICB0cmFuc2l0aW9uLWR1cmF0aW9uOiAke3RyYW5zaXRpb25EdXJhdGlvbn1tcztcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlM2QoLXt7dmFsfX1weCwgMCwgMCk7XG4gICAgLW1zLXRyYW5zZm9ybTogdHJhbnNsYXRlM2QoLXt7dmFsfX1weCwgMCwgMCk7YDtcbiAgICBsZXQgdG91Y2hpbmcgPSBmYWxzZTtcbiAgICBsZXQgcG9zWCA9IDA7XG4gICAgbGV0IGRpciA9IDA7XG4gICAgbGV0IHg7XG5cblxuXG4gICAgbGV0IHBsYXllZCA9IDA7XG4gICAgbGV0IHJ1bl9pbnRlcnZhbCA9IGZhbHNlO1xuXG4gICAgJDogaW5kaWNhdG9ycyA9IEFycmF5KGl0ZW1zKTtcblxuICAgICQ6IHtcbiAgICAgICAgaWYoYXV0b3BsYXkgJiYgIXJ1bl9pbnRlcnZhbCl7XG4gICAgICAgICAgICBydW5faW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChjaGFuZ2VWaWV3ICwgZGVsYXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIWF1dG9wbGF5ICYmIHJ1bl9pbnRlcnZhbCl7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHJ1bl9pbnRlcnZhbClcbiAgICAgICAgICAgIHJ1bl9pbnRlcnZhbCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiB1cGRhdGUoKXtcbiAgICAgICAgc3dpcGVIYW5kbGVyLnN0eWxlLnRvcCA9IHRvcENsZWFyZW5jZSArICdweCc7XG4gICAgICAgIGF2YWlsYWJsZVdpZHRoID0gc3dpcGVXcmFwcGVyLnF1ZXJ5U2VsZWN0b3IoJy5zd2lwZWFibGUtaXRlbXMnKS5vZmZzZXRXaWR0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtczsgaSsrKSB7XG4gICAgICAgICAgICBlbGVtc1tpXS5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlM2QoJyArIChhdmFpbGFibGVXaWR0aCAqIGkpICsgJ3B4LCAwLCAwKSc7XG4gICAgICAgIH1cbiAgICAgICAgZGlmZiA9IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5pdCgpe1xuICAgICAgICBlbGVtcyA9IHN3aXBlV3JhcHBlci5xdWVyeVNlbGVjdG9yQWxsKCcuc3dpcGVhYmxlLWl0ZW0nKTtcbiAgICAgICAgaXRlbXMgPSBlbGVtcy5sZW5ndGg7XG4gICAgICAgIHVwZGF0ZSgpO1xuICAgIH1cblxuICAgIG9uTW91bnQoKCkgPT4ge1xuICAgICAgICBpbml0KCk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB1cGRhdGUpO1xuICAgIH0pO1xuXG5cblxuICAgIG9uRGVzdHJveSgoKT0+e1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdXBkYXRlKTtcbiAgICB9KVxuXG4gICAgZnVuY3Rpb24gbW92ZUhhbmRsZXIoZSl7XG4gICAgICAgIGlmICh0b3VjaGluZykge1xuICAgICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cblxuICAgICAgICAgICAgbGV0IG1heCA9IGF2YWlsYWJsZVdpZHRoO1xuXG4gICAgICAgICAgICBsZXQgX3ggPSBlLnRvdWNoZXMgPyBlLnRvdWNoZXNbMF0ucGFnZVggOiBlLnBhZ2VYO1xuICAgICAgICAgICAgbGV0IF9kaWZmID0gKHggLSBfeCkgKyBwb3NYO1xuICAgICAgICAgICAgbGV0IGRpciA9IF94ID4geCA/IDAgOiAxO1xuICAgICAgICAgICAgaWYgKCFkaXIpIHsgX2RpZmYgPSBwb3NYIC0gKF94IC0geCkgfVxuICAgICAgICAgICAgaWYgKF9kaWZmIDw9IChtYXggKiAoaXRlbXMgLSAxKSkgJiYgX2RpZmYgPj0gbWluKSB7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRlbXBsYXRlID0gaSA8IDAgPyAne3t2YWx9fScgOiAnLXt7dmFsfX0nO1xuICAgICAgICAgICAgICAgICAgICBsZXQgX3ZhbHVlID0gKG1heCAqIGkpIC0gX2RpZmY7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1zW2ldLnN0eWxlLmNzc1RleHQgPSB0b3VjaGluZ1RwbC5yZXBsYWNlKHRlbXBsYXRlLCBfdmFsdWUpLnJlcGxhY2UodGVtcGxhdGUsIF92YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZGlmZiA9IF9kaWZmO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbmRIYW5kbGVyKGUpIHtcbiAgICAgICAgZSAmJiBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICBlICYmIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGUgJiYgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIGxldCBtYXggPSBhdmFpbGFibGVXaWR0aDtcblxuICAgICAgICB0b3VjaGluZyA9IGZhbHNlO1xuICAgICAgICB4ID0gbnVsbDtcblxuICAgICAgICBsZXQgZGVsdGEgPSAuMDVcbiAgICAgICAgbGV0IHN3aXBlX3RocmVzaG9sZCA9IDAuODU7XG4gICAgICAgIGxldCBkX21heCA9IChkaWZmIC8gbWF4KTtcbiAgICAgICAgbGV0IGRlbHRhRE1heCA9IGRfbWF4IC0gTWF0aC5mbG9vcihkX21heCkgLy8gY3VzdG9tIGRlbHRhXG4gICAgICAgIGxldCBfdGFyZ2V0ID0gZGVsdGFETWF4ID4gZGVsdGEgJiYgZGVsdGFETWF4IDwgLjUgPyBNYXRoLmNlaWwoZF9tYXgpIDogTWF0aC5mbG9vcihkX21heCk7IC8vIE1hdGgucm91bmQoZF9tYXgpO1xuXG4gICAgICAgIGlmKE1hdGguYWJzKF90YXJnZXQgLSBkX21heCkgPCBzd2lwZV90aHJlc2hvbGQgKXtcbiAgICAgICAgICAgIGRpZmYgPSBfdGFyZ2V0ICogbWF4O1xuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIGRpZmYgPSAoZGlyID8gKF90YXJnZXQgLSAxKSA6IChfdGFyZ2V0ICsgMSkpICogbWF4O1xuICAgICAgICB9XG5cbiAgICAgICAgcG9zWCA9IGRpZmY7XG4gICAgICAgIGFjdGl2ZUluZGljYXRvciA9IChkaWZmIC8gbWF4KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtczsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdGVtcGxhdGUgPSBpIDwgMCA/ICd7e3ZhbH19JyA6ICcte3t2YWx9fSc7XG4gICAgICAgICAgICBsZXQgX3ZhbHVlID0gKG1heCAqIGkpIC0gcG9zWDtcbiAgICAgICAgICAgIGVsZW1zW2ldLnN0eWxlLmNzc1RleHQgPSBub25fdG91Y2hpbmdUcGwucmVwbGFjZSh0ZW1wbGF0ZSwgX3ZhbHVlKS5yZXBsYWNlKHRlbXBsYXRlLCBfdmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG1vdmVIYW5kbGVyKTtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBlbmRIYW5kbGVyKTtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG1vdmVIYW5kbGVyKTtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgZW5kSGFuZGxlcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW92ZVN0YXJ0KGUpe1xuICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgbGV0IG1heCA9IGF2YWlsYWJsZVdpZHRoO1xuXG4gICAgICAgIHRvdWNoaW5nID0gdHJ1ZTtcbiAgICAgICAgeCA9IGUudG91Y2hlcyA/IGUudG91Y2hlc1swXS5wYWdlWCA6IGUucGFnZVg7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBtb3ZlSGFuZGxlcik7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgZW5kSGFuZGxlcik7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBtb3ZlSGFuZGxlcik7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIGVuZEhhbmRsZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoYW5nZUl0ZW0oaXRlbSkge1xuICAgICAgICBsZXQgbWF4ID0gYXZhaWxhYmxlV2lkdGg7XG4gICAgICAgIGRpZmYgPSBtYXggKiBpdGVtO1xuICAgICAgICBhY3RpdmVJbmRpY2F0b3IgPSBpdGVtO1xuICAgICAgICBlbmRIYW5kbGVyKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hhbmdlVmlldygpIHtcbiAgICAgICAgY2hhbmdlSXRlbShwbGF5ZWQpO1xuICAgICAgICBwbGF5ZWQgPSBwbGF5ZWQgPCAoaXRlbXMgLSAxKSA/ICsrcGxheWVkIDogMDtcbiAgICB9XG5cbjwvc2NyaXB0PlxuXG48c3R5bGU+XG5cbiAgICAuc3dpcGUtcGFuZWwge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIGhlaWdodDogdmFyKC0tc3Ytc3dpcGUtcGFuZWwtaGVpZ2h0LCAxMDAlKTtcbiAgICAgICAgd2lkdGg6IHZhcigtLXN2LXN3aXBlLXBhbmVsLXdpZHRoLCBpbmhlcml0KTtcbiAgICB9XG4gICAgLnN3aXBlLWl0ZW0td3JhcHBlcntcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgYWxpZ24tc2VsZjogc3RyZXRjaDtcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBoZWlnaHQ6IGluaGVyaXQ7XG4gICAgICAgIHotaW5kZXg6IHZhcigtLXN2LXN3aXBlLXBhbmVsLXdyYXBwZXItaW5kZXgsIDIpO1xuICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICB9XG5cbiAgICAuc3dpcGVhYmxlLWl0ZW1zLFxuICAgIC5zd2lwZWFibGUtc2xvdC13cmFwcGVyIHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgYWxpZ24tc2VsZjogc3RyZXRjaDtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICB9XG5cbiAgICAuc3dpcGUtaGFuZGxlciB7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogNDBweDtcbiAgICAgICAgYm90dG9tOiAwcHg7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIHJpZ2h0OiAwO1xuICAgICAgICBiYWNrZ3JvdW5kOiByZ2JhKDAsMCwwLDApO1xuICAgIH1cbiAgICAuc3dpcGUtaW5kaWNhdG9yIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBib3R0b206IDEuNXJlbTtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgIHotaW5kZXg6IHZhcigtLXN2LXN3aXBlLXBhbmVsLXdyYXBwZXItaW5kZXgsIDIpO1xuICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICB9XG5cbiAgICAuZG90IHtcbiAgICAgICAgaGVpZ2h0OiAxMHB4O1xuICAgICAgICB3aWR0aDogMTBweDtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG4gICAgICAgIGJvcmRlcjogMXB4IHNvbGlkIGdyZXk7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcbiAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgICAgICBtYXJnaW46IDBweCAycHg7XG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICAgICAgcG9pbnRlci1ldmVudHM6IGZpbGw7XG4gICAgfVxuICAgIC5zd2lwZS1pbmRpY2F0b3IgLmlzLWFjdGl2ZSB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLXN2LXN3aXBlLWluZGljYXRvci1hY3RpdmUtY29sb3IsIGdyZXkpO1xuICAgIH1cblxuPC9zdHlsZT5cblxuPGRpdiBjbGFzcz1cInN3aXBlLXBhbmVsXCI+XG4gICAgPGRpdiBjbGFzcz1cInN3aXBlLWl0ZW0td3JhcHBlclwiIGJpbmQ6dGhpcz17c3dpcGVXcmFwcGVyfT5cbiAgICAgICAgPGRpdiBjbGFzcz1cInN3aXBlYWJsZS1pdGVtc1wiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInN3aXBlYWJsZS1zbG90LXdyYXBwZXJcIj5cbiAgICAgICAgICAgICAgICA8c2xvdCAvPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJzd2lwZS1oYW5kbGVyXCIgYmluZDp0aGlzPXtzd2lwZUhhbmRsZXJ9IG9uOnRvdWNoc3RhcnQ9e21vdmVTdGFydH0gb246bW91c2Vkb3duPXttb3ZlU3RhcnR9PjwvZGl2PlxuICAgIHsjaWYgc2hvd0luZGljYXRvcnN9XG4gICAgICAgIDxkaXYgY2xhc3M9XCJzd2lwZS1pbmRpY2F0b3Igc3dpcGUtaW5kaWNhdG9yLWluc2lkZVwiPlxuICAgICAgICAgICAgeyNlYWNoIGluZGljYXRvcnMgYXMgeCwgaSB9XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJkb3Qge2FjdGl2ZUluZGljYXRvciA9PSBpID8gJ2lzLWFjdGl2ZScgOiAnJ31cIiBvbjpjbGljaz17KCkgPT4ge2NoYW5nZUl0ZW0oaSl9fT48L3NwYW4+XG4gICAgICAgICAgICB7L2VhY2h9XG4gICAgICAgIDwvZGl2PlxuICAgIHsvaWZ9XG5cbjwvZGl2PlxuIiwiPHNjcmlwdD5cbiAgICBleHBvcnQgbGV0IGNsYXNzZXMgPSAnJztcbjwvc2NyaXB0PlxuXG48c3R5bGU+XG4gICAgLnN3aXBlYWJsZS1pdGVtIHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgYWxpZ24tc2VsZjogc3RyZXRjaDtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IDA7XG4gICAgICAgIGJvdHRvbTogMDtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgICAgcmlnaHQ6IDA7XG4gICAgICAgIHRyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uOiBlYXNlLW91dDtcbiAgICB9XG48L3N0eWxlPlxuXG48ZGl2IGNsYXNzPVwic3dpcGVhYmxlLWl0ZW0ge2NsYXNzZXN9XCI+XG4gICAgPHNsb3QgLz5cbjwvZGl2PlxuIiwiPHNjcmlwdD5cbiAgICBleHBvcnQgbGV0IGFtb3VudCA9IDFcblxuICAgICQ6IGJyQXJyID0gbmV3IEFycmF5KE51bWJlci5pc0Zpbml0ZSgrYW1vdW50KSA/ICthbW91bnQgOiAxKS5maWxsKG51bGwpXG48L3NjcmlwdD5cblxueyNlYWNoIGJyQXJyIGFzIF9pfVxuICAgIDxici8+XG57L2VhY2h9XG5cbjxzdHlsZT5cblxuPC9zdHlsZT5cbiIsIi8qIVxuICBDb3B5cmlnaHQgKGMpIDIwMTcgSmVkIFdhdHNvbi5cbiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIChNSVQpLCBzZWVcbiAgaHR0cDovL2plZHdhdHNvbi5naXRodWIuaW8vY2xhc3NuYW1lc1xuKi9cbi8qIGdsb2JhbCBkZWZpbmUgKi9cblxuKGZ1bmN0aW9uICgpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBoYXNPd24gPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuXHRmdW5jdGlvbiBjbGFzc05hbWVzICgpIHtcblx0XHR2YXIgY2xhc3NlcyA9IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBhcmcgPSBhcmd1bWVudHNbaV07XG5cdFx0XHRpZiAoIWFyZykgY29udGludWU7XG5cblx0XHRcdHZhciBhcmdUeXBlID0gdHlwZW9mIGFyZztcblxuXHRcdFx0aWYgKGFyZ1R5cGUgPT09ICdzdHJpbmcnIHx8IGFyZ1R5cGUgPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdGNsYXNzZXMucHVzaChhcmcpO1xuXHRcdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZykgJiYgYXJnLmxlbmd0aCkge1xuXHRcdFx0XHR2YXIgaW5uZXIgPSBjbGFzc05hbWVzLmFwcGx5KG51bGwsIGFyZyk7XG5cdFx0XHRcdGlmIChpbm5lcikge1xuXHRcdFx0XHRcdGNsYXNzZXMucHVzaChpbm5lcik7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoYXJnVHlwZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0Zm9yICh2YXIga2V5IGluIGFyZykge1xuXHRcdFx0XHRcdGlmIChoYXNPd24uY2FsbChhcmcsIGtleSkgJiYgYXJnW2tleV0pIHtcblx0XHRcdFx0XHRcdGNsYXNzZXMucHVzaChrZXkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBjbGFzc2VzLmpvaW4oJyAnKTtcblx0fVxuXG5cdGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuXHRcdGNsYXNzTmFtZXMuZGVmYXVsdCA9IGNsYXNzTmFtZXM7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBjbGFzc05hbWVzO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT09ICdvYmplY3QnICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyByZWdpc3RlciBhcyAnY2xhc3NuYW1lcycsIGNvbnNpc3RlbnQgd2l0aCBucG0gcGFja2FnZSBuYW1lXG5cdFx0ZGVmaW5lKCdjbGFzc25hbWVzJywgW10sIGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBjbGFzc05hbWVzO1xuXHRcdH0pO1xuXHR9IGVsc2Uge1xuXHRcdHdpbmRvdy5jbGFzc05hbWVzID0gY2xhc3NOYW1lcztcblx0fVxufSgpKTtcbiIsImV4cG9ydCB7IGRlZmF1bHQgYXMgY2xhc3NuYW1lcyB9IGZyb20gJ2NsYXNzbmFtZXMnXG5cbmV4cG9ydCBjb25zdCB0b0NTU1N0cmluZyA9IChzdHlsZXMgPSB7fSkgPT4gT2JqZWN0LmVudHJpZXMoc3R5bGVzKVxuICAuZmlsdGVyKChbX3Byb3BOYW1lLCBwcm9wVmFsdWVdKSA9PiBwcm9wVmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wVmFsdWUgIT09IG51bGwpXG4gIC5yZWR1Y2UoKHN0eWxlU3RyaW5nLCBbcHJvcE5hbWUsIHByb3BWYWx1ZV0pID0+IHtcbiAgICBwcm9wTmFtZSA9IHByb3BOYW1lLnJlcGxhY2UoL1tBLVpdL2csIG1hdGNoID0+IGAtJHttYXRjaC50b0xvd2VyQ2FzZSgpfWApXG4gICAgcmV0dXJuIGAke3N0eWxlU3RyaW5nfSR7cHJvcE5hbWV9OiR7cHJvcFZhbHVlfTtgXG4gIH0sICcnKVxuXG4vKipcbiAqXG4gKiBAZnVuY3Rpb24gc2FmZUdldFxuICpcbiAqIEBkZXNjcmlwdGlvbiBTYWZlIGdldHRpbmcgb2YgYW4gYW55IHZhbHVlIG9mIGEgbmVzdGVkIG9iamVjdHMuXG4gKlxuICogQHBhcmFtIGV4cHJlc3Npb25GbiB7ZnVuY3Rpb259IC0gVGhlIGZ1bmN0aW9uIHdpdGggYW4gZXhwcmVzc2lvbiB3aGljaCByZXR1cm5zIHJlc3VsdCBvZiB0aGUgc2FmZSBnZXR0aW5nLlxuICogQHBhcmFtIGRlZmF1bHRWYWx1ZSB7YW55fSAtIFRoZSBkZWZhdWx0IHZhbHVlIHdoZW4gcmVzdWx0IGlzIHVuZGVmaW5lZC5cbiAqIEBwYXJhbSBpc0RlZmF1bHRUeXBlZCB7Ym9vbGVhbn0gLSBXaGV0ZXIgaXMgdGhlIHJlc3VsdCBmcm9tIGFuIGV4cHJlc3Npb24gbXVzdCBiZSB0aGUgc2FtZSB0eXBlIGFzIHRoZSBkZWZhdWx0IHZhbHVlLlxuICpcbiAqIEBleGFtcGxlc1xuICogLy8gU29tZSBkYXRhLlxuICogY29uc3QgdmVyeSA9IHtcbiAqICBuZXN0ZWQ6IHtcbiAqICAgb2JqZWN0OiBbe1xuICogICAgIHdpdGg6IHtcbiAqICAgICAgIGFycmF5czogJ3N0dWZmJ1xuICogICAgIH1cbiAqICAgfV1cbiAqICB9XG4gKiB9XG4gKlxuICogLy8gR2V0dGluZy5cbiAqIDEuIHNhZmVHZXQoKCkgPT4gdmVyeS5uZXN0ZWQub2JqZWN0WzBdLndpdGguYXJyYXlzKTtcbiAqIDIuIHNhZmVHZXQoKCkgPT4gdmVyeS5uZXN0ZWQub2JqZWN0WzBdLndpdGguYXJyYXlzLCB7IGRlZmF1bHQ6ICd2YWx1ZScgfSk7XG4gKiAzLiBzYWZlR2V0KCgpID0+IHZlcnkubmVzdGVkLm9iamVjdFswXS53aXRoLmFycmF5cywgeyBkZWZhdWx0OiAndmFsdWUnIH0sIHRydWUpO1xuICpcbiAqIC8vIFJldHVybi5cbiAqIDEuICdzdHVmZidcbiAqIDIuICdzdHVmZidcbiAqIDMuIHsgZGVmYXVsdDogJ3ZhbHVlJyB9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzYWZlR2V0KGV4cHJlc3Npb25GbiwgZGVmYXVsdFZhbHVlLCBpc0RlZmF1bHRUeXBlZCA9IGZhbHNlKSB7XG4gIC8vIENoZWNrIHdoZXRoZXIgYSBhbmQgYiBoYXZlIHRoZSBzYW1lIHR5cGUuICh1dGlsKVxuICBmdW5jdGlvbiBpc1NhbWVUeXBlKGEsIGIpIHtcbiAgICBjb25zdCBydWxlcyA9IFtcbiAgICAgIChhLCBiKSA9PiB0eXBlb2YgYSA9PT0gdHlwZW9mIGIsXG4gICAgICAoYSwgYikgPT4gKCthID09PSBhKSA9PT0gKCtiID09PSBiKSwgICAgICAgICAgICAgIC8vIHdoZXRoZXIgb25lIGlzIE5hTlxuICAgICAgKGEsIGIpID0+IChhID09PSBudWxsKSA9PT0gKGIgPT09IG51bGwpLCAgICAgICAgICAvLyBudWxsIGlzIG9iamVjdCB0eXBlIHRvb1xuICAgICAgKGEsIGIpID0+IEFycmF5LmlzQXJyYXkoYSkgPT09IEFycmF5LmlzQXJyYXkoYiksICAvLyBhcnJheSBpcyBvYmplY3QgdHlwZSB0b29cbiAgICBdXG4gICAgcmV0dXJuICFydWxlcy5zb21lKHJ1bGVGbiA9PiAhcnVsZUZuKGEsIGIpKVxuICB9XG4gIC8vIENvcmUgb2Ygc2FmZSBnZXR0aW5nLiBFeGVjdXRpbmcgYSBmdW5jdGlvbi4gRGVmYXVsdCB2YWx1ZXMuXG4gIGZ1bmN0aW9uIGdldChleHByZXNzaW9uRm4sIGRlZmF1bHRWYWx1ZSwgaXNEZWZhdWx0VHlwZWQpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gZXhwcmVzc2lvbkZuLmNhbGwodGhpcylcbiAgICAgIGlmIChpc0RlZmF1bHRUeXBlZCkge1xuICAgICAgICByZXR1cm4gaXNTYW1lVHlwZShyZXN1bHQsIGRlZmF1bHRWYWx1ZSkgPyByZXN1bHQgOiBkZWZhdWx0VmFsdWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdFxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBkZWZhdWx0VmFsdWVcbiAgICB9XG4gIH1cbiAgLy8gU2FmZSBnZXR0aW5nIG9mIHRoZSBleHByZXNzaW9uRm4uXG4gIGlmICh0eXBlb2YgZXhwcmVzc2lvbkZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGdldChleHByZXNzaW9uRm4sIGRlZmF1bHRWYWx1ZSwgaXNEZWZhdWx0VHlwZWQpXG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS53YXJuKCdZb3UgbmVlZCB0byB1c2UgYSBmdW5jdGlvbiBhcyB0aGUgZmlyc3QgYXJndW1lbnQuJylcbiAgfVxuICByZXR1cm4gZGVmYXVsdFZhbHVlXG59XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IGNsYXNzbmFtZXMsIHRvQ1NTU3RyaW5nIH0gZnJvbSAnLi4vdXRpbHMnXG5cbiAgICBleHBvcnQgbGV0IHR5cGVcbiAgICBleHBvcnQgbGV0IGlzIC8vIHByaW1hcnl8d2FybmluZ3xkYW5nZXJ8bGlnaHR8ZGFya1xuICAgIGV4cG9ydCBsZXQgc2l6ZSA9ICdtZWRpdW0nIC8vIHNtYWxsfG1lZGl1bXxiaWdcbiAgICBleHBvcnQgbGV0IHJvdGF0ZSA9IDBcbiAgICBleHBvcnQgbGV0IHN0eWxlID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCBpZCA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgdGl0bGUgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IGFyaWFMYWJlbCA9IHVuZGVmaW5lZFxuXG4gICAgbGV0IHRpdGxlUHJvcCA9IHRpdGxlIHx8IGFyaWFMYWJlbFxuICAgIGxldCBhcmlhTGFiZWxQcm9wID0gYXJpYUxhYmVsIHx8IHRpdGxlXG4gICAgbGV0IHN0eWxlUHJvcCA9IHRvQ1NTU3RyaW5nKHsgdHJhbnNmb3JtOiAhIXJvdGF0ZSA/IGByb3RhdGVaKCR7cm90YXRlfWRlZylgIDogbnVsbCwgLi4uc3R5bGUgfSlcblxuICAgICQ6ICBjbGFzc1Byb3AgPSBjbGFzc25hbWVzKCdpY28nLCBpcywgc2l6ZSwgJCRwcm9wcy5jbGFzcylcbjwvc2NyaXB0PlxuXG48c3ZnXG4gICAgICAgIHtpZH1cbiAgICAgICAgdGl0bGU9e3RpdGxlUHJvcH1cbiAgICAgICAgY2xhc3M9e2NsYXNzUHJvcH1cbiAgICAgICAgc3R5bGU9e3N0eWxlUHJvcH1cbiAgICAgICAgYXJpYS1sYWJlbD17YXJpYUxhYmVsUHJvcH1cbj5cbiAgICA8dXNlIHhsaW5rOmhyZWY9e2AjaWNvLSR7dHlwZX1gfSBjbGFzcz1cImljby11c2VcIi8+XG48L3N2Zz5cblxuPHN0eWxlPlxuICAgIHN2ZyB7XG4gICAgICAgIGRpc3BsYXk6IGluaGVyaXQ7XG4gICAgfVxuXG4gICAgc3ZnLCBzdmcgKiB7XG4gICAgICAgIGZpbGw6IHJnYmEodmFyKC0tdGhlbWUtc3ZnLWZpbGwpKTtcbiAgICAgICAgc3Ryb2tlOiByZ2JhKHZhcigtLXRoZW1lLXN2Zy1maWxsKSk7XG4gICAgfVxuXG4gICAgLyogLS0tLS0tLS0tLS0tPT09PT09PT09KCBTaXplICk9PT09PT09PT0tLS0tLS0tLS0tLS0gKi9cbiAgICAuc21hbGwge1xuICAgICAgICB3aWR0aDogMTVweDtcbiAgICAgICAgaGVpZ2h0OiAxNXB4O1xuICAgIH1cblxuICAgIC5tZWRpdW0ge1xuICAgICAgICB3aWR0aDogMjJweDtcbiAgICAgICAgaGVpZ2h0OiAyMnB4O1xuICAgIH1cblxuICAgIC5iaWcge1xuICAgICAgICB3aWR0aDogMzVweDtcbiAgICAgICAgaGVpZ2h0OiAzNXB4O1xuICAgIH1cblxuICAgIC8qIC0tLS0tLS0tLS0tLT09PT09PT09PSggQ29sb3IgKT09PT09PT09PS0tLS0tLS0tLS0tLSAqL1xuICAgIC5wcmltYXJ5LCAucHJpbWFyeSAqIHtcbiAgICAgICAgZmlsbDogcmdiKHZhcigtLWNvbG9yLXN1Y2Nlc3MpKTtcbiAgICAgICAgc3Ryb2tlOiByZ2IodmFyKC0tY29sb3Itc3VjY2VzcykpO1xuICAgIH1cblxuICAgIC53YXJuaW5nLCAud2FybmluZyAqIHtcbiAgICAgICAgZmlsbDogcmdiKHZhcigtLWNvbG9yLXdhcm5pbmcpKTtcbiAgICAgICAgc3Ryb2tlOiByZ2IodmFyKC0tY29sb3Itd2FybmluZykpO1xuICAgIH1cblxuICAgIC5kYW5nZXIsIC5kYW5nZXIgKiB7XG4gICAgICAgIGZpbGw6IHJnYih2YXIoLS1jb2xvci1kYW5nZXIpKTtcbiAgICAgICAgc3Ryb2tlOiByZ2IodmFyKC0tY29sb3ItZGFuZ2VyKSk7XG4gICAgfVxuXG4gICAgLmluZm8sIC5pbmZvICoge1xuICAgICAgICBmaWxsOiByZ2IodmFyKC0tY29sb3ItaW5mbykpO1xuICAgICAgICBzdHJva2U6IHJnYih2YXIoLS1jb2xvci1pbmZvKSk7XG4gICAgfVxuXG4gICAgLmxpZ2h0LCAubGlnaHQgKiB7XG4gICAgICAgIGZpbGw6IHZhcigtLWNvbG9yLWxpZ2h0LTEpO1xuICAgICAgICBzdHJva2U6IHZhcigtLWNvbG9yLWxpZ2h0LTEpO1xuICAgIH1cblxuICAgIC5kYXJrLCAuZGFyayAqIHtcbiAgICAgICAgZmlsbDogdmFyKC0tY29sb3ItZGFyay0xKTtcbiAgICAgICAgc3Ryb2tlOiB2YXIoLS1jb2xvci1kYXJrLTEpO1xuICAgIH1cbjwvc3R5bGU+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCBJY29uIGZyb20gJy4uL2NvbXBvbmVudHMvSWNvbi5zdmVsdGUnXG5cbiAgICBleHBvcnQgbGV0IGlzID0gJ2RhbmdlcidcbiAgICBleHBvcnQgbGV0IHNpemUgPSAnbWVkaXVtJyAvLyBzbWFsbHxtZWRpdW18bWlnXG48L3NjcmlwdD5cblxuPHVsIGNsYXNzPVwicmF0ZVwiPlxuICAgIDxsaT5cbiAgICAgICAgPEljb24ge2lzfSB7c2l6ZX0gdHlwZT1cImhlYXJ0LWZpbGxlZFwiLz5cbiAgICA8L2xpPlxuICAgIDxsaT5cbiAgICAgICAgPEljb24ge2lzfSB7c2l6ZX0gdHlwZT1cImhlYXJ0LWZpbGxlZFwiLz5cbiAgICA8L2xpPlxuICAgIDxsaT5cbiAgICAgICAgPEljb24ge2lzfSB7c2l6ZX0gdHlwZT1cImhlYXJ0LWZpbGxlZFwiLz5cbiAgICA8L2xpPlxuICAgIDxsaT5cbiAgICAgICAgPEljb24ge2lzfSB7c2l6ZX0gdHlwZT1cImhlYXJ0LWZpbGxlZFwiLz5cbiAgICA8L2xpPlxuICAgIDxsaT5cbiAgICAgICAgPEljb24ge2lzfSB7c2l6ZX0gdHlwZT1cImhlYXJ0LWZpbGxlZFwiLz5cbiAgICA8L2xpPlxuPC91bD5cblxuPHN0eWxlPlxuICAgIC5yYXRlIHtcbiAgICAgICAgZGlzcGxheTogaW5saW5lLWZsZXg7XG4gICAgICAgIG1hcmdpbjogY2FsYyh2YXIoLS1zY3JlZW4tcGFkZGluZykgKiAtMSAvIDMpO1xuICAgIH1cblxuICAgIGxpIHtcbiAgICAgICAgcGFkZGluZzogY2FsYyh2YXIoLS1zY3JlZW4tcGFkZGluZykgLyAzKTtcbiAgICB9XG5cbiAgICAucmF0ZSBsaSB7XG4gICAgICAgIC13ZWJraXQtZmlsdGVyOiBkcm9wLXNoYWRvdygtMXB4IDJweCAxcHggcmdiYSh2YXIoLS1jb2xvci1ibGFjayksIC4yNSkpO1xuICAgICAgICBmaWx0ZXI6IGRyb3Atc2hhZG93KC0xcHggMnB4IDFweCByZ2JhKHZhcigtLWNvbG9yLWJsYWNrKSwgLjI1KSk7XG4gICAgfVxuPC9zdHlsZT5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgY3JlYXRlRXZlbnREaXNwYXRjaGVyIH0gZnJvbSAnc3ZlbHRlJ1xuICAgIGltcG9ydCB7IGNsYXNzbmFtZXMsIHRvQ1NTU3RyaW5nIH0gZnJvbSAnLi4vdXRpbHMnXG5cbiAgICBjb25zdCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpXG5cbiAgICBleHBvcnQgbGV0IG5hbWVcbiAgICBleHBvcnQgbGV0IHZhbHVlID0gJydcbiAgICBleHBvcnQgbGV0IHN0eWxlID0ge31cbiAgICBleHBvcnQgbGV0IHR5cGUgPSAndGV4dCdcbiAgICBleHBvcnQgbGV0IGlkID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCBhbGlnbiA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgbWF4bGVuZ3RoID0gMTAwMFxuICAgIGV4cG9ydCBsZXQgcm93cyA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgZGlzYWJsZWQgPSBmYWxzZVxuICAgIGV4cG9ydCBsZXQgdGl0bGUgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IGludmFsaWQgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IG1pbiA9IHVuZGVmaW5lZCAvLyBTcGVjaWZpZXMgYSBtaW5pbXVtIHZhbHVlIGZvciBhbiA8aW5wdXQ+IGVsZW1lbnRcbiAgICBleHBvcnQgbGV0IG1heCA9IHVuZGVmaW5lZCAvLyBTcGVjaWZpZXMgdGhlIG1heGltdW0gdmFsdWUgZm9yIGFuIDxpbnB1dD4gZWxlbWVudFxuICAgIGV4cG9ydCBsZXQgbGlzdCA9IHVuZGVmaW5lZCAvLyBSZWZlcnMgdG8gYSA8ZGF0YWxpc3Q+IGVsZW1lbnQgdGhhdCBjb250YWlucyBwcmUtZGVmaW5lZCBvcHRpb25zIGZvciBhbiA8aW5wdXQ+IGVsZW1lbnRcbiAgICBleHBvcnQgbGV0IGZvcm0gPSB1bmRlZmluZWQgLy8gU3BlY2lmaWVzIHRoZSBmb3JtIHRoZSA8aW5wdXQ+IGVsZW1lbnQgYmVsb25ncyB0b1xuICAgIGV4cG9ydCBsZXQgcmVhZG9ubHkgPSB1bmRlZmluZWQgLy8gdW5kZWZpbmVkfHJlYWRvbmx5XG4gICAgZXhwb3J0IGxldCByZXF1aXJlZCA9IHVuZGVmaW5lZCAvLyB1bmRlZmluZWR8cmVxdWlyZWRcbiAgICBleHBvcnQgbGV0IHBhdHRlcm4gPSB1bmRlZmluZWQgLy8gU3BlY2lmaWVzIGEgcmVndWxhciBleHByZXNzaW9uIHRoYXQgYW4gPGlucHV0PiBlbGVtZW50J3MgdmFsdWUgaXMgY2hlY2tlZCBhZ2FpbnN0IChyZWdleHApXG4gICAgZXhwb3J0IGxldCBhdXRvY29tcGxldGUgPSB0cnVlIC8vIG9ufG9mZlxuICAgIGV4cG9ydCBsZXQgYXV0b3NlbGVjdCA9IGZhbHNlXG4gICAgZXhwb3J0IGxldCBhcmlhTGFiZWwgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IHBsYWNlaG9sZGVyID0gdW5kZWZpbmVkXG5cbiAgICBsZXQgaWRQcm9wID0gaWQgfHwgbmFtZVxuICAgIGxldCB0eXBlUHJvcCA9IHR5cGUgPT09ICdudW1iZXInID8gJ3RleHQnIDogdHlwZVxuICAgIGxldCB0aXRsZVByb3AgPSB0aXRsZSB8fCBhcmlhTGFiZWwgfHwgcGxhY2Vob2xkZXJcbiAgICBsZXQgYXJpYUxhYmVsUHJvcCA9IGFyaWFMYWJlbCB8fCB0aXRsZSB8fCBwbGFjZWhvbGRlclxuICAgIGxldCBhdXRvY29tcGxldGVQcm9wID0gYXV0b2NvbXBsZXRlID8gJ29uJyA6ICdvZmYnXG4gICAgbGV0IHN0eWxlUHJvcCA9IHRvQ1NTU3RyaW5nKHsgLi4uc3R5bGUsIHRleHRBbGlnbjogYWxpZ24gfSlcbiAgICBsZXQgcGF0dGVyblByb3AgPSB0eXBlID09PSAnbnVtYmVyJyAmJiAhcGF0dGVybiA/ICdbMC05XSonIDogcGF0dGVyblxuXG4gICAgJDogY2xhc3NQcm9wID0gY2xhc3NuYW1lcygnaW5wJywgJCRwcm9wcy5jbGFzcywgeyBkaXNhYmxlZCwgcmVhZG9ubHksIHJlcXVpcmVkLCBpbnZhbGlkIH0pXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvbiBFbWl0IGNsaWNrIGFuZCBzZWxlY3QgY29udGVudCB3aGVuIFwiYXV0b3NlbGVjdFwiIGlzIGVuYWJsZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGUgLSBOYXRpdmUgbW91c2UgZXZlbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gb25DbGljayhlKSB7XG4gICAgICAgICFkaXNhYmxlZCAmJiBkaXNwYXRjaChcImNsaWNrXCIsIGUpXG4gICAgICAgICFkaXNhYmxlZCAmJiBhdXRvc2VsZWN0ICYmIGUudGFyZ2V0LnNlbGVjdCgpXG4gICAgfVxuPC9zY3JpcHQ+XG5cbnsjaWYgcm93c31cbiAgICA8dGV4dGFyZWFcbiAgICAgICAgICAgIHttaW59XG4gICAgICAgICAgICB7bWF4fVxuICAgICAgICAgICAge3Jvd3N9XG4gICAgICAgICAgICB7bmFtZX1cbiAgICAgICAgICAgIHtmb3JtfVxuICAgICAgICAgICAge2FsaWdufVxuICAgICAgICAgICAge3JlYWRvbmx5fVxuICAgICAgICAgICAge2Rpc2FibGVkfVxuICAgICAgICAgICAge3JlcXVpcmVkfVxuICAgICAgICAgICAge21heGxlbmd0aH1cbiAgICAgICAgICAgIHtwbGFjZWhvbGRlcn1cbiAgICAgICAgICAgIGlkPXtpZFByb3B9XG4gICAgICAgICAgICBjbGFzcz17Y2xhc3NQcm9wfVxuICAgICAgICAgICAgdGl0bGU9e3RpdGxlUHJvcH1cbiAgICAgICAgICAgIHN0eWxlPXtzdHlsZVByb3B9XG4gICAgICAgICAgICBwYXR0ZXJuPXtwYXR0ZXJuUHJvcH1cbiAgICAgICAgICAgIGFyaWEtbGFiZWw9e2FyaWFMYWJlbFByb3B9XG4gICAgICAgICAgICBhdXRvY29tcGxldGU9e2F1dG9jb21wbGV0ZVByb3B9XG4gICAgICAgICAgICB7Li4ueyB0eXBlOiB0eXBlUHJvcCB9fVxuICAgICAgICAgICAgYmluZDp2YWx1ZVxuICAgICAgICAgICAgb246Ymx1cj0ne2UgPT4gIWRpc2FibGVkICYmIGRpc3BhdGNoKFwiYmx1clwiLCBlKX0nXG4gICAgICAgICAgICBvbjpmb2N1cz0ne2UgPT4gIWRpc2FibGVkICYmIGRpc3BhdGNoKFwiZm9jdXNcIiwgZSl9J1xuICAgICAgICAgICAgb246Y2xpY2s9J3tvbkNsaWNrfSdcbiAgICA+PC90ZXh0YXJlYT5cbns6ZWxzZX1cbiAgICA8aW5wdXRcbiAgICAgICAgICAgIHttaW59XG4gICAgICAgICAgICB7bWF4fVxuICAgICAgICAgICAge25hbWV9XG4gICAgICAgICAgICB7bGlzdH1cbiAgICAgICAgICAgIHtmb3JtfVxuICAgICAgICAgICAge2FsaWdufVxuICAgICAgICAgICAge3JlYWRvbmx5fVxuICAgICAgICAgICAge2Rpc2FibGVkfVxuICAgICAgICAgICAge3JlcXVpcmVkfVxuICAgICAgICAgICAge21heGxlbmd0aH1cbiAgICAgICAgICAgIHtwbGFjZWhvbGRlcn1cbiAgICAgICAgICAgIGlkPXtpZFByb3B9XG4gICAgICAgICAgICBjbGFzcz17Y2xhc3NQcm9wfVxuICAgICAgICAgICAgdGl0bGU9e3RpdGxlUHJvcH1cbiAgICAgICAgICAgIHN0eWxlPXtzdHlsZVByb3B9XG4gICAgICAgICAgICBwYXR0ZXJuPXtwYXR0ZXJuUHJvcH1cbiAgICAgICAgICAgIGFyaWEtbGFiZWw9e2FyaWFMYWJlbFByb3B9XG4gICAgICAgICAgICBhdXRvY29tcGxldGU9e2F1dG9jb21wbGV0ZVByb3B9XG4gICAgICAgICAgICB7Li4ueyB0eXBlOiB0eXBlUHJvcCB9fVxuICAgICAgICAgICAgYmluZDp2YWx1ZVxuICAgICAgICAgICAgb246Ymx1cj0ne2UgPT4gIWRpc2FibGVkICYmIGRpc3BhdGNoKFwiYmx1clwiLCBlKX0nXG4gICAgICAgICAgICBvbjpmb2N1cz0ne2UgPT4gIWRpc2FibGVkICYmIGRpc3BhdGNoKFwiZm9jdXNcIiwgZSl9J1xuICAgICAgICAgICAgb246Y2xpY2s9J3tvbkNsaWNrfSdcbiAgICAvPlxuey9pZn1cblxuPHN0eWxlPlxuICAgIC5pbnAge1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgZmxleDogMSAxIDA7XG4gICAgICAgIGNvbG9yOiBpbmhlcml0O1xuICAgICAgICBib3JkZXItcmFkaXVzOiB2YXIoLS1ib3JkZXItcmFkaXVzKTtcbiAgICAgICAgbWluLXdpZHRoOiB2YXIoLS1taW4taW50ZXJhY3RpdmUtc2l6ZSk7XG4gICAgICAgIG1pbi1oZWlnaHQ6IHZhcigtLW1pbi1pbnRlcmFjdGl2ZS1zaXplKTtcbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgcmdiYSh2YXIoLS1jb2xvci1ibGFjayksIC4yNSk7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEodmFyKC0tdGhlbWUtYmctY29sb3IpKTtcbiAgICAgICAgYm94LXNoYWRvdzogaW5zZXQgdmFyKC0tc2hhZG93LXByaW1hcnkpLCB2YXIoLS1zaGFkb3ctc2Vjb25kYXJ5LWluc2V0KTtcbiAgICB9XG5cbiAgICAuaW5wOmZvY3VzIHtcbiAgICAgICAgYm9yZGVyLWNvbG9yOiByZ2IodmFyKC0tY29sb3Itc3VjY2VzcykpO1xuICAgIH1cblxuICAgIC5pbnA6aW52YWxpZCwgLmlucC5pbnZhbGlkIHtcbiAgICAgICAgYm9yZGVyLWNvbG9yOiByZ2IodmFyKC0tY29sb3ItZGFuZ2VyKSk7XG4gICAgfVxuPC9zdHlsZT5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgY3JlYXRlRXZlbnREaXNwYXRjaGVyIH0gZnJvbSAnc3ZlbHRlJ1xuICAgIGltcG9ydCB7IGNsYXNzbmFtZXMgfSBmcm9tICcuLi91dGlscydcblxuICAgIGNvbnN0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKClcblxuICAgIGV4cG9ydCBsZXQgc3JjXG4gICAgZXhwb3J0IGxldCBhbHRcbiAgICBleHBvcnQgbGV0IGlkID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCB3aWR0aCA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgaGVpZ2h0ID0gdW5kZWZpbmVkXG5cbiAgICBsZXQgbG9hZGluZyA9IHRydWVcbiAgICBsZXQgaXNFcnJvciA9IGZhbHNlXG5cbiAgICAkOiB3cmFwQ2xhc3NQcm9wID0gY2xhc3NuYW1lcygncGljdHVyZScsICQkcHJvcHMuY2xhc3MsIHsgbG9hZGluZywgaXNFcnJvciB9KVxuXG4gICAgZnVuY3Rpb24gb25Mb2FkKGUpIHtcbiAgICAgICAgbG9hZGluZyA9IGZhbHNlXG4gICAgICAgIGRpc3BhdGNoKCdsb2FkJywgZSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkVycm9yKGUpIHtcbiAgICAgICAgbG9hZGluZyA9IGZhbHNlXG4gICAgICAgIGlzRXJyb3IgPSB0cnVlXG4gICAgICAgIGRpc3BhdGNoKCdlcnJvcicsIGUpXG4gICAgfVxuPC9zY3JpcHQ+XG5cbjxmaWd1cmUgY2xhc3M9e3dyYXBDbGFzc1Byb3B9PlxuICAgIDxpbWdcbiAgICAgICAgICAgIHtpZH1cbiAgICAgICAgICAgIHthbHR9XG4gICAgICAgICAgICB7c3JjfVxuICAgICAgICAgICAge3dpZHRofVxuICAgICAgICAgICAge2hlaWdodH1cbiAgICAgICAgICAgIGNsYXNzPVwicGljXCJcbiAgICAgICAgICAgIG9uOmxvYWQ9e29uTG9hZH1cbiAgICAgICAgICAgIG9uOmVycm9yPXtvbkVycm9yfVxuICAgIC8+XG5cbiAgICA8ZmlnY2FwdGlvbj5cbiAgICAgICAgPHNsb3Q+PC9zbG90PlxuICAgIDwvZmlnY2FwdGlvbj5cbjwvZmlndXJlPlxuXG48c3R5bGU+XG4gICAgLnBpY3R1cmUge1xuICAgICAgICBmbGV4LWdyb3c6IDE7XG4gICAgICAgIGFsaWduLXNlbGY6IHN0cmV0Y2g7XG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1mbGV4O1xuICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgICBhbGlnbi1pdGVtczogc3RyZXRjaDtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBzdHJldGNoO1xuICAgIH1cblxuICAgIC5waWN0dXJlIC5waWMge1xuICAgICAgICBmbGV4LWdyb3c6IDE7XG4gICAgICAgIGFsaWduLXNlbGY6IHN0cmV0Y2g7XG4gICAgICAgIG9iamVjdC1maXQ6IGNvdmVyO1xuICAgICAgICBvYmplY3QtcG9zaXRpb246IGNlbnRlcjtcbiAgICAgICAgdHJhbnNpdGlvbjogb3BhY2l0eSAuM3MgZWFzZS1pbjtcbiAgICB9XG5cbiAgICAucGljdHVyZS5sb2FkaW5nIC5waWMge1xuICAgICAgICBvcGFjaXR5OiAwO1xuICAgIH1cbjwvc3R5bGU+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IGNsYXNzbmFtZXMgfSBmcm9tICcuLi91dGlscydcbiAgICBpbXBvcnQgUGljdHVyZSBmcm9tICcuL1BpY3R1cmUuc3ZlbHRlJ1xuXG4gICAgZXhwb3J0IGxldCBzcmNcbiAgICBleHBvcnQgbGV0IGFsdFxuICAgIGV4cG9ydCBsZXQgc2l6ZSA9ICdtZWRpdW0nIC8vIHNtYWxsfG1lZGl1bXxiaWdcblxuICAgICQ6IGNsYXNzUHJvcCA9IGNsYXNzbmFtZXMoJ2F2YScsIHNpemUsICQkcHJvcHMuY2xhc3MpXG48L3NjcmlwdD5cblxuPGRpdiBjbGFzcz17Y2xhc3NQcm9wfT5cbiAgICA8UGljdHVyZSB7c3JjfSB7YWx0fS8+XG48L2Rpdj5cblxuPHN0eWxlPlxuICAgIC5hdmEge1xuICAgICAgICBmbGV4OiBub25lO1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBib3JkZXItcmFkaXVzOiA1MCU7XG4gICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICAgIGJveC1zaGFkb3c6IHZhcigtLXNoYWRvdy1wcmltYXJ5KTtcbiAgICB9XG5cbiAgICAuc21hbGwge1xuICAgICAgICB3aWR0aDogMjVweDtcbiAgICAgICAgaGVpZ2h0OiAyNXB4O1xuICAgIH1cbiAgICAubWVkaXVtIHtcbiAgICAgICAgd2lkdGg6IDM1cHg7XG4gICAgICAgIGhlaWdodDogMzVweDtcbiAgICB9XG4gICAgLmJpZyB7XG4gICAgICAgIHdpZHRoOiA0NXB4O1xuICAgICAgICBoZWlnaHQ6IDQ1cHg7XG4gICAgfVxuPC9zdHlsZT5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgY3JlYXRlRXZlbnREaXNwYXRjaGVyIH0gZnJvbSAnc3ZlbHRlJ1xuICAgIGltcG9ydCB7IGNsYXNzbmFtZXMgfSBmcm9tICcuLi91dGlscydcblxuICAgIGNvbnN0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKClcblxuICAgIGV4cG9ydCBsZXQgaXMgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IGlkID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCBocmVmID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCBhdXRvID0gZmFsc2VcbiAgICBleHBvcnQgbGV0IHR5cGUgPSAnYnV0dG9uJ1xuICAgIGV4cG9ydCBsZXQgc2l6ZSA9ICdtZWRpdW0nXG4gICAgZXhwb3J0IGxldCB0aXRsZSA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgaHRtbEZvciA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgZGlzYWJsZWQgPSBmYWxzZVxuICAgIGV4cG9ydCBsZXQgYXJpYUxhYmVsID0gdW5kZWZpbmVkXG5cbiAgICBsZXQgdGl0bGVQcm9wID0gdGl0bGUgfHwgYXJpYUxhYmVsXG4gICAgbGV0IGFyaWFMYWJlbFByb3AgPSBhcmlhTGFiZWwgfHwgdGl0bGVcblxuICAgICQ6IGNsYXNzUHJvcCA9IGNsYXNzbmFtZXMoJ2J0bicsIGlzLCBzaXplLCAkJHByb3BzLmNsYXNzLCB7IGF1dG8sIGRpc2FibGVkIH0pXG5cbiAgICBmdW5jdGlvbiBvbkxhYmVsQ2xpY2soZSkge1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChodG1sRm9yKS5jbGljaygpXG4gICAgICAgIC8vIHRyeSB7IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGh0bWxGb3IpLmNsaWNrKCkgfSBjYXRjaCAoZSkge31cbiAgICAgICAgIWRpc2FibGVkICYmIGRpc3BhdGNoKFwiY2xpY2tcIiwgZSlcbiAgICB9XG48L3NjcmlwdD5cblxueyNpZiBocmVmfVxuICAgIDxhXG4gICAgICAgICAgICB7aWR9XG4gICAgICAgICAgICB7aHJlZn1cbiAgICAgICAgICAgIHRpdGxlPXt0aXRsZVByb3B9XG4gICAgICAgICAgICBjbGFzcz17Y2xhc3NQcm9wfVxuICAgICAgICAgICAgYXJpYS1sYWJlbD17YXJpYUxhYmVsUHJvcH1cbiAgICAgICAgICAgIG9uOmNsaWNrPSd7ZSA9PiAhZGlzYWJsZWQgJiYgZGlzcGF0Y2goXCJjbGlja1wiLCBlKX0nXG4gICAgPlxuICAgICAgICA8c2xvdD48L3Nsb3Q+XG4gICAgPC9hPlxuezplbHNlIGlmIGh0bWxGb3J9XG4gICAgPGxhYmVsXG4gICAgICAgICAgICB7aWR9XG4gICAgICAgICAgICB7ZGlzYWJsZWR9XG4gICAgICAgICAgICBmb3I9e2h0bWxGb3J9XG4gICAgICAgICAgICB0aXRsZT17dGl0bGVQcm9wfVxuICAgICAgICAgICAgY2xhc3M9e2NsYXNzUHJvcH1cbiAgICAgICAgICAgIGFyaWEtbGFiZWw9e2FyaWFMYWJlbFByb3B9XG4gICAgICAgICAgICBvbjpjbGljaz17b25MYWJlbENsaWNrfVxuICAgID5cbiAgICAgICAgPHNsb3Q+PC9zbG90PlxuICAgIDwvbGFiZWw+XG57OmVsc2V9XG4gICAgPGJ1dHRvblxuICAgICAgICAgICAge2lkfVxuICAgICAgICAgICAge3R5cGV9XG4gICAgICAgICAgICB7ZGlzYWJsZWR9XG4gICAgICAgICAgICB0aXRsZT17dGl0bGVQcm9wfVxuICAgICAgICAgICAgY2xhc3M9e2NsYXNzUHJvcH1cbiAgICAgICAgICAgIGFyaWEtbGFiZWw9e2FyaWFMYWJlbFByb3B9XG4gICAgICAgICAgICBvbjpjbGljaz0ne2UgPT4gIWRpc2FibGVkICYmIGRpc3BhdGNoKFwiY2xpY2tcIiwgZSl9J1xuICAgID5cbiAgICAgICAgPHNsb3Q+PC9zbG90PlxuICAgIDwvYnV0dG9uPlxuey9pZn1cblxuPHN0eWxlPlxuICAgIC5idG46bm90KC5hdXRvKSB7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgIH1cblxuICAgIDpnbG9iYWwoLmJ0bikge1xuICAgICAgICBmbGV4OiBub25lO1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgIG1heC13aWR0aDogMTAwJTtcbiAgICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgIHBhZGRpbmc6IDVweCAxNXB4O1xuICAgICAgICBtYXJnaW4tYm90dG9tOiAzcHg7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1mbGV4O1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogdmFyKC0tYm9yZGVyLXJhZGl1cyk7XG4gICAgICAgIGNvbG9yOiByZ2JhKHZhcigtLXRoZW1lLWZvbnQtY29sb3IpKTtcbiAgICAgICAgdGV4dC1zaGFkb3c6IDFweCAxcHggcmdiYSh2YXIoLS1jb2xvci1ibGFjayksIC4zKTtcbiAgICB9XG5cbiAgICA6Z2xvYmFsKC5idG4uc21hbGwpIHtcbiAgICAgICAgcGFkZGluZzogNXB4O1xuICAgICAgICBtaW4td2lkdGg6IGNhbGModmFyKC0tbWluLWludGVyYWN0aXZlLXNpemUpIC8gMS41KTtcbiAgICAgICAgbWluLWhlaWdodDogY2FsYyh2YXIoLS1taW4taW50ZXJhY3RpdmUtc2l6ZSkgLyAxLjUpO1xuICAgIH1cblxuICAgIDpnbG9iYWwoLmJ0bi5tZWRpdW0pIHtcbiAgICAgICAgcGFkZGluZzogNXB4IDEwcHg7XG4gICAgICAgIG1pbi13aWR0aDogdmFyKC0tbWluLWludGVyYWN0aXZlLXNpemUpO1xuICAgICAgICBtaW4taGVpZ2h0OiB2YXIoLS1taW4taW50ZXJhY3RpdmUtc2l6ZSk7XG4gICAgfVxuXG4gICAgOmdsb2JhbCguYnRuLmJpZykge1xuICAgICAgICBwYWRkaW5nOiA1cHggMTVweDtcbiAgICAgICAgbWluLXdpZHRoOiBjYWxjKHZhcigtLW1pbi1pbnRlcmFjdGl2ZS1zaXplKSAqIDEuNSk7XG4gICAgICAgIG1pbi1oZWlnaHQ6IGNhbGModmFyKC0tbWluLWludGVyYWN0aXZlLXNpemUpICogMS41KTtcbiAgICB9XG5cbiAgICA6Z2xvYmFsKC5idG46Zm9jdXMpIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSh2YXIoLS1jb2xvci1ibGFjayksIDAuMSk7XG4gICAgfVxuXG4gICAgOmdsb2JhbCguYnRuOmhvdmVyKSB7XG4gICAgICAgIGJveC1zaGFkb3c6IDAgMnB4IHJnYmEodmFyKC0tY29sb3ItYmxhY2spLCAwLjIpO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKHZhcigtLWNvbG9yLWJsYWNrKSwgMC4xKTtcbiAgICB9XG5cbiAgICA6Z2xvYmFsKC5idG46YWN0aXZlKSB7XG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgxcHgpO1xuICAgICAgICBib3gtc2hhZG93OiAwIDFweCByZ2JhKHZhcigtLWNvbG9yLWJsYWNrKSwgMC4yKTtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSh2YXIoLS1jb2xvci1ibGFjayksIDAuMSk7XG4gICAgfVxuXG4gICAgLyogU3VjY2VzcyAqL1xuXG4gICAgLmJ0bi5zdWNjZXNzIHtcbiAgICAgICAgY29sb3I6IHJnYmEodmFyKC0tY29sb3ItZm9udC1saWdodCkpO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKHZhcigtLWNvbG9yLXN1Y2Nlc3MpKTtcbiAgICAgICAgYm94LXNoYWRvdzogMCAycHggcmdiYSh2YXIoLS1jb2xvci1zdWNjZXNzLWRhcmspKSwgdmFyKC0tc2hhZG93LXNlY29uZGFyeSksIHZhcigtLXNoYWRvdy1wcmltYXJ5KTtcbiAgICB9XG5cbiAgICAuYnRuLnN1Y2Nlc3M6Zm9jdXMge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKHZhcigtLWNvbG9yLXN1Y2Nlc3MpLCAuODUpO1xuICAgIH1cblxuICAgIC5idG4uc3VjY2Vzczpob3ZlciB7XG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgxcHgpO1xuICAgICAgICBib3gtc2hhZG93OiAwIDJweCByZ2JhKHZhcigtLWNvbG9yLXN1Y2Nlc3MtZGFyaykpLCB2YXIoLS1zaGFkb3ctc2Vjb25kYXJ5KSwgdmFyKC0tc2hhZG93LXByaW1hcnkpO1xuICAgIH1cblxuICAgIC5idG4uc3VjY2VzczphY3RpdmUge1xuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMnB4KTtcbiAgICAgICAgYm94LXNoYWRvdzogMCAxcHggcmdiYSh2YXIoLS1jb2xvci1zdWNjZXNzLWRhcmspKSwgdmFyKC0tc2hhZG93LXNlY29uZGFyeSk7XG4gICAgfVxuXG4gICAgLyogV2FybmluZyAqL1xuXG4gICAgLmJ0bi53YXJuaW5nIHtcbiAgICAgICAgY29sb3I6IHJnYmEodmFyKC0tY29sb3ItZm9udC1saWdodCkpO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKHZhcigtLWNvbG9yLXdhcm5pbmcpKTtcbiAgICAgICAgYm94LXNoYWRvdzogMCAycHggcmdiYSh2YXIoLS1jb2xvci13YXJuaW5nLWRhcmspKSwgdmFyKC0tc2hhZG93LXNlY29uZGFyeSksIHZhcigtLXNoYWRvdy1wcmltYXJ5KTtcbiAgICB9XG5cbiAgICAuYnRuLndhcm5pbmc6Zm9jdXMge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKHZhcigtLWNvbG9yLXdhcm5pbmcpLCAuODUpO1xuICAgIH1cblxuICAgIC5idG4ud2FybmluZzpob3ZlciB7XG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgxcHgpO1xuICAgICAgICBib3gtc2hhZG93OiAwIDJweCByZ2JhKHZhcigtLWNvbG9yLXdhcm5pbmctZGFyaykpLCB2YXIoLS1zaGFkb3ctc2Vjb25kYXJ5KSwgdmFyKC0tc2hhZG93LXByaW1hcnkpO1xuICAgIH1cblxuICAgIC5idG4ud2FybmluZzphY3RpdmUge1xuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMnB4KTtcbiAgICAgICAgYm94LXNoYWRvdzogMCAxcHggcmdiYSh2YXIoLS1jb2xvci13YXJuaW5nLWRhcmspKSwgdmFyKC0tc2hhZG93LXNlY29uZGFyeSk7XG4gICAgfVxuXG4gICAgLyogRGFuZ2VyICovXG5cbiAgICAuYnRuLmRhbmdlciB7XG4gICAgICAgIGNvbG9yOiByZ2JhKHZhcigtLWNvbG9yLWZvbnQtbGlnaHQpKTtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSh2YXIoLS1jb2xvci1kYW5nZXIpKTtcbiAgICAgICAgYm94LXNoYWRvdzogMCAycHggcmdiYSh2YXIoLS1jb2xvci1kYW5nZXItZGFyaykpLCB2YXIoLS1zaGFkb3ctc2Vjb25kYXJ5KSwgdmFyKC0tc2hhZG93LXByaW1hcnkpO1xuICAgIH1cblxuICAgIC5idG4uZGFuZ2VyOmZvY3VzIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSh2YXIoLS1jb2xvci1kYW5nZXIpLCAuODUpO1xuICAgIH1cblxuICAgIC5idG4uZGFuZ2VyOmhvdmVyIHtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDFweCk7XG4gICAgICAgIGJveC1zaGFkb3c6IDAgMnB4IHJnYmEodmFyKC0tY29sb3ItZGFuZ2VyLWRhcmspKSwgdmFyKC0tc2hhZG93LXNlY29uZGFyeSksIHZhcigtLXNoYWRvdy1wcmltYXJ5KTtcbiAgICB9XG5cbiAgICAuYnRuLmRhbmdlcjphY3RpdmUge1xuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMnB4KTtcbiAgICAgICAgYm94LXNoYWRvdzogMCAxcHggcmdiYSh2YXIoLS1jb2xvci1kYW5nZXItZGFyaykpLCB2YXIoLS1zaGFkb3ctc2Vjb25kYXJ5KTtcbiAgICB9XG5cblxuICAgIEBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDc2OXB4KSB7XG4gICAgICAgIDpnbG9iYWwoLmJ0bikge1xuICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMnB4O1xuICAgICAgICB9XG4gICAgICAgIC5idG4uc3VjY2VzcyB7XG4gICAgICAgICAgICBib3gtc2hhZG93OiAwIDNweCByZ2JhKHZhcigtLWNvbG9yLXN1Y2Nlc3MtZGFyaykpLCB2YXIoLS1zaGFkb3ctc2Vjb25kYXJ5KSwgdmFyKC0tc2hhZG93LXByaW1hcnkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLmJ0bi53YXJuaW5nIHtcbiAgICAgICAgICAgIGJveC1zaGFkb3c6IDAgM3B4IHJnYmEodmFyKC0tY29sb3Itd2FybmluZy1kYXJrKSksIHZhcigtLXNoYWRvdy1zZWNvbmRhcnkpLCB2YXIoLS1zaGFkb3ctcHJpbWFyeSk7XG4gICAgICAgIH1cblxuICAgICAgICAuYnRuLmRhbmdlciB7XG4gICAgICAgICAgICBib3gtc2hhZG93OiAwIDNweCByZ2JhKHZhcigtLWNvbG9yLWRhbmdlci1kYXJrKSksIHZhcigtLXNoYWRvdy1zZWNvbmRhcnkpLCB2YXIoLS1zaGFkb3ctcHJpbWFyeSk7XG4gICAgICAgIH1cbiAgICB9XG48L3N0eWxlPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyB0b0NTU1N0cmluZywgY2xhc3NuYW1lcyB9IGZyb20gJy4uL3V0aWxzJ1xuXG4gICAgZXhwb3J0IGxldCBpcyA9ICdpbmZvJ1xuICAgIGV4cG9ydCBsZXQgc2l6ZSA9IDBcbiAgICBleHBvcnQgbGV0IHdpZHRoID0gMlxuXG4gICAgJDogY2xhc3NQcm9wID0gY2xhc3NuYW1lcygnZGl2aWRlcicsIGlzLCAkJHByb3BzLmNsYXNzKVxuICAgICQ6IHN0eWxlUHJvcCA9IHRvQ1NTU3RyaW5nKHsgcGFkZGluZzogYCR7c2l6ZSAvIDJ9cHggMGAsIGhlaWdodDogYCR7d2lkdGh9cHhgIH0pXG48L3NjcmlwdD5cblxuPGhyIGNsYXNzPXtjbGFzc1Byb3B9IHN0eWxlPXtzdHlsZVByb3B9PlxuXG48c3R5bGU+XG4gICAgLmRpdmlkZXIge1xuICAgICAgICBtYXJnaW46IDA7XG4gICAgICAgIGJvcmRlcjogbm9uZTtcbiAgICAgICAgYm94LXNpemluZzogY29udGVudC1ib3g7XG4gICAgICAgIGJhY2tncm91bmQtY2xpcDogY29udGVudC1ib3g7XG4gICAgfVxuXG4gICAgLmluZm8ge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IodmFyKC0tY29sb3ItaW5mbykpO1xuICAgIH1cblxuICAgIC5zdWNjZXNzIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiKHZhcigtLWNvbG9yLXN1Y2Nlc3MpKTtcbiAgICB9XG5cbiAgICAud2FybmluZyB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYih2YXIoLS1jb2xvci13YXJuaW5nKSk7XG4gICAgfVxuXG4gICAgLmRhbmdlciB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYih2YXIoLS1jb2xvci1kYW5nZXIpKTtcbiAgICB9XG48L3N0eWxlPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBjcmVhdGVFdmVudERpc3BhdGNoZXIsIG9uTW91bnQgfSBmcm9tICdzdmVsdGUnXG4gICAgaW1wb3J0IHsgY2xhc3NuYW1lcywgc2FmZUdldCB9IGZyb20gJy4uL3V0aWxzJ1xuXG4gICAgY29uc3QgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXIoKVxuXG4gICAgZXhwb3J0IGxldCBpZCA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgdmFsdWUgPSAwIC8vIDAgLSAxMDBcbiAgICBleHBvcnQgbGV0IHNpemUgPSAnbWVkaXVtJ1xuICAgIGV4cG9ydCBsZXQgdGl0bGUgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IGFyaWFMYWJlbCA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgYm9yZGVyUmFkaXVzID0gdW5kZWZpbmVkXG5cbiAgICAkOiB2YWwgPSAwXG4gICAgJDogdGl0bGVQcm9wID0gdGl0bGUgfHwgYFByb2dyZXNzIC0gJHt2YWx9JWBcbiAgICAkOiBhcmlhTGFiZWxQcm9wID0gYXJpYUxhYmVsIHx8IGBQcm9ncmVzcyAtICR7dmFsfSVgXG4gICAgJDogY2xhc3NQcm9wID0gY2xhc3NuYW1lcygncHJvZ3Jlc3MnLCBzaXplLCAkJHByb3BzLmNsYXNzKVxuXG4gICAgb25Nb3VudCgoKSA9PiB7XG4gICAgICAgIC8vIE1ha2UgbG9hZGluZyBwcm9ncmVzcyBlZmZlY3Qgb24gbW91bnQgY29tcG9uZW50LlxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHZhbCA9IE51bWJlci5pc0Zpbml0ZSgrdmFsdWUpID8gTWF0aC5tYXgoMCwgTWF0aC5taW4oK3ZhbHVlLCAxMDApKSA6IDAsIDApXG4gICAgfSlcblxuICAgIGZ1bmN0aW9uIGdldEJvcmRlclJhZGl1cyhib3JkZXJzLCBkZWZhdWx0cyA9ICc5OTk5OXB4Jykge1xuICAgICAgICBjb25zdCBickRlZmF1bHQgPSBuZXcgQXJyYXkoNCkuZmlsbChkZWZhdWx0cylcbiAgICAgICAgY29uc3QgYmRzID0gc2FmZUdldCgoKSA9PiBib3JkZXJzLnNwbGl0KCcgJyksIFtdLCB0cnVlKVxuICAgICAgICBjb25zdCBydWxlID0gJ2JvcmRlci1yYWRpdXMnXG4gICAgICAgIHJldHVybiBgJHtydWxlfToke2JyRGVmYXVsdC5tYXAoKGRlZiwgaSkgPT4gYCR7YmRzW2ldIHx8IGRlZn1gKS5qb2luKCcgJyl9YFxuICAgIH1cbjwvc2NyaXB0PlxuXG5cbjxkaXZcbiAgICAgICAge2lkfVxuICAgICAgICBjbGFzcz17Y2xhc3NQcm9wfVxuICAgICAgICB0aXRsZT17dGl0bGVQcm9wfVxuICAgICAgICBhcmlhLWxhYmVsPXthcmlhTGFiZWxQcm9wfVxuICAgICAgICByb2xlPVwicHJvZ3Jlc3NiYXJcIlxuICAgICAgICBhcmlhLXZhbHVlbWluPVwiMFwiXG4gICAgICAgIGFyaWEtdmFsdWVtYXg9XCIxMDBcIlxuICAgICAgICBhcmlhLXZhbHVlbm93PXt2YWx9XG4gICAgICAgIHN0eWxlPXtgJHtnZXRCb3JkZXJSYWRpdXMoYm9yZGVyUmFkaXVzKX1gfVxuPlxuICAgIDxkaXYgY2xhc3M9XCJwcm9ncmVzcy1pbm5lci1mcmFtZVwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwicHJvZ3Jlc3MtY29yZVwiIHN0eWxlPXtgd2lkdGg6JHt2YWx9JWB9PjwvZGl2PlxuICAgIDwvZGl2PlxuPC9kaXY+XG5cbjxzdHlsZT5cbiAgICAucHJvZ3Jlc3Mge1xuICAgICAgICAtLXByb2dyZXNzLWhlaWdodDogMjBweDtcbiAgICAgICAgLS1wcm9ncmVzcy1wYWRkaW5nLXBvaW50OiAzO1xuICAgIH1cblxuICAgIC5wcm9ncmVzcy5zbWFsbCB7XG4gICAgICAgIC0tcHJvZ3Jlc3MtaGVpZ2h0OiAxNXB4O1xuICAgICAgICAtLXByb2dyZXNzLXBhZGRpbmctcG9pbnQ6IDM7XG4gICAgfVxuXG4gICAgLnByb2dyZXNzLm1lZGl1bSB7XG4gICAgICAgIC0tcHJvZ3Jlc3MtaGVpZ2h0OiAyMHB4O1xuICAgICAgICAtLXByb2dyZXNzLXBhZGRpbmctcG9pbnQ6IDMuNTtcbiAgICB9XG5cbiAgICAucHJvZ3Jlc3MuYmlnIHtcbiAgICAgICAgLS1wcm9ncmVzcy1oZWlnaHQ6IDMwcHg7XG4gICAgICAgIC0tcHJvZ3Jlc3MtcGFkZGluZy1wb2ludDogNDtcbiAgICB9XG5cbiAgICAucHJvZ3Jlc3Mge1xuICAgICAgICBmbGV4OiAwO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogOTk5OXB4O1xuICAgICAgICBoZWlnaHQ6IHZhcigtLXByb2dyZXNzLWhlaWdodCk7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEodmFyKC0tdGhlbWUtYmctY29sb3IpKTtcbiAgICAgICAgcGFkZGluZzogY2FsYyh2YXIoLS1wcm9ncmVzcy1oZWlnaHQpIC8gdmFyKC0tcHJvZ3Jlc3MtcGFkZGluZy1wb2ludCkpO1xuICAgICAgICBib3gtc2hhZG93OiBpbnNldCB2YXIoLS1zaGFkb3ctcHJpbWFyeSksIHZhcigtLXNoYWRvdy1zZWNvbmRhcnktaW5zZXQpO1xuICAgIH1cblxuICAgIC5wcm9ncmVzcy1pbm5lci1mcmFtZSB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDk5OTlweDtcbiAgICB9XG5cbiAgICAucHJvZ3Jlc3MtY29yZSB7XG4gICAgICAgIGZsZXg6IG5vbmU7XG4gICAgICAgIGFsaWduLXNlbGY6IHN0cmV0Y2g7XG4gICAgICAgIHRyYW5zaXRpb246IDFzIGVhc2UtaW4tb3V0O1xuICAgICAgICBtYXJnaW4tYm90dG9tOiAycHg7XG4gICAgICAgIGJveC1zaGFkb3c6IHZhcigtLXNoYWRvdy1wcmltYXJ5KTtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogdmFyKC0tYm9yZGVyLXJhZGl1cyk7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEodmFyKC0tY29sb3Itc3VjY2VzcykpO1xuICAgIH1cbjwvc3R5bGU+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IFN3aXBlLCBTd2lwZUl0ZW0gfSBmcm9tICcuLi9wbHVnaW5zJ1xuICAgIGltcG9ydCB7IFBpY3R1cmUgfSBmcm9tICcuLi9jb21wb25lbnRzJ1xuXG4gICAgY29uc3QgY2FyZHMgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIHNyYzogJ2h0dHBzOi8vcGxhY2VpbWcuY29tLzMwMC8zMDAvdGVjaCcsXG4gICAgICAgICAgICB0aXRsZTogJ1RoZSBtYWluIHRpdGxlIGFuZCBzaG9ydCBkZXNjcmlwdGlvbi4nLFxuICAgICAgICAgICAgcGVyY2VudDogNDUsXG4gICAgICAgICAgICBvcmdIZWFkOiAnVGluYSBLYW5kZWxha2knLFxuICAgICAgICAgICAgb3JnSGVhZFNyYzogJ2h0dHBzOi8vcGxhY2VpbWcuY29tLzMwMC8zMDAvcGVvcGxlJyxcbiAgICAgICAgICAgIG9yZ2FuaXphdGlvbjogJ09SRyBjaGFyaXR5IG9mIENoYXJpdGlmeS4nLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBzcmM6ICdodHRwczovL3BsYWNlaW1nLmNvbS8zMDAvMzAwL2FyY2gnLFxuICAgICAgICAgICAgdGl0bGU6ICdTZWNvbmQgYmlnZ2VyIG1ham9yIGNhcmQgdGl0bGUgbGluZSB3aXRoIGEgYml0IGxvbmdlciBkZXNjcmlwdGlvbi4nLFxuICAgICAgICAgICAgcGVyY2VudDogNjUsXG4gICAgICAgICAgICBvcmdIZWFkOiAnVGluYSBLYW5kZWxha2knLFxuICAgICAgICAgICAgb3JnSGVhZFNyYzogJ2h0dHBzOi8vcGxhY2VpbWcuY29tLzMwMC8zMDAvcGVvcGxlJyxcbiAgICAgICAgICAgIG9yZ2FuaXphdGlvbjogJ09SRyBjaGFyaXR5IG9mIENoYXJpdGlmeS4nLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBzcmM6ICdodHRwczovL3BsYWNlaW1nLmNvbS8zMDAvMzAwL2FueScsXG4gICAgICAgICAgICB0aXRsZTogJ1RoZSBtYWluIHRpdGxlIGFuZCBzaG9ydCBkZXNjcmlwdGlvbi4nLFxuICAgICAgICAgICAgcGVyY2VudDogNSxcbiAgICAgICAgICAgIG9yZ0hlYWQ6ICdUaW5hcmFtaXNpbXVzcyBLYW5kZWxha2ludXNrYXMnLFxuICAgICAgICAgICAgb3JnSGVhZFNyYzogJ2h0dHBzOi8vcGxhY2VpbWcuY29tLzMwMC8zMDAvcGVvcGxlJyxcbiAgICAgICAgICAgIG9yZ2FuaXphdGlvbjogJ09SRyBjaGFyaXR5IG9mIENoYXJpdGlmeS4nLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBzcmM6ICdodHRwczovL3BsYWNlaW1nLmNvbS8zMDAvMzAwL25hdHVyZScsXG4gICAgICAgICAgICB0aXRsZTogJ1RoZSBtYWluIHRpdGxlIGFuZCBzaG9ydCBkZXNjcmlwdGlvbi4nLFxuICAgICAgICAgICAgcGVyY2VudDogOTUsXG4gICAgICAgICAgICBvcmdIZWFkOiAnVGluYSBLYW5kZWxha2knLFxuICAgICAgICAgICAgb3JnSGVhZFNyYzogJ2h0dHBzOi8vcGxhY2VpbWcuY29tLzMwMC8zMDAvcGVvcGxlJyxcbiAgICAgICAgICAgIG9yZ2FuaXphdGlvbjogJ09SRyBnaWFudCBjaGFyaXR5IG9yZ2FuaXphdGlvbiBvZiBiaWcgQ2hhcml0aWZ5IGNvbXBhbnkuJyxcbiAgICAgICAgfSxcbiAgICBdXG5cbiAgICBjb25zdCBpbWFnZXNEZWZhdWx0ID0gY2FyZHMubWFwKGNhcmQgPT4gKHtcbiAgICAgICAgc3JjOiBbY2FyZC5zcmMsIGNhcmQuc3JjLCBjYXJkLnNyY10sXG4gICAgICAgIGFsdDogY2FyZC50aXRsZSxcbiAgICB9KSlcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHR5cGUge3tcbiAgICAgKiAgICAgc3JjOiBzdHJpbmcsXG4gICAgICogICAgIGFsdDogc3RyaW5nLFxuICAgICAqICAgICBvbkNsaWNrPzogZnVuY3Rpb24sXG4gICAgICogfVtdfVxuICAgICAqL1xuICAgIGV4cG9ydCBsZXQgaW1hZ2VzID0gaW1hZ2VzRGVmYXVsdFxuXG4gICAgJDogaW1hZ2VzQXJyID0gW10uY29uY2F0KGltYWdlcykubWFwKGltZyA9PiB0eXBlb2YgaW1nID09PSAnc3RyaW5nJyA/IHsgc3JjOiBpbWcgfSA6IGltZylcbjwvc2NyaXB0PlxuXG48c2VjdGlvbj5cbiAgICA8U3dpcGU+XG4gICAgICAgIHsjZWFjaCBpbWFnZXNBcnIgYXMgaW1nfVxuICAgICAgICAgICAgPFN3aXBlSXRlbT5cbiAgICAgICAgICAgICAgICA8UGljdHVyZSBzcmM9e2ltZy5zcmN9IGFsdD17aW1nLmFsdH0vPlxuICAgICAgICAgICAgPC9Td2lwZUl0ZW0+XG4gICAgICAgIHsvZWFjaH1cbiAgICA8L1N3aXBlPlxuPC9zZWN0aW9uPlxuXG48c3R5bGU+XG4gICAgc2VjdGlvbiB7XG4gICAgICAgIHotaW5kZXg6IDA7XG4gICAgICAgIGZsZXgtZ3JvdzogMTtcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgbWFyZ2luLWJvdHRvbTogMnB4O1xuICAgICAgICBib3gtc2hhZG93OiB2YXIoLS1zaGFkb3ctcHJpbWFyeSk7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IHZhcigtLWJvcmRlci1yYWRpdXMpO1xuICAgIH1cbjwvc3R5bGU+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IEF2YXRhciB9IGZyb20gJy4uL2NvbXBvbmVudHMnXG5cbiAgICBleHBvcnQgbGV0IHNyYyA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgdGl0bGUgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IHN1YnRpdGxlID0gdW5kZWZpbmVkXG48L3NjcmlwdD5cblxuPHNlY3Rpb24+XG4gICAgPEF2YXRhciBzcmM9e3NyY30gYWx0PXt0aXRsZX0vPlxuXG4gICAgPHNwYW4+XG4gICAgICAgIDxoND57dGl0bGV9PC9oND5cbiAgICAgICAgPHA+e3N1YnRpdGxlfTwvcD5cbiAgICA8L3NwYW4+XG48L3NlY3Rpb24+XG5cbjxzdHlsZT5cbiAgICBzZWN0aW9uIHtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIGZsZXgtZ3JvdzogMTtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgYWxpZ24tc2VsZjogc3RyZXRjaDtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICB9XG5cbiAgICBzcGFuIHtcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgcGFkZGluZzogMCA4cHg7XG4gICAgfVxuc1xuICAgIHNwYW4gaDQsXG4gICAgc3BhbiBwIHtcbiAgICAgICAgbGluZS1oZWlnaHQ6IDEuMjtcbiAgICAgICAgbWF4LXdpZHRoOiAxMDAlO1xuICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICB3aGl0ZS1zcGFjZTogbm93cmFwO1xuICAgICAgICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcbiAgICB9XG48L3N0eWxlPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBSYXRlLCBQcm9ncmVzcywgQXZhdGFyIH0gZnJvbSAnLi4vY29tcG9uZW50cydcbiAgICBpbXBvcnQgQ2Fyb3VzZWwgZnJvbSAnLi9DYXJvdXNlbC5zdmVsdGUnXG4gICAgaW1wb3J0IEF2YXRhckFuZE5hbWUgZnJvbSAnLi9BdmF0YXJBbmROYW1lLnN2ZWx0ZSdcblxuICAgIGV4cG9ydCBsZXQgc3JjID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCB0aXRsZSA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgcGVyY2VudCA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgb3JnSGVhZCA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgb3JnSGVhZFNyYyA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgb3JnYW5pemF0aW9uID0gdW5kZWZpbmVkXG48L3NjcmlwdD5cblxuPHNlY3Rpb24gY2xhc3M9XCJjYXJkXCI+XG4gICAgPGRpdiBjbGFzcz1cImltYWdlcy13cmFwXCI+XG4gICAgICAgIDxDYXJvdXNlbCBpbWFnZXM9e3NyY30vPlxuICAgIDwvZGl2PlxuXG4gICAgPFByb2dyZXNzIHZhbHVlPXtwZXJjZW50fSBib3JkZXJSYWRpdXM9XCIwIDBcIi8+XG5cbiAgICA8aDQ+e3RpdGxlfTwvaDQ+XG5cbiAgICA8ZGl2IGNsYXNzPVwicmF0ZS13cmFwXCI+XG4gICAgICAgIDxSYXRlIHNpemU9XCJzbWFsbFwiLz5cbiAgICA8L2Rpdj5cblxuICAgIDxmb290ZXI+XG4gICAgICAgIDxBdmF0YXJBbmROYW1lIHNyYz17b3JnSGVhZFNyY30gdGl0bGU9e29yZ0hlYWR9IHN1YnRpdGxlPXtvcmdhbml6YXRpb259Lz5cbiAgICA8L2Zvb3Rlcj5cbjwvc2VjdGlvbj5cblxuPHN0eWxlPlxuICAgIC5jYXJkIHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAgZmxleDogbm9uZTtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIG1heC13aWR0aDogMTAwJTtcbiAgICB9XG5cbiAgICAucmF0ZS13cmFwIHtcbiAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgICAgICBwYWRkaW5nLXRvcDogNnB4O1xuICAgIH1cblxuICAgIC5pbWFnZXMtd3JhcCB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGhlaWdodDogMTAwcHg7XG4gICAgfVxuXG4gICAgaDQge1xuICAgICAgICAtLWNhcmQtbGluZS1oZWlnaHQ6IDEuNDtcblxuICAgICAgICBmb250LXNpemU6IC44ZW07XG4gICAgICAgIGxpbmUtaGVpZ2h0OiB2YXIoLS1jYXJkLWxpbmUtaGVpZ2h0KTtcbiAgICAgICAgaGVpZ2h0OiBjYWxjKHZhcigtLWZvbnQtc2l6ZSkgKiAodmFyKC0tY2FyZC1saW5lLWhlaWdodCkgLyAxLjIpICogMik7XG4gICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgfVxuPC9zdHlsZT5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgRGl2aWRlciB9IGZyb20gJy4uL2NvbXBvbmVudHMnXG4gICAgaW1wb3J0IENoYXJpdHlDYXJkIGZyb20gJy4uL2xheW91dHMvQ2hhcml0eUNhcmQuc3ZlbHRlJ1xuXG4gICAgZXhwb3J0IGxldCBhbW91bnQgPSAyXG5cbiAgICAkOiBjYXJkcyA9IFtcbiAgICAgICAge1xuICAgICAgICAgICAgc3JjOiAnaHR0cHM6Ly9wbGFjZWltZy5jb20vMzAwLzMwMC90ZWNoJyxcbiAgICAgICAgICAgIHRpdGxlOiAnVGhlIG1haW4gdGl0bGUgYW5kIHNob3J0IGRlc2NyaXB0aW9uLicsXG4gICAgICAgICAgICBwZXJjZW50OiA0NSxcbiAgICAgICAgICAgIG9yZ0hlYWQ6ICdUaW5hIEthbmRlbGFraScsXG4gICAgICAgICAgICBvcmdIZWFkU3JjOiAnaHR0cHM6Ly9wbGFjZWltZy5jb20vMzAwLzMwMC9wZW9wbGUnLFxuICAgICAgICAgICAgb3JnYW5pemF0aW9uOiAnT1JHIGNoYXJpdHkgb2YgQ2hhcml0aWZ5LicsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHNyYzogJ2h0dHBzOi8vcGxhY2VpbWcuY29tLzMwMC8zMDAvYXJjaCcsXG4gICAgICAgICAgICB0aXRsZTogJ1NlY29uZCBiaWdnZXIgbWFqb3IgY2FyZCB0aXRsZSBsaW5lIHdpdGggYSBiaXQgbG9uZ2VyIGRlc2NyaXB0aW9uLicsXG4gICAgICAgICAgICBwZXJjZW50OiA2NSxcbiAgICAgICAgICAgIG9yZ0hlYWQ6ICdUaW5hIEthbmRlbGFraScsXG4gICAgICAgICAgICBvcmdIZWFkU3JjOiAnaHR0cHM6Ly9wbGFjZWltZy5jb20vMzAwLzMwMC9wZW9wbGUnLFxuICAgICAgICAgICAgb3JnYW5pemF0aW9uOiAnT1JHIGNoYXJpdHkgb2YgQ2hhcml0aWZ5LicsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHNyYzogJ2h0dHBzOi8vcGxhY2VpbWcuY29tLzMwMC8zMDAvYW55JyxcbiAgICAgICAgICAgIHRpdGxlOiAnVGhlIG1haW4gdGl0bGUgYW5kIHNob3J0IGRlc2NyaXB0aW9uLicsXG4gICAgICAgICAgICBwZXJjZW50OiA1LFxuICAgICAgICAgICAgb3JnSGVhZDogJ1RpbmFyYW1pc2ltdXNzIEthbmRlbGFraW51c2thcycsXG4gICAgICAgICAgICBvcmdIZWFkU3JjOiAnaHR0cHM6Ly9wbGFjZWltZy5jb20vMzAwLzMwMC9wZW9wbGUnLFxuICAgICAgICAgICAgb3JnYW5pemF0aW9uOiAnT1JHIGNoYXJpdHkgb2YgQ2hhcml0aWZ5LicsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHNyYzogJ2h0dHBzOi8vcGxhY2VpbWcuY29tLzMwMC8zMDAvbmF0dXJlJyxcbiAgICAgICAgICAgIHRpdGxlOiAnVGhlIG1haW4gdGl0bGUgYW5kIHNob3J0IGRlc2NyaXB0aW9uLicsXG4gICAgICAgICAgICBwZXJjZW50OiA5NSxcbiAgICAgICAgICAgIG9yZ0hlYWQ6ICdUaW5hIEthbmRlbGFraScsXG4gICAgICAgICAgICBvcmdIZWFkU3JjOiAnaHR0cHM6Ly9wbGFjZWltZy5jb20vMzAwLzMwMC9wZW9wbGUnLFxuICAgICAgICAgICAgb3JnYW5pemF0aW9uOiAnT1JHIGdpYW50IGNoYXJpdHkgb3JnYW5pemF0aW9uIG9mIGJpZyBDaGFyaXRpZnkgY29tcGFueS4nLFxuICAgICAgICB9LFxuICAgIF0uc2xpY2UoTnVtYmVyLmlzRmluaXRlKCthbW91bnQpID8gK2Ftb3VudCA6IDApXG5cbiAgICAkOiBpbWFnZXMgPSBjYXJkcy5tYXAoY2FyZCA9PiAoe1xuICAgICAgICBzcmM6IFtjYXJkLnNyYywgY2FyZC5zcmMsIGNhcmQuc3JjXSxcbiAgICAgICAgYWx0OiBjYXJkLnRpdGxlLFxuICAgIH0pKVxuPC9zY3JpcHQ+XG5cbjxEaXZpZGVyIHNpemU9XCIxNlwiLz5cbjxoMiBzdHlsZT1cInRleHQtYWxpZ246IHJpZ2h0XCI+VGhlIHNlY29uZCBsaXN0OjwvaDI+XG48RGl2aWRlciBzaXplPVwiMjBcIi8+XG48YnI+XG48dWwgY2xhc3M9XCJjYXJkc1wiPlxuICAgIHsjZWFjaCBjYXJkcyBhcyBjYXJkfVxuICAgICAgICA8bGk+XG4gICAgICAgICAgICA8Q2hhcml0eUNhcmQgey4uLmNhcmR9Lz5cbiAgICAgICAgPC9saT5cbiAgICB7L2VhY2h9XG48L3VsPlxuXG48c3R5bGU+XG4gICAgLmNhcmRzIHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgZmxleC13cmFwOiB3cmFwO1xuICAgICAgICBhbGlnbi1pdGVtczogZmxleC1zdGFydDtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgIHBhZGRpbmc6IHZhcigtLXNjcmVlbi1wYWRkaW5nKSAwO1xuICAgICAgICBtYXJnaW46IGNhbGModmFyKC0tc2NyZWVuLXBhZGRpbmcpICogLTMpIGNhbGModmFyKC0tc2NyZWVuLXBhZGRpbmcpICogLTEpO1xuICAgIH1cblxuICAgIC5jYXJkcyBsaSB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogc3RyZXRjaDtcbiAgICAgICAgd2lkdGg6IDUwJTtcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgcGFkZGluZzogY2FsYyh2YXIoLS1zY3JlZW4tcGFkZGluZykgKiAzKSB2YXIoLS1zY3JlZW4tcGFkZGluZyk7XG4gICAgfVxuXG4gICAgLmNhcmRzIGxpOmhvdmVyIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAwLCAwLCAuMSlcbiAgICB9XG48L3N0eWxlPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBJY29uLCBCdXR0b24sIEF2YXRhciB9IGZyb20gJy4uL2NvbXBvbmVudHMnXG5cbiAgICBleHBvcnQgbGV0IHNlZ21lbnRcblxuICAgIGxldCBpc0RhcmtUaGVtZSA9IGZhbHNlXG5cbiAgICBsZXQgdmFsdWUgPSAndWEnXG5cbiAgICBmdW5jdGlvbiBjaGFuZ2VUaGVtZSgpIHtcbiAgICAgICAgaXNEYXJrVGhlbWUgPSAhaXNEYXJrVGhlbWVcbiAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKCd0aGVtZS1kYXJrJylcbiAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKCd0aGVtZS1saWdodCcpXG4gICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZChpc0RhcmtUaGVtZSA/ICd0aGVtZS1kYXJrJyA6ICd0aGVtZS1saWdodCcpXG4gICAgfVxuPC9zY3JpcHQ+XG5cbjxuYXYgY2xhc3M9XCJ0aGVtZS1iZyBjb250YWluZXJcIj5cbiAgICA8dWw+XG4gICAgICAgIDxsaT48YSBjbGFzczpzZWxlY3RlZD0ne3NlZ21lbnQgPT09IHVuZGVmaW5lZH0nIGhyZWY9Jy4nPmhvbWU8L2E+PC9saT5cbiAgICAgICAgPGxpPjxhIGNsYXNzOnNlbGVjdGVkPSd7c2VnbWVudCA9PT0gXCJsaXN0XCJ9JyBocmVmPSdsaXN0Jz5saXN0PC9hPjwvbGk+XG4gICAgICAgIDxsaT48YSByZWw9cHJlZmV0Y2ggY2xhc3M6c2VsZWN0ZWQ9J3tzZWdtZW50ID09PSBcImNoYXJpdHlcIn0nIGhyZWY9J2NoYXJpdHknPmNoYXJpdHk8L2E+PC9saT5cbiAgICAgICAgPGxpPjxhIGNsYXNzOnNlbGVjdGVkPSd7c2VnbWVudCA9PT0gXCJhYm91dFwifScgaHJlZj0nYWJvdXQnPmFib3V0PC9hPjwvbGk+XG4gICAgPC91bD5cblxuICAgIDx1bCBjbGFzcz1cIm5hdi1hY3Rpb25zXCI+XG4gICAgICAgIDxsaT5cbiAgICAgICAgICAgIDxzZWxlY3Qge3ZhbHVlfSBuYW1lPVwibGFuZ1wiIGlkPVwibGFuZ1wiIGNsYXNzPVwiYnRuIHNtYWxsIGxhbmctc2VsZWN0XCI+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInVhXCI+VWE8L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicnVcIj5SdTwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJlblwiPkVuPC9vcHRpb24+XG4gICAgICAgICAgICA8L3NlbGVjdD5cbiAgICAgICAgPC9saT5cblxuICAgICAgICA8bGk+XG4gICAgICAgICAgICA8QnV0dG9uIG9uOmNsaWNrPXtjaGFuZ2VUaGVtZX0gYXV0byBzaXplPVwic21hbGxcIj5cbiAgICAgICAgICAgICAgICA8SWNvbiB0eXBlPVwibW9vblwiIGNsYXNzPVwidGhlbWUtc3ZnLWZpbGxcIi8+XG4gICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgPC9saT5cblxuICAgICAgICA8bGk+XG4gICAgICAgICAgICA8QnV0dG9uIG9uOmNsaWNrPXtjaGFuZ2VUaGVtZX0gYXV0byBzaXplPVwic21hbGxcIj5cbiAgICAgICAgICAgICAgICA8QXZhdGFyIHNpemU9XCJzbWFsbFwiIHNyYz1cImh0dHBzOi8vcGxhY2VpbWcuY29tLzMwMC8zMDAvcGVvcGxlXCIvPlxuICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgIDwvbGk+XG4gICAgPC91bD5cbjwvbmF2PlxuXG48c3R5bGU+XG4gICAgbmF2IHtcbiAgICAgICAgcG9zaXRpb246IHN0aWNreTtcbiAgICAgICAgdG9wOiAwO1xuICAgICAgICB6LWluZGV4OiAxMDtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgICAgICBib3gtc2hhZG93OiB2YXIoLS1zaGFkb3ctc2Vjb25kYXJ5KTtcbiAgICAgICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkIHJnYmEodmFyKC0tY29sb3ItZGFuZ2VyKSwgLjEpO1xuICAgIH1cblxuICAgIC5zZWxlY3RlZCB7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgIH1cblxuICAgIC5zZWxlY3RlZDo6YWZ0ZXIge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIGNvbnRlbnQ6IFwiXCI7XG4gICAgICAgIHdpZHRoOiBjYWxjKDEwMCUgLSAxZW0pO1xuICAgICAgICBoZWlnaHQ6IDJweDtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiKHZhcigtLWNvbG9yLWRhbmdlcikpO1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgYm90dG9tOiAtMXB4O1xuICAgIH1cblxuICAgIGEge1xuICAgICAgICBwYWRkaW5nOiAuOGVtIDAuNWVtO1xuICAgIH1cblxuICAgIC5uYXYtYWN0aW9ucyB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgIG1hcmdpbjogLTNweDtcbiAgICB9XG5cbiAgICAubmF2LWFjdGlvbnMgbGkge1xuICAgICAgICBwYWRkaW5nOiAzcHg7XG4gICAgfVxuXG4gICAgLmxhbmctc2VsZWN0IHtcbiAgICAgICAgcGFkZGluZzogNXB4O1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcbiAgICB9XG5cbiAgICAubGFuZy1zZWxlY3Q6aG92ZXIsXG4gICAgLmxhbmctc2VsZWN0OmZvY3VzIHtcbiAgICAgICAgYm94LXNoYWRvdzogbm9uZTtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSh2YXIoLS1jb2xvci1ibGFjayksIDAuMSk7XG4gICAgfVxuPC9zdHlsZT5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgSW5wdXQsIEJ1dHRvbiB9IGZyb20gJy4uL2NvbXBvbmVudHMnXG48L3NjcmlwdD5cblxuPHVsPlxuICAgIDxsaT5cbiAgICAgICAgPEJ1dHRvbiBpcz1cInN1Y2Nlc3NcIiBvbjpjbGljaz1cIntlID0+IGNvbnNvbGUubG9nKGUpfVwiPnRlc3QxPC9CdXR0b24+XG4gICAgPC9saT5cbiAgICA8bGk+XG4gICAgICAgIDxCdXR0b24gaXM9XCJzdWNjZXNzXCIgb246Y2xpY2s9XCJ7ZSA9PiBjb25zb2xlLmxvZyhlKX1cIj50ZXN0MTI8L0J1dHRvbj5cbiAgICA8L2xpPlxuICAgIDxsaT5cbiAgICAgICAgPEJ1dHRvbiBpcz1cInN1Y2Nlc3NcIiBvbjpjbGljaz1cIntlID0+IGNvbnNvbGUubG9nKGUpfVwiPnRlc3QxMjM8L0J1dHRvbj5cbiAgICA8L2xpPlxuICAgIDxsaT5cbiAgICAgICAgPGJyPlxuICAgICAgICA8SW5wdXRcbiAgICAgICAgICAgICAgICB0eXBlPVwibnVtYmVyXCJcbiAgICAgICAgICAgICAgICBuYW1lPVwibnVtXCJcbiAgICAgICAgICAgICAgICBsaXN0PVwic3VtLXN1Z2dlc3Rpb25zXCJcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cIk51bVwiXG4gICAgICAgICAgICAgICAgYXV0b3NlbGVjdFxuICAgICAgICAgICAgICAgIGFsaWduPVwicmlnaHRcIlxuICAgICAgICAvPlxuXG4gICAgICAgIDxkYXRhbGlzdCBpZD1cInN1bS1zdWdnZXN0aW9uc1wiPlxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIjIwXCI+XG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiNTAwXCI+XG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiMTAwMFwiPlxuICAgICAgICA8L2RhdGFsaXN0PlxuICAgIDwvbGk+XG4gICAgPGxpPlxuICAgICAgICA8QnV0dG9uIGlzPVwid2FybmluZ1wiIG9uOmNsaWNrPVwie2UgPT4gY29uc29sZS5sb2coZSl9XCI+U3VibWl0PC9CdXR0b24+XG4gICAgPC9saT5cbjwvdWw+XG5cbjxzdHlsZT5cbiAgICB1bCB7XG4gICAgICAgIGZsZXg6IDA7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICAgIG1hcmdpbjogY2FsYyh2YXIoLS1zY3JlZW4tcGFkZGluZykgKiAtMSAvIDIpIDA7XG4gICAgICAgIHBhZGRpbmc6IDAgMCAwIHZhcigtLXNjcmVlbi1wYWRkaW5nKTtcbiAgICB9XG5cbiAgICB1bCBsaSB7XG4gICAgICAgIGZsZXg6IG5vbmU7XG4gICAgICAgIG1hcmdpbjogY2FsYyh2YXIoLS1zY3JlZW4tcGFkZGluZykgLyAyKSAwO1xuICAgIH1cbjwvc3R5bGU+XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztvQkFLcUIsSUFBSSxHQUFHLFdBQVc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7aUNDa1BwQixHQUFVOzs7Z0NBQWYsTUFBSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0NBQUMsR0FBVTs7OytCQUFmLE1BQUk7Ozs7Ozs7Ozs7Ozs7Ozs7b0NBQUosTUFBSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7NEVBQ2dCLEdBQWUsYUFBSSxHQUFDO0tBQUcsV0FBVztLQUFHLEVBQUU7Ozs7Ozs7Ozs7O2tIQUF2QyxHQUFlLGFBQUksR0FBQztLQUFHLFdBQVc7S0FBRyxFQUFFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7bUNBSGhFLEdBQWM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7aURBRGdELEdBQVM7Z0RBQWdCLEdBQVM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBCQUNoRyxHQUFjOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQWhQUixrQkFBa0IsR0FBRyxHQUFHO09BQ3hCLGNBQWMsR0FBRyxLQUFLO09BQ3RCLFFBQVEsR0FBRyxLQUFLO09BQ2hCLEtBQUssR0FBRyxJQUFJO0tBSW5CLGVBQWUsR0FBRyxDQUFDO0tBQ25CLFVBQVU7S0FDVixLQUFLLEdBQUcsQ0FBQztLQUNULGNBQWMsR0FBRyxDQUFDO0tBQ2xCLFlBQVksR0FBRyxDQUFDO0tBRWhCLEtBQUs7S0FDTCxJQUFJLEdBQUcsQ0FBQztLQUVSLFlB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Ozs7Ozs7Ozs7Ozs7OzZDQUhuQixHQUFPLFFBQUssU0FBUzs7Ozs2Q0FDckIsR0FBTyxRQUFLLE1BQU07Ozs7NkNBQ0wsR0FBTyxRQUFLLFNBQVM7Ozs7NkNBQ2xDLEdBQU8sUUFBSyxPQUFPOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FuQnBDLE9BQU87S0FFZCxXQUFXLEdBQUcsS0FBSztLQUVuQixLQUFLLEdBQUcsSUFBSTs7VUFFUCxXQUFXO0VBQ2hCLFdBQVcsSUFBSSxXQUFXO0VBQzFCLFFBQVEsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxZQUFZO0VBQzNDLFFBQVEsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxhQUFhO0VBQzVDLFFBQVEsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxXQUFXLEdBQUcsWUFBWSxHQUFHLGFBQWE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7dUJDUHRDLENBQUMsSUFBSSxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7eUJBR2xCLENBQUMsSUFBSSxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7eUJBR2xCLENBQUMsSUFBSSxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7eUJBb0JsQixDQUFDLElBQUksT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsifQ==
