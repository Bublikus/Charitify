import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, _ as FancyBox, B as Br, v as validate_slots, a1 as Avatar, O as Loader, a2 as SocialsX, a3 as SocialsY, Q as empty, r as insert_dev, R as group_outros, y as transition_out, U as check_outros, x as transition_in, h as detach_dev, g as create_component, f as space, m as claim_component, j as claim_space, u as mount_component, z as destroy_component, e as element, k as claim_element, l as children, p as add_location, o as attr_dev, a as append_dev, G as set_style, w as noop, t as text, n as claim_text, N as set_data_dev, a8 as FormBuilder, a0 as Card, Z as safeGet, I as Icon, H as Button, ah as EditArea, K as FundCards, W as onMount, af as API, ag as delay } from './client.02b1df94.js';

/* src/routes/users/_components/_UserCardView.svelte generated by Svelte v3.24.0 */
const file = "src/routes/users/_components/_UserCardView.svelte";

// (16:12) <section slot="box" class="flex full-width full-height" style="height: 100vw">
function create_box_slot(ctx) {
	let section;
	let div;
	let avatar;
	let current;

	avatar = new Avatar({
			props: {
				src: /*src*/ ctx[0],
				srcBig: /*srcBig*/ ctx[1],
				alt: "ava"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			section = element("section");
			div = element("div");
			create_component(avatar.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { slot: true, class: true, style: true });
			var section_nodes = children(section);
			div = claim_element(section_nodes, "DIV", { class: true, style: true });
			var div_nodes = children(div);
			claim_component(avatar.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "flex flex-self-stretch flex-1 overflow-hidden flex-justify-stretch");
			set_style(div, "padding", "var(--screen-padding) 0");
			add_location(div, file, 16, 16, 517);
			attr_dev(section, "slot", "box");
			attr_dev(section, "class", "flex full-width full-height");
			set_style(section, "height", "100vw");
			add_location(section, file, 15, 12, 422);
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			append_dev(section, div);
			mount_component(avatar, div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const avatar_changes = {};
			if (dirty & /*src*/ 1) avatar_changes.src = /*src*/ ctx[0];
			if (dirty & /*srcBig*/ 2) avatar_changes.srcBig = /*srcBig*/ ctx[1];
			avatar.$set(avatar_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(avatar.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(avatar.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			destroy_component(avatar);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_box_slot.name,
		type: "slot",
		source: "(16:12) <section slot=\\\"box\\\" class=\\\"flex full-width full-height\\\" style=\\\"height: 100vw\\\">",
		ctx
	});

	return block;
}

// (14:8) <FancyBox class="flex-justify-center">
function create_default_slot(ctx) {
	let avatar;
	let t;
	let current;

	avatar = new Avatar({
			props: {
				size: "big",
				src: /*src*/ ctx[0],
				alt: "Організація"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(avatar.$$.fragment);
			t = space();
		},
		l: function claim(nodes) {
			claim_component(avatar.$$.fragment, nodes);
			t = claim_space(nodes);
		},
		m: function mount(target, anchor) {
			mount_component(avatar, target, anchor);
			insert_dev(target, t, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const avatar_changes = {};
			if (dirty & /*src*/ 1) avatar_changes.src = /*src*/ ctx[0];
			avatar.$set(avatar_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(avatar.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(avatar.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(avatar, detaching);
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(14:8) <FancyBox class=\\\"flex-justify-center\\\">",
		ctx
	});

	return block;
}

// (25:4) {#if title !== undefined}
function create_if_block_4(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_5, create_else_block_1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*title*/ ctx[2] !== null) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4.name,
		type: "if",
		source: "(25:4) {#if title !== undefined}",
		ctx
	});

	return block;
}

// (28:4) {:else}
function create_else_block_1(ctx) {
	let div;
	let loader;
	let current;
	loader = new Loader({ props: { type: "h2" }, $$inline: true });

	const block = {
		c: function create() {
			div = element("div");
			create_component(loader.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { style: true });
			var div_nodes = children(div);
			claim_component(loader.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_style(div, "width", "200px");
			add_location(div, file, 28, 8, 893);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(loader, div, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(loader.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loader.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(loader);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1.name,
		type: "else",
		source: "(28:4) {:else}",
		ctx
	});

	return block;
}

// (26:4) {#if title !== null}
function create_if_block_5(ctx) {
	let h2;
	let t;

	const block = {
		c: function create() {
			h2 = element("h2");
			t = text(/*title*/ ctx[2]);
			this.h();
		},
		l: function claim(nodes) {
			h2 = claim_element(nodes, "H2", {});
			var h2_nodes = children(h2);
			t = claim_text(h2_nodes, /*title*/ ctx[2]);
			h2_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(h2, file, 26, 8, 856);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h2, anchor);
			append_dev(h2, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*title*/ 4) set_data_dev(t, /*title*/ ctx[2]);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(h2);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_5.name,
		type: "if",
		source: "(26:4) {#if title !== null}",
		ctx
	});

	return block;
}

// (33:4) {#if title !== undefined}
function create_if_block_2(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_3, create_else_block];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*title*/ ctx[2] !== null) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_1(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(33:4) {#if title !== undefined}",
		ctx
	});

	return block;
}

// (36:4) {:else}
function create_else_block(ctx) {
	let div;
	let loader;
	let current;
	loader = new Loader({ props: { type: "p" }, $$inline: true });

	const block = {
		c: function create() {
			div = element("div");
			create_component(loader.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { style: true });
			var div_nodes = children(div);
			claim_component(loader.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_style(div, "width", "100px");
			add_location(div, file, 36, 8, 1085);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(loader, div, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(loader.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loader.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(loader);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(36:4) {:else}",
		ctx
	});

	return block;
}

// (34:4) {#if title !== null}
function create_if_block_3(ctx) {
	let p;
	let t;

	const block = {
		c: function create() {
			p = element("p");
			t = text(/*subtitle*/ ctx[3]);
			this.h();
		},
		l: function claim(nodes) {
			p = claim_element(nodes, "P", {});
			var p_nodes = children(p);
			t = claim_text(p_nodes, /*subtitle*/ ctx[3]);
			p_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(p, file, 34, 8, 1047);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*subtitle*/ 8) set_data_dev(t, /*subtitle*/ ctx[3]);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(34:4) {#if title !== null}",
		ctx
	});

	return block;
}

// (42:0) {#if Array.isArray(itemsX)}
function create_if_block_1(ctx) {
	let br;
	let t;
	let socialsx;
	let current;
	br = new Br({ props: { size: "30" }, $$inline: true });

	socialsx = new SocialsX({
			props: { items: /*itemsX*/ ctx[4] },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(br.$$.fragment);
			t = space();
			create_component(socialsx.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(br.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(socialsx.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(br, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(socialsx, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const socialsx_changes = {};
			if (dirty & /*itemsX*/ 16) socialsx_changes.items = /*itemsX*/ ctx[4];
			socialsx.$set(socialsx_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(br.$$.fragment, local);
			transition_in(socialsx.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br.$$.fragment, local);
			transition_out(socialsx.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(br, detaching);
			if (detaching) detach_dev(t);
			destroy_component(socialsx, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(42:0) {#if Array.isArray(itemsX)}",
		ctx
	});

	return block;
}

// (47:0) {#if Array.isArray(itemsY)}
function create_if_block(ctx) {
	let br;
	let t;
	let socialsy;
	let current;
	br = new Br({ props: { size: "30" }, $$inline: true });

	socialsy = new SocialsY({
			props: { items: /*itemsY*/ ctx[5] },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(br.$$.fragment);
			t = space();
			create_component(socialsy.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(br.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(socialsy.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(br, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(socialsy, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const socialsy_changes = {};
			if (dirty & /*itemsY*/ 32) socialsy_changes.items = /*itemsY*/ ctx[5];
			socialsy.$set(socialsy_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(br.$$.fragment, local);
			transition_in(socialsy.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br.$$.fragment, local);
			transition_out(socialsy.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(br, detaching);
			if (detaching) detach_dev(t);
			destroy_component(socialsy, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(47:0) {#if Array.isArray(itemsY)}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let div;
	let span;
	let fancybox;
	let t0;
	let br0;
	let t1;
	let t2;
	let br1;
	let t3;
	let t4;
	let show_if_1 = Array.isArray(/*itemsX*/ ctx[4]);
	let t5;
	let show_if = Array.isArray(/*itemsY*/ ctx[5]);
	let if_block3_anchor;
	let current;

	fancybox = new FancyBox({
			props: {
				class: "flex-justify-center",
				$$slots: {
					default: [create_default_slot],
					box: [create_box_slot]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	br0 = new Br({ props: { size: "20" }, $$inline: true });
	let if_block0 = /*title*/ ctx[2] !== undefined && create_if_block_4(ctx);
	br1 = new Br({ props: { size: "4" }, $$inline: true });
	let if_block1 = /*title*/ ctx[2] !== undefined && create_if_block_2(ctx);
	let if_block2 = show_if_1 && create_if_block_1(ctx);
	let if_block3 = show_if && create_if_block(ctx);

	const block = {
		c: function create() {
			div = element("div");
			span = element("span");
			create_component(fancybox.$$.fragment);
			t0 = space();
			create_component(br0.$$.fragment);
			t1 = space();
			if (if_block0) if_block0.c();
			t2 = space();
			create_component(br1.$$.fragment);
			t3 = space();
			if (if_block1) if_block1.c();
			t4 = space();
			if (if_block2) if_block2.c();
			t5 = space();
			if (if_block3) if_block3.c();
			if_block3_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			span = claim_element(div_nodes, "SPAN", {});
			var span_nodes = children(span);
			claim_component(fancybox.$$.fragment, span_nodes);
			span_nodes.forEach(detach_dev);
			t0 = claim_space(div_nodes);
			claim_component(br0.$$.fragment, div_nodes);
			t1 = claim_space(div_nodes);
			if (if_block0) if_block0.l(div_nodes);
			t2 = claim_space(div_nodes);
			claim_component(br1.$$.fragment, div_nodes);
			t3 = claim_space(div_nodes);
			if (if_block1) if_block1.l(div_nodes);
			div_nodes.forEach(detach_dev);
			t4 = claim_space(nodes);
			if (if_block2) if_block2.l(nodes);
			t5 = claim_space(nodes);
			if (if_block3) if_block3.l(nodes);
			if_block3_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			add_location(span, file, 12, 4, 299);
			attr_dev(div, "class", "text-center flex flex-column flex-align-center");
			add_location(div, file, 11, 0, 234);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, span);
			mount_component(fancybox, span, null);
			append_dev(div, t0);
			mount_component(br0, div, null);
			append_dev(div, t1);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t2);
			mount_component(br1, div, null);
			append_dev(div, t3);
			if (if_block1) if_block1.m(div, null);
			insert_dev(target, t4, anchor);
			if (if_block2) if_block2.m(target, anchor);
			insert_dev(target, t5, anchor);
			if (if_block3) if_block3.m(target, anchor);
			insert_dev(target, if_block3_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const fancybox_changes = {};

			if (dirty & /*$$scope, src, srcBig*/ 67) {
				fancybox_changes.$$scope = { dirty, ctx };
			}

			fancybox.$set(fancybox_changes);

			if (/*title*/ ctx[2] !== undefined) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*title*/ 4) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_4(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div, t2);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*title*/ ctx[2] !== undefined) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*title*/ 4) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_2(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (dirty & /*itemsX*/ 16) show_if_1 = Array.isArray(/*itemsX*/ ctx[4]);

			if (show_if_1) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty & /*itemsX*/ 16) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_1(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(t5.parentNode, t5);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (dirty & /*itemsY*/ 32) show_if = Array.isArray(/*itemsY*/ ctx[5]);

			if (show_if) {
				if (if_block3) {
					if_block3.p(ctx, dirty);

					if (dirty & /*itemsY*/ 32) {
						transition_in(if_block3, 1);
					}
				} else {
					if_block3 = create_if_block(ctx);
					if_block3.c();
					transition_in(if_block3, 1);
					if_block3.m(if_block3_anchor.parentNode, if_block3_anchor);
				}
			} else if (if_block3) {
				group_outros();

				transition_out(if_block3, 1, 1, () => {
					if_block3 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(fancybox.$$.fragment, local);
			transition_in(br0.$$.fragment, local);
			transition_in(if_block0);
			transition_in(br1.$$.fragment, local);
			transition_in(if_block1);
			transition_in(if_block2);
			transition_in(if_block3);
			current = true;
		},
		o: function outro(local) {
			transition_out(fancybox.$$.fragment, local);
			transition_out(br0.$$.fragment, local);
			transition_out(if_block0);
			transition_out(br1.$$.fragment, local);
			transition_out(if_block1);
			transition_out(if_block2);
			transition_out(if_block3);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(fancybox);
			destroy_component(br0);
			if (if_block0) if_block0.d();
			destroy_component(br1);
			if (if_block1) if_block1.d();
			if (detaching) detach_dev(t4);
			if (if_block2) if_block2.d(detaching);
			if (detaching) detach_dev(t5);
			if (if_block3) if_block3.d(detaching);
			if (detaching) detach_dev(if_block3_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { src } = $$props;
	let { srcBig } = $$props;
	let { title } = $$props;
	let { subtitle } = $$props;
	let { itemsX } = $$props;
	let { itemsY } = $$props;
	const writable_props = ["src", "srcBig", "title", "subtitle", "itemsX", "itemsY"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<UserCardView> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("UserCardView", $$slots, []);

	$$self.$set = $$props => {
		if ("src" in $$props) $$invalidate(0, src = $$props.src);
		if ("srcBig" in $$props) $$invalidate(1, srcBig = $$props.srcBig);
		if ("title" in $$props) $$invalidate(2, title = $$props.title);
		if ("subtitle" in $$props) $$invalidate(3, subtitle = $$props.subtitle);
		if ("itemsX" in $$props) $$invalidate(4, itemsX = $$props.itemsX);
		if ("itemsY" in $$props) $$invalidate(5, itemsY = $$props.itemsY);
	};

	$$self.$capture_state = () => ({
		Br,
		Avatar,
		Loader,
		FancyBox,
		SocialsX,
		SocialsY,
		src,
		srcBig,
		title,
		subtitle,
		itemsX,
		itemsY
	});

	$$self.$inject_state = $$props => {
		if ("src" in $$props) $$invalidate(0, src = $$props.src);
		if ("srcBig" in $$props) $$invalidate(1, srcBig = $$props.srcBig);
		if ("title" in $$props) $$invalidate(2, title = $$props.title);
		if ("subtitle" in $$props) $$invalidate(3, subtitle = $$props.subtitle);
		if ("itemsX" in $$props) $$invalidate(4, itemsX = $$props.itemsX);
		if ("itemsY" in $$props) $$invalidate(5, itemsY = $$props.itemsY);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [src, srcBig, title, subtitle, itemsX, itemsY];
}

class UserCardView extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance, create_fragment, safe_not_equal, {
			src: 0,
			srcBig: 1,
			title: 2,
			subtitle: 3,
			itemsX: 4,
			itemsY: 5
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "UserCardView",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*src*/ ctx[0] === undefined && !("src" in props)) {
			console.warn("<UserCardView> was created without expected prop 'src'");
		}

		if (/*srcBig*/ ctx[1] === undefined && !("srcBig" in props)) {
			console.warn("<UserCardView> was created without expected prop 'srcBig'");
		}

		if (/*title*/ ctx[2] === undefined && !("title" in props)) {
			console.warn("<UserCardView> was created without expected prop 'title'");
		}

		if (/*subtitle*/ ctx[3] === undefined && !("subtitle" in props)) {
			console.warn("<UserCardView> was created without expected prop 'subtitle'");
		}

		if (/*itemsX*/ ctx[4] === undefined && !("itemsX" in props)) {
			console.warn("<UserCardView> was created without expected prop 'itemsX'");
		}

		if (/*itemsY*/ ctx[5] === undefined && !("itemsY" in props)) {
			console.warn("<UserCardView> was created without expected prop 'itemsY'");
		}
	}

	get src() {
		throw new Error("<UserCardView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set src(value) {
		throw new Error("<UserCardView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get srcBig() {
		throw new Error("<UserCardView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set srcBig(value) {
		throw new Error("<UserCardView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get title() {
		throw new Error("<UserCardView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<UserCardView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get subtitle() {
		throw new Error("<UserCardView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set subtitle(value) {
		throw new Error("<UserCardView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get itemsX() {
		throw new Error("<UserCardView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set itemsX(value) {
		throw new Error("<UserCardView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get itemsY() {
		throw new Error("<UserCardView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set itemsY(value) {
		throw new Error("<UserCardView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/users/_components/_UserCardEdit.svelte generated by Svelte v3.24.0 */
const file$1 = "src/routes/users/_components/_UserCardEdit.svelte";

// (156:4) {#if title !== undefined}
function create_if_block_2$1(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_3$1, create_else_block_1$1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*title*/ ctx[1] !== null) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$1.name,
		type: "if",
		source: "(156:4) {#if title !== undefined}",
		ctx
	});

	return block;
}

// (159:4) {:else}
function create_else_block_1$1(ctx) {
	let div;
	let loader;
	let current;
	loader = new Loader({ props: { type: "h2" }, $$inline: true });

	const block = {
		c: function create() {
			div = element("div");
			create_component(loader.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { style: true });
			var div_nodes = children(div);
			claim_component(loader.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_style(div, "width", "200px");
			add_location(div, file$1, 159, 8, 4135);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(loader, div, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(loader.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loader.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(loader);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1$1.name,
		type: "else",
		source: "(159:4) {:else}",
		ctx
	});

	return block;
}

// (157:4) {#if title !== null}
function create_if_block_3$1(ctx) {
	let h2;
	let t;

	const block = {
		c: function create() {
			h2 = element("h2");
			t = text(/*title*/ ctx[1]);
			this.h();
		},
		l: function claim(nodes) {
			h2 = claim_element(nodes, "H2", {});
			var h2_nodes = children(h2);
			t = claim_text(h2_nodes, /*title*/ ctx[1]);
			h2_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(h2, file$1, 157, 8, 4098);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h2, anchor);
			append_dev(h2, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*title*/ 2) set_data_dev(t, /*title*/ ctx[1]);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(h2);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$1.name,
		type: "if",
		source: "(157:4) {#if title !== null}",
		ctx
	});

	return block;
}

// (164:4) {#if title !== undefined}
function create_if_block$1(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_1$1, create_else_block$1];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*title*/ ctx[1] !== null) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_1(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(164:4) {#if title !== undefined}",
		ctx
	});

	return block;
}

// (167:4) {:else}
function create_else_block$1(ctx) {
	let div;
	let loader;
	let current;
	loader = new Loader({ props: { type: "p" }, $$inline: true });

	const block = {
		c: function create() {
			div = element("div");
			create_component(loader.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { style: true });
			var div_nodes = children(div);
			claim_component(loader.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_style(div, "width", "100px");
			add_location(div, file$1, 167, 8, 4327);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(loader, div, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(loader.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loader.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(loader);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$1.name,
		type: "else",
		source: "(167:4) {:else}",
		ctx
	});

	return block;
}

// (165:4) {#if title !== null}
function create_if_block_1$1(ctx) {
	let p;
	let t;

	const block = {
		c: function create() {
			p = element("p");
			t = text(/*subtitle*/ ctx[2]);
			this.h();
		},
		l: function claim(nodes) {
			p = claim_element(nodes, "P", {});
			var p_nodes = children(p);
			t = claim_text(p_nodes, /*subtitle*/ ctx[2]);
			p_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(p, file$1, 165, 8, 4289);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*subtitle*/ 4) set_data_dev(t, /*subtitle*/ ctx[2]);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$1.name,
		type: "if",
		source: "(165:4) {#if title !== null}",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let div;
	let span;
	let avatar;
	let t0;
	let br0;
	let t1;
	let t2;
	let br1;
	let t3;
	let t4;
	let br2;
	let t5;
	let section;
	let formbuilder;
	let t6;
	let button;
	let t7;
	let current;

	avatar = new Avatar({
			props: {
				size: "big",
				src: /*src*/ ctx[0],
				alt: "Організація"
			},
			$$inline: true
		});

	br0 = new Br({ props: { size: "20" }, $$inline: true });
	let if_block0 = /*title*/ ctx[1] !== undefined && create_if_block_2$1(ctx);
	br1 = new Br({ props: { size: "4" }, $$inline: true });
	let if_block1 = /*title*/ ctx[1] !== undefined && create_if_block$1(ctx);
	br2 = new Br({ props: { size: "40" }, $$inline: true });

	formbuilder = new FormBuilder({
			props: {
				items: /*formFields*/ ctx[5],
				data: /*formValues*/ ctx[3],
				errors: /*formErrors*/ ctx[4]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div = element("div");
			span = element("span");
			create_component(avatar.$$.fragment);
			t0 = space();
			create_component(br0.$$.fragment);
			t1 = space();
			if (if_block0) if_block0.c();
			t2 = space();
			create_component(br1.$$.fragment);
			t3 = space();
			if (if_block1) if_block1.c();
			t4 = space();
			create_component(br2.$$.fragment);
			t5 = space();
			section = element("section");
			create_component(formbuilder.$$.fragment);
			t6 = space();
			button = element("button");
			t7 = text("Зберегти");
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			span = claim_element(div_nodes, "SPAN", {});
			var span_nodes = children(span);
			claim_component(avatar.$$.fragment, span_nodes);
			span_nodes.forEach(detach_dev);
			t0 = claim_space(div_nodes);
			claim_component(br0.$$.fragment, div_nodes);
			t1 = claim_space(div_nodes);
			if (if_block0) if_block0.l(div_nodes);
			t2 = claim_space(div_nodes);
			claim_component(br1.$$.fragment, div_nodes);
			t3 = claim_space(div_nodes);
			if (if_block1) if_block1.l(div_nodes);
			t4 = claim_space(div_nodes);
			claim_component(br2.$$.fragment, div_nodes);
			t5 = claim_space(div_nodes);
			section = claim_element(div_nodes, "SECTION", { class: true });
			var section_nodes = children(section);
			claim_component(formbuilder.$$.fragment, section_nodes);
			t6 = claim_space(section_nodes);
			button = claim_element(section_nodes, "BUTTON", { type: true, form: true });
			var button_nodes = children(button);
			t7 = claim_text(button_nodes, "Зберегти");
			button_nodes.forEach(detach_dev);
			section_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(span, file$1, 149, 4, 3941);
			attr_dev(button, "type", "submit");
			attr_dev(button, "form", "user-form");
			add_location(button, file$1, 179, 8, 4598);
			attr_dev(section, "class", "full-width");
			add_location(section, file$1, 172, 4, 4423);
			attr_dev(div, "class", "text-center flex flex-column flex-align-center");
			add_location(div, file$1, 148, 0, 3876);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, span);
			mount_component(avatar, span, null);
			append_dev(div, t0);
			mount_component(br0, div, null);
			append_dev(div, t1);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t2);
			mount_component(br1, div, null);
			append_dev(div, t3);
			if (if_block1) if_block1.m(div, null);
			append_dev(div, t4);
			mount_component(br2, div, null);
			append_dev(div, t5);
			append_dev(div, section);
			mount_component(formbuilder, section, null);
			append_dev(section, t6);
			append_dev(section, button);
			append_dev(button, t7);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const avatar_changes = {};
			if (dirty & /*src*/ 1) avatar_changes.src = /*src*/ ctx[0];
			avatar.$set(avatar_changes);

			if (/*title*/ ctx[1] !== undefined) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*title*/ 2) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_2$1(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div, t2);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*title*/ ctx[1] !== undefined) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*title*/ 2) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block$1(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t4);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(avatar.$$.fragment, local);
			transition_in(br0.$$.fragment, local);
			transition_in(if_block0);
			transition_in(br1.$$.fragment, local);
			transition_in(if_block1);
			transition_in(br2.$$.fragment, local);
			transition_in(formbuilder.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(avatar.$$.fragment, local);
			transition_out(br0.$$.fragment, local);
			transition_out(if_block0);
			transition_out(br1.$$.fragment, local);
			transition_out(if_block1);
			transition_out(br2.$$.fragment, local);
			transition_out(formbuilder.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(avatar);
			destroy_component(br0);
			if (if_block0) if_block0.d();
			destroy_component(br1);
			if (if_block1) if_block1.d();
			destroy_component(br2);
			destroy_component(formbuilder);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let { src } = $$props;
	let { title } = $$props;
	let { subtitle } = $$props;

	// export let itemsX
	// export let itemsY
	let formValues = {};

	let formErrors = {
		password: "Обов'язкове поле",
		name: "Мало символів",
		email: "Некоректний email",
		bday: "Некоректний email",
		organization: "Некоректно",
		vaccines: "Некоректно"
	};

	let formFields = [
		{
			label: "Моє ім'я:",
			type: "text",
			name: "name",
			meta: { placeholder: "Віталій Бублик" }
		},
		{
			label: "Email:",
			type: "email",
			name: "email",
			meta: { placeholder: "mylovedmail@gmail.com" }
		},
		{
			label: "Телефон:",
			type: "tel",
			name: "phone",
			meta: { placeholder: "+380974354532" }
		},
		{
			label: "Місто:",
			type: "text",
			name: "ship-city",
			meta: {
				postIcon: "search",
				placeholder: "Львів..."
			}
		},
		{
			label: "День народження:",
			type: "date",
			name: "bday",
			meta: { placeholder: "10.10.2010" }
		},
		{
			label: "Пароль:",
			type: "password",
			name: "password",
			meta: {
				minlength: 8,
				required: "required",
				placeholder: "Введіть пароль..."
			}
		},
		{
			label: "Фотогалерея:",
			type: "files",
			name: "photos"
		},
		{
			label: "Стать:",
			type: "radio",
			name: "sex"
		},
		{
			label: "Фото:",
			type: "file",
			name: "photo"
		}
	]; // {
	//     label: 'Вакцинація:',
	//     type: 'checkbox',

	const writable_props = ["src", "title", "subtitle"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<UserCardEdit> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("UserCardEdit", $$slots, []);

	$$self.$set = $$props => {
		if ("src" in $$props) $$invalidate(0, src = $$props.src);
		if ("title" in $$props) $$invalidate(1, title = $$props.title);
		if ("subtitle" in $$props) $$invalidate(2, subtitle = $$props.subtitle);
	};

	$$self.$capture_state = () => ({
		Br,
		Avatar,
		Loader,
		FormBuilder,
		src,
		title,
		subtitle,
		formValues,
		formErrors,
		formFields
	});

	$$self.$inject_state = $$props => {
		if ("src" in $$props) $$invalidate(0, src = $$props.src);
		if ("title" in $$props) $$invalidate(1, title = $$props.title);
		if ("subtitle" in $$props) $$invalidate(2, subtitle = $$props.subtitle);
		if ("formValues" in $$props) $$invalidate(3, formValues = $$props.formValues);
		if ("formErrors" in $$props) $$invalidate(4, formErrors = $$props.formErrors);
		if ("formFields" in $$props) $$invalidate(5, formFields = $$props.formFields);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [src, title, subtitle, formValues, formErrors, formFields];
}

class UserCardEdit extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, { src: 0, title: 1, subtitle: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "UserCardEdit",
			options,
			id: create_fragment$1.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*src*/ ctx[0] === undefined && !("src" in props)) {
			console.warn("<UserCardEdit> was created without expected prop 'src'");
		}

		if (/*title*/ ctx[1] === undefined && !("title" in props)) {
			console.warn("<UserCardEdit> was created without expected prop 'title'");
		}

		if (/*subtitle*/ ctx[2] === undefined && !("subtitle" in props)) {
			console.warn("<UserCardEdit> was created without expected prop 'subtitle'");
		}
	}

	get src() {
		throw new Error("<UserCardEdit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set src(value) {
		throw new Error("<UserCardEdit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get title() {
		throw new Error("<UserCardEdit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<UserCardEdit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get subtitle() {
		throw new Error("<UserCardEdit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set subtitle(value) {
		throw new Error("<UserCardEdit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/users/_Usercard.svelte generated by Svelte v3.24.0 */
const file$2 = "src/routes/users/_Usercard.svelte";

// (32:4) {:else}
function create_else_block_1$2(ctx) {
	let usercardedit;
	let current;

	usercardedit = new UserCardEdit({
			props: {
				src: /*src*/ ctx[0],
				title: /*title*/ ctx[2],
				subtitle: /*subtitle*/ ctx[3]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(usercardedit.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(usercardedit.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(usercardedit, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const usercardedit_changes = {};
			if (dirty & /*src*/ 1) usercardedit_changes.src = /*src*/ ctx[0];
			if (dirty & /*title*/ 4) usercardedit_changes.title = /*title*/ ctx[2];
			if (dirty & /*subtitle*/ 8) usercardedit_changes.subtitle = /*subtitle*/ ctx[3];
			usercardedit.$set(usercardedit_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(usercardedit.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(usercardedit.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(usercardedit, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1$2.name,
		type: "else",
		source: "(32:4) {:else}",
		ctx
	});

	return block;
}

// (23:4) {#if isViewMode}
function create_if_block_1$2(ctx) {
	let usercardview;
	let current;

	usercardview = new UserCardView({
			props: {
				src: /*src*/ ctx[0],
				srcBig: /*srcBig*/ ctx[1],
				title: /*title*/ ctx[2],
				subtitle: /*subtitle*/ ctx[3],
				itemsX: /*itemsX*/ ctx[5],
				itemsY: /*itemsY*/ ctx[6]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(usercardview.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(usercardview.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(usercardview, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const usercardview_changes = {};
			if (dirty & /*src*/ 1) usercardview_changes.src = /*src*/ ctx[0];
			if (dirty & /*srcBig*/ 2) usercardview_changes.srcBig = /*srcBig*/ ctx[1];
			if (dirty & /*title*/ 4) usercardview_changes.title = /*title*/ ctx[2];
			if (dirty & /*subtitle*/ 8) usercardview_changes.subtitle = /*subtitle*/ ctx[3];
			if (dirty & /*itemsX*/ 32) usercardview_changes.itemsX = /*itemsX*/ ctx[5];
			if (dirty & /*itemsY*/ 64) usercardview_changes.itemsY = /*itemsY*/ ctx[6];
			usercardview.$set(usercardview_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(usercardview.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(usercardview.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(usercardview, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$2.name,
		type: "if",
		source: "(23:4) {#if isViewMode}",
		ctx
	});

	return block;
}

// (50:8) {:else}
function create_else_block$2(ctx) {
	let span;
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text("Переглянути");
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t = claim_text(span_nodes, "Переглянути");
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "h3 font-secondary font-w-500 flex flex-align-center");
			add_location(span, file$2, 50, 12, 1374);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$2.name,
		type: "else",
		source: "(50:8) {:else}",
		ctx
	});

	return block;
}

// (43:8) {#if isViewMode}
function create_if_block$2(ctx) {
	let span;
	let t0;
	let s0;
	let t1;
	let s1;
	let t2;
	let icon;
	let current;

	icon = new Icon({
			props: { type: "edit", size: "small", is: "light" },
			$$inline: true
		});

	const block = {
		c: function create() {
			span = element("span");
			t0 = text("Редагувати\n                ");
			s0 = element("s");
			t1 = space();
			s1 = element("s");
			t2 = space();
			create_component(icon.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t0 = claim_text(span_nodes, "Редагувати\n                ");
			s0 = claim_element(span_nodes, "S", {});
			children(s0).forEach(detach_dev);
			t1 = claim_space(span_nodes);
			s1 = claim_element(span_nodes, "S", {});
			children(s1).forEach(detach_dev);
			t2 = claim_space(span_nodes);
			claim_component(icon.$$.fragment, span_nodes);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(s0, file$2, 45, 16, 1234);
			add_location(s1, file$2, 46, 16, 1258);
			attr_dev(span, "class", "h3 font-secondary font-w-500 flex flex-align-center");
			add_location(span, file$2, 43, 12, 1124);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t0);
			append_dev(span, s0);
			append_dev(span, t1);
			append_dev(span, s1);
			append_dev(span, t2);
			mount_component(icon, span, null);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			destroy_component(icon);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$2.name,
		type: "if",
		source: "(43:8) {#if isViewMode}",
		ctx
	});

	return block;
}

// (42:4) <Button size="small" is={isViewMode ? "info" : ''} on:click={() => isViewMode = !isViewMode}>
function create_default_slot_1(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$2, create_else_block$2];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*isViewMode*/ ctx[4]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_1(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index !== previous_block_index) {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1.name,
		type: "slot",
		source: "(42:4) <Button size=\\\"small\\\" is={isViewMode ? \\\"info\\\" : ''} on:click={() => isViewMode = !isViewMode}>",
		ctx
	});

	return block;
}

// (20:0) <Card class="container">
function create_default_slot$1(ctx) {
	let br0;
	let t0;
	let current_block_type_index;
	let if_block;
	let t1;
	let br1;
	let t2;
	let button;
	let t3;
	let br2;
	let current;
	br0 = new Br({ props: { size: "30" }, $$inline: true });
	const if_block_creators = [create_if_block_1$2, create_else_block_1$2];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*isViewMode*/ ctx[4]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	br1 = new Br({ props: { size: "30" }, $$inline: true });

	button = new Button({
			props: {
				size: "small",
				is: /*isViewMode*/ ctx[4] ? "info" : "",
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button.$on("click", /*click_handler*/ ctx[8]);
	br2 = new Br({ props: { size: "30" }, $$inline: true });

	const block = {
		c: function create() {
			create_component(br0.$$.fragment);
			t0 = space();
			if_block.c();
			t1 = space();
			create_component(br1.$$.fragment);
			t2 = space();
			create_component(button.$$.fragment);
			t3 = space();
			create_component(br2.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(br0.$$.fragment, nodes);
			t0 = claim_space(nodes);
			if_block.l(nodes);
			t1 = claim_space(nodes);
			claim_component(br1.$$.fragment, nodes);
			t2 = claim_space(nodes);
			claim_component(button.$$.fragment, nodes);
			t3 = claim_space(nodes);
			claim_component(br2.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(br0, target, anchor);
			insert_dev(target, t0, anchor);
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(br1, target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(button, target, anchor);
			insert_dev(target, t3, anchor);
			mount_component(br2, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(t1.parentNode, t1);
			}

			const button_changes = {};
			if (dirty & /*isViewMode*/ 16) button_changes.is = /*isViewMode*/ ctx[4] ? "info" : "";

			if (dirty & /*$$scope, isViewMode*/ 1040) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(br0.$$.fragment, local);
			transition_in(if_block);
			transition_in(br1.$$.fragment, local);
			transition_in(button.$$.fragment, local);
			transition_in(br2.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br0.$$.fragment, local);
			transition_out(if_block);
			transition_out(br1.$$.fragment, local);
			transition_out(button.$$.fragment, local);
			transition_out(br2.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(br0, detaching);
			if (detaching) detach_dev(t0);
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(t1);
			destroy_component(br1, detaching);
			if (detaching) detach_dev(t2);
			destroy_component(button, detaching);
			if (detaching) detach_dev(t3);
			destroy_component(br2, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$1.name,
		type: "slot",
		source: "(20:0) <Card class=\\\"container\\\">",
		ctx
	});

	return block;
}

function create_fragment$2(ctx) {
	let card;
	let current;

	card = new Card({
			props: {
				class: "container",
				$$slots: { default: [create_default_slot$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(card.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(card.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(card, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const card_changes = {};

			if (dirty & /*$$scope, isViewMode, src, srcBig, title, subtitle, itemsX, itemsY*/ 1151) {
				card_changes.$$scope = { dirty, ctx };
			}

			card.$set(card_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(card.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(card.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(card, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	let { src = null } = $$props;
	let { srcBig = null } = $$props;
	let { items = null } = $$props;
	let { title = null } = $$props;
	let { subtitle = null } = $$props;
	const top = ["telegram", "facebook", "viber"];
	let isViewMode = true;
	const writable_props = ["src", "srcBig", "items", "title", "subtitle"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Usercard> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Usercard", $$slots, []);
	const click_handler = () => $$invalidate(4, isViewMode = !isViewMode);

	$$self.$set = $$props => {
		if ("src" in $$props) $$invalidate(0, src = $$props.src);
		if ("srcBig" in $$props) $$invalidate(1, srcBig = $$props.srcBig);
		if ("items" in $$props) $$invalidate(7, items = $$props.items);
		if ("title" in $$props) $$invalidate(2, title = $$props.title);
		if ("subtitle" in $$props) $$invalidate(3, subtitle = $$props.subtitle);
	};

	$$self.$capture_state = () => ({
		safeGet,
		Br,
		Card,
		Icon,
		Button,
		UserCardView,
		UserCardEdit,
		src,
		srcBig,
		items,
		title,
		subtitle,
		top,
		isViewMode,
		itemsX,
		itemsY
	});

	$$self.$inject_state = $$props => {
		if ("src" in $$props) $$invalidate(0, src = $$props.src);
		if ("srcBig" in $$props) $$invalidate(1, srcBig = $$props.srcBig);
		if ("items" in $$props) $$invalidate(7, items = $$props.items);
		if ("title" in $$props) $$invalidate(2, title = $$props.title);
		if ("subtitle" in $$props) $$invalidate(3, subtitle = $$props.subtitle);
		if ("isViewMode" in $$props) $$invalidate(4, isViewMode = $$props.isViewMode);
		if ("itemsX" in $$props) $$invalidate(5, itemsX = $$props.itemsX);
		if ("itemsY" in $$props) $$invalidate(6, itemsY = $$props.itemsY);
	};

	let itemsX;
	let itemsY;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*items*/ 128) {
			 $$invalidate(5, itemsX = items === null
			? null
			: safeGet(() => items.filter(i => top.includes(i.type))));
		}

		if ($$self.$$.dirty & /*items*/ 128) {
			 $$invalidate(6, itemsY = items === null
			? null
			: safeGet(() => items.filter(i => !top.includes(i.type))));
		}
	};

	return [src, srcBig, title, subtitle, isViewMode, itemsX, itemsY, items, click_handler];
}

class Usercard extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2, create_fragment$2, safe_not_equal, {
			src: 0,
			srcBig: 1,
			items: 7,
			title: 2,
			subtitle: 3
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Usercard",
			options,
			id: create_fragment$2.name
		});
	}

	get src() {
		throw new Error("<Usercard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set src(value) {
		throw new Error("<Usercard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get srcBig() {
		throw new Error("<Usercard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set srcBig(value) {
		throw new Error("<Usercard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get items() {
		throw new Error("<Usercard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set items(value) {
		throw new Error("<Usercard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get title() {
		throw new Error("<Usercard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<Usercard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get subtitle() {
		throw new Error("<Usercard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set subtitle(value) {
		throw new Error("<Usercard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/users/me.svelte generated by Svelte v3.24.0 */
const file$3 = "src/routes/users/me.svelte";

// (72:24) <Button size="small" is="info" href={id}>
function create_default_slot_6(ctx) {
	let span;
	let t0;
	let s0;
	let t1;
	let s1;
	let t2;
	let icon;
	let current;

	icon = new Icon({
			props: { type: "edit", size: "small", is: "light" },
			$$inline: true
		});

	const block = {
		c: function create() {
			span = element("span");
			t0 = text("Редагувати\n                                ");
			s0 = element("s");
			t1 = space();
			s1 = element("s");
			t2 = space();
			create_component(icon.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t0 = claim_text(span_nodes, "Редагувати\n                                ");
			s0 = claim_element(span_nodes, "S", {});
			children(s0).forEach(detach_dev);
			t1 = claim_space(span_nodes);
			s1 = claim_element(span_nodes, "S", {});
			children(s1).forEach(detach_dev);
			t2 = claim_space(span_nodes);
			claim_component(icon.$$.fragment, span_nodes);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(s0, file$3, 74, 32, 2361);
			add_location(s1, file$3, 75, 32, 2401);
			attr_dev(span, "class", "h3 font-secondary font-w-500 flex flex-align-center");
			add_location(span, file$3, 72, 28, 2219);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t0);
			append_dev(span, s0);
			append_dev(span, t1);
			append_dev(span, s1);
			append_dev(span, t2);
			mount_component(icon, span, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			destroy_component(icon);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_6.name,
		type: "slot",
		source: "(72:24) <Button size=\\\"small\\\" is=\\\"info\\\" href={id}>",
		ctx
	});

	return block;
}

// (71:20) <div slot="button" let:id={id}>
function create_button_slot_1(ctx) {
	let div;
	let button;
	let current;

	button = new Button({
			props: {
				size: "small",
				is: "info",
				href: /*id*/ ctx[10],
				$$slots: { default: [create_default_slot_6] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div = element("div");
			create_component(button.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { slot: true });
			var div_nodes = children(div);
			claim_component(button.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "slot", "button");
			add_location(div, file$3, 70, 20, 2093);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(button, div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const button_changes = {};
			if (dirty & /*id*/ 1024) button_changes.href = /*id*/ ctx[10];

			if (dirty & /*$$scope*/ 2048) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(button);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_button_slot_1.name,
		type: "slot",
		source: "(71:20) <div slot=\\\"button\\\" let:id={id}>",
		ctx
	});

	return block;
}

// (85:12) <Button size="big" is="success" href={href}>
function create_default_slot_4(ctx) {
	let span;
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text("Додати");
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t = claim_text(span_nodes, "Додати");
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "h2 font-secondary font-w-600");
			add_location(span, file$3, 85, 16, 2733);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4.name,
		type: "slot",
		source: "(85:12) <Button size=\\\"big\\\" is=\\\"success\\\" href={href}>",
		ctx
	});

	return block;
}

// (65:8) <EditArea>
function create_default_slot_3(ctx) {
	let br0;
	let t0;
	let h1;
	let t1;
	let t2;
	let br1;
	let t3;
	let div;
	let fundcards;
	let t4;
	let br2;
	let t5;
	let button;
	let t6;
	let br3;
	let current;
	br0 = new Br({ props: { size: "40" }, $$inline: true });
	br1 = new Br({ props: { size: "5" }, $$inline: true });

	fundcards = new FundCards({
			props: {
				items: /*animalFunds*/ ctx[2],
				$$slots: {
					button: [
						create_button_slot_1,
						({ id }) => ({ 10: id }),
						({ id }) => id ? 1024 : 0
					]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	br2 = new Br({ props: { size: "35" }, $$inline: true });

	button = new Button({
			props: {
				size: "big",
				is: "success",
				href: /*href*/ ctx[4],
				$$slots: { default: [create_default_slot_4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	br3 = new Br({ props: { size: "40" }, $$inline: true });

	const block = {
		c: function create() {
			create_component(br0.$$.fragment);
			t0 = space();
			h1 = element("h1");
			t1 = text("Мої організації");
			t2 = space();
			create_component(br1.$$.fragment);
			t3 = space();
			div = element("div");
			create_component(fundcards.$$.fragment);
			t4 = space();
			create_component(br2.$$.fragment);
			t5 = space();
			create_component(button.$$.fragment);
			t6 = space();
			create_component(br3.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			claim_component(br0.$$.fragment, nodes);
			t0 = claim_space(nodes);
			h1 = claim_element(nodes, "H1", {});
			var h1_nodes = children(h1);
			t1 = claim_text(h1_nodes, "Мої організації");
			h1_nodes.forEach(detach_dev);
			t2 = claim_space(nodes);
			claim_component(br1.$$.fragment, nodes);
			t3 = claim_space(nodes);
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			claim_component(fundcards.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			t4 = claim_space(nodes);
			claim_component(br2.$$.fragment, nodes);
			t5 = claim_space(nodes);
			claim_component(button.$$.fragment, nodes);
			t6 = claim_space(nodes);
			claim_component(br3.$$.fragment, nodes);
			this.h();
		},
		h: function hydrate() {
			add_location(h1, file$3, 66, 12, 1931);
			attr_dev(div, "class", "full-container");
			add_location(div, file$3, 68, 12, 1996);
		},
		m: function mount(target, anchor) {
			mount_component(br0, target, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, h1, anchor);
			append_dev(h1, t1);
			insert_dev(target, t2, anchor);
			mount_component(br1, target, anchor);
			insert_dev(target, t3, anchor);
			insert_dev(target, div, anchor);
			mount_component(fundcards, div, null);
			insert_dev(target, t4, anchor);
			mount_component(br2, target, anchor);
			insert_dev(target, t5, anchor);
			mount_component(button, target, anchor);
			insert_dev(target, t6, anchor);
			mount_component(br3, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const fundcards_changes = {};
			if (dirty & /*animalFunds*/ 4) fundcards_changes.items = /*animalFunds*/ ctx[2];

			if (dirty & /*$$scope, id*/ 3072) {
				fundcards_changes.$$scope = { dirty, ctx };
			}

			fundcards.$set(fundcards_changes);
			const button_changes = {};

			if (dirty & /*$$scope*/ 2048) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(br0.$$.fragment, local);
			transition_in(br1.$$.fragment, local);
			transition_in(fundcards.$$.fragment, local);
			transition_in(br2.$$.fragment, local);
			transition_in(button.$$.fragment, local);
			transition_in(br3.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br0.$$.fragment, local);
			transition_out(br1.$$.fragment, local);
			transition_out(fundcards.$$.fragment, local);
			transition_out(br2.$$.fragment, local);
			transition_out(button.$$.fragment, local);
			transition_out(br3.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(br0, detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(h1);
			if (detaching) detach_dev(t2);
			destroy_component(br1, detaching);
			if (detaching) detach_dev(t3);
			if (detaching) detach_dev(div);
			destroy_component(fundcards);
			if (detaching) detach_dev(t4);
			destroy_component(br2, detaching);
			if (detaching) detach_dev(t5);
			destroy_component(button, detaching);
			if (detaching) detach_dev(t6);
			destroy_component(br3, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3.name,
		type: "slot",
		source: "(65:8) <EditArea>",
		ctx
	});

	return block;
}

// (101:16) <Button size="small" is="info" href={id}>
function create_default_slot_2(ctx) {
	let span;
	let t0;
	let s0;
	let t1;
	let s1;
	let t2;
	let icon;
	let current;

	icon = new Icon({
			props: { type: "edit", size: "small", is: "light" },
			$$inline: true
		});

	const block = {
		c: function create() {
			span = element("span");
			t0 = text("Редагувати\n                        ");
			s0 = element("s");
			t1 = space();
			s1 = element("s");
			t2 = space();
			create_component(icon.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t0 = claim_text(span_nodes, "Редагувати\n                        ");
			s0 = claim_element(span_nodes, "S", {});
			children(s0).forEach(detach_dev);
			t1 = claim_space(span_nodes);
			s1 = claim_element(span_nodes, "S", {});
			children(s1).forEach(detach_dev);
			t2 = claim_space(span_nodes);
			claim_component(icon.$$.fragment, span_nodes);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(s0, file$3, 103, 24, 3297);
			add_location(s1, file$3, 104, 24, 3329);
			attr_dev(span, "class", "h3 font-secondary font-w-500 flex flex-align-center");
			add_location(span, file$3, 101, 20, 3171);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t0);
			append_dev(span, s0);
			append_dev(span, t1);
			append_dev(span, s1);
			append_dev(span, t2);
			mount_component(icon, span, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			destroy_component(icon);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2.name,
		type: "slot",
		source: "(101:16) <Button size=\\\"small\\\" is=\\\"info\\\" href={id}>",
		ctx
	});

	return block;
}

// (100:12) <div slot="button" let:id={id}>
function create_button_slot(ctx) {
	let div;
	let button;
	let current;

	button = new Button({
			props: {
				size: "small",
				is: "info",
				href: /*id*/ ctx[10],
				$$slots: { default: [create_default_slot_2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div = element("div");
			create_component(button.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { slot: true });
			var div_nodes = children(div);
			claim_component(button.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "slot", "button");
			add_location(div, file$3, 99, 12, 3061);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(button, div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const button_changes = {};
			if (dirty & /*id*/ 1024) button_changes.href = /*id*/ ctx[10];

			if (dirty & /*$$scope*/ 2048) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(button);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_button_slot.name,
		type: "slot",
		source: "(100:12) <div slot=\\\"button\\\" let:id={id}>",
		ctx
	});

	return block;
}

// (114:4) <Button size="big" is="success" href={href}>
function create_default_slot$2(ctx) {
	let span;
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text("Додати");
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t = claim_text(span_nodes, "Додати");
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "h2 font-secondary font-w-600");
			add_location(span, file$3, 114, 8, 3589);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$2.name,
		type: "slot",
		source: "(114:4) <Button size=\\\"big\\\" is=\\\"success\\\" href={href}>",
		ctx
	});

	return block;
}

function create_fragment$3(ctx) {
	let section;
	let br0;
	let t0;
	let br1;
	let t1;
	let h10;
	let t2;
	let t3;
	let br2;
	let t4;
	let usercard;
	let t5;
	let br3;
	let t6;
	let div0;
	let editarea;
	let t7;
	let br4;
	let t8;
	let h11;
	let t9;
	let t10;
	let br5;
	let t11;
	let div1;
	let fundcards;
	let t12;
	let br6;
	let t13;
	let button;
	let t14;
	let br7;
	let current;

	br0 = new Br({
			props: { size: "var(--header-height)" },
			$$inline: true
		});

	br1 = new Br({ props: { size: "35" }, $$inline: true });
	br2 = new Br({ props: { size: "20" }, $$inline: true });

	usercard = new Usercard({
			props: {
				items: /*contacts*/ ctx[1],
				title: safeGet(/*func*/ ctx[5]),
				subtitle: safeGet(/*func_1*/ ctx[6]),
				src: safeGet(/*func_2*/ ctx[7]),
				srcBig: safeGet(/*func_3*/ ctx[8])
			},
			$$inline: true
		});

	br3 = new Br({ props: { size: "15" }, $$inline: true });

	editarea = new EditArea({
			props: {
				$$slots: { default: [create_default_slot_3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	br4 = new Br({ props: { size: "15" }, $$inline: true });
	br5 = new Br({ props: { size: "5" }, $$inline: true });

	fundcards = new FundCards({
			props: {
				items: /*othersFunds*/ ctx[3],
				$$slots: {
					button: [
						create_button_slot,
						({ id }) => ({ 10: id }),
						({ id }) => id ? 1024 : 0
					]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	br6 = new Br({ props: { size: "35" }, $$inline: true });

	button = new Button({
			props: {
				size: "big",
				is: "success",
				href: /*href*/ ctx[4],
				$$slots: { default: [create_default_slot$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	br7 = new Br({ props: { size: "125" }, $$inline: true });

	const block = {
		c: function create() {
			section = element("section");
			create_component(br0.$$.fragment);
			t0 = space();
			create_component(br1.$$.fragment);
			t1 = space();
			h10 = element("h1");
			t2 = text("Про мене");
			t3 = space();
			create_component(br2.$$.fragment);
			t4 = space();
			create_component(usercard.$$.fragment);
			t5 = space();
			create_component(br3.$$.fragment);
			t6 = space();
			div0 = element("div");
			create_component(editarea.$$.fragment);
			t7 = space();
			create_component(br4.$$.fragment);
			t8 = space();
			h11 = element("h1");
			t9 = text("Мої фонди");
			t10 = space();
			create_component(br5.$$.fragment);
			t11 = space();
			div1 = element("div");
			create_component(fundcards.$$.fragment);
			t12 = space();
			create_component(br6.$$.fragment);
			t13 = space();
			create_component(button.$$.fragment);
			t14 = space();
			create_component(br7.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { class: true });
			var section_nodes = children(section);
			claim_component(br0.$$.fragment, section_nodes);
			t0 = claim_space(section_nodes);
			claim_component(br1.$$.fragment, section_nodes);
			t1 = claim_space(section_nodes);
			h10 = claim_element(section_nodes, "H1", { class: true });
			var h10_nodes = children(h10);
			t2 = claim_text(h10_nodes, "Про мене");
			h10_nodes.forEach(detach_dev);
			t3 = claim_space(section_nodes);
			claim_component(br2.$$.fragment, section_nodes);
			t4 = claim_space(section_nodes);
			claim_component(usercard.$$.fragment, section_nodes);
			t5 = claim_space(section_nodes);
			claim_component(br3.$$.fragment, section_nodes);
			t6 = claim_space(section_nodes);
			div0 = claim_element(section_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			claim_component(editarea.$$.fragment, div0_nodes);
			div0_nodes.forEach(detach_dev);
			t7 = claim_space(section_nodes);
			claim_component(br4.$$.fragment, section_nodes);
			t8 = claim_space(section_nodes);
			h11 = claim_element(section_nodes, "H1", {});
			var h11_nodes = children(h11);
			t9 = claim_text(h11_nodes, "Мої фонди");
			h11_nodes.forEach(detach_dev);
			t10 = claim_space(section_nodes);
			claim_component(br5.$$.fragment, section_nodes);
			t11 = claim_space(section_nodes);
			div1 = claim_element(section_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			claim_component(fundcards.$$.fragment, div1_nodes);
			div1_nodes.forEach(detach_dev);
			t12 = claim_space(section_nodes);
			claim_component(br6.$$.fragment, section_nodes);
			t13 = claim_space(section_nodes);
			claim_component(button.$$.fragment, section_nodes);
			t14 = claim_space(section_nodes);
			claim_component(br7.$$.fragment, section_nodes);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(h10, "class", "text-center");
			add_location(h10, file$3, 50, 4, 1484);
			attr_dev(div0, "class", "full-container");
			add_location(div0, file$3, 63, 4, 1842);
			add_location(h11, file$3, 95, 4, 2937);
			attr_dev(div1, "class", "full-container");
			add_location(div1, file$3, 97, 4, 2980);
			attr_dev(section, "class", "container theme-bg-color-secondary");
			add_location(section, file$3, 46, 0, 1368);
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			mount_component(br0, section, null);
			append_dev(section, t0);
			mount_component(br1, section, null);
			append_dev(section, t1);
			append_dev(section, h10);
			append_dev(h10, t2);
			append_dev(section, t3);
			mount_component(br2, section, null);
			append_dev(section, t4);
			mount_component(usercard, section, null);
			append_dev(section, t5);
			mount_component(br3, section, null);
			append_dev(section, t6);
			append_dev(section, div0);
			mount_component(editarea, div0, null);
			append_dev(section, t7);
			mount_component(br4, section, null);
			append_dev(section, t8);
			append_dev(section, h11);
			append_dev(h11, t9);
			append_dev(section, t10);
			mount_component(br5, section, null);
			append_dev(section, t11);
			append_dev(section, div1);
			mount_component(fundcards, div1, null);
			append_dev(section, t12);
			mount_component(br6, section, null);
			append_dev(section, t13);
			mount_component(button, section, null);
			append_dev(section, t14);
			mount_component(br7, section, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const usercard_changes = {};
			if (dirty & /*contacts*/ 2) usercard_changes.items = /*contacts*/ ctx[1];
			if (dirty & /*organization*/ 1) usercard_changes.title = safeGet(/*func*/ ctx[5]);
			if (dirty & /*organization*/ 1) usercard_changes.subtitle = safeGet(/*func_1*/ ctx[6]);
			if (dirty & /*organization*/ 1) usercard_changes.src = safeGet(/*func_2*/ ctx[7]);
			if (dirty & /*organization*/ 1) usercard_changes.srcBig = safeGet(/*func_3*/ ctx[8]);
			usercard.$set(usercard_changes);
			const editarea_changes = {};

			if (dirty & /*$$scope, animalFunds*/ 2052) {
				editarea_changes.$$scope = { dirty, ctx };
			}

			editarea.$set(editarea_changes);
			const fundcards_changes = {};
			if (dirty & /*othersFunds*/ 8) fundcards_changes.items = /*othersFunds*/ ctx[3];

			if (dirty & /*$$scope, id*/ 3072) {
				fundcards_changes.$$scope = { dirty, ctx };
			}

			fundcards.$set(fundcards_changes);
			const button_changes = {};

			if (dirty & /*$$scope*/ 2048) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(br0.$$.fragment, local);
			transition_in(br1.$$.fragment, local);
			transition_in(br2.$$.fragment, local);
			transition_in(usercard.$$.fragment, local);
			transition_in(br3.$$.fragment, local);
			transition_in(editarea.$$.fragment, local);
			transition_in(br4.$$.fragment, local);
			transition_in(br5.$$.fragment, local);
			transition_in(fundcards.$$.fragment, local);
			transition_in(br6.$$.fragment, local);
			transition_in(button.$$.fragment, local);
			transition_in(br7.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br0.$$.fragment, local);
			transition_out(br1.$$.fragment, local);
			transition_out(br2.$$.fragment, local);
			transition_out(usercard.$$.fragment, local);
			transition_out(br3.$$.fragment, local);
			transition_out(editarea.$$.fragment, local);
			transition_out(br4.$$.fragment, local);
			transition_out(br5.$$.fragment, local);
			transition_out(fundcards.$$.fragment, local);
			transition_out(br6.$$.fragment, local);
			transition_out(button.$$.fragment, local);
			transition_out(br7.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			destroy_component(br0);
			destroy_component(br1);
			destroy_component(br2);
			destroy_component(usercard);
			destroy_component(br3);
			destroy_component(editarea);
			destroy_component(br4);
			destroy_component(br5);
			destroy_component(fundcards);
			destroy_component(br6);
			destroy_component(button);
			destroy_component(br7);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3($$self, $$props, $$invalidate) {
	let href = ".";

	// Entities
	let organization = {};

	let funds;

	onMount(async () => {
		await delay(7000);
		$$invalidate(0, organization = await API.getOrganization(1));
		$$invalidate(9, funds = await API.getFunds());
	});

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Me> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Me", $$slots, []);
	const func = () => organization.name;
	const func_1 = () => organization.title;
	const func_2 = () => organization.avatar;
	const func_3 = () => organization.avatarBig;

	$$self.$capture_state = () => ({
		onMount,
		API,
		delay,
		safeGet,
		Br,
		Icon,
		Card,
		Avatar,
		Button,
		FundCards,
		EditArea,
		Usercard,
		href,
		organization,
		funds,
		contacts,
		animalFunds,
		othersFunds
	});

	$$self.$inject_state = $$props => {
		if ("href" in $$props) $$invalidate(4, href = $$props.href);
		if ("organization" in $$props) $$invalidate(0, organization = $$props.organization);
		if ("funds" in $$props) $$invalidate(9, funds = $$props.funds);
		if ("contacts" in $$props) $$invalidate(1, contacts = $$props.contacts);
		if ("animalFunds" in $$props) $$invalidate(2, animalFunds = $$props.animalFunds);
		if ("othersFunds" in $$props) $$invalidate(3, othersFunds = $$props.othersFunds);
	};

	let contacts;
	let animalFunds;
	let othersFunds;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*organization*/ 1) {
			 $$invalidate(1, contacts = safeGet(
				() => organization.contacts.map(c => ({
					title: c.title,
					href: c.value,
					type: c.type
				})),
				null
			));
		}

		if ($$self.$$.dirty & /*funds*/ 512) {
			 $$invalidate(2, animalFunds = safeGet(
				() => funds.filter(f => f.type === "animal").reduce((acc, f) => acc.concat(f, f, f), []).map(f => ({
					id: f.id,
					src: f.avatars[0].src,
					type: f.type,
					title: f.title,
					total: f.need_sum,
					current: f.current_sum,
					currency: f.currency,
					city: f.location.city
				})),
				null
			));
		}

		if ($$self.$$.dirty & /*funds*/ 512) {
			 $$invalidate(3, othersFunds = safeGet(
				() => funds.filter(f => f.type === "animal").reduce((acc, f) => acc.concat(f, f, f), []).map(f => ({
					id: f.id,
					src: f.avatars[0].src,
					type: f.type,
					title: f.title,
					total: f.need_sum,
					current: f.current_sum,
					currency: f.currency,
					city: f.location.city
				})),
				null
			));
		}
	};

	return [
		organization,
		contacts,
		animalFunds,
		othersFunds,
		href,
		func,
		func_1,
		func_2,
		func_3
	];
}

class Me extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3, create_fragment$3, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Me",
			options,
			id: create_fragment$3.name
		});
	}
}

export default Me;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWUuYzJlMTgxOTIuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9yb3V0ZXMvdXNlcnMvX2NvbXBvbmVudHMvX1VzZXJDYXJkVmlldy5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvcm91dGVzL3VzZXJzL19jb21wb25lbnRzL19Vc2VyQ2FyZEVkaXQuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy91c2Vycy9fVXNlcmNhcmQuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy91c2Vycy9tZS5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBCciwgQXZhdGFyLCBMb2FkZXIsIEZhbmN5Qm94LCBTb2NpYWxzWCwgU29jaWFsc1kgfSBmcm9tICdAY29tcG9uZW50cydcblxuICAgIGV4cG9ydCBsZXQgc3JjXG4gICAgZXhwb3J0IGxldCBzcmNCaWdcbiAgICBleHBvcnQgbGV0IHRpdGxlXG4gICAgZXhwb3J0IGxldCBzdWJ0aXRsZVxuICAgIGV4cG9ydCBsZXQgaXRlbXNYXG4gICAgZXhwb3J0IGxldCBpdGVtc1lcbjwvc2NyaXB0PlxuXG48ZGl2IGNsYXNzPVwidGV4dC1jZW50ZXIgZmxleCBmbGV4LWNvbHVtbiBmbGV4LWFsaWduLWNlbnRlclwiPlxuICAgIDxzcGFuPlxuICAgICAgICA8RmFuY3lCb3ggY2xhc3M9XCJmbGV4LWp1c3RpZnktY2VudGVyXCI+XG4gICAgICAgICAgICA8QXZhdGFyIHNpemU9XCJiaWdcIiB7c3JjfSBhbHQ9XCLQntGA0LPQsNC90ZbQt9Cw0YbRltGPXCIvPlxuICAgICAgICAgICAgPHNlY3Rpb24gc2xvdD1cImJveFwiIGNsYXNzPVwiZmxleCBmdWxsLXdpZHRoIGZ1bGwtaGVpZ2h0XCIgc3R5bGU9XCJoZWlnaHQ6IDEwMHZ3XCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZsZXggZmxleC1zZWxmLXN0cmV0Y2ggZmxleC0xIG92ZXJmbG93LWhpZGRlbiBmbGV4LWp1c3RpZnktc3RyZXRjaFwiIHN0eWxlPVwicGFkZGluZzogdmFyKC0tc2NyZWVuLXBhZGRpbmcpIDBcIj5cbiAgICAgICAgICAgICAgICAgICAgPEF2YXRhciB7c3JjfSB7c3JjQmlnfSBhbHQ9XCJhdmFcIi8+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L3NlY3Rpb24+XG4gICAgICAgIDwvRmFuY3lCb3g+XG4gICAgPC9zcGFuPlxuXG4gICAgPEJyIHNpemU9XCIyMFwiLz5cbiAgICB7I2lmIHRpdGxlICE9PSB1bmRlZmluZWR9XG4gICAgeyNpZiB0aXRsZSAhPT0gbnVsbH1cbiAgICAgICAgPGgyPnt0aXRsZX08L2gyPlxuICAgIHs6ZWxzZX1cbiAgICAgICAgPGRpdiBzdHlsZT1cIndpZHRoOiAyMDBweFwiPjxMb2FkZXIgdHlwZT1cImgyXCIvPjwvZGl2PlxuICAgIHsvaWZ9XG4gICAgey9pZn1cbiAgICA8QnIgc2l6ZT1cIjRcIi8+XG4gICAgeyNpZiB0aXRsZSAhPT0gdW5kZWZpbmVkfVxuICAgIHsjaWYgdGl0bGUgIT09IG51bGx9XG4gICAgICAgIDxwPntzdWJ0aXRsZX08L3A+XG4gICAgezplbHNlfVxuICAgICAgICA8ZGl2IHN0eWxlPVwid2lkdGg6IDEwMHB4XCI+PExvYWRlciB0eXBlPVwicFwiLz48L2Rpdj5cbiAgICB7L2lmfVxuICAgIHsvaWZ9XG48L2Rpdj5cblxueyNpZiBBcnJheS5pc0FycmF5KGl0ZW1zWCl9XG4gICAgPEJyIHNpemU9XCIzMFwiLz5cbiAgICA8U29jaWFsc1ggaXRlbXM9e2l0ZW1zWH0vPlxuey9pZn1cblxueyNpZiBBcnJheS5pc0FycmF5KGl0ZW1zWSl9XG4gICAgPEJyIHNpemU9XCIzMFwiLz5cbiAgICA8U29jaWFsc1kgaXRlbXM9e2l0ZW1zWX0vPlxuey9pZn1cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgQnIsIEF2YXRhciwgTG9hZGVyLCBGb3JtQnVpbGRlciB9IGZyb20gJ0Bjb21wb25lbnRzJ1xuXG4gICAgZXhwb3J0IGxldCBzcmNcbiAgICBleHBvcnQgbGV0IHRpdGxlXG4gICAgZXhwb3J0IGxldCBzdWJ0aXRsZVxuICAgIC8vIGV4cG9ydCBsZXQgaXRlbXNYXG4gICAgLy8gZXhwb3J0IGxldCBpdGVtc1lcblxuICAgIGxldCBmb3JtVmFsdWVzID0ge1xuXG4gICAgfVxuXG4gICAgbGV0IGZvcm1FcnJvcnMgPSB7XG4gICAgICAgIHBhc3N3b3JkOiAn0J7QsdC+0LJcXCfRj9C30LrQvtCy0LUg0L/QvtC70LUnLFxuICAgICAgICBuYW1lOiAn0JzQsNC70L4g0YHQuNC80LLQvtC70ZbQsicsXG4gICAgICAgIGVtYWlsOiAn0J3QtdC60L7RgNC10LrRgtC90LjQuSBlbWFpbCcsXG4gICAgICAgIGJkYXk6ICfQndC10LrQvtGA0LXQutGC0L3QuNC5IGVtYWlsJyxcbiAgICAgICAgb3JnYW5pemF0aW9uOiAn0J3QtdC60L7RgNC10LrRgtC90L4nLFxuICAgICAgICB2YWNjaW5lczogJ9Cd0LXQutC+0YDQtdC60YLQvdC+JyxcbiAgICB9XG5cbiAgICBsZXQgZm9ybUZpZWxkcyA9IFtcbiAgICAgICAge1xuICAgICAgICAgICAgbGFiZWw6ICfQnNC+0ZQg0ZbQvFxcJ9GPOicsXG4gICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICBuYW1lOiAnbmFtZScsXG4gICAgICAgICAgICBtZXRhOiB7XG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6ICfQktGW0YLQsNC70ZbQuSDQkdGD0LHQu9C40LonLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbGFiZWw6ICdFbWFpbDonLFxuICAgICAgICAgICAgdHlwZTogJ2VtYWlsJyxcbiAgICAgICAgICAgIG5hbWU6ICdlbWFpbCcsXG4gICAgICAgICAgICBtZXRhOiB7XG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6ICdteWxvdmVkbWFpbEBnbWFpbC5jb20nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbGFiZWw6ICfQotC10LvQtdGE0L7QvTonLFxuICAgICAgICAgICAgdHlwZTogJ3RlbCcsXG4gICAgICAgICAgICBuYW1lOiAncGhvbmUnLFxuICAgICAgICAgICAgbWV0YToge1xuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiAnKzM4MDk3NDM1NDUzMicsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBsYWJlbDogJ9Cc0ZbRgdGC0L46JyxcbiAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgIG5hbWU6ICdzaGlwLWNpdHknLFxuICAgICAgICAgICAgbWV0YToge1xuICAgICAgICAgICAgICAgIHBvc3RJY29uOiAnc2VhcmNoJyxcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogJ9Cb0YzQstGW0LIuLi4nLFxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBsYWJlbDogJ9CU0LXQvdGMINC90LDRgNC+0LTQttC10L3QvdGPOicsXG4gICAgICAgICAgICB0eXBlOiAnZGF0ZScsXG4gICAgICAgICAgICBuYW1lOiAnYmRheScsXG4gICAgICAgICAgICBtZXRhOiB7XG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6ICcxMC4xMC4yMDEwJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxhYmVsOiAn0J/QsNGA0L7Qu9GMOicsXG4gICAgICAgICAgICB0eXBlOiAncGFzc3dvcmQnLFxuICAgICAgICAgICAgbmFtZTogJ3Bhc3N3b3JkJyxcbiAgICAgICAgICAgIG1ldGE6IHtcbiAgICAgICAgICAgICAgICBtaW5sZW5ndGg6IDgsXG4gICAgICAgICAgICAgICAgcmVxdWlyZWQ6ICdyZXF1aXJlZCcsXG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6ICfQktCy0LXQtNGW0YLRjCDQv9Cw0YDQvtC70YwuLi4nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbGFiZWw6ICfQpNC+0YLQvtCz0LDQu9C10YDQtdGPOicsXG4gICAgICAgICAgICB0eXBlOiAnZmlsZXMnLFxuICAgICAgICAgICAgbmFtZTogJ3Bob3RvcycsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxhYmVsOiAn0KHRgtCw0YLRjDonLFxuICAgICAgICAgICAgdHlwZTogJ3JhZGlvJyxcbiAgICAgICAgICAgIG5hbWU6ICdzZXgnLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBsYWJlbDogJ9Ck0L7RgtC+OicsXG4gICAgICAgICAgICB0eXBlOiAnZmlsZScsXG4gICAgICAgICAgICBuYW1lOiAncGhvdG8nLFxuICAgICAgICB9LFxuICAgICAgICAvLyB7XG4gICAgICAgIC8vICAgICBsYWJlbDogJ9CS0LDQutGG0LjQvdCw0YbRltGPOicsXG4gICAgICAgIC8vICAgICB0eXBlOiAnY2hlY2tib3gnLFxuICAgICAgICAvLyAgICAgbmFtZTogJ3ZhY2NpbmVzJyxcbiAgICAgICAgLy8gICAgIG1ldGE6IHtcbiAgICAgICAgLy8gICAgICAgICBvcHRpb25zOiBbXG4gICAgICAgIC8vICAgICAgICAgICAgIHtcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIHZhbHVlOiAnb3JnMScsXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICB0ZXh0OiAn0JLRltC0INC60LvRltGJ0ZbQsicsXG4gICAgICAgIC8vICAgICAgICAgICAgIH0sXG4gICAgICAgIC8vICAgICAgICAgICAgIHtcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIHZhbHVlOiAnb3JnMicsXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICB0ZXh0OiAn0JLRltC0INC/0LDRgNCy0L7QstGW0YDRg9GB0L3QvtCz0L4g0LXQvdGC0LXRgNC40YLQsCDQktGW0LQg0L/QsNGA0LLQvtCy0ZbRgNGD0YHQvdC+0LPQviDQtdC90YLQtdGA0LjRgtCwINCS0ZbQtCDQv9Cw0YDQstC+0LLRltGA0YPRgdC90L7Qs9C+INC10L3RgtC10YDQuNGC0LAnLFxuICAgICAgICAvLyAgICAgICAgICAgICB9LFxuICAgICAgICAvLyAgICAgICAgICAgICB7XG4gICAgICAgIC8vICAgICAgICAgICAgICAgICB2YWx1ZTogJ29yZzMnLFxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgdGV4dDogJ9CS0ZbQtCDQutC70ZbRidGW0LInLFxuICAgICAgICAvLyAgICAgICAgICAgICB9XG4gICAgICAgIC8vICAgICAgICAgXVxuICAgICAgICAvLyAgICAgfSxcbiAgICAgICAgLy8gfSxcbiAgICAgICAgLy8ge1xuICAgICAgICAvLyAgICAgbGFiZWw6ICfQntGA0LPQsNC90ZbQt9Cw0YbRltGPOicsXG4gICAgICAgIC8vICAgICB0eXBlOiAnc2VsZWN0JyxcbiAgICAgICAgLy8gICAgIG5hbWU6ICdvcmdhbml6YXRpb24nLFxuICAgICAgICAvLyAgICAgbWV0YToge1xuICAgICAgICAvLyAgICAgICAgIHBsYWNlaG9sZGVyOiAn0JLQuNCx0LXRgNGW0YLRjCDQvtGA0LPQsNC90ZbQt9Cw0YbRltGOLi4uJyxcbiAgICAgICAgLy8gICAgICAgICBvcHRpb25zOiBbXG4gICAgICAgIC8vICAgICAgICAgICAgIHtcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIHZhbHVlOiAnJyxcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIGxhYmVsOiAn0JLQuNCx0YDQsNGC0LguLi4nLFxuICAgICAgICAvLyAgICAgICAgICAgICB9LFxuICAgICAgICAvLyAgICAgICAgICAgICB7XG4gICAgICAgIC8vICAgICAgICAgICAgICAgICB2YWx1ZTogJ29yZzEnLFxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgbGFiZWw6ICfQlNGW0Lwg0KHRltGA0LrQsCcsXG4gICAgICAgIC8vICAgICAgICAgICAgIH0sXG4gICAgICAgIC8vICAgICAgICAgICAgIHtcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIHZhbHVlOiAnb3JnMicsXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICBsYWJlbDogJ9Cc0LjQu9C+0YHQtdGA0LTRjycsXG4gICAgICAgIC8vICAgICAgICAgICAgIH0sXG4gICAgICAgIC8vICAgICAgICAgICAgIHtcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIHZhbHVlOiAnb3JnMycsXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICBsYWJlbDogJ9CU0L7QsdGA0ZYg0LvRjtC00LgnLFxuICAgICAgICAvLyAgICAgICAgICAgICB9XG4gICAgICAgIC8vICAgICAgICAgXVxuICAgICAgICAvLyAgICAgfSxcbiAgICAgICAgLy8gfSxcbiAgICAgICAgLy8ge1xuICAgICAgICAvLyAgICAgbGFiZWw6ICfQntC/0LjRgSDRhNC+0L3QtNGDOicsXG4gICAgICAgIC8vICAgICB0eXBlOiAndGV4dGFyZWEnLFxuICAgICAgICAvLyAgICAgbmFtZTogJ2Rlc2NyaXB0aW9uJyxcbiAgICAgICAgLy8gICAgIG1ldGE6IHtcbiAgICAgICAgLy8gICAgICAgICByb3dzOiA2LFxuICAgICAgICAvLyAgICAgICAgIHBsYWNlaG9sZGVyOiAn0JfQsdC40YDQsNGU0LzQviDQs9GA0L7RiNGWINC90LAg0LTQvtC/0L7QvNC+0LPRgy4uLicsXG4gICAgICAgIC8vICAgICB9LFxuICAgICAgICAvLyB9LFxuICAgIF1cbjwvc2NyaXB0PlxuXG48ZGl2IGNsYXNzPVwidGV4dC1jZW50ZXIgZmxleCBmbGV4LWNvbHVtbiBmbGV4LWFsaWduLWNlbnRlclwiPlxuICAgIDxzcGFuPlxuICAgICAgICA8QXZhdGFyIHNpemU9XCJiaWdcIiB7c3JjfSBhbHQ9XCLQntGA0LPQsNC90ZbQt9Cw0YbRltGPXCIvPlxuICAgIDwvc3Bhbj5cblxuICAgIDxCciBzaXplPVwiMjBcIi8+XG5cbiAgICB7I2lmIHRpdGxlICE9PSB1bmRlZmluZWR9XG4gICAgeyNpZiB0aXRsZSAhPT0gbnVsbH1cbiAgICAgICAgPGgyPnt0aXRsZX08L2gyPlxuICAgIHs6ZWxzZX1cbiAgICAgICAgPGRpdiBzdHlsZT1cIndpZHRoOiAyMDBweFwiPjxMb2FkZXIgdHlwZT1cImgyXCIvPjwvZGl2PlxuICAgIHsvaWZ9XG4gICAgey9pZn1cbiAgICA8QnIgc2l6ZT1cIjRcIi8+XG4gICAgeyNpZiB0aXRsZSAhPT0gdW5kZWZpbmVkfVxuICAgIHsjaWYgdGl0bGUgIT09IG51bGx9XG4gICAgICAgIDxwPntzdWJ0aXRsZX08L3A+XG4gICAgezplbHNlfVxuICAgICAgICA8ZGl2IHN0eWxlPVwid2lkdGg6IDEwMHB4XCI+PExvYWRlciB0eXBlPVwicFwiLz48L2Rpdj5cbiAgICB7L2lmfVxuICAgIHsvaWZ9XG5cbiAgICA8QnIgc2l6ZT1cIjQwXCIvPlxuICAgIDxzZWN0aW9uIGNsYXNzPVwiZnVsbC13aWR0aFwiPlxuICAgICAgICA8Rm9ybUJ1aWxkZXJcbiAgICAgICAgICAgICAgICBpdGVtcz17Zm9ybUZpZWxkc31cbiAgICAgICAgICAgICAgICBkYXRhPXtmb3JtVmFsdWVzfVxuICAgICAgICAgICAgICAgIGVycm9ycz17Zm9ybUVycm9yc31cbiAgICAgICAgLz5cblxuICAgICAgICA8YnV0dG9uIHR5cGU9XCJzdWJtaXRcIiBmb3JtPVwidXNlci1mb3JtXCI+0JfQsdC10YDQtdCz0YLQuDwvYnV0dG9uPlxuICAgIDwvc2VjdGlvbj5cbjwvZGl2PlxuIiwiIDxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgc2FmZUdldCB9IGZyb20gJ0B1dGlscydcbiAgICBpbXBvcnQgeyBCciwgQ2FyZCwgSWNvbiwgQnV0dG9uIH0gZnJvbSAnQGNvbXBvbmVudHMnXG4gICAgaW1wb3J0IHsgVXNlckNhcmRWaWV3LCBVc2VyQ2FyZEVkaXQgfSBmcm9tICcuL19jb21wb25lbnRzJ1xuXG4gICAgZXhwb3J0IGxldCBzcmMgPSBudWxsXG4gICAgZXhwb3J0IGxldCBzcmNCaWcgPSBudWxsXG4gICAgZXhwb3J0IGxldCBpdGVtcyA9IG51bGxcbiAgICBleHBvcnQgbGV0IHRpdGxlID0gbnVsbFxuICAgIGV4cG9ydCBsZXQgc3VidGl0bGUgPSBudWxsXG5cbiAgICBjb25zdCB0b3AgPSBbJ3RlbGVncmFtJywgJ2ZhY2Vib29rJywgJ3ZpYmVyJ11cblxuICAgIGxldCBpc1ZpZXdNb2RlID0gdHJ1ZVxuXG4gICAgJDogaXRlbXNYID0gaXRlbXMgPT09IG51bGwgPyBudWxsIDogc2FmZUdldCgoKSA9PiBpdGVtcy5maWx0ZXIoaSA9PiB0b3AuaW5jbHVkZXMoaS50eXBlKSkpXG4gICAgJDogaXRlbXNZID0gaXRlbXMgPT09IG51bGwgPyBudWxsIDogc2FmZUdldCgoKSA9PiBpdGVtcy5maWx0ZXIoaSA9PiAhdG9wLmluY2x1ZGVzKGkudHlwZSkpKVxuPC9zY3JpcHQ+XG5cbjxDYXJkIGNsYXNzPVwiY29udGFpbmVyXCI+XG4gICAgPEJyIHNpemU9XCIzMFwiLz5cblxuICAgIHsjaWYgaXNWaWV3TW9kZX1cbiAgICAgICAgPFVzZXJDYXJkVmlld1xuICAgICAgICAgICAgICAgIHtzcmN9XG4gICAgICAgICAgICAgICAge3NyY0JpZ31cbiAgICAgICAgICAgICAgICB7dGl0bGV9XG4gICAgICAgICAgICAgICAge3N1YnRpdGxlfVxuICAgICAgICAgICAgICAgIHtpdGVtc1h9XG4gICAgICAgICAgICAgICAge2l0ZW1zWX1cbiAgICAgICAgLz5cbiAgICB7OmVsc2V9XG4gICAgICAgIDxVc2VyQ2FyZEVkaXRcbiAgICAgICAgICAgICAgICB7c3JjfVxuICAgICAgICAgICAgICAgIHt0aXRsZX1cbiAgICAgICAgICAgICAgICB7c3VidGl0bGV9XG4gICAgICAgIC8+XG4gICAgey9pZn1cblxuICAgIDxCciBzaXplPVwiMzBcIi8+XG5cbiAgICA8QnV0dG9uIHNpemU9XCJzbWFsbFwiIGlzPXtpc1ZpZXdNb2RlID8gXCJpbmZvXCIgOiAnJ30gb246Y2xpY2s9eygpID0+IGlzVmlld01vZGUgPSAhaXNWaWV3TW9kZX0+XG4gICAgICAgIHsjaWYgaXNWaWV3TW9kZX1cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaDMgZm9udC1zZWNvbmRhcnkgZm9udC13LTUwMCBmbGV4IGZsZXgtYWxpZ24tY2VudGVyXCI+XG4gICAgICAgICAgICAgICAg0KDQtdC00LDQs9GD0LLQsNGC0LhcbiAgICAgICAgICAgICAgICA8cz48L3M+XG4gICAgICAgICAgICAgICAgPHM+PC9zPlxuICAgICAgICAgICAgICAgIDxJY29uIHR5cGU9XCJlZGl0XCIgc2l6ZT1cInNtYWxsXCIgaXM9XCJsaWdodFwiLz5cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJoMyBmb250LXNlY29uZGFyeSBmb250LXctNTAwIGZsZXggZmxleC1hbGlnbi1jZW50ZXJcIj5cbiAgICAgICAgICAgICAgICDQn9C10YDQtdCz0LvRj9C90YPRgtC4XG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgIHsvaWZ9XG4gICAgPC9CdXR0b24+XG5cbiAgICA8QnIgc2l6ZT1cIjMwXCIvPlxuPC9DYXJkPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSAnc3ZlbHRlJ1xuICAgIGltcG9ydCB7IEFQSSB9IGZyb20gJ0BzZXJ2aWNlcydcbiAgICBpbXBvcnQgeyBkZWxheSwgc2FmZUdldCB9IGZyb20gJ0B1dGlscydcbiAgICBpbXBvcnQgeyBCciwgSWNvbiwgQ2FyZCwgQXZhdGFyLCBCdXR0b24sIEZ1bmRDYXJkcywgRWRpdEFyZWEgfSBmcm9tICdAY29tcG9uZW50cydcbiAgICBpbXBvcnQgVXNlcmNhcmQgZnJvbSAnLi9fVXNlcmNhcmQuc3ZlbHRlJ1xuXG4gICAgbGV0IGhyZWYgPSAnLidcblxuICAgIC8vIEVudGl0aWVzXG4gICAgbGV0IG9yZ2FuaXphdGlvbiA9IHt9XG4gICAgbGV0IGZ1bmRzXG5cbiAgICAkOiBjb250YWN0cyA9IHNhZmVHZXQoKCkgPT4gb3JnYW5pemF0aW9uLmNvbnRhY3RzLm1hcChjID0+ICh7XG4gICAgICAgIHRpdGxlOiBjLnRpdGxlLFxuICAgICAgICBocmVmOiBjLnZhbHVlLFxuICAgICAgICB0eXBlOiBjLnR5cGUsXG4gICAgfSkpLCBudWxsKVxuICAgICQ6IGFuaW1hbEZ1bmRzID0gc2FmZUdldCgoKSA9PiBmdW5kcy5maWx0ZXIoZiA9PiBmLnR5cGUgPT09ICdhbmltYWwnKS5yZWR1Y2UoKGFjYywgZikgPT4gYWNjLmNvbmNhdChmLCBmLCBmKSwgW10pLm1hcChmID0+ICh7XG4gICAgICAgIGlkOiBmLmlkLFxuICAgICAgICBzcmM6IGYuYXZhdGFyc1swXS5zcmMsXG4gICAgICAgIHR5cGU6IGYudHlwZSxcbiAgICAgICAgdGl0bGU6IGYudGl0bGUsXG4gICAgICAgIHRvdGFsOiBmLm5lZWRfc3VtLFxuICAgICAgICBjdXJyZW50OiBmLmN1cnJlbXRfc3VtLFxuICAgICAgICBjdXJyZW5jeTogZi5jdXJyZW5jeSxcbiAgICAgICAgY2l0eTogZi5sb2NhdGlvbi5jaXR5LFxuICAgIH0pKSwgbnVsbClcbiAgICAkOiBvdGhlcnNGdW5kcyA9IHNhZmVHZXQoKCkgPT4gZnVuZHMuZmlsdGVyKGYgPT4gZi50eXBlID09PSAnYW5pbWFsJykucmVkdWNlKChhY2MsIGYpID0+IGFjYy5jb25jYXQoZiwgZiwgZiksIFtdKS5tYXAoZiA9PiAoe1xuICAgICAgICBpZDogZi5pZCxcbiAgICAgICAgc3JjOiBmLmF2YXRhcnNbMF0uc3JjLFxuICAgICAgICB0eXBlOiBmLnR5cGUsXG4gICAgICAgIHRpdGxlOiBmLnRpdGxlLFxuICAgICAgICB0b3RhbDogZi5uZWVkX3N1bSxcbiAgICAgICAgY3VycmVudDogZi5jdXJyZW10X3N1bSxcbiAgICAgICAgY3VycmVuY3k6IGYuY3VycmVuY3ksXG4gICAgICAgIGNpdHk6IGYubG9jYXRpb24uY2l0eSxcbiAgICB9KSksIG51bGwpXG5cbiAgICBvbk1vdW50KGFzeW5jICgpID0+IHtcbiAgICAgICAgYXdhaXQgZGVsYXkoNzAwMClcbiAgICAgICAgb3JnYW5pemF0aW9uID0gYXdhaXQgQVBJLmdldE9yZ2FuaXphdGlvbigxKTtcbiAgICAgICAgZnVuZHMgPSBhd2FpdCBBUEkuZ2V0RnVuZHMoKVxuICAgIH0pO1xuPC9zY3JpcHQ+XG5cbjxzZWN0aW9uIGNsYXNzPVwiY29udGFpbmVyIHRoZW1lLWJnLWNvbG9yLXNlY29uZGFyeVwiPlxuICAgIDxCciBzaXplPVwidmFyKC0taGVhZGVyLWhlaWdodClcIi8+XG4gICAgPEJyIHNpemU9XCIzNVwiLz5cblxuICAgIDxoMSBjbGFzcz1cInRleHQtY2VudGVyXCI+0J/RgNC+INC80LXQvdC1PC9oMT5cbiAgICA8QnIgc2l6ZT1cIjIwXCIvPlxuXG4gICAgPFVzZXJjYXJkXG4gICAgICAgICAgICBpdGVtcz17Y29udGFjdHN9XG4gICAgICAgICAgICB0aXRsZT17c2FmZUdldCgoKSA9PiBvcmdhbml6YXRpb24ubmFtZSl9XG4gICAgICAgICAgICBzdWJ0aXRsZT17c2FmZUdldCgoKSA9PiBvcmdhbml6YXRpb24udGl0bGUpfVxuICAgICAgICAgICAgc3JjPXtzYWZlR2V0KCgpID0+IG9yZ2FuaXphdGlvbi5hdmF0YXIpfVxuICAgICAgICAgICAgc3JjQmlnPXtzYWZlR2V0KCgpID0+IG9yZ2FuaXphdGlvbi5hdmF0YXJCaWcpfVxuICAgIC8+XG5cbiAgICA8QnIgc2l6ZT1cIjE1XCIgLz5cblxuICAgIDxkaXYgY2xhc3M9XCJmdWxsLWNvbnRhaW5lclwiPlxuICAgICAgICA8RWRpdEFyZWE+XG4gICAgICAgICAgICA8QnIgc2l6ZT1cIjQwXCIgLz5cbiAgICAgICAgICAgIDxoMT7QnNC+0Zcg0L7RgNCz0LDQvdGW0LfQsNGG0ZbRlzwvaDE+XG4gICAgICAgICAgICA8QnIgc2l6ZT1cIjVcIiAvPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZ1bGwtY29udGFpbmVyXCI+XG4gICAgICAgICAgICAgICAgPEZ1bmRDYXJkcyBpdGVtcz17YW5pbWFsRnVuZHN9PlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IHNsb3Q9XCJidXR0b25cIiBsZXQ6aWQ9e2lkfT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxCdXR0b24gc2l6ZT1cInNtYWxsXCIgaXM9XCJpbmZvXCIgaHJlZj17aWR9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaDMgZm9udC1zZWNvbmRhcnkgZm9udC13LTUwMCBmbGV4IGZsZXgtYWxpZ24tY2VudGVyXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgINCg0LXQtNCw0LPRg9Cy0LDRgtC4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzPjwvcz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHM+PC9zPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8SWNvbiB0eXBlPVwiZWRpdFwiIHNpemU9XCJzbWFsbFwiIGlzPVwibGlnaHRcIi8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvRnVuZENhcmRzPlxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgIDxCciBzaXplPVwiMzVcIiAvPlxuICAgICAgICAgICAgPEJ1dHRvbiBzaXplPVwiYmlnXCIgaXM9XCJzdWNjZXNzXCIgaHJlZj17aHJlZn0+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJoMiBmb250LXNlY29uZGFyeSBmb250LXctNjAwXCI+XG4gICAgICAgICAgICAgICAgICAgINCU0L7QtNCw0YLQuFxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICAgICAgPEJyIHNpemU9XCI0MFwiIC8+XG4gICAgICAgIDwvRWRpdEFyZWE+XG4gICAgPC9kaXY+XG5cbiAgICA8QnIgc2l6ZT1cIjE1XCIgLz5cblxuICAgIDxoMT7QnNC+0Zcg0YTQvtC90LTQuDwvaDE+XG4gICAgPEJyIHNpemU9XCI1XCIgLz5cbiAgICA8ZGl2IGNsYXNzPVwiZnVsbC1jb250YWluZXJcIj5cbiAgICAgICAgPEZ1bmRDYXJkcyBpdGVtcz17b3RoZXJzRnVuZHN9PlxuICAgICAgICAgICAgPGRpdiBzbG90PVwiYnV0dG9uXCIgbGV0OmlkPXtpZH0+XG4gICAgICAgICAgICAgICAgPEJ1dHRvbiBzaXplPVwic21hbGxcIiBpcz1cImluZm9cIiBocmVmPXtpZH0+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaDMgZm9udC1zZWNvbmRhcnkgZm9udC13LTUwMCBmbGV4IGZsZXgtYWxpZ24tY2VudGVyXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICDQoNC10LTQsNCz0YPQstCw0YLQuFxuICAgICAgICAgICAgICAgICAgICAgICAgPHM+PC9zPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHM+PC9zPlxuICAgICAgICAgICAgICAgICAgICAgICAgPEljb24gdHlwZT1cImVkaXRcIiBzaXplPVwic21hbGxcIiBpcz1cImxpZ2h0XCIvPlxuICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9GdW5kQ2FyZHM+XG4gICAgPC9kaXY+XG5cbiAgICA8QnIgc2l6ZT1cIjM1XCIgLz5cbiAgICA8QnV0dG9uIHNpemU9XCJiaWdcIiBpcz1cInN1Y2Nlc3NcIiBocmVmPXtocmVmfT5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJoMiBmb250LXNlY29uZGFyeSBmb250LXctNjAwXCI+XG4gICAgICAgICAgICDQlNC+0LTQsNGC0LhcbiAgICAgICAgPC9zcGFuPlxuICAgIDwvQnV0dG9uPlxuXG4gICAgPEJyIHNpemU9XCIxMjVcIiAvPlxuPC9zZWN0aW9uPlxuXG48c3R5bGU+XG48L3N0eWxlPlxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2dCQXlCUyxHQUFLLFFBQUssSUFBSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztzQkFDVixHQUFLOzs7Ozs7c0NBQUwsR0FBSzs7Ozs7Ozs7Ozs7O3NEQUFMLEdBQUs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztnQkFPVCxHQUFLLFFBQUssSUFBSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt5QkFDWCxHQUFROzs7Ozs7d0NBQVIsR0FBUTs7Ozs7Ozs7Ozs7OzREQUFSLEdBQVE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzhCQVNDLEdBQU07Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2tFQUFOLEdBQU07Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzhCQUtOLEdBQU07Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2tFQUFOLEdBQU07Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7aUJBUHRCLEtBQUssQ0FBQyxPQUFPLFlBQUMsR0FBTTs7ZUFLcEIsS0FBSyxDQUFDLE9BQU8sWUFBQyxHQUFNOzs7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
