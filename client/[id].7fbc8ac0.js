import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, A as TrustButton, B as Br, E as createEventDispatcher, v as validate_slots, e as element, g as create_component, f as space, t as text, k as claim_element, l as children, m as claim_component, h as detach_dev, j as claim_space, n as claim_text, G as set_style, p as add_location, o as attr_dev, r as insert_dev, a as append_dev, u as mount_component, x as transition_in, y as transition_out, z as destroy_component, H as Button, I as Icon, w as noop, C as Carousel, c as Comments, J as DonatorsList, K as FundCards, M as Modal, N as set_data_dev, O as Loader, Q as empty, R as group_outros, U as check_outros, V as NewsList, W as onMount, X as modals, Y as bodyScroll, Z as safeGet, _ as FancyBox, $ as Documents$2, a0 as Card, a1 as Avatar, a2 as SocialsX, a3 as SocialsY, a4 as Picture, a5 as classnames, a6 as null_to_empty, a7 as EditCard, a8 as FormBuilder, a9 as bubble, aa as options, ab as LazyToggle, F as Footer, ac as stores$1, ad as validate_store, ae as component_subscribe, af as API, ag as delay, ah as EditArea, ai as globals, q as query_selector_all } from './client.02b1df94.js';

/* src/routes/organizations/components/_Trust.svelte generated by Svelte v3.24.0 */
const file = "src/routes/organizations/components/_Trust.svelte";

function create_fragment(ctx) {
	let section;
	let div;
	let trustbutton;
	let t0;
	let br;
	let t1;
	let h2;
	let t2;
	let current;

	trustbutton = new TrustButton({
			props: { isActive: /*active*/ ctx[0] },
			$$inline: true
		});

	trustbutton.$on("click", /*click_handler*/ ctx[2]);
	br = new Br({ props: { size: "10" }, $$inline: true });

	const block = {
		c: function create() {
			section = element("section");
			div = element("div");
			create_component(trustbutton.$$.fragment);
			t0 = space();
			create_component(br.$$.fragment);
			t1 = space();
			h2 = element("h2");
			t2 = text("Я довіряю");
			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { class: true });
			var section_nodes = children(section);
			div = claim_element(section_nodes, "DIV", { style: true });
			var div_nodes = children(div);
			claim_component(trustbutton.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			t0 = claim_space(section_nodes);
			claim_component(br.$$.fragment, section_nodes);
			t1 = claim_space(section_nodes);
			h2 = claim_element(section_nodes, "H2", {});
			var h2_nodes = children(h2);
			t2 = claim_text(h2_nodes, "Я довіряю");
			h2_nodes.forEach(detach_dev);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_style(div, "width", "100px");
			set_style(div, "max-width", "100%");
			add_location(div, file, 10, 4, 275);
			add_location(h2, file, 14, 4, 438);
			attr_dev(section, "class", "flex flex-column flex-align-center flex-justify-center");
			add_location(section, file, 9, 0, 198);
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			append_dev(section, div);
			mount_component(trustbutton, div, null);
			append_dev(section, t0);
			mount_component(br, section, null);
			append_dev(section, t1);
			append_dev(section, h2);
			append_dev(h2, t2);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const trustbutton_changes = {};
			if (dirty & /*active*/ 1) trustbutton_changes.isActive = /*active*/ ctx[0];
			trustbutton.$set(trustbutton_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(trustbutton.$$.fragment, local);
			transition_in(br.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(trustbutton.$$.fragment, local);
			transition_out(br.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			destroy_component(trustbutton);
			destroy_component(br);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	const dispatch = createEventDispatcher();
	let { active = false } = $$props;
	const writable_props = ["active"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Trust> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Trust", $$slots, []);
	const click_handler = e => dispatch("click", !active);

	$$self.$set = $$props => {
		if ("active" in $$props) $$invalidate(0, active = $$props.active);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		TrustButton,
		Br,
		dispatch,
		active
	});

	$$self.$inject_state = $$props => {
		if ("active" in $$props) $$invalidate(0, active = $$props.active);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [active, dispatch, click_handler];
}

class Trust extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, { active: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Trust",
			options,
			id: create_fragment.name
		});
	}

	get active() {
		throw new Error("<Trust>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set active(value) {
		throw new Error("<Trust>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/organizations/components/_Share.svelte generated by Svelte v3.24.0 */
const file$1 = "src/routes/organizations/components/_Share.svelte";

// (6:2) <Button class="flex flex-align-center" auto size="small">
function create_default_slot_1(ctx) {
	let icon;
	let t0;
	let s0;
	let t1;
	let s1;
	let t2;
	let h3;
	let t3;
	let current;

	icon = new Icon({
			props: {
				type: "share",
				size: "medium",
				class: "theme-svg-fill"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
			t0 = space();
			s0 = element("s");
			t1 = space();
			s1 = element("s");
			t2 = space();
			h3 = element("h3");
			t3 = text("Поділитись");
			this.h();
		},
		l: function claim(nodes) {
			claim_component(icon.$$.fragment, nodes);
			t0 = claim_space(nodes);
			s0 = claim_element(nodes, "S", {});
			children(s0).forEach(detach_dev);
			t1 = claim_space(nodes);
			s1 = claim_element(nodes, "S", {});
			children(s1).forEach(detach_dev);
			t2 = claim_space(nodes);
			h3 = claim_element(nodes, "H3", { class: true });
			var h3_nodes = children(h3);
			t3 = claim_text(h3_nodes, "Поділитись");
			h3_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(s0, file$1, 7, 4, 210);
			add_location(s1, file$1, 8, 4, 220);
			attr_dev(h3, "class", "font-w-500");
			add_location(h3, file$1, 9, 4, 230);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, s0, anchor);
			insert_dev(target, t1, anchor);
			insert_dev(target, s1, anchor);
			insert_dev(target, t2, anchor);
			insert_dev(target, h3, anchor);
			append_dev(h3, t3);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(s0);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(s1);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(h3);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1.name,
		type: "slot",
		source: "(6:2) <Button class=\\\"flex flex-align-center\\\" auto size=\\\"small\\\">",
		ctx
	});

	return block;
}

// (17:2) <Button class="flex flex-align-center" auto size="small">
function create_default_slot(ctx) {
	let icon;
	let t0;
	let s0;
	let t1;
	let s1;
	let t2;
	let h3;
	let t3;
	let current;

	icon = new Icon({
			props: {
				type: "link",
				size: "medium",
				class: "theme-svg-fill"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
			t0 = space();
			s0 = element("s");
			t1 = space();
			s1 = element("s");
			t2 = space();
			h3 = element("h3");
			t3 = text("Скопіювати");
			this.h();
		},
		l: function claim(nodes) {
			claim_component(icon.$$.fragment, nodes);
			t0 = claim_space(nodes);
			s0 = claim_element(nodes, "S", {});
			children(s0).forEach(detach_dev);
			t1 = claim_space(nodes);
			s1 = claim_element(nodes, "S", {});
			children(s1).forEach(detach_dev);
			t2 = claim_space(nodes);
			h3 = claim_element(nodes, "H3", { class: true });
			var h3_nodes = children(h3);
			t3 = claim_text(h3_nodes, "Скопіювати");
			h3_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(s0, file$1, 18, 4, 447);
			add_location(s1, file$1, 19, 4, 457);
			attr_dev(h3, "class", "font-w-500");
			add_location(h3, file$1, 20, 4, 467);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, s0, anchor);
			insert_dev(target, t1, anchor);
			insert_dev(target, s1, anchor);
			insert_dev(target, t2, anchor);
			insert_dev(target, h3, anchor);
			append_dev(h3, t3);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(s0);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(s1);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(h3);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(17:2) <Button class=\\\"flex flex-align-center\\\" auto size=\\\"small\\\">",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let p;
	let button0;
	let t0;
	let s0;
	let t1;
	let s1;
	let t2;
	let s2;
	let t3;
	let s3;
	let t4;
	let s4;
	let t5;
	let button1;
	let current;

	button0 = new Button({
			props: {
				class: "flex flex-align-center",
				auto: true,
				size: "small",
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button1 = new Button({
			props: {
				class: "flex flex-align-center",
				auto: true,
				size: "small",
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			p = element("p");
			create_component(button0.$$.fragment);
			t0 = space();
			s0 = element("s");
			t1 = space();
			s1 = element("s");
			t2 = space();
			s2 = element("s");
			t3 = space();
			s3 = element("s");
			t4 = space();
			s4 = element("s");
			t5 = space();
			create_component(button1.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			p = claim_element(nodes, "P", { class: true });
			var p_nodes = children(p);
			claim_component(button0.$$.fragment, p_nodes);
			t0 = claim_space(p_nodes);
			s0 = claim_element(p_nodes, "S", {});
			children(s0).forEach(detach_dev);
			t1 = claim_space(p_nodes);
			s1 = claim_element(p_nodes, "S", {});
			children(s1).forEach(detach_dev);
			t2 = claim_space(p_nodes);
			s2 = claim_element(p_nodes, "S", {});
			children(s2).forEach(detach_dev);
			t3 = claim_space(p_nodes);
			s3 = claim_element(p_nodes, "S", {});
			children(s3).forEach(detach_dev);
			t4 = claim_space(p_nodes);
			s4 = claim_element(p_nodes, "S", {});
			children(s4).forEach(detach_dev);
			t5 = claim_space(p_nodes);
			claim_component(button1.$$.fragment, p_nodes);
			p_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(s0, file$1, 11, 2, 283);
			add_location(s1, file$1, 12, 2, 291);
			add_location(s2, file$1, 13, 2, 299);
			add_location(s3, file$1, 14, 2, 307);
			add_location(s4, file$1, 15, 2, 315);
			attr_dev(p, "class", "flex");
			add_location(p, file$1, 4, 0, 66);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			mount_component(button0, p, null);
			append_dev(p, t0);
			append_dev(p, s0);
			append_dev(p, t1);
			append_dev(p, s1);
			append_dev(p, t2);
			append_dev(p, s2);
			append_dev(p, t3);
			append_dev(p, s3);
			append_dev(p, t4);
			append_dev(p, s4);
			append_dev(p, t5);
			mount_component(button1, p, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const button0_changes = {};

			if (dirty & /*$$scope*/ 1) {
				button0_changes.$$scope = { dirty, ctx };
			}

			button0.$set(button0_changes);
			const button1_changes = {};

			if (dirty & /*$$scope*/ 1) {
				button1_changes.$$scope = { dirty, ctx };
			}

			button1.$set(button1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
			destroy_component(button0);
			destroy_component(button1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Share> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Share", $$slots, []);
	$$self.$capture_state = () => ({ Button, Icon });
	return [];
}

class Share extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Share",
			options,
			id: create_fragment$1.name
		});
	}
}

/* src/routes/organizations/components/_Videos.svelte generated by Svelte v3.24.0 */
const file$2 = "src/routes/organizations/components/_Videos.svelte";

function create_fragment$2(ctx) {
	let h1;
	let t0;
	let t1;
	let br;
	let t2;
	let section;
	let carousel;
	let current;
	br = new Br({ props: { size: "20" }, $$inline: true });

	carousel = new Carousel({
			props: { items: /*items*/ ctx[0] },
			$$inline: true
		});

	const block = {
		c: function create() {
			h1 = element("h1");
			t0 = text("Відео про нас");
			t1 = space();
			create_component(br.$$.fragment);
			t2 = space();
			section = element("section");
			create_component(carousel.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			h1 = claim_element(nodes, "H1", {});
			var h1_nodes = children(h1);
			t0 = claim_text(h1_nodes, "Відео про нас");
			h1_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			claim_component(br.$$.fragment, nodes);
			t2 = claim_space(nodes);
			section = claim_element(nodes, "SECTION", { class: true, style: true });
			var section_nodes = children(section);
			claim_component(carousel.$$.fragment, section_nodes);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(h1, file$2, 6, 0, 89);
			attr_dev(section, "class", "flex");
			set_style(section, "height", "240px");
			add_location(section, file$2, 8, 0, 129);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h1, anchor);
			append_dev(h1, t0);
			insert_dev(target, t1, anchor);
			mount_component(br, target, anchor);
			insert_dev(target, t2, anchor);
			insert_dev(target, section, anchor);
			mount_component(carousel, section, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const carousel_changes = {};
			if (dirty & /*items*/ 1) carousel_changes.items = /*items*/ ctx[0];
			carousel.$set(carousel_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(br.$$.fragment, local);
			transition_in(carousel.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br.$$.fragment, local);
			transition_out(carousel.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h1);
			if (detaching) detach_dev(t1);
			destroy_component(br, detaching);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(section);
			destroy_component(carousel);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	let { items } = $$props;
	const writable_props = ["items"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Videos> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Videos", $$slots, []);

	$$self.$set = $$props => {
		if ("items" in $$props) $$invalidate(0, items = $$props.items);
	};

	$$self.$capture_state = () => ({ Br, Carousel, items });

	$$self.$inject_state = $$props => {
		if ("items" in $$props) $$invalidate(0, items = $$props.items);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [items];
}

class Videos extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, { items: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Videos",
			options,
			id: create_fragment$2.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*items*/ ctx[0] === undefined && !("items" in props)) {
			console.warn("<Videos> was created without expected prop 'items'");
		}
	}

	get items() {
		throw new Error("<Videos>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set items(value) {
		throw new Error("<Videos>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/organizations/components/_WeOnMap.svelte generated by Svelte v3.24.0 */
const file$3 = "src/routes/organizations/components/_WeOnMap.svelte";

function add_css() {
	var style = element("style");
	style.id = "svelte-1mfnpq7-style";
	style.textContent = "div.svelte-1mfnpq7{background-color:rgba(var(--theme-bg-color-opposite), .04)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiX1dlT25NYXAuc3ZlbHRlIiwic291cmNlcyI6WyJfV2VPbk1hcC5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdD5cbiAgaW1wb3J0IHsgQnIgfSBmcm9tIFwiQGNvbXBvbmVudHNcIjtcbiAgXG4gIGV4cG9ydCBsZXQgc3JjXG48L3NjcmlwdD5cblxuPGgxPtCc0Lgg0L3QsCDQutCw0YDRgtGWPC9oMT5cbjxCciBzaXplPVwiMjBcIiAvPlxuPGRpdiBjbGFzcz1cImZ1bGwtY29udGFpbmVyXCI+XG4gIDxpZnJhbWVcbiAgICB7c3JjfVxuICAgIHRpdGxlPVwi0JrQsNGA0YLQsFwiXG4gICAgd2lkdGg9XCIxMDAlXCJcbiAgICBoZWlnaHQ9XCI0NTBcIlxuICAgIGZyYW1lYm9yZGVyPVwiMFwiXG4gICAgc3R5bGU9XCJib3JkZXI6MDtcIlxuICAgIGFsbG93ZnVsbHNjcmVlbj1cIlwiXG4gICAgYXJpYS1oaWRkZW49XCJmYWxzZVwiXG4gICAgdGFiaW5kZXg9XCIwXCIgPjwvaWZyYW1lPlxuPC9kaXY+XG5cbjxzdHlsZT5cbmRpdiB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSh2YXIoLS10aGVtZS1iZy1jb2xvci1vcHBvc2l0ZSksIC4wNCk7XG59PC9zdHlsZT5cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFzQkEsR0FBRyxlQUFDLENBQUMsQUFDRCxnQkFBZ0IsQ0FBRSxLQUFLLElBQUkseUJBQXlCLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxBQUMvRCxDQUFDIn0= */";
	append_dev(document.head, style);
}

function create_fragment$3(ctx) {
	let h1;
	let t0;
	let t1;
	let br;
	let t2;
	let div;
	let iframe;
	let iframe_src_value;
	let current;
	br = new Br({ props: { size: "20" }, $$inline: true });

	const block = {
		c: function create() {
			h1 = element("h1");
			t0 = text("Ми на карті");
			t1 = space();
			create_component(br.$$.fragment);
			t2 = space();
			div = element("div");
			iframe = element("iframe");
			this.h();
		},
		l: function claim(nodes) {
			h1 = claim_element(nodes, "H1", {});
			var h1_nodes = children(h1);
			t0 = claim_text(h1_nodes, "Ми на карті");
			h1_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			claim_component(br.$$.fragment, nodes);
			t2 = claim_space(nodes);
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);

			iframe = claim_element(div_nodes, "IFRAME", {
				src: true,
				title: true,
				width: true,
				height: true,
				frameborder: true,
				style: true,
				allowfullscreen: true,
				"aria-hidden": true,
				tabindex: true
			});

			children(iframe).forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(h1, file$3, 6, 0, 76);
			if (iframe.src !== (iframe_src_value = /*src*/ ctx[0])) attr_dev(iframe, "src", iframe_src_value);
			attr_dev(iframe, "title", "Карта");
			attr_dev(iframe, "width", "100%");
			attr_dev(iframe, "height", "450");
			attr_dev(iframe, "frameborder", "0");
			set_style(iframe, "border", "0");
			iframe.allowFullscreen = "";
			attr_dev(iframe, "aria-hidden", "false");
			attr_dev(iframe, "tabindex", "0");
			add_location(iframe, file$3, 9, 2, 145);
			attr_dev(div, "class", "full-container svelte-1mfnpq7");
			add_location(div, file$3, 8, 0, 114);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h1, anchor);
			append_dev(h1, t0);
			insert_dev(target, t1, anchor);
			mount_component(br, target, anchor);
			insert_dev(target, t2, anchor);
			insert_dev(target, div, anchor);
			append_dev(div, iframe);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (!current || dirty & /*src*/ 1 && iframe.src !== (iframe_src_value = /*src*/ ctx[0])) {
				attr_dev(iframe, "src", iframe_src_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(br.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h1);
			if (detaching) detach_dev(t1);
			destroy_component(br, detaching);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3($$self, $$props, $$invalidate) {
	let { src } = $$props;
	const writable_props = ["src"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<WeOnMap> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("WeOnMap", $$slots, []);

	$$self.$set = $$props => {
		if ("src" in $$props) $$invalidate(0, src = $$props.src);
	};

	$$self.$capture_state = () => ({ Br, src });

	$$self.$inject_state = $$props => {
		if ("src" in $$props) $$invalidate(0, src = $$props.src);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [src];
}

class WeOnMap extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document.getElementById("svelte-1mfnpq7-style")) add_css();
		init(this, options, instance$3, create_fragment$3, safe_not_equal, { src: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "WeOnMap",
			options,
			id: create_fragment$3.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*src*/ ctx[0] === undefined && !("src" in props)) {
			console.warn("<WeOnMap> was created without expected prop 'src'");
		}
	}

	get src() {
		throw new Error("<WeOnMap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set src(value) {
		throw new Error("<WeOnMap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/organizations/components/_Comments.svelte generated by Svelte v3.24.0 */
const file$4 = "src/routes/organizations/components/_Comments.svelte";

function create_fragment$4(ctx) {
	let h1;
	let t0;
	let t1;
	let br;
	let t2;
	let div;
	let comments;
	let current;
	br = new Br({ props: { size: "5" }, $$inline: true });

	comments = new Comments({
			props: { items: /*items*/ ctx[0] },
			$$inline: true
		});

	const block = {
		c: function create() {
			h1 = element("h1");
			t0 = text("Коментарі");
			t1 = space();
			create_component(br.$$.fragment);
			t2 = space();
			div = element("div");
			create_component(comments.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			h1 = claim_element(nodes, "H1", {});
			var h1_nodes = children(h1);
			t0 = claim_text(h1_nodes, "Коментарі");
			h1_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			claim_component(br.$$.fragment, nodes);
			t2 = claim_space(nodes);
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			claim_component(comments.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(h1, file$4, 6, 0, 86);
			attr_dev(div, "class", "full-container");
			add_location(div, file$4, 8, 0, 121);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h1, anchor);
			append_dev(h1, t0);
			insert_dev(target, t1, anchor);
			mount_component(br, target, anchor);
			insert_dev(target, t2, anchor);
			insert_dev(target, div, anchor);
			mount_component(comments, div, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const comments_changes = {};
			if (dirty & /*items*/ 1) comments_changes.items = /*items*/ ctx[0];
			comments.$set(comments_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(br.$$.fragment, local);
			transition_in(comments.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br.$$.fragment, local);
			transition_out(comments.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h1);
			if (detaching) detach_dev(t1);
			destroy_component(br, detaching);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(div);
			destroy_component(comments);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4($$self, $$props, $$invalidate) {
	let { items } = $$props;
	const writable_props = ["items"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Comments> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Comments", $$slots, []);

	$$self.$set = $$props => {
		if ("items" in $$props) $$invalidate(0, items = $$props.items);
	};

	$$self.$capture_state = () => ({ Br, Comments, items });

	$$self.$inject_state = $$props => {
		if ("items" in $$props) $$invalidate(0, items = $$props.items);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [items];
}

class Comments_1 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4, create_fragment$4, safe_not_equal, { items: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Comments_1",
			options,
			id: create_fragment$4.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*items*/ ctx[0] === undefined && !("items" in props)) {
			console.warn("<Comments> was created without expected prop 'items'");
		}
	}

	get items() {
		throw new Error("<Comments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set items(value) {
		throw new Error("<Comments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/organizations/components/_Donators.svelte generated by Svelte v3.24.0 */
const file$5 = "src/routes/organizations/components/_Donators.svelte";

function create_fragment$5(ctx) {
	let h1;
	let t0;
	let t1;
	let br;
	let t2;
	let div;
	let donatorslist;
	let current;
	br = new Br({ props: { size: "20" }, $$inline: true });

	donatorslist = new DonatorsList({
			props: { items: /*items*/ ctx[0] },
			$$inline: true
		});

	const block = {
		c: function create() {
			h1 = element("h1");
			t0 = text("Наші піклувальники");
			t1 = space();
			create_component(br.$$.fragment);
			t2 = space();
			div = element("div");
			create_component(donatorslist.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			h1 = claim_element(nodes, "H1", {});
			var h1_nodes = children(h1);
			t0 = claim_text(h1_nodes, "Наші піклувальники");
			h1_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			claim_component(br.$$.fragment, nodes);
			t2 = claim_space(nodes);
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			claim_component(donatorslist.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(h1, file$5, 6, 0, 93);
			attr_dev(div, "class", "full-container");
			add_location(div, file$5, 8, 0, 137);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h1, anchor);
			append_dev(h1, t0);
			insert_dev(target, t1, anchor);
			mount_component(br, target, anchor);
			insert_dev(target, t2, anchor);
			insert_dev(target, div, anchor);
			mount_component(donatorslist, div, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const donatorslist_changes = {};
			if (dirty & /*items*/ 1) donatorslist_changes.items = /*items*/ ctx[0];
			donatorslist.$set(donatorslist_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(br.$$.fragment, local);
			transition_in(donatorslist.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br.$$.fragment, local);
			transition_out(donatorslist.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h1);
			if (detaching) detach_dev(t1);
			destroy_component(br, detaching);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(div);
			destroy_component(donatorslist);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$5.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$5($$self, $$props, $$invalidate) {
	let { items } = $$props;
	const writable_props = ["items"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Donators> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Donators", $$slots, []);

	$$self.$set = $$props => {
		if ("items" in $$props) $$invalidate(0, items = $$props.items);
	};

	$$self.$capture_state = () => ({ Br, DonatorsList, items });

	$$self.$inject_state = $$props => {
		if ("items" in $$props) $$invalidate(0, items = $$props.items);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [items];
}

class Donators extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$5, create_fragment$5, safe_not_equal, { items: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Donators",
			options,
			id: create_fragment$5.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*items*/ ctx[0] === undefined && !("items" in props)) {
			console.warn("<Donators> was created without expected prop 'items'");
		}
	}

	get items() {
		throw new Error("<Donators>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set items(value) {
		throw new Error("<Donators>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/organizations/components/_FundList.svelte generated by Svelte v3.24.0 */
const file$6 = "src/routes/organizations/components/_FundList.svelte";

function create_fragment$6(ctx) {
	let h1;
	let t0;
	let t1;
	let br;
	let t2;
	let div;
	let fundcards;
	let current;
	br = new Br({ props: { size: "5" }, $$inline: true });

	fundcards = new FundCards({
			props: { items: /*items*/ ctx[1] },
			$$inline: true
		});

	const block = {
		c: function create() {
			h1 = element("h1");
			t0 = text(/*title*/ ctx[0]);
			t1 = space();
			create_component(br.$$.fragment);
			t2 = space();
			div = element("div");
			create_component(fundcards.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			h1 = claim_element(nodes, "H1", {});
			var h1_nodes = children(h1);
			t0 = claim_text(h1_nodes, /*title*/ ctx[0]);
			h1_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			claim_component(br.$$.fragment, nodes);
			t2 = claim_space(nodes);
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			claim_component(fundcards.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(h1, file$6, 7, 0, 118);
			attr_dev(div, "class", "full-container");
			add_location(div, file$6, 9, 0, 151);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h1, anchor);
			append_dev(h1, t0);
			insert_dev(target, t1, anchor);
			mount_component(br, target, anchor);
			insert_dev(target, t2, anchor);
			insert_dev(target, div, anchor);
			mount_component(fundcards, div, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (!current || dirty & /*title*/ 1) set_data_dev(t0, /*title*/ ctx[0]);
			const fundcards_changes = {};
			if (dirty & /*items*/ 2) fundcards_changes.items = /*items*/ ctx[1];
			fundcards.$set(fundcards_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(br.$$.fragment, local);
			transition_in(fundcards.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br.$$.fragment, local);
			transition_out(fundcards.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h1);
			if (detaching) detach_dev(t1);
			destroy_component(br, detaching);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(div);
			destroy_component(fundcards);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$6.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$6($$self, $$props, $$invalidate) {
	let { title } = $$props;
	let { items } = $$props;
	const writable_props = ["title", "items"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<FundList> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("FundList", $$slots, []);

	$$self.$set = $$props => {
		if ("title" in $$props) $$invalidate(0, title = $$props.title);
		if ("items" in $$props) $$invalidate(1, items = $$props.items);
	};

	$$self.$capture_state = () => ({ Br, FundCards, Modal, title, items });

	$$self.$inject_state = $$props => {
		if ("title" in $$props) $$invalidate(0, title = $$props.title);
		if ("items" in $$props) $$invalidate(1, items = $$props.items);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [title, items];
}

class FundList extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$6, create_fragment$6, safe_not_equal, { title: 0, items: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "FundList",
			options,
			id: create_fragment$6.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*title*/ ctx[0] === undefined && !("title" in props)) {
			console.warn("<FundList> was created without expected prop 'title'");
		}

		if (/*items*/ ctx[1] === undefined && !("items" in props)) {
			console.warn("<FundList> was created without expected prop 'items'");
		}
	}

	get title() {
		throw new Error("<FundList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<FundList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get items() {
		throw new Error("<FundList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set items(value) {
		throw new Error("<FundList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/organizations/components/_TopCarousel.svelte generated by Svelte v3.24.0 */
const file$7 = "src/routes/organizations/components/_TopCarousel.svelte";

function create_fragment$7(ctx) {
	let section;
	let carousel;
	let current;

	carousel = new Carousel({
			props: {
				items: /*items*/ ctx[0],
				dotsBelow: false
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			section = element("section");
			create_component(carousel.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { class: true, style: true });
			var section_nodes = children(section);
			claim_component(carousel.$$.fragment, section_nodes);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(section, "class", "flex");
			set_style(section, "height", "240px");
			add_location(section, file$7, 6, 0, 90);
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			mount_component(carousel, section, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const carousel_changes = {};
			if (dirty & /*items*/ 1) carousel_changes.items = /*items*/ ctx[0];
			carousel.$set(carousel_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(carousel.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(carousel.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			destroy_component(carousel);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$7.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$7($$self, $$props, $$invalidate) {
	let { items = [] } = $$props;
	const writable_props = ["items"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<TopCarousel> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("TopCarousel", $$slots, []);

	$$self.$set = $$props => {
		if ("items" in $$props) $$invalidate(0, items = $$props.items);
	};

	$$self.$capture_state = () => ({ Carousel, items });

	$$self.$inject_state = $$props => {
		if ("items" in $$props) $$invalidate(0, items = $$props.items);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [items];
}

class TopCarousel extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$7, create_fragment$7, safe_not_equal, { items: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "TopCarousel",
			options,
			id: create_fragment$7.name
		});
	}

	get items() {
		throw new Error("<TopCarousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set items(value) {
		throw new Error("<TopCarousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/organizations/components/_DescriptionShort.svelte generated by Svelte v3.24.0 */
const file$8 = "src/routes/organizations/components/_DescriptionShort.svelte";

// (10:0) {:else}
function create_else_block_1(ctx) {
	let div;
	let loader;
	let current;
	loader = new Loader({ props: { type: "h2" }, $$inline: true });

	const block = {
		c: function create() {
			div = element("div");
			create_component(loader.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { style: true });
			var div_nodes = children(div);
			claim_component(loader.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_style(div, "width", "85%");
			add_location(div, file$8, 10, 4, 152);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(loader, div, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(loader.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loader.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(loader);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1.name,
		type: "else",
		source: "(10:0) {:else}",
		ctx
	});

	return block;
}

// (8:0) {#if title}
function create_if_block_1(ctx) {
	let h2;
	let t;

	const block = {
		c: function create() {
			h2 = element("h2");
			t = text(/*title*/ ctx[0]);
			this.h();
		},
		l: function claim(nodes) {
			h2 = claim_element(nodes, "H2", {});
			var h2_nodes = children(h2);
			t = claim_text(h2_nodes, /*title*/ ctx[0]);
			h2_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(h2, file$8, 8, 4, 123);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h2, anchor);
			append_dev(h2, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*title*/ 1) set_data_dev(t, /*title*/ ctx[0]);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(h2);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(8:0) {#if title}",
		ctx
	});

	return block;
}

// (19:0) {:else}
function create_else_block(ctx) {
	let loader0;
	let t0;
	let loader1;
	let t1;
	let loader2;
	let t2;
	let div;
	let loader3;
	let current;
	loader0 = new Loader({ props: { type: "pre" }, $$inline: true });
	loader1 = new Loader({ props: { type: "pre" }, $$inline: true });
	loader2 = new Loader({ props: { type: "pre" }, $$inline: true });
	loader3 = new Loader({ props: { type: "pre" }, $$inline: true });

	const block = {
		c: function create() {
			create_component(loader0.$$.fragment);
			t0 = space();
			create_component(loader1.$$.fragment);
			t1 = space();
			create_component(loader2.$$.fragment);
			t2 = space();
			div = element("div");
			create_component(loader3.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			claim_component(loader0.$$.fragment, nodes);
			t0 = claim_space(nodes);
			claim_component(loader1.$$.fragment, nodes);
			t1 = claim_space(nodes);
			claim_component(loader2.$$.fragment, nodes);
			t2 = claim_space(nodes);
			div = claim_element(nodes, "DIV", { style: true });
			var div_nodes = children(div);
			claim_component(loader3.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_style(div, "width", "60%");
			add_location(div, file$8, 22, 4, 375);
		},
		m: function mount(target, anchor) {
			mount_component(loader0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(loader1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(loader2, target, anchor);
			insert_dev(target, t2, anchor);
			insert_dev(target, div, anchor);
			mount_component(loader3, div, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(loader0.$$.fragment, local);
			transition_in(loader1.$$.fragment, local);
			transition_in(loader2.$$.fragment, local);
			transition_in(loader3.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loader0.$$.fragment, local);
			transition_out(loader1.$$.fragment, local);
			transition_out(loader2.$$.fragment, local);
			transition_out(loader3.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(loader0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(loader1, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(loader2, detaching);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(div);
			destroy_component(loader3);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(19:0) {:else}",
		ctx
	});

	return block;
}

// (15:0) {#if text}
function create_if_block(ctx) {
	let pre;
	let t;

	const block = {
		c: function create() {
			pre = element("pre");
			t = text(/*text*/ ctx[1]);
			this.h();
		},
		l: function claim(nodes) {
			pre = claim_element(nodes, "PRE", { class: true });
			var pre_nodes = children(pre);
			t = claim_text(pre_nodes, /*text*/ ctx[1]);
			pre_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(pre, "class", "font-w-300");
			add_location(pre, file$8, 15, 0, 239);
		},
		m: function mount(target, anchor) {
			insert_dev(target, pre, anchor);
			append_dev(pre, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*text*/ 2) set_data_dev(t, /*text*/ ctx[1]);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(pre);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(15:0) {#if text}",
		ctx
	});

	return block;
}

function create_fragment$8(ctx) {
	let current_block_type_index;
	let if_block0;
	let t0;
	let br;
	let t1;
	let current_block_type_index_1;
	let if_block1;
	let if_block1_anchor;
	let current;
	const if_block_creators = [create_if_block_1, create_else_block_1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*title*/ ctx[0]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	br = new Br({ props: { size: "10" }, $$inline: true });
	const if_block_creators_1 = [create_if_block, create_else_block];
	const if_blocks_1 = [];

	function select_block_type_1(ctx, dirty) {
		if (/*text*/ ctx[1]) return 0;
		return 1;
	}

	current_block_type_index_1 = select_block_type_1(ctx);
	if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);

	const block = {
		c: function create() {
			if_block0.c();
			t0 = space();
			create_component(br.$$.fragment);
			t1 = space();
			if_block1.c();
			if_block1_anchor = empty();
		},
		l: function claim(nodes) {
			if_block0.l(nodes);
			t0 = claim_space(nodes);
			claim_component(br.$$.fragment, nodes);
			t1 = claim_space(nodes);
			if_block1.l(nodes);
			if_block1_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(br, target, anchor);
			insert_dev(target, t1, anchor);
			if_blocks_1[current_block_type_index_1].m(target, anchor);
			insert_dev(target, if_block1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block0 = if_blocks[current_block_type_index];

				if (!if_block0) {
					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block0.c();
				}

				transition_in(if_block0, 1);
				if_block0.m(t0.parentNode, t0);
			}

			let previous_block_index_1 = current_block_type_index_1;
			current_block_type_index_1 = select_block_type_1(ctx);

			if (current_block_type_index_1 === previous_block_index_1) {
				if_blocks_1[current_block_type_index_1].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
					if_blocks_1[previous_block_index_1] = null;
				});

				check_outros();
				if_block1 = if_blocks_1[current_block_type_index_1];

				if (!if_block1) {
					if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
					if_block1.c();
				}

				transition_in(if_block1, 1);
				if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(br.$$.fragment, local);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(br.$$.fragment, local);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(t0);
			destroy_component(br, detaching);
			if (detaching) detach_dev(t1);
			if_blocks_1[current_block_type_index_1].d(detaching);
			if (detaching) detach_dev(if_block1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$8.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$8($$self, $$props, $$invalidate) {
	let { title } = $$props;
	let { text } = $$props;
	const writable_props = ["title", "text"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<DescriptionShort> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("DescriptionShort", $$slots, []);

	$$self.$set = $$props => {
		if ("title" in $$props) $$invalidate(0, title = $$props.title);
		if ("text" in $$props) $$invalidate(1, text = $$props.text);
	};

	$$self.$capture_state = () => ({ Br, Loader, title, text });

	$$self.$inject_state = $$props => {
		if ("title" in $$props) $$invalidate(0, title = $$props.title);
		if ("text" in $$props) $$invalidate(1, text = $$props.text);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [title, text];
}

class DescriptionShort extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$8, create_fragment$8, safe_not_equal, { title: 0, text: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "DescriptionShort",
			options,
			id: create_fragment$8.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*title*/ ctx[0] === undefined && !("title" in props)) {
			console.warn("<DescriptionShort> was created without expected prop 'title'");
		}

		if (/*text*/ ctx[1] === undefined && !("text" in props)) {
			console.warn("<DescriptionShort> was created without expected prop 'text'");
		}
	}

	get title() {
		throw new Error("<DescriptionShort>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<DescriptionShort>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get text() {
		throw new Error("<DescriptionShort>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set text(value) {
		throw new Error("<DescriptionShort>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/organizations/components/_InteractionIndicators.svelte generated by Svelte v3.24.0 */
const file$9 = "src/routes/organizations/components/_InteractionIndicators.svelte";

// (25:4) {:else}
function create_else_block_1$1(ctx) {
	let span1;
	let span0;
	let t0;
	let t1;
	let loader;
	let current;

	loader = new Loader({
			props: { type: "h3", absolute: true },
			$$inline: true
		});

	const block = {
		c: function create() {
			span1 = element("span");
			span0 = element("span");
			t0 = text("199");
			t1 = space();
			create_component(loader.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			span1 = claim_element(nodes, "SPAN", { class: true });
			var span1_nodes = children(span1);
			span0 = claim_element(span1_nodes, "SPAN", { style: true });
			var span0_nodes = children(span0);
			t0 = claim_text(span0_nodes, "199");
			span0_nodes.forEach(detach_dev);
			t1 = claim_space(span1_nodes);
			claim_component(loader.$$.fragment, span1_nodes);
			span1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_style(span0, "visibility", "hidden");
			add_location(span0, file$9, 26, 8, 726);
			attr_dev(span1, "class", "font-secondary font-w-600 h3 relative");
			add_location(span1, file$9, 25, 6, 665);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span1, anchor);
			append_dev(span1, span0);
			append_dev(span0, t0);
			append_dev(span1, t1);
			mount_component(loader, span1, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(loader.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loader.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span1);
			destroy_component(loader);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1$1.name,
		type: "else",
		source: "(25:4) {:else}",
		ctx
	});

	return block;
}

// (23:4) {#if likes !== null}
function create_if_block_1$1(ctx) {
	let span;
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(/*likes*/ ctx[0]);
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t = claim_text(span_nodes, /*likes*/ ctx[0]);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "font-secondary font-w-600 h3");
			add_location(span, file$9, 23, 6, 589);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*likes*/ 1) set_data_dev(t, /*likes*/ ctx[0]);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$1.name,
		type: "if",
		source: "(23:4) {#if likes !== null}",
		ctx
	});

	return block;
}

// (13:2) <Button      class="flex flex-align-center"      auto     size="small"     style={`opacity: ${isLiked ? 1 : .5}`}     on:click={() => dispatch('click', !isLiked)} >
function create_default_slot_1$1(ctx) {
	let icon;
	let t0;
	let s0;
	let t1;
	let s1;
	let t2;
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;

	icon = new Icon({
			props: {
				is: "danger",
				type: "heart",
				size: "medium"
			},
			$$inline: true
		});

	const if_block_creators = [create_if_block_1$1, create_else_block_1$1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*likes*/ ctx[0] !== null) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
			t0 = space();
			s0 = element("s");
			t1 = space();
			s1 = element("s");
			t2 = space();
			if_block.c();
			if_block_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			claim_component(icon.$$.fragment, nodes);
			t0 = claim_space(nodes);
			s0 = claim_element(nodes, "S", {});
			children(s0).forEach(detach_dev);
			t1 = claim_space(nodes);
			s1 = claim_element(nodes, "S", {});
			children(s1).forEach(detach_dev);
			t2 = claim_space(nodes);
			if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			add_location(s0, file$9, 20, 4, 542);
			add_location(s1, file$9, 21, 4, 552);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, s0, anchor);
			insert_dev(target, t1, anchor);
			insert_dev(target, s1, anchor);
			insert_dev(target, t2, anchor);
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(s0);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(s1);
			if (detaching) detach_dev(t2);
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$1.name,
		type: "slot",
		source: "(13:2) <Button      class=\\\"flex flex-align-center\\\"      auto     size=\\\"small\\\"     style={`opacity: ${isLiked ? 1 : .5}`}     on:click={() => dispatch('click', !isLiked)} >",
		ctx
	});

	return block;
}

// (34:4) <Button class="flex flex-align-center" auto size="small">
function create_default_slot$1(ctx) {
	let icon;
	let t0;
	let s0;
	let t1;
	let s1;
	let t2;
	let h3;
	let t3;
	let current;

	icon = new Icon({
			props: {
				type: "share",
				size: "medium",
				class: "theme-svg-fill"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
			t0 = space();
			s0 = element("s");
			t1 = space();
			s1 = element("s");
			t2 = space();
			h3 = element("h3");
			t3 = text("Поділитись");
			this.h();
		},
		l: function claim(nodes) {
			claim_component(icon.$$.fragment, nodes);
			t0 = claim_space(nodes);
			s0 = claim_element(nodes, "S", {});
			children(s0).forEach(detach_dev);
			t1 = claim_space(nodes);
			s1 = claim_element(nodes, "S", {});
			children(s1).forEach(detach_dev);
			t2 = claim_space(nodes);
			h3 = claim_element(nodes, "H3", { class: true });
			var h3_nodes = children(h3);
			t3 = claim_text(h3_nodes, "Поділитись");
			h3_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(s0, file$9, 35, 6, 1001);
			add_location(s1, file$9, 36, 6, 1013);
			attr_dev(h3, "class", "font-w-600");
			add_location(h3, file$9, 37, 6, 1025);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, s0, anchor);
			insert_dev(target, t1, anchor);
			insert_dev(target, s1, anchor);
			insert_dev(target, t2, anchor);
			insert_dev(target, h3, anchor);
			append_dev(h3, t3);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(s0);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(s1);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(h3);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$1.name,
		type: "slot",
		source: "(34:4) <Button class=\\\"flex flex-align-center\\\" auto size=\\\"small\\\">",
		ctx
	});

	return block;
}

// (47:4) {:else}
function create_else_block$1(ctx) {
	let span1;
	let span0;
	let t0;
	let t1;
	let loader;
	let current;

	loader = new Loader({
			props: { type: "h3", absolute: true },
			$$inline: true
		});

	const block = {
		c: function create() {
			span1 = element("span");
			span0 = element("span");
			t0 = text("199");
			t1 = space();
			create_component(loader.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			span1 = claim_element(nodes, "SPAN", { class: true });
			var span1_nodes = children(span1);
			span0 = claim_element(span1_nodes, "SPAN", { style: true });
			var span0_nodes = children(span0);
			t0 = claim_text(span0_nodes, "199");
			span0_nodes.forEach(detach_dev);
			t1 = claim_space(span1_nodes);
			claim_component(loader.$$.fragment, span1_nodes);
			span1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_style(span0, "visibility", "hidden");
			add_location(span0, file$9, 48, 8, 1377);
			attr_dev(span1, "class", "font-secondary font-w-600 h3 relative");
			add_location(span1, file$9, 47, 6, 1316);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span1, anchor);
			append_dev(span1, span0);
			append_dev(span0, t0);
			append_dev(span1, t1);
			mount_component(loader, span1, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(loader.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loader.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span1);
			destroy_component(loader);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$1.name,
		type: "else",
		source: "(47:4) {:else}",
		ctx
	});

	return block;
}

// (45:4) {#if views !== null}
function create_if_block$1(ctx) {
	let span;
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(/*views*/ ctx[1]);
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t = claim_text(span_nodes, /*views*/ ctx[1]);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "font-secondary font-w-600 h3");
			add_location(span, file$9, 45, 6, 1240);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*views*/ 2) set_data_dev(t, /*views*/ ctx[1]);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(45:4) {#if views !== null}",
		ctx
	});

	return block;
}

function create_fragment$9(ctx) {
	let p;
	let button0;
	let t0;
	let span0;
	let button1;
	let t1;
	let span1;
	let icon;
	let t2;
	let s0;
	let t3;
	let s1;
	let t4;
	let current_block_type_index;
	let if_block;
	let current;

	button0 = new Button({
			props: {
				class: "flex flex-align-center",
				auto: true,
				size: "small",
				style: `opacity: ${/*isLiked*/ ctx[2] ? 1 : 0.5}`,
				$$slots: { default: [create_default_slot_1$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button0.$on("click", /*click_handler*/ ctx[4]);

	button1 = new Button({
			props: {
				class: "flex flex-align-center",
				auto: true,
				size: "small",
				$$slots: { default: [create_default_slot$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	icon = new Icon({
			props: {
				type: "eye",
				size: "medium",
				class: "theme-svg-fill"
			},
			$$inline: true
		});

	const if_block_creators = [create_if_block$1, create_else_block$1];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*views*/ ctx[1] !== null) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_1(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			p = element("p");
			create_component(button0.$$.fragment);
			t0 = space();
			span0 = element("span");
			create_component(button1.$$.fragment);
			t1 = space();
			span1 = element("span");
			create_component(icon.$$.fragment);
			t2 = space();
			s0 = element("s");
			t3 = space();
			s1 = element("s");
			t4 = space();
			if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			p = claim_element(nodes, "P", { class: true });
			var p_nodes = children(p);
			claim_component(button0.$$.fragment, p_nodes);
			t0 = claim_space(p_nodes);
			span0 = claim_element(p_nodes, "SPAN", { class: true });
			var span0_nodes = children(span0);
			claim_component(button1.$$.fragment, span0_nodes);
			span0_nodes.forEach(detach_dev);
			t1 = claim_space(p_nodes);
			span1 = claim_element(p_nodes, "SPAN", { class: true });
			var span1_nodes = children(span1);
			claim_component(icon.$$.fragment, span1_nodes);
			t2 = claim_space(span1_nodes);
			s0 = claim_element(span1_nodes, "S", {});
			children(s0).forEach(detach_dev);
			t3 = claim_space(span1_nodes);
			s1 = claim_element(span1_nodes, "S", {});
			children(s1).forEach(detach_dev);
			t4 = claim_space(span1_nodes);
			if_block.l(span1_nodes);
			span1_nodes.forEach(detach_dev);
			p_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span0, "class", "flex");
			add_location(span0, file$9, 32, 2, 848);
			add_location(s0, file$9, 42, 4, 1193);
			add_location(s1, file$9, 43, 4, 1203);
			attr_dev(span1, "class", "flex flex-align-center");
			add_location(span1, file$9, 40, 2, 1090);
			attr_dev(p, "class", "container flex flex-justify-between flex-align-center");
			add_location(p, file$9, 11, 0, 253);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			mount_component(button0, p, null);
			append_dev(p, t0);
			append_dev(p, span0);
			mount_component(button1, span0, null);
			append_dev(p, t1);
			append_dev(p, span1);
			mount_component(icon, span1, null);
			append_dev(span1, t2);
			append_dev(span1, s0);
			append_dev(span1, t3);
			append_dev(span1, s1);
			append_dev(span1, t4);
			if_blocks[current_block_type_index].m(span1, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const button0_changes = {};
			if (dirty & /*isLiked*/ 4) button0_changes.style = `opacity: ${/*isLiked*/ ctx[2] ? 1 : 0.5}`;

			if (dirty & /*$$scope, likes*/ 33) {
				button0_changes.$$scope = { dirty, ctx };
			}

			button0.$set(button0_changes);
			const button1_changes = {};

			if (dirty & /*$$scope*/ 32) {
				button1_changes.$$scope = { dirty, ctx };
			}

			button1.$set(button1_changes);
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(span1, null);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			transition_in(icon.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			transition_out(icon.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
			destroy_component(button0);
			destroy_component(button1);
			destroy_component(icon);
			if_blocks[current_block_type_index].d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$9.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$9($$self, $$props, $$invalidate) {
	const dispatch = createEventDispatcher();
	let { likes = null } = $$props;
	let { views = null } = $$props;
	let { isLiked = false } = $$props;
	const writable_props = ["likes", "views", "isLiked"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<InteractionIndicators> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("InteractionIndicators", $$slots, []);
	const click_handler = () => dispatch("click", !isLiked);

	$$self.$set = $$props => {
		if ("likes" in $$props) $$invalidate(0, likes = $$props.likes);
		if ("views" in $$props) $$invalidate(1, views = $$props.views);
		if ("isLiked" in $$props) $$invalidate(2, isLiked = $$props.isLiked);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		Icon,
		Button,
		Loader,
		dispatch,
		likes,
		views,
		isLiked
	});

	$$self.$inject_state = $$props => {
		if ("likes" in $$props) $$invalidate(0, likes = $$props.likes);
		if ("views" in $$props) $$invalidate(1, views = $$props.views);
		if ("isLiked" in $$props) $$invalidate(2, isLiked = $$props.isLiked);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [likes, views, isLiked, dispatch, click_handler];
}

class InteractionIndicators extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$9, create_fragment$9, safe_not_equal, { likes: 0, views: 1, isLiked: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "InteractionIndicators",
			options,
			id: create_fragment$9.name
		});
	}

	get likes() {
		throw new Error("<InteractionIndicators>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set likes(value) {
		throw new Error("<InteractionIndicators>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get views() {
		throw new Error("<InteractionIndicators>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set views(value) {
		throw new Error("<InteractionIndicators>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isLiked() {
		throw new Error("<InteractionIndicators>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isLiked(value) {
		throw new Error("<InteractionIndicators>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/organizations/components/_LastNews.svelte generated by Svelte v3.24.0 */
const file$a = "src/routes/organizations/components/_LastNews.svelte";

// (32:8) {:else}
function create_else_block_1$2(ctx) {
	let loader;
	let current;
	loader = new Loader({ props: { type: "h1" }, $$inline: true });

	const block = {
		c: function create() {
			create_component(loader.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(loader.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(loader, target, anchor);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(loader.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loader.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(loader, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1$2.name,
		type: "else",
		source: "(32:8) {:else}",
		ctx
	});

	return block;
}

// (30:8) {#if descriptionShort.name !== null}
function create_if_block_1$2(ctx) {
	let h1;
	let t_value = /*descriptionShort*/ ctx[4].name + "";
	let t;

	const block = {
		c: function create() {
			h1 = element("h1");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			h1 = claim_element(nodes, "H1", {});
			var h1_nodes = children(h1);
			t = claim_text(h1_nodes, t_value);
			h1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(h1, file$a, 30, 12, 1026);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h1, anchor);
			append_dev(h1, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*descriptionShort*/ 16 && t_value !== (t_value = /*descriptionShort*/ ctx[4].name + "")) set_data_dev(t, t_value);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(h1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$2.name,
		type: "if",
		source: "(30:8) {#if descriptionShort.name !== null}",
		ctx
	});

	return block;
}

// (38:8) {:else}
function create_else_block$2(ctx) {
	let div;
	let loader;
	let current;
	loader = new Loader({ props: { type: "p" }, $$inline: true });

	const block = {
		c: function create() {
			div = element("div");
			create_component(loader.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { style: true });
			var div_nodes = children(div);
			claim_component(loader.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_style(div, "width", "40%");
			add_location(div, file$a, 38, 12, 1264);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(loader, div, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(loader.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loader.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(loader);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$2.name,
		type: "else",
		source: "(38:8) {:else}",
		ctx
	});

	return block;
}

// (36:8) {#if descriptionShort.name !== null}
function create_if_block$2(ctx) {
	let p;
	let t_value = /*descriptionShort*/ ctx[4].name + "";
	let t;

	const block = {
		c: function create() {
			p = element("p");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			p = claim_element(nodes, "P", {});
			var p_nodes = children(p);
			t = claim_text(p_nodes, t_value);
			p_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(p, file$a, 36, 12, 1203);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*descriptionShort*/ 16 && t_value !== (t_value = /*descriptionShort*/ ctx[4].name + "")) set_data_dev(t, t_value);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$2.name,
		type: "if",
		source: "(36:8) {#if descriptionShort.name !== null}",
		ctx
	});

	return block;
}

// (26:0) <Modal id="last-news" size="full" swipe="all">
function create_default_slot$2(ctx) {
	let section1;
	let br0;
	let t0;
	let current_block_type_index;
	let if_block0;
	let t1;
	let br1;
	let t2;
	let current_block_type_index_1;
	let if_block1;
	let t3;
	let br2;
	let t4;
	let section0;
	let carousel_1;
	let t5;
	let br3;
	let t6;
	let descriptionshort;
	let t7;
	let br4;
	let t8;
	let interactionindicators;
	let t9;
	let br5;
	let t10;
	let trust;
	let t11;
	let br6;
	let current;
	br0 = new Br({ $$inline: true });
	const if_block_creators = [create_if_block_1$2, create_else_block_1$2];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*descriptionShort*/ ctx[4].name !== null) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	br1 = new Br({ props: { size: "5" }, $$inline: true });
	const if_block_creators_1 = [create_if_block$2, create_else_block$2];
	const if_blocks_1 = [];

	function select_block_type_1(ctx, dirty) {
		if (/*descriptionShort*/ ctx[4].name !== null) return 0;
		return 1;
	}

	current_block_type_index_1 = select_block_type_1(ctx);
	if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
	br2 = new Br({ props: { size: "25" }, $$inline: true });

	carousel_1 = new Carousel({
			props: {
				items: /*carousel*/ ctx[1],
				stopPropagation: true
			},
			$$inline: true
		});

	br3 = new Br({ props: { size: "25" }, $$inline: true });

	descriptionshort = new DescriptionShort({
			props: {
				text: /*descriptionShort*/ ctx[4].text,
				title: /*descriptionShort*/ ctx[4].name
			},
			$$inline: true
		});

	br4 = new Br({ props: { size: "10" }, $$inline: true });

	interactionindicators = new InteractionIndicators({
			props: {
				likes: /*iconsLine*/ ctx[2].likes,
				views: /*iconsLine*/ ctx[2].views,
				isLiked: /*organization*/ ctx[3].isLiked
			},
			$$inline: true
		});

	br5 = new Br({ props: { size: "50" }, $$inline: true });

	trust = new Trust({
			props: { active: /*organization*/ ctx[3].isLiked },
			$$inline: true
		});

	br6 = new Br({ $$inline: true });

	const block = {
		c: function create() {
			section1 = element("section");
			create_component(br0.$$.fragment);
			t0 = space();
			if_block0.c();
			t1 = space();
			create_component(br1.$$.fragment);
			t2 = space();
			if_block1.c();
			t3 = space();
			create_component(br2.$$.fragment);
			t4 = space();
			section0 = element("section");
			create_component(carousel_1.$$.fragment);
			t5 = space();
			create_component(br3.$$.fragment);
			t6 = space();
			create_component(descriptionshort.$$.fragment);
			t7 = space();
			create_component(br4.$$.fragment);
			t8 = space();
			create_component(interactionindicators.$$.fragment);
			t9 = space();
			create_component(br5.$$.fragment);
			t10 = space();
			create_component(trust.$$.fragment);
			t11 = space();
			create_component(br6.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			section1 = claim_element(nodes, "SECTION", { class: true });
			var section1_nodes = children(section1);
			claim_component(br0.$$.fragment, section1_nodes);
			t0 = claim_space(section1_nodes);
			if_block0.l(section1_nodes);
			t1 = claim_space(section1_nodes);
			claim_component(br1.$$.fragment, section1_nodes);
			t2 = claim_space(section1_nodes);
			if_block1.l(section1_nodes);
			t3 = claim_space(section1_nodes);
			claim_component(br2.$$.fragment, section1_nodes);
			t4 = claim_space(section1_nodes);
			section0 = claim_element(section1_nodes, "SECTION", { class: true, style: true });
			var section0_nodes = children(section0);
			claim_component(carousel_1.$$.fragment, section0_nodes);
			section0_nodes.forEach(detach_dev);
			t5 = claim_space(section1_nodes);
			claim_component(br3.$$.fragment, section1_nodes);
			t6 = claim_space(section1_nodes);
			claim_component(descriptionshort.$$.fragment, section1_nodes);
			t7 = claim_space(section1_nodes);
			claim_component(br4.$$.fragment, section1_nodes);
			t8 = claim_space(section1_nodes);
			claim_component(interactionindicators.$$.fragment, section1_nodes);
			t9 = claim_space(section1_nodes);
			claim_component(br5.$$.fragment, section1_nodes);
			t10 = claim_space(section1_nodes);
			claim_component(trust.$$.fragment, section1_nodes);
			t11 = claim_space(section1_nodes);
			claim_component(br6.$$.fragment, section1_nodes);
			section1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(section0, "class", "flex");
			set_style(section0, "height", "240px");
			add_location(section0, file$a, 42, 8, 1368);
			attr_dev(section1, "class", "container flex flex-column relative");
			add_location(section1, file$a, 26, 4, 900);
		},
		m: function mount(target, anchor) {
			insert_dev(target, section1, anchor);
			mount_component(br0, section1, null);
			append_dev(section1, t0);
			if_blocks[current_block_type_index].m(section1, null);
			append_dev(section1, t1);
			mount_component(br1, section1, null);
			append_dev(section1, t2);
			if_blocks_1[current_block_type_index_1].m(section1, null);
			append_dev(section1, t3);
			mount_component(br2, section1, null);
			append_dev(section1, t4);
			append_dev(section1, section0);
			mount_component(carousel_1, section0, null);
			append_dev(section1, t5);
			mount_component(br3, section1, null);
			append_dev(section1, t6);
			mount_component(descriptionshort, section1, null);
			append_dev(section1, t7);
			mount_component(br4, section1, null);
			append_dev(section1, t8);
			mount_component(interactionindicators, section1, null);
			append_dev(section1, t9);
			mount_component(br5, section1, null);
			append_dev(section1, t10);
			mount_component(trust, section1, null);
			append_dev(section1, t11);
			mount_component(br6, section1, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block0 = if_blocks[current_block_type_index];

				if (!if_block0) {
					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block0.c();
				}

				transition_in(if_block0, 1);
				if_block0.m(section1, t1);
			}

			let previous_block_index_1 = current_block_type_index_1;
			current_block_type_index_1 = select_block_type_1(ctx);

			if (current_block_type_index_1 === previous_block_index_1) {
				if_blocks_1[current_block_type_index_1].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
					if_blocks_1[previous_block_index_1] = null;
				});

				check_outros();
				if_block1 = if_blocks_1[current_block_type_index_1];

				if (!if_block1) {
					if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
					if_block1.c();
				}

				transition_in(if_block1, 1);
				if_block1.m(section1, t3);
			}

			const carousel_1_changes = {};
			if (dirty & /*carousel*/ 2) carousel_1_changes.items = /*carousel*/ ctx[1];
			carousel_1.$set(carousel_1_changes);
			const descriptionshort_changes = {};
			if (dirty & /*descriptionShort*/ 16) descriptionshort_changes.text = /*descriptionShort*/ ctx[4].text;
			if (dirty & /*descriptionShort*/ 16) descriptionshort_changes.title = /*descriptionShort*/ ctx[4].name;
			descriptionshort.$set(descriptionshort_changes);
			const interactionindicators_changes = {};
			if (dirty & /*iconsLine*/ 4) interactionindicators_changes.likes = /*iconsLine*/ ctx[2].likes;
			if (dirty & /*iconsLine*/ 4) interactionindicators_changes.views = /*iconsLine*/ ctx[2].views;
			if (dirty & /*organization*/ 8) interactionindicators_changes.isLiked = /*organization*/ ctx[3].isLiked;
			interactionindicators.$set(interactionindicators_changes);
			const trust_changes = {};
			if (dirty & /*organization*/ 8) trust_changes.active = /*organization*/ ctx[3].isLiked;
			trust.$set(trust_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(br0.$$.fragment, local);
			transition_in(if_block0);
			transition_in(br1.$$.fragment, local);
			transition_in(if_block1);
			transition_in(br2.$$.fragment, local);
			transition_in(carousel_1.$$.fragment, local);
			transition_in(br3.$$.fragment, local);
			transition_in(descriptionshort.$$.fragment, local);
			transition_in(br4.$$.fragment, local);
			transition_in(interactionindicators.$$.fragment, local);
			transition_in(br5.$$.fragment, local);
			transition_in(trust.$$.fragment, local);
			transition_in(br6.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br0.$$.fragment, local);
			transition_out(if_block0);
			transition_out(br1.$$.fragment, local);
			transition_out(if_block1);
			transition_out(br2.$$.fragment, local);
			transition_out(carousel_1.$$.fragment, local);
			transition_out(br3.$$.fragment, local);
			transition_out(descriptionshort.$$.fragment, local);
			transition_out(br4.$$.fragment, local);
			transition_out(interactionindicators.$$.fragment, local);
			transition_out(br5.$$.fragment, local);
			transition_out(trust.$$.fragment, local);
			transition_out(br6.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section1);
			destroy_component(br0);
			if_blocks[current_block_type_index].d();
			destroy_component(br1);
			if_blocks_1[current_block_type_index_1].d();
			destroy_component(br2);
			destroy_component(carousel_1);
			destroy_component(br3);
			destroy_component(descriptionshort);
			destroy_component(br4);
			destroy_component(interactionindicators);
			destroy_component(br5);
			destroy_component(trust);
			destroy_component(br6);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$2.name,
		type: "slot",
		source: "(26:0) <Modal id=\\\"last-news\\\" size=\\\"full\\\" swipe=\\\"all\\\">",
		ctx
	});

	return block;
}

function create_fragment$a(ctx) {
	let h1;
	let t0;
	let t1;
	let br;
	let t2;
	let newslist;
	let t3;
	let modal;
	let current;
	br = new Br({ props: { size: "20" }, $$inline: true });

	newslist = new NewsList({
			props: { items: /*items*/ ctx[0] },
			$$inline: true
		});

	newslist.$on("click", /*onClick*/ ctx[5].bind(null, true));

	modal = new Modal({
			props: {
				id: "last-news",
				size: "full",
				swipe: "all",
				$$slots: { default: [create_default_slot$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			h1 = element("h1");
			t0 = text("Останні новини");
			t1 = space();
			create_component(br.$$.fragment);
			t2 = space();
			create_component(newslist.$$.fragment);
			t3 = space();
			create_component(modal.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			h1 = claim_element(nodes, "H1", {});
			var h1_nodes = children(h1);
			t0 = claim_text(h1_nodes, "Останні новини");
			h1_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			claim_component(br.$$.fragment, nodes);
			t2 = claim_space(nodes);
			claim_component(newslist.$$.fragment, nodes);
			t3 = claim_space(nodes);
			claim_component(modal.$$.fragment, nodes);
			this.h();
		},
		h: function hydrate() {
			add_location(h1, file$a, 21, 0, 751);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h1, anchor);
			append_dev(h1, t0);
			insert_dev(target, t1, anchor);
			mount_component(br, target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(newslist, target, anchor);
			insert_dev(target, t3, anchor);
			mount_component(modal, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const newslist_changes = {};
			if (dirty & /*items*/ 1) newslist_changes.items = /*items*/ ctx[0];
			newslist.$set(newslist_changes);
			const modal_changes = {};

			if (dirty & /*$$scope, organization, iconsLine, descriptionShort, carousel*/ 94) {
				modal_changes.$$scope = { dirty, ctx };
			}

			modal.$set(modal_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(br.$$.fragment, local);
			transition_in(newslist.$$.fragment, local);
			transition_in(modal.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br.$$.fragment, local);
			transition_out(newslist.$$.fragment, local);
			transition_out(modal.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h1);
			if (detaching) detach_dev(t1);
			destroy_component(br, detaching);
			if (detaching) detach_dev(t2);
			destroy_component(newslist, detaching);
			if (detaching) detach_dev(t3);
			destroy_component(modal, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$a.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$a($$self, $$props, $$invalidate) {
	let { items } = $$props;
	let { carousel = [] } = $$props;
	let { iconsLine = {} } = $$props;
	let { organization = {} } = $$props;
	let { descriptionShort = {} } = $$props;

	function onClick(open, e) {
		modals.update(s => ({
			...s,
			["modal-last-news"]: {
				open,
				id: safeGet(() => e.detail.item.id)
			}
		}));
	}

	const writable_props = ["items", "carousel", "iconsLine", "organization", "descriptionShort"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<LastNews> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("LastNews", $$slots, []);

	$$self.$set = $$props => {
		if ("items" in $$props) $$invalidate(0, items = $$props.items);
		if ("carousel" in $$props) $$invalidate(1, carousel = $$props.carousel);
		if ("iconsLine" in $$props) $$invalidate(2, iconsLine = $$props.iconsLine);
		if ("organization" in $$props) $$invalidate(3, organization = $$props.organization);
		if ("descriptionShort" in $$props) $$invalidate(4, descriptionShort = $$props.descriptionShort);
	};

	$$self.$capture_state = () => ({
		onMount,
		modals,
		bodyScroll,
		safeGet,
		Br,
		NewsList,
		Modal,
		FancyBox,
		Carousel,
		Loader,
		TopCarousel,
		Trust,
		DescriptionShort,
		InteractionIndicators,
		items,
		carousel,
		iconsLine,
		organization,
		descriptionShort,
		onClick
	});

	$$self.$inject_state = $$props => {
		if ("items" in $$props) $$invalidate(0, items = $$props.items);
		if ("carousel" in $$props) $$invalidate(1, carousel = $$props.carousel);
		if ("iconsLine" in $$props) $$invalidate(2, iconsLine = $$props.iconsLine);
		if ("organization" in $$props) $$invalidate(3, organization = $$props.organization);
		if ("descriptionShort" in $$props) $$invalidate(4, descriptionShort = $$props.descriptionShort);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [items, carousel, iconsLine, organization, descriptionShort, onClick];
}

class LastNews extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$a, create_fragment$a, safe_not_equal, {
			items: 0,
			carousel: 1,
			iconsLine: 2,
			organization: 3,
			descriptionShort: 4
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "LastNews",
			options,
			id: create_fragment$a.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*items*/ ctx[0] === undefined && !("items" in props)) {
			console.warn("<LastNews> was created without expected prop 'items'");
		}
	}

	get items() {
		throw new Error("<LastNews>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set items(value) {
		throw new Error("<LastNews>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get carousel() {
		throw new Error("<LastNews>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set carousel(value) {
		throw new Error("<LastNews>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get iconsLine() {
		throw new Error("<LastNews>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set iconsLine(value) {
		throw new Error("<LastNews>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get organization() {
		throw new Error("<LastNews>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set organization(value) {
		throw new Error("<LastNews>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get descriptionShort() {
		throw new Error("<LastNews>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set descriptionShort(value) {
		throw new Error("<LastNews>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/organizations/components/_Description.svelte generated by Svelte v3.24.0 */
const file$b = "src/routes/organizations/components/_Description.svelte";

// (10:0) {:else}
function create_else_block_1$3(ctx) {
	let div;
	let loader;
	let current;
	loader = new Loader({ props: { type: "h1" }, $$inline: true });

	const block = {
		c: function create() {
			div = element("div");
			create_component(loader.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { style: true });
			var div_nodes = children(div);
			claim_component(loader.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_style(div, "width", "85%");
			add_location(div, file$b, 10, 4, 175);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(loader, div, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(loader.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loader.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(loader);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1$3.name,
		type: "else",
		source: "(10:0) {:else}",
		ctx
	});

	return block;
}

// (8:0) {#if title !== null}
function create_if_block_1$3(ctx) {
	let h1;
	let t;

	const block = {
		c: function create() {
			h1 = element("h1");
			t = text(/*title*/ ctx[0]);
			this.h();
		},
		l: function claim(nodes) {
			h1 = claim_element(nodes, "H1", {});
			var h1_nodes = children(h1);
			t = claim_text(h1_nodes, /*title*/ ctx[0]);
			h1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(h1, file$b, 8, 4, 146);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h1, anchor);
			append_dev(h1, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*title*/ 1) set_data_dev(t, /*title*/ ctx[0]);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(h1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$3.name,
		type: "if",
		source: "(8:0) {#if title !== null}",
		ctx
	});

	return block;
}

// (19:0) {:else}
function create_else_block$3(ctx) {
	let loader0;
	let t0;
	let loader1;
	let t1;
	let loader2;
	let t2;
	let loader3;
	let t3;
	let loader4;
	let t4;
	let div;
	let loader5;
	let current;
	loader0 = new Loader({ props: { type: "pre" }, $$inline: true });
	loader1 = new Loader({ props: { type: "pre" }, $$inline: true });
	loader2 = new Loader({ props: { type: "pre" }, $$inline: true });
	loader3 = new Loader({ props: { type: "pre" }, $$inline: true });
	loader4 = new Loader({ props: { type: "pre" }, $$inline: true });
	loader5 = new Loader({ props: { type: "pre" }, $$inline: true });

	const block = {
		c: function create() {
			create_component(loader0.$$.fragment);
			t0 = space();
			create_component(loader1.$$.fragment);
			t1 = space();
			create_component(loader2.$$.fragment);
			t2 = space();
			create_component(loader3.$$.fragment);
			t3 = space();
			create_component(loader4.$$.fragment);
			t4 = space();
			div = element("div");
			create_component(loader5.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			claim_component(loader0.$$.fragment, nodes);
			t0 = claim_space(nodes);
			claim_component(loader1.$$.fragment, nodes);
			t1 = claim_space(nodes);
			claim_component(loader2.$$.fragment, nodes);
			t2 = claim_space(nodes);
			claim_component(loader3.$$.fragment, nodes);
			t3 = claim_space(nodes);
			claim_component(loader4.$$.fragment, nodes);
			t4 = claim_space(nodes);
			div = claim_element(nodes, "DIV", { style: true });
			var div_nodes = children(div);
			claim_component(loader5.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_style(div, "width", "60%");
			add_location(div, file$b, 24, 4, 461);
		},
		m: function mount(target, anchor) {
			mount_component(loader0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(loader1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(loader2, target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(loader3, target, anchor);
			insert_dev(target, t3, anchor);
			mount_component(loader4, target, anchor);
			insert_dev(target, t4, anchor);
			insert_dev(target, div, anchor);
			mount_component(loader5, div, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(loader0.$$.fragment, local);
			transition_in(loader1.$$.fragment, local);
			transition_in(loader2.$$.fragment, local);
			transition_in(loader3.$$.fragment, local);
			transition_in(loader4.$$.fragment, local);
			transition_in(loader5.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loader0.$$.fragment, local);
			transition_out(loader1.$$.fragment, local);
			transition_out(loader2.$$.fragment, local);
			transition_out(loader3.$$.fragment, local);
			transition_out(loader4.$$.fragment, local);
			transition_out(loader5.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(loader0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(loader1, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(loader2, detaching);
			if (detaching) detach_dev(t2);
			destroy_component(loader3, detaching);
			if (detaching) detach_dev(t3);
			destroy_component(loader4, detaching);
			if (detaching) detach_dev(t4);
			if (detaching) detach_dev(div);
			destroy_component(loader5);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$3.name,
		type: "else",
		source: "(19:0) {:else}",
		ctx
	});

	return block;
}

// (15:0) {#if text !== null}
function create_if_block$3(ctx) {
	let pre;
	let t;

	const block = {
		c: function create() {
			pre = element("pre");
			t = text(/*text*/ ctx[1]);
			this.h();
		},
		l: function claim(nodes) {
			pre = claim_element(nodes, "PRE", { class: true });
			var pre_nodes = children(pre);
			t = claim_text(pre_nodes, /*text*/ ctx[1]);
			pre_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(pre, "class", "font-w-300");
			add_location(pre, file$b, 15, 0, 271);
		},
		m: function mount(target, anchor) {
			insert_dev(target, pre, anchor);
			append_dev(pre, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*text*/ 2) set_data_dev(t, /*text*/ ctx[1]);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(pre);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$3.name,
		type: "if",
		source: "(15:0) {#if text !== null}",
		ctx
	});

	return block;
}

function create_fragment$b(ctx) {
	let current_block_type_index;
	let if_block0;
	let t0;
	let br;
	let t1;
	let current_block_type_index_1;
	let if_block1;
	let if_block1_anchor;
	let current;
	const if_block_creators = [create_if_block_1$3, create_else_block_1$3];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*title*/ ctx[0] !== null) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	br = new Br({ props: { size: "10" }, $$inline: true });
	const if_block_creators_1 = [create_if_block$3, create_else_block$3];
	const if_blocks_1 = [];

	function select_block_type_1(ctx, dirty) {
		if (/*text*/ ctx[1] !== null) return 0;
		return 1;
	}

	current_block_type_index_1 = select_block_type_1(ctx);
	if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);

	const block = {
		c: function create() {
			if_block0.c();
			t0 = space();
			create_component(br.$$.fragment);
			t1 = space();
			if_block1.c();
			if_block1_anchor = empty();
		},
		l: function claim(nodes) {
			if_block0.l(nodes);
			t0 = claim_space(nodes);
			claim_component(br.$$.fragment, nodes);
			t1 = claim_space(nodes);
			if_block1.l(nodes);
			if_block1_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(br, target, anchor);
			insert_dev(target, t1, anchor);
			if_blocks_1[current_block_type_index_1].m(target, anchor);
			insert_dev(target, if_block1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block0 = if_blocks[current_block_type_index];

				if (!if_block0) {
					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block0.c();
				}

				transition_in(if_block0, 1);
				if_block0.m(t0.parentNode, t0);
			}

			let previous_block_index_1 = current_block_type_index_1;
			current_block_type_index_1 = select_block_type_1(ctx);

			if (current_block_type_index_1 === previous_block_index_1) {
				if_blocks_1[current_block_type_index_1].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
					if_blocks_1[previous_block_index_1] = null;
				});

				check_outros();
				if_block1 = if_blocks_1[current_block_type_index_1];

				if (!if_block1) {
					if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
					if_block1.c();
				}

				transition_in(if_block1, 1);
				if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(br.$$.fragment, local);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(br.$$.fragment, local);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(t0);
			destroy_component(br, detaching);
			if (detaching) detach_dev(t1);
			if_blocks_1[current_block_type_index_1].d(detaching);
			if (detaching) detach_dev(if_block1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$b.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$b($$self, $$props, $$invalidate) {
	let { title = null } = $$props;
	let { text = null } = $$props;
	const writable_props = ["title", "text"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Description> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Description", $$slots, []);

	$$self.$set = $$props => {
		if ("title" in $$props) $$invalidate(0, title = $$props.title);
		if ("text" in $$props) $$invalidate(1, text = $$props.text);
	};

	$$self.$capture_state = () => ({ Br, Loader, title, text });

	$$self.$inject_state = $$props => {
		if ("title" in $$props) $$invalidate(0, title = $$props.title);
		if ("text" in $$props) $$invalidate(1, text = $$props.text);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [title, text];
}

class Description extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$b, create_fragment$b, safe_not_equal, { title: 0, text: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Description",
			options,
			id: create_fragment$b.name
		});
	}

	get title() {
		throw new Error("<Description>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<Description>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get text() {
		throw new Error("<Description>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set text(value) {
		throw new Error("<Description>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/organizations/components/_VirtualTour.svelte generated by Svelte v3.24.0 */
const file$c = "src/routes/organizations/components/_VirtualTour.svelte";

function add_css$1() {
	var style = element("style");
	style.id = "svelte-1mfnpq7-style";
	style.textContent = "div.svelte-1mfnpq7{background-color:rgba(var(--theme-bg-color-opposite), .04)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiX1ZpcnR1YWxUb3VyLnN2ZWx0ZSIsInNvdXJjZXMiOlsiX1ZpcnR1YWxUb3VyLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0PlxuICBpbXBvcnQgeyBCciB9IGZyb20gXCJAY29tcG9uZW50c1wiO1xuXG4gIGV4cG9ydCBsZXQgc3JjXG48L3NjcmlwdD5cblxuPGgxPjNEIC0g0KLRg9GAIDM2MMKwPC9oMT5cbjxCciBzaXplPVwiMjBcIiAvPlxuPGRpdiBjbGFzcz1cImZ1bGwtY29udGFpbmVyXCI+XG4gIDxpZnJhbWVcbiAgICB7c3JjfVxuICAgIHRpdGxlPVwiMzYwINGC0YPRgFwiXG4gICAgd2lkdGg9XCIxMDAlXCJcbiAgICBoZWlnaHQ9XCI0NTBcIlxuICAgIGZyYW1lYm9yZGVyPVwiMFwiXG4gICAgc3R5bGU9XCJib3JkZXI6MDtcIlxuICAgIGFsbG93ZnVsbHNjcmVlbj1cIlwiXG4gICAgYXJpYS1oaWRkZW49XCJmYWxzZVwiXG4gICAgdGFiaW5kZXg9XCIwXCIgPjwvaWZyYW1lPlxuPC9kaXY+XG5cbjxzdHlsZT5cbmRpdiB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSh2YXIoLS10aGVtZS1iZy1jb2xvci1vcHBvc2l0ZSksIC4wNCk7XG59PC9zdHlsZT5cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFzQkEsR0FBRyxlQUFDLENBQUMsQUFDRCxnQkFBZ0IsQ0FBRSxLQUFLLElBQUkseUJBQXlCLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxBQUMvRCxDQUFDIn0= */";
	append_dev(document.head, style);
}

function create_fragment$c(ctx) {
	let h1;
	let t0;
	let t1;
	let br;
	let t2;
	let div;
	let iframe;
	let iframe_src_value;
	let current;
	br = new Br({ props: { size: "20" }, $$inline: true });

	const block = {
		c: function create() {
			h1 = element("h1");
			t0 = text("3D - Тур 360°");
			t1 = space();
			create_component(br.$$.fragment);
			t2 = space();
			div = element("div");
			iframe = element("iframe");
			this.h();
		},
		l: function claim(nodes) {
			h1 = claim_element(nodes, "H1", {});
			var h1_nodes = children(h1);
			t0 = claim_text(h1_nodes, "3D - Тур 360°");
			h1_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			claim_component(br.$$.fragment, nodes);
			t2 = claim_space(nodes);
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);

			iframe = claim_element(div_nodes, "IFRAME", {
				src: true,
				title: true,
				width: true,
				height: true,
				frameborder: true,
				style: true,
				allowfullscreen: true,
				"aria-hidden": true,
				tabindex: true
			});

			children(iframe).forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(h1, file$c, 6, 0, 74);
			if (iframe.src !== (iframe_src_value = /*src*/ ctx[0])) attr_dev(iframe, "src", iframe_src_value);
			attr_dev(iframe, "title", "360 тур");
			attr_dev(iframe, "width", "100%");
			attr_dev(iframe, "height", "450");
			attr_dev(iframe, "frameborder", "0");
			set_style(iframe, "border", "0");
			iframe.allowFullscreen = "";
			attr_dev(iframe, "aria-hidden", "false");
			attr_dev(iframe, "tabindex", "0");
			add_location(iframe, file$c, 9, 2, 145);
			attr_dev(div, "class", "full-container svelte-1mfnpq7");
			add_location(div, file$c, 8, 0, 114);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h1, anchor);
			append_dev(h1, t0);
			insert_dev(target, t1, anchor);
			mount_component(br, target, anchor);
			insert_dev(target, t2, anchor);
			insert_dev(target, div, anchor);
			append_dev(div, iframe);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (!current || dirty & /*src*/ 1 && iframe.src !== (iframe_src_value = /*src*/ ctx[0])) {
				attr_dev(iframe, "src", iframe_src_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(br.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h1);
			if (detaching) detach_dev(t1);
			destroy_component(br, detaching);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$c.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$c($$self, $$props, $$invalidate) {
	let { src } = $$props;
	const writable_props = ["src"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<VirtualTour> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("VirtualTour", $$slots, []);

	$$self.$set = $$props => {
		if ("src" in $$props) $$invalidate(0, src = $$props.src);
	};

	$$self.$capture_state = () => ({ Br, src });

	$$self.$inject_state = $$props => {
		if ("src" in $$props) $$invalidate(0, src = $$props.src);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [src];
}

class VirtualTour extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document.getElementById("svelte-1mfnpq7-style")) add_css$1();
		init(this, options, instance$c, create_fragment$c, safe_not_equal, { src: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "VirtualTour",
			options,
			id: create_fragment$c.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*src*/ ctx[0] === undefined && !("src" in props)) {
			console.warn("<VirtualTour> was created without expected prop 'src'");
		}
	}

	get src() {
		throw new Error("<VirtualTour>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set src(value) {
		throw new Error("<VirtualTour>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/organizations/components/_Certificates.svelte generated by Svelte v3.24.0 */
const file$d = "src/routes/organizations/components/_Certificates.svelte";

function create_fragment$d(ctx) {
	let h1;
	let t0;
	let t1;
	let br;
	let t2;
	let div;
	let documents;
	let current;
	br = new Br({ props: { size: "5" }, $$inline: true });

	documents = new Documents$2({
			props: { items: /*items*/ ctx[0] },
			$$inline: true
		});

	const block = {
		c: function create() {
			h1 = element("h1");
			t0 = text("Сертифікати");
			t1 = space();
			create_component(br.$$.fragment);
			t2 = space();
			div = element("div");
			create_component(documents.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			h1 = claim_element(nodes, "H1", {});
			var h1_nodes = children(h1);
			t0 = claim_text(h1_nodes, "Сертифікати");
			h1_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			claim_component(br.$$.fragment, nodes);
			t2 = claim_space(nodes);
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			claim_component(documents.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(h1, file$d, 6, 0, 91);
			attr_dev(div, "class", "full-container");
			add_location(div, file$d, 8, 0, 128);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h1, anchor);
			append_dev(h1, t0);
			insert_dev(target, t1, anchor);
			mount_component(br, target, anchor);
			insert_dev(target, t2, anchor);
			insert_dev(target, div, anchor);
			mount_component(documents, div, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const documents_changes = {};
			if (dirty & /*items*/ 1) documents_changes.items = /*items*/ ctx[0];
			documents.$set(documents_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(br.$$.fragment, local);
			transition_in(documents.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br.$$.fragment, local);
			transition_out(documents.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h1);
			if (detaching) detach_dev(t1);
			destroy_component(br, detaching);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(div);
			destroy_component(documents);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$d.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$d($$self, $$props, $$invalidate) {
	let { items } = $$props;
	const writable_props = ["items"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Certificates> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Certificates", $$slots, []);

	$$self.$set = $$props => {
		if ("items" in $$props) $$invalidate(0, items = $$props.items);
	};

	$$self.$capture_state = () => ({ Br, Documents: Documents$2, items });

	$$self.$inject_state = $$props => {
		if ("items" in $$props) $$invalidate(0, items = $$props.items);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [items];
}

class Certificates extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$d, create_fragment$d, safe_not_equal, { items: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Certificates",
			options,
			id: create_fragment$d.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*items*/ ctx[0] === undefined && !("items" in props)) {
			console.warn("<Certificates> was created without expected prop 'items'");
		}
	}

	get items() {
		throw new Error("<Certificates>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set items(value) {
		throw new Error("<Certificates>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/organizations/components/_ContactsCard.svelte generated by Svelte v3.24.0 */

const file$e = "src/routes/organizations/components/_ContactsCard.svelte";

// (24:20) <section slot="box" class="flex full-width full-height" style="height: 100vw">
function create_box_slot(ctx) {
	let section;
	let div;
	let avatar_1;
	let current;

	avatar_1 = new Avatar({
			props: {
				src: /*avatar*/ ctx[1],
				srcBig: /*avatarBig*/ ctx[2],
				alt: "ava"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			section = element("section");
			div = element("div");
			create_component(avatar_1.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { slot: true, class: true, style: true });
			var section_nodes = children(section);
			div = claim_element(section_nodes, "DIV", { class: true, style: true });
			var div_nodes = children(div);
			claim_component(avatar_1.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "flex flex-self-stretch flex-1 overflow-hidden flex-justify-stretch");
			set_style(div, "padding", "var(--screen-padding) 0");
			add_location(div, file$e, 24, 24, 875);
			attr_dev(section, "slot", "box");
			attr_dev(section, "class", "flex full-width full-height");
			set_style(section, "height", "100vw");
			add_location(section, file$e, 23, 20, 772);
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			append_dev(section, div);
			mount_component(avatar_1, div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const avatar_1_changes = {};
			if (dirty & /*avatar*/ 2) avatar_1_changes.src = /*avatar*/ ctx[1];
			if (dirty & /*avatarBig*/ 4) avatar_1_changes.srcBig = /*avatarBig*/ ctx[2];
			avatar_1.$set(avatar_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(avatar_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(avatar_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			destroy_component(avatar_1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_box_slot.name,
		type: "slot",
		source: "(24:20) <section slot=\\\"box\\\" class=\\\"flex full-width full-height\\\" style=\\\"height: 100vw\\\">",
		ctx
	});

	return block;
}

// (22:16) <FancyBox class="flex-justify-center">
function create_default_slot_1$2(ctx) {
	let avatar_1;
	let t;
	let current;

	avatar_1 = new Avatar({
			props: {
				size: "big",
				src: /*avatar*/ ctx[1],
				alt: "Організація"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(avatar_1.$$.fragment);
			t = space();
		},
		l: function claim(nodes) {
			claim_component(avatar_1.$$.fragment, nodes);
			t = claim_space(nodes);
		},
		m: function mount(target, anchor) {
			mount_component(avatar_1, target, anchor);
			insert_dev(target, t, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const avatar_1_changes = {};
			if (dirty & /*avatar*/ 2) avatar_1_changes.src = /*avatar*/ ctx[1];
			avatar_1.$set(avatar_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(avatar_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(avatar_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(avatar_1, detaching);
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$2.name,
		type: "slot",
		source: "(22:16) <FancyBox class=\\\"flex-justify-center\\\">",
		ctx
	});

	return block;
}

// (40:12) {:else}
function create_else_block$4(ctx) {
	let p;
	let loader;
	let current;
	loader = new Loader({ props: { type: "h3" }, $$inline: true });

	const block = {
		c: function create() {
			p = element("p");
			create_component(loader.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			p = claim_element(nodes, "P", { style: true });
			var p_nodes = children(p);
			claim_component(loader.$$.fragment, p_nodes);
			p_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_style(p, "width", "60%");
			add_location(p, file$e, 40, 16, 1480);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			mount_component(loader, p, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(loader.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loader.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
			destroy_component(loader);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$4.name,
		type: "else",
		source: "(40:12) {:else}",
		ctx
	});

	return block;
}

// (36:12) {#if orgName !== null}
function create_if_block$4(ctx) {
	let p;
	let t;

	const block = {
		c: function create() {
			p = element("p");
			t = text(/*orgName*/ ctx[0]);
			this.h();
		},
		l: function claim(nodes) {
			p = claim_element(nodes, "P", { class: true, style: true });
			var p_nodes = children(p);
			t = claim_text(p_nodes, /*orgName*/ ctx[0]);
			p_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(p, "class", "h3 font-secondary font-w-500");
			set_style(p, "opacity", ".7");
			add_location(p, file$e, 36, 16, 1332);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*orgName*/ 1) set_data_dev(t, /*orgName*/ ctx[0]);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$4.name,
		type: "if",
		source: "(36:12) {#if orgName !== null}",
		ctx
	});

	return block;
}

// (15:0) <Card>
function create_default_slot$3(ctx) {
	let section;
	let br0;
	let t0;
	let div;
	let span;
	let fancybox;
	let t1;
	let br1;
	let t2;
	let h2;
	let t3;
	let t4;
	let br2;
	let t5;
	let current_block_type_index;
	let if_block;
	let t6;
	let br3;
	let t7;
	let socialsy;
	let t8;
	let br4;
	let t9;
	let socialsx;
	let t10;
	let br5;
	let current;
	br0 = new Br({ props: { size: "30" }, $$inline: true });

	fancybox = new FancyBox({
			props: {
				class: "flex-justify-center",
				$$slots: {
					default: [create_default_slot_1$2],
					box: [create_box_slot]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	br1 = new Br({ props: { size: "20" }, $$inline: true });
	br2 = new Br({ props: { size: "5" }, $$inline: true });
	const if_block_creators = [create_if_block$4, create_else_block$4];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*orgName*/ ctx[0] !== null) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	br3 = new Br({ props: { size: "30" }, $$inline: true });

	socialsy = new SocialsY({
			props: { items: /*topItems*/ ctx[3] },
			$$inline: true
		});

	br4 = new Br({ props: { size: "30" }, $$inline: true });

	socialsx = new SocialsX({
			props: { items: /*bottomItems*/ ctx[4] },
			$$inline: true
		});

	br5 = new Br({ props: { size: "30" }, $$inline: true });

	const block = {
		c: function create() {
			section = element("section");
			create_component(br0.$$.fragment);
			t0 = space();
			div = element("div");
			span = element("span");
			create_component(fancybox.$$.fragment);
			t1 = space();
			create_component(br1.$$.fragment);
			t2 = space();
			h2 = element("h2");
			t3 = text("Наші контакти");
			t4 = space();
			create_component(br2.$$.fragment);
			t5 = space();
			if_block.c();
			t6 = space();
			create_component(br3.$$.fragment);
			t7 = space();
			create_component(socialsy.$$.fragment);
			t8 = space();
			create_component(br4.$$.fragment);
			t9 = space();
			create_component(socialsx.$$.fragment);
			t10 = space();
			create_component(br5.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { style: true });
			var section_nodes = children(section);
			claim_component(br0.$$.fragment, section_nodes);
			t0 = claim_space(section_nodes);
			div = claim_element(section_nodes, "DIV", { class: true });
			var div_nodes = children(div);
			span = claim_element(div_nodes, "SPAN", {});
			var span_nodes = children(span);
			claim_component(fancybox.$$.fragment, span_nodes);
			span_nodes.forEach(detach_dev);
			t1 = claim_space(div_nodes);
			claim_component(br1.$$.fragment, div_nodes);
			t2 = claim_space(div_nodes);
			h2 = claim_element(div_nodes, "H2", {});
			var h2_nodes = children(h2);
			t3 = claim_text(h2_nodes, "Наші контакти");
			h2_nodes.forEach(detach_dev);
			t4 = claim_space(div_nodes);
			claim_component(br2.$$.fragment, div_nodes);
			t5 = claim_space(div_nodes);
			if_block.l(div_nodes);
			div_nodes.forEach(detach_dev);
			t6 = claim_space(section_nodes);
			claim_component(br3.$$.fragment, section_nodes);
			t7 = claim_space(section_nodes);
			claim_component(socialsy.$$.fragment, section_nodes);
			t8 = claim_space(section_nodes);
			claim_component(br4.$$.fragment, section_nodes);
			t9 = claim_space(section_nodes);
			claim_component(socialsx.$$.fragment, section_nodes);
			t10 = claim_space(section_nodes);
			claim_component(br5.$$.fragment, section_nodes);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(span, file$e, 20, 12, 618);
			add_location(h2, file$e, 32, 12, 1229);
			attr_dev(div, "class", "flex flex-column flex-align-center");
			add_location(div, file$e, 18, 8, 544);
			set_style(section, "padding", "0 20px");
			add_location(section, file$e, 15, 4, 476);
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			mount_component(br0, section, null);
			append_dev(section, t0);
			append_dev(section, div);
			append_dev(div, span);
			mount_component(fancybox, span, null);
			append_dev(div, t1);
			mount_component(br1, div, null);
			append_dev(div, t2);
			append_dev(div, h2);
			append_dev(h2, t3);
			append_dev(div, t4);
			mount_component(br2, div, null);
			append_dev(div, t5);
			if_blocks[current_block_type_index].m(div, null);
			append_dev(section, t6);
			mount_component(br3, section, null);
			append_dev(section, t7);
			mount_component(socialsy, section, null);
			append_dev(section, t8);
			mount_component(br4, section, null);
			append_dev(section, t9);
			mount_component(socialsx, section, null);
			append_dev(section, t10);
			mount_component(br5, section, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const fancybox_changes = {};

			if (dirty & /*$$scope, avatar, avatarBig*/ 134) {
				fancybox_changes.$$scope = { dirty, ctx };
			}

			fancybox.$set(fancybox_changes);
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(div, null);
			}

			const socialsy_changes = {};
			if (dirty & /*topItems*/ 8) socialsy_changes.items = /*topItems*/ ctx[3];
			socialsy.$set(socialsy_changes);
			const socialsx_changes = {};
			if (dirty & /*bottomItems*/ 16) socialsx_changes.items = /*bottomItems*/ ctx[4];
			socialsx.$set(socialsx_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(br0.$$.fragment, local);
			transition_in(fancybox.$$.fragment, local);
			transition_in(br1.$$.fragment, local);
			transition_in(br2.$$.fragment, local);
			transition_in(if_block);
			transition_in(br3.$$.fragment, local);
			transition_in(socialsy.$$.fragment, local);
			transition_in(br4.$$.fragment, local);
			transition_in(socialsx.$$.fragment, local);
			transition_in(br5.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br0.$$.fragment, local);
			transition_out(fancybox.$$.fragment, local);
			transition_out(br1.$$.fragment, local);
			transition_out(br2.$$.fragment, local);
			transition_out(if_block);
			transition_out(br3.$$.fragment, local);
			transition_out(socialsy.$$.fragment, local);
			transition_out(br4.$$.fragment, local);
			transition_out(socialsx.$$.fragment, local);
			transition_out(br5.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			destroy_component(br0);
			destroy_component(fancybox);
			destroy_component(br1);
			destroy_component(br2);
			if_blocks[current_block_type_index].d();
			destroy_component(br3);
			destroy_component(socialsy);
			destroy_component(br4);
			destroy_component(socialsx);
			destroy_component(br5);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$3.name,
		type: "slot",
		source: "(15:0) <Card>",
		ctx
	});

	return block;
}

function create_fragment$e(ctx) {
	let card;
	let current;

	card = new Card({
			props: {
				$$slots: { default: [create_default_slot$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(card.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(card.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(card, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const card_changes = {};

			if (dirty & /*$$scope, bottomItems, topItems, orgName, avatar, avatarBig*/ 159) {
				card_changes.$$scope = { dirty, ctx };
			}

			card.$set(card_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(card.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(card.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(card, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$e.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$e($$self, $$props, $$invalidate) {
	let { items = null } = $$props;
	let { orgName = null } = $$props;
	let { avatar = null } = $$props;
	let { avatarBig = null } = $$props;
	const top = ["telegram", "facebook", "viber"];
	const writable_props = ["items", "orgName", "avatar", "avatarBig"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ContactsCard> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("ContactsCard", $$slots, []);

	$$self.$set = $$props => {
		if ("items" in $$props) $$invalidate(5, items = $$props.items);
		if ("orgName" in $$props) $$invalidate(0, orgName = $$props.orgName);
		if ("avatar" in $$props) $$invalidate(1, avatar = $$props.avatar);
		if ("avatarBig" in $$props) $$invalidate(2, avatarBig = $$props.avatarBig);
	};

	$$self.$capture_state = () => ({
		Br,
		Card,
		Icon,
		Avatar,
		FancyBox,
		Loader,
		SocialsX,
		SocialsY,
		items,
		orgName,
		avatar,
		avatarBig,
		top,
		topItems,
		bottomItems
	});

	$$self.$inject_state = $$props => {
		if ("items" in $$props) $$invalidate(5, items = $$props.items);
		if ("orgName" in $$props) $$invalidate(0, orgName = $$props.orgName);
		if ("avatar" in $$props) $$invalidate(1, avatar = $$props.avatar);
		if ("avatarBig" in $$props) $$invalidate(2, avatarBig = $$props.avatarBig);
		if ("topItems" in $$props) $$invalidate(3, topItems = $$props.topItems);
		if ("bottomItems" in $$props) $$invalidate(4, bottomItems = $$props.bottomItems);
	};

	let topItems;
	let bottomItems;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*items*/ 32) {
			 $$invalidate(3, topItems = items === null
			? undefined
			: items.filter(i => !top.includes(i.type)));
		}

		if ($$self.$$.dirty & /*items*/ 32) {
			 $$invalidate(4, bottomItems = items === null
			? undefined
			: items.filter(i => top.includes(i.type)));
		}
	};

	return [orgName, avatar, avatarBig, topItems, bottomItems, items];
}

class ContactsCard extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$e, create_fragment$e, safe_not_equal, {
			items: 5,
			orgName: 0,
			avatar: 1,
			avatarBig: 2
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ContactsCard",
			options,
			id: create_fragment$e.name
		});
	}

	get items() {
		throw new Error("<ContactsCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set items(value) {
		throw new Error("<ContactsCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get orgName() {
		throw new Error("<ContactsCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set orgName(value) {
		throw new Error("<ContactsCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get avatar() {
		throw new Error("<ContactsCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set avatar(value) {
		throw new Error("<ContactsCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get avatarBig() {
		throw new Error("<ContactsCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set avatarBig(value) {
		throw new Error("<ContactsCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/organizations/components/_OrganizationButton.svelte generated by Svelte v3.24.0 */
const file$f = "src/routes/organizations/components/_OrganizationButton.svelte";

// (25:6) {:else}
function create_else_block$5(ctx) {
	let span;
	let loader;
	let current;
	loader = new Loader({ props: { type: "h3" }, $$inline: true });

	const block = {
		c: function create() {
			span = element("span");
			create_component(loader.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", {});
			var span_nodes = children(span);
			claim_component(loader.$$.fragment, span_nodes);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(span, file$f, 25, 8, 632);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			mount_component(loader, span, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(loader.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loader.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			destroy_component(loader);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$5.name,
		type: "else",
		source: "(25:6) {:else}",
		ctx
	});

	return block;
}

// (21:6) {#if title !== null}
function create_if_block$5(ctx) {
	let s0;
	let t0;
	let s1;
	let t1;
	let h3;
	let t2;

	const block = {
		c: function create() {
			s0 = element("s");
			t0 = space();
			s1 = element("s");
			t1 = space();
			h3 = element("h3");
			t2 = text(/*title*/ ctx[2]);
			this.h();
		},
		l: function claim(nodes) {
			s0 = claim_element(nodes, "S", {});
			children(s0).forEach(detach_dev);
			t0 = claim_space(nodes);
			s1 = claim_element(nodes, "S", {});
			children(s1).forEach(detach_dev);
			t1 = claim_space(nodes);
			h3 = claim_element(nodes, "H3", {});
			var h3_nodes = children(h3);
			t2 = claim_text(h3_nodes, /*title*/ ctx[2]);
			h3_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(s0, file$f, 21, 8, 565);
			add_location(s1, file$f, 22, 8, 579);
			add_location(h3, file$f, 23, 8, 593);
		},
		m: function mount(target, anchor) {
			insert_dev(target, s0, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, s1, anchor);
			insert_dev(target, t1, anchor);
			insert_dev(target, h3, anchor);
			append_dev(h3, t2);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*title*/ 4) set_data_dev(t2, /*title*/ ctx[2]);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(s0);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(s1);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(h3);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$5.name,
		type: "if",
		source: "(21:6) {#if title !== null}",
		ctx
	});

	return block;
}

// (9:0) <Button rel="prefetch" href={id} class="white">
function create_default_slot$4(ctx) {
	let div2;
	let div1;
	let s0;
	let t0;
	let div0;
	let picture;
	let t1;
	let s1;
	let t2;
	let current_block_type_index;
	let if_block;
	let current;

	picture = new Picture({
			props: {
				src: /*src*/ ctx[1],
				size: "contain",
				alt: "якесь фото організації"
			},
			$$inline: true
		});

	const if_block_creators = [create_if_block$5, create_else_block$5];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*title*/ ctx[2] !== null) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			div2 = element("div");
			div1 = element("div");
			s0 = element("s");
			t0 = space();
			div0 = element("div");
			create_component(picture.$$.fragment);
			t1 = space();
			s1 = element("s");
			t2 = space();
			if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			div2 = claim_element(nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			s0 = claim_element(div1_nodes, "S", {});
			children(s0).forEach(detach_dev);
			t0 = claim_space(div1_nodes);
			div0 = claim_element(div1_nodes, "DIV", { class: true, style: true });
			var div0_nodes = children(div0);
			claim_component(picture.$$.fragment, div0_nodes);
			div0_nodes.forEach(detach_dev);
			t1 = claim_space(div1_nodes);
			s1 = claim_element(div1_nodes, "S", {});
			children(s1).forEach(detach_dev);
			t2 = claim_space(div1_nodes);
			if_block.l(div1_nodes);
			div1_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(s0, file$f, 12, 6, 318);
			attr_dev(div0, "class", "flex");
			set_style(div0, "max-width", "45px");
			set_style(div0, "height", "40px");
			set_style(div0, "overflow", "hidden");
			add_location(div0, file$f, 13, 6, 330);
			add_location(s1, file$f, 19, 6, 524);
			attr_dev(div1, "class", "flex flex-align-center");
			add_location(div1, file$f, 11, 4, 275);
			attr_dev(div2, "class", "flex flex-align-center flex-justify-between full-width");
			add_location(div2, file$f, 9, 2, 201);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);
			append_dev(div2, div1);
			append_dev(div1, s0);
			append_dev(div1, t0);
			append_dev(div1, div0);
			mount_component(picture, div0, null);
			append_dev(div1, t1);
			append_dev(div1, s1);
			append_dev(div1, t2);
			if_blocks[current_block_type_index].m(div1, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const picture_changes = {};
			if (dirty & /*src*/ 2) picture_changes.src = /*src*/ ctx[1];
			picture.$set(picture_changes);
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(div1, null);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(picture.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(picture.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div2);
			destroy_component(picture);
			if_blocks[current_block_type_index].d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$4.name,
		type: "slot",
		source: "(9:0) <Button rel=\\\"prefetch\\\" href={id} class=\\\"white\\\">",
		ctx
	});

	return block;
}

function create_fragment$f(ctx) {
	let button;
	let current;

	button = new Button({
			props: {
				rel: "prefetch",
				href: /*id*/ ctx[0],
				class: "white",
				$$slots: { default: [create_default_slot$4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(button.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(button.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const button_changes = {};
			if (dirty & /*id*/ 1) button_changes.href = /*id*/ ctx[0];

			if (dirty & /*$$scope, title, src*/ 14) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(button, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$f.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$f($$self, $$props, $$invalidate) {
	let { id = null } = $$props;
	let { src = null } = $$props;
	let { title = null } = $$props;
	const writable_props = ["id", "src", "title"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<OrganizationButton> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("OrganizationButton", $$slots, []);

	$$self.$set = $$props => {
		if ("id" in $$props) $$invalidate(0, id = $$props.id);
		if ("src" in $$props) $$invalidate(1, src = $$props.src);
		if ("title" in $$props) $$invalidate(2, title = $$props.title);
	};

	$$self.$capture_state = () => ({ Picture, Button, Loader, id, src, title });

	$$self.$inject_state = $$props => {
		if ("id" in $$props) $$invalidate(0, id = $$props.id);
		if ("src" in $$props) $$invalidate(1, src = $$props.src);
		if ("title" in $$props) $$invalidate(2, title = $$props.title);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [id, src, title];
}

class OrganizationButton extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$f, create_fragment$f, safe_not_equal, { id: 0, src: 1, title: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "OrganizationButton",
			options,
			id: create_fragment$f.name
		});
	}

	get id() {
		throw new Error("<OrganizationButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<OrganizationButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get src() {
		throw new Error("<OrganizationButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set src(value) {
		throw new Error("<OrganizationButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get title() {
		throw new Error("<OrganizationButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<OrganizationButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/organizations/view/_Map.svelte generated by Svelte v3.24.0 */
const file$g = "src/routes/organizations/view/_Map.svelte";

function add_css$2() {
	var style = element("style");
	style.id = "svelte-190a4wu-style";
	style.textContent = ".preview.svelte-190a4wu .full-container{height:200px;width:100%;margin:0;border-radius:var(--border-radius-big);overflow:hidden;-webkit-transform:translateZ(0);transform:translateZ(0)}.preview.svelte-190a4wu iframe{height:100% !important}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiX01hcC5zdmVsdGUiLCJzb3VyY2VzIjpbIl9NYXAuc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgQnIgfSBmcm9tICdAY29tcG9uZW50cydcbiAgICBpbXBvcnQgeyBjbGFzc25hbWVzIH0gZnJvbSAnQHV0aWxzJ1xuICAgIGltcG9ydCB7IFZpcnR1YWxUb3VyLCBXZU9uTWFwIH0gZnJvbSAnLi4vY29tcG9uZW50cydcblxuICAgIGV4cG9ydCBsZXQgbG9jYXRpb25cbiAgICBleHBvcnQgbGV0IHByZXZpZXdcbjwvc2NyaXB0PlxuXG48c3R5bGU+XG4ucHJldmlldyA6Z2xvYmFsKC5mdWxsLWNvbnRhaW5lcikge1xuICAgIGhlaWdodDogMjAwcHg7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgbWFyZ2luOiAwO1xuICAgIGJvcmRlci1yYWRpdXM6IHZhcigtLWJvcmRlci1yYWRpdXMtYmlnKTtcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVaKDApO1xuICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVaKDApO1xufVxuXG4ucHJldmlldyA6Z2xvYmFsKGlmcmFtZSkge1xuICAgIGhlaWdodDogMTAwJSAhaW1wb3J0YW50O1xufTwvc3R5bGU+XG5cbjxzZWN0aW9uIGNsYXNzPXtjbGFzc25hbWVzKHsgcHJldmlldyB9KX0+XG4gICAgPFZpcnR1YWxUb3VyIHNyYz17bG9jYXRpb24udmlydHVhbF90b3VyfS8+XG4gICAgPEJyIHNpemU9e3ByZXZpZXcgPyAyMCA6IDYwfSAvPlxuICAgIDxXZU9uTWFwIHNyYz17bG9jYXRpb24ubWFwfS8+XG48L3NlY3Rpb24+XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBVUEsdUJBQVEsQ0FBQyxBQUFRLGVBQWUsQUFBRSxDQUFDLEFBQy9CLE1BQU0sQ0FBRSxLQUFLLENBQ2IsS0FBSyxDQUFFLElBQUksQ0FDWCxNQUFNLENBQUUsQ0FBQyxDQUNULGFBQWEsQ0FBRSxJQUFJLG1CQUFtQixDQUFDLENBQ3ZDLFFBQVEsQ0FBRSxNQUFNLENBQ2hCLGlCQUFpQixDQUFFLFdBQVcsQ0FBQyxDQUFDLENBQ3hCLFNBQVMsQ0FBRSxXQUFXLENBQUMsQ0FBQyxBQUNwQyxDQUFDLEFBRUQsdUJBQVEsQ0FBQyxBQUFRLE1BQU0sQUFBRSxDQUFDLEFBQ3RCLE1BQU0sQ0FBRSxJQUFJLENBQUMsVUFBVSxBQUMzQixDQUFDIn0= */";
	append_dev(document.head, style);
}

function create_fragment$g(ctx) {
	let section;
	let virtualtour;
	let t0;
	let br;
	let t1;
	let weonmap;
	let section_class_value;
	let current;

	virtualtour = new VirtualTour({
			props: { src: /*location*/ ctx[0].virtual_tour },
			$$inline: true
		});

	br = new Br({
			props: { size: /*preview*/ ctx[1] ? 20 : 60 },
			$$inline: true
		});

	weonmap = new WeOnMap({
			props: { src: /*location*/ ctx[0].map },
			$$inline: true
		});

	const block = {
		c: function create() {
			section = element("section");
			create_component(virtualtour.$$.fragment);
			t0 = space();
			create_component(br.$$.fragment);
			t1 = space();
			create_component(weonmap.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { class: true });
			var section_nodes = children(section);
			claim_component(virtualtour.$$.fragment, section_nodes);
			t0 = claim_space(section_nodes);
			claim_component(br.$$.fragment, section_nodes);
			t1 = claim_space(section_nodes);
			claim_component(weonmap.$$.fragment, section_nodes);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(section, "class", section_class_value = "" + (null_to_empty(classnames({ preview: /*preview*/ ctx[1] })) + " svelte-190a4wu"));
			add_location(section, file$g, 24, 0, 510);
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			mount_component(virtualtour, section, null);
			append_dev(section, t0);
			mount_component(br, section, null);
			append_dev(section, t1);
			mount_component(weonmap, section, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const virtualtour_changes = {};
			if (dirty & /*location*/ 1) virtualtour_changes.src = /*location*/ ctx[0].virtual_tour;
			virtualtour.$set(virtualtour_changes);
			const br_changes = {};
			if (dirty & /*preview*/ 2) br_changes.size = /*preview*/ ctx[1] ? 20 : 60;
			br.$set(br_changes);
			const weonmap_changes = {};
			if (dirty & /*location*/ 1) weonmap_changes.src = /*location*/ ctx[0].map;
			weonmap.$set(weonmap_changes);

			if (!current || dirty & /*preview*/ 2 && section_class_value !== (section_class_value = "" + (null_to_empty(classnames({ preview: /*preview*/ ctx[1] })) + " svelte-190a4wu"))) {
				attr_dev(section, "class", section_class_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(virtualtour.$$.fragment, local);
			transition_in(br.$$.fragment, local);
			transition_in(weonmap.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(virtualtour.$$.fragment, local);
			transition_out(br.$$.fragment, local);
			transition_out(weonmap.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			destroy_component(virtualtour);
			destroy_component(br);
			destroy_component(weonmap);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$g.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$g($$self, $$props, $$invalidate) {
	let { location } = $$props;
	let { preview } = $$props;
	const writable_props = ["location", "preview"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Map> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Map", $$slots, []);

	$$self.$set = $$props => {
		if ("location" in $$props) $$invalidate(0, location = $$props.location);
		if ("preview" in $$props) $$invalidate(1, preview = $$props.preview);
	};

	$$self.$capture_state = () => ({
		Br,
		classnames,
		VirtualTour,
		WeOnMap,
		location,
		preview
	});

	$$self.$inject_state = $$props => {
		if ("location" in $$props) $$invalidate(0, location = $$props.location);
		if ("preview" in $$props) $$invalidate(1, preview = $$props.preview);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [location, preview];
}

class Map extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document.getElementById("svelte-190a4wu-style")) add_css$2();
		init(this, options, instance$g, create_fragment$g, safe_not_equal, { location: 0, preview: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Map",
			options,
			id: create_fragment$g.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*location*/ ctx[0] === undefined && !("location" in props)) {
			console.warn("<Map> was created without expected prop 'location'");
		}

		if (/*preview*/ ctx[1] === undefined && !("preview" in props)) {
			console.warn("<Map> was created without expected prop 'preview'");
		}
	}

	get location() {
		throw new Error("<Map>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set location(value) {
		throw new Error("<Map>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get preview() {
		throw new Error("<Map>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set preview(value) {
		throw new Error("<Map>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/organizations/view/_About.svelte generated by Svelte v3.24.0 */

function create_fragment$h(ctx) {
	let description;
	let current;

	description = new Description({
			props: {
				title: /*title*/ ctx[0],
				text: /*text*/ ctx[1]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(description.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(description.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(description, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const description_changes = {};
			if (dirty & /*title*/ 1) description_changes.title = /*title*/ ctx[0];
			if (dirty & /*text*/ 2) description_changes.text = /*text*/ ctx[1];
			description.$set(description_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(description.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(description.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(description, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$h.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$h($$self, $$props, $$invalidate) {
	let { title = undefined } = $$props;
	let { text = undefined } = $$props;
	const writable_props = ["title", "text"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<About> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("About", $$slots, []);

	$$self.$set = $$props => {
		if ("title" in $$props) $$invalidate(0, title = $$props.title);
		if ("text" in $$props) $$invalidate(1, text = $$props.text);
	};

	$$self.$capture_state = () => ({ Description, title, text });

	$$self.$inject_state = $$props => {
		if ("title" in $$props) $$invalidate(0, title = $$props.title);
		if ("text" in $$props) $$invalidate(1, text = $$props.text);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [title, text];
}

class About extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$h, create_fragment$h, safe_not_equal, { title: 0, text: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "About",
			options,
			id: create_fragment$h.name
		});
	}

	get title() {
		throw new Error("<About>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<About>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get text() {
		throw new Error("<About>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set text(value) {
		throw new Error("<About>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/organizations/view/_Videos.svelte generated by Svelte v3.24.0 */

function create_fragment$i(ctx) {
	let videos;
	let current;

	videos = new Videos({
			props: { items: /*items*/ ctx[0] },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(videos.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(videos.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(videos, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const videos_changes = {};
			if (dirty & /*items*/ 1) videos_changes.items = /*items*/ ctx[0];
			videos.$set(videos_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(videos.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(videos.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(videos, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$i.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$i($$self, $$props, $$invalidate) {
	let { items } = $$props;
	const writable_props = ["items"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Videos> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Videos", $$slots, []);

	$$self.$set = $$props => {
		if ("items" in $$props) $$invalidate(0, items = $$props.items);
	};

	$$self.$capture_state = () => ({ Videos, items });

	$$self.$inject_state = $$props => {
		if ("items" in $$props) $$invalidate(0, items = $$props.items);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [items];
}

class Videos_1 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$i, create_fragment$i, safe_not_equal, { items: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Videos_1",
			options,
			id: create_fragment$i.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*items*/ ctx[0] === undefined && !("items" in props)) {
			console.warn("<Videos> was created without expected prop 'items'");
		}
	}

	get items() {
		throw new Error("<Videos>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set items(value) {
		throw new Error("<Videos>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/organizations/view/_Contacts.svelte generated by Svelte v3.24.0 */

function create_fragment$j(ctx) {
	let contactscard;
	let current;

	contactscard = new ContactsCard({
			props: {
				items: /*contacts*/ ctx[0],
				orgName: /*organization*/ ctx[1].title,
				avatar: /*organization*/ ctx[1].avatar,
				avatarBig: /*organization*/ ctx[1].avatarBig
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(contactscard.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(contactscard.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(contactscard, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const contactscard_changes = {};
			if (dirty & /*contacts*/ 1) contactscard_changes.items = /*contacts*/ ctx[0];
			if (dirty & /*organization*/ 2) contactscard_changes.orgName = /*organization*/ ctx[1].title;
			if (dirty & /*organization*/ 2) contactscard_changes.avatar = /*organization*/ ctx[1].avatar;
			if (dirty & /*organization*/ 2) contactscard_changes.avatarBig = /*organization*/ ctx[1].avatarBig;
			contactscard.$set(contactscard_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(contactscard.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(contactscard.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(contactscard, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$j.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$j($$self, $$props, $$invalidate) {
	let { contacts } = $$props;
	let { organization } = $$props;
	const writable_props = ["contacts", "organization"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Contacts> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Contacts", $$slots, []);

	$$self.$set = $$props => {
		if ("contacts" in $$props) $$invalidate(0, contacts = $$props.contacts);
		if ("organization" in $$props) $$invalidate(1, organization = $$props.organization);
	};

	$$self.$capture_state = () => ({ ContactsCard, contacts, organization });

	$$self.$inject_state = $$props => {
		if ("contacts" in $$props) $$invalidate(0, contacts = $$props.contacts);
		if ("organization" in $$props) $$invalidate(1, organization = $$props.organization);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [contacts, organization];
}

class Contacts extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$j, create_fragment$j, safe_not_equal, { contacts: 0, organization: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Contacts",
			options,
			id: create_fragment$j.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*contacts*/ ctx[0] === undefined && !("contacts" in props)) {
			console.warn("<Contacts> was created without expected prop 'contacts'");
		}

		if (/*organization*/ ctx[1] === undefined && !("organization" in props)) {
			console.warn("<Contacts> was created without expected prop 'organization'");
		}
	}

	get contacts() {
		throw new Error("<Contacts>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set contacts(value) {
		throw new Error("<Contacts>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get organization() {
		throw new Error("<Contacts>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set organization(value) {
		throw new Error("<Contacts>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/organizations/view/_Documents.svelte generated by Svelte v3.24.0 */

function create_fragment$k(ctx) {
	let certificates;
	let current;

	certificates = new Certificates({
			props: { items: /*items*/ ctx[0] },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(certificates.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(certificates.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(certificates, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const certificates_changes = {};
			if (dirty & /*items*/ 1) certificates_changes.items = /*items*/ ctx[0];
			certificates.$set(certificates_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(certificates.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(certificates.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(certificates, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$k.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$k($$self, $$props, $$invalidate) {
	let { items } = $$props;
	const writable_props = ["items"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Documents> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Documents", $$slots, []);

	$$self.$set = $$props => {
		if ("items" in $$props) $$invalidate(0, items = $$props.items);
	};

	$$self.$capture_state = () => ({ Certificates, items });

	$$self.$inject_state = $$props => {
		if ("items" in $$props) $$invalidate(0, items = $$props.items);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [items];
}

class Documents extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$k, create_fragment$k, safe_not_equal, { items: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Documents",
			options,
			id: create_fragment$k.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*items*/ ctx[0] === undefined && !("items" in props)) {
			console.warn("<Documents> was created without expected prop 'items'");
		}
	}

	get items() {
		throw new Error("<Documents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set items(value) {
		throw new Error("<Documents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/organizations/view/_Description.svelte generated by Svelte v3.24.0 */

function create_fragment$l(ctx) {
	let topcarousel;
	let t0;
	let br;
	let t1;
	let descriptionshort;
	let current;

	topcarousel = new TopCarousel({
			props: { items: /*carouselTop*/ ctx[2] },
			$$inline: true
		});

	br = new Br({ props: { size: "60" }, $$inline: true });

	descriptionshort = new DescriptionShort({
			props: {
				title: /*title*/ ctx[0],
				text: /*text*/ ctx[1]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(topcarousel.$$.fragment);
			t0 = space();
			create_component(br.$$.fragment);
			t1 = space();
			create_component(descriptionshort.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(topcarousel.$$.fragment, nodes);
			t0 = claim_space(nodes);
			claim_component(br.$$.fragment, nodes);
			t1 = claim_space(nodes);
			claim_component(descriptionshort.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(topcarousel, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(br, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(descriptionshort, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const topcarousel_changes = {};
			if (dirty & /*carouselTop*/ 4) topcarousel_changes.items = /*carouselTop*/ ctx[2];
			topcarousel.$set(topcarousel_changes);
			const descriptionshort_changes = {};
			if (dirty & /*title*/ 1) descriptionshort_changes.title = /*title*/ ctx[0];
			if (dirty & /*text*/ 2) descriptionshort_changes.text = /*text*/ ctx[1];
			descriptionshort.$set(descriptionshort_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(topcarousel.$$.fragment, local);
			transition_in(br.$$.fragment, local);
			transition_in(descriptionshort.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(topcarousel.$$.fragment, local);
			transition_out(br.$$.fragment, local);
			transition_out(descriptionshort.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(topcarousel, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(br, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(descriptionshort, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$l.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$l($$self, $$props, $$invalidate) {
	let { title = undefined } = $$props;
	let { text = undefined } = $$props;
	let { carouselTop = undefined } = $$props;
	const writable_props = ["title", "text", "carouselTop"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Description> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Description", $$slots, []);

	$$self.$set = $$props => {
		if ("title" in $$props) $$invalidate(0, title = $$props.title);
		if ("text" in $$props) $$invalidate(1, text = $$props.text);
		if ("carouselTop" in $$props) $$invalidate(2, carouselTop = $$props.carouselTop);
	};

	$$self.$capture_state = () => ({
		Br,
		TopCarousel,
		DescriptionShort,
		title,
		text,
		carouselTop
	});

	$$self.$inject_state = $$props => {
		if ("title" in $$props) $$invalidate(0, title = $$props.title);
		if ("text" in $$props) $$invalidate(1, text = $$props.text);
		if ("carouselTop" in $$props) $$invalidate(2, carouselTop = $$props.carouselTop);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [title, text, carouselTop];
}

class Description$1 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$l, create_fragment$l, safe_not_equal, { title: 0, text: 1, carouselTop: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Description",
			options,
			id: create_fragment$l.name
		});
	}

	get title() {
		throw new Error("<Description>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<Description>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get text() {
		throw new Error("<Description>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set text(value) {
		throw new Error("<Description>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get carouselTop() {
		throw new Error("<Description>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set carouselTop(value) {
		throw new Error("<Description>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/organizations/view/_OrganizationButton.svelte generated by Svelte v3.24.0 */

function create_fragment$m(ctx) {
	let organizationbutton;
	let current;

	organizationbutton = new OrganizationButton({
			props: {
				id: /*organization*/ ctx[0].id,
				src: /*organization*/ ctx[0].avatar,
				title: /*organization*/ ctx[0].name
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(organizationbutton.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(organizationbutton.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(organizationbutton, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const organizationbutton_changes = {};
			if (dirty & /*organization*/ 1) organizationbutton_changes.id = /*organization*/ ctx[0].id;
			if (dirty & /*organization*/ 1) organizationbutton_changes.src = /*organization*/ ctx[0].avatar;
			if (dirty & /*organization*/ 1) organizationbutton_changes.title = /*organization*/ ctx[0].name;
			organizationbutton.$set(organizationbutton_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(organizationbutton.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(organizationbutton.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(organizationbutton, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$m.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$m($$self, $$props, $$invalidate) {
	let { organization } = $$props;
	const writable_props = ["organization"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<OrganizationButton> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("OrganizationButton", $$slots, []);

	$$self.$set = $$props => {
		if ("organization" in $$props) $$invalidate(0, organization = $$props.organization);
	};

	$$self.$capture_state = () => ({ Br, OrganizationButton, organization });

	$$self.$inject_state = $$props => {
		if ("organization" in $$props) $$invalidate(0, organization = $$props.organization);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [organization];
}

class OrganizationButton_1 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$m, create_fragment$m, safe_not_equal, { organization: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "OrganizationButton_1",
			options,
			id: create_fragment$m.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*organization*/ ctx[0] === undefined && !("organization" in props)) {
			console.warn("<OrganizationButton> was created without expected prop 'organization'");
		}
	}

	get organization() {
		throw new Error("<OrganizationButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set organization(value) {
		throw new Error("<OrganizationButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/organizations/edit/_Map.svelte generated by Svelte v3.24.0 */

// (42:0) <EditCard form="map-form" on:cancel={onCancel}>
function create_default_slot$5(ctx) {
	let formbuilder;
	let current;

	formbuilder = new FormBuilder({
			props: {
				id: "map-form",
				items: /*formFields*/ ctx[2],
				data: /*formValues*/ ctx[0],
				errors: /*formErrors*/ ctx[1],
				submit: /*onSubmit*/ ctx[3]
			},
			$$inline: true
		});

	formbuilder.$on("change", /*change_handler*/ ctx[7]);

	const block = {
		c: function create() {
			create_component(formbuilder.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(formbuilder.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(formbuilder, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const formbuilder_changes = {};
			if (dirty & /*formValues*/ 1) formbuilder_changes.data = /*formValues*/ ctx[0];
			if (dirty & /*formErrors*/ 2) formbuilder_changes.errors = /*formErrors*/ ctx[1];
			formbuilder.$set(formbuilder_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(formbuilder.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(formbuilder.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(formbuilder, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$5.name,
		type: "slot",
		source: "(42:0) <EditCard form=\\\"map-form\\\" on:cancel={onCancel}>",
		ctx
	});

	return block;
}

function create_fragment$n(ctx) {
	let editcard;
	let current;

	editcard = new EditCard({
			props: {
				form: "map-form",
				$$slots: { default: [create_default_slot$5] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	editcard.$on("cancel", /*onCancel*/ ctx[4]);

	const block = {
		c: function create() {
			create_component(editcard.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(editcard.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(editcard, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const editcard_changes = {};

			if (dirty & /*$$scope, formValues, formErrors*/ 515) {
				editcard_changes.$$scope = { dirty, ctx };
			}

			editcard.$set(editcard_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(editcard.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(editcard.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(editcard, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$n.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$n($$self, $$props, $$invalidate) {
	let { data = undefined } = $$props;

	let { submit = async () => {
		
	} } = $$props;

	const dispatch = createEventDispatcher();

	let formFields = [
		{
			label: "Адрес:",
			type: "url",
			name: "location.map",
			meta: {
				placeholder: "https://www.google.com.ua/maps/place/..."
			}
		},
		{
			label: "3D - Тур:",
			type: "url",
			name: "location.virtual_tour",
			meta: {
				placeholder: "https://www.google.com.ua/maps/@48.8994332,24.7567114..."
			}
		}
	];

	async function onSubmit(e) {
		await submit(e);
	}

	function onCancel() {
		$$invalidate(0, formValues = data);
		dispatch("cancel");
	}

	const writable_props = ["data", "submit"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Map> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Map", $$slots, []);

	function change_handler(event) {
		bubble($$self, event);
	}

	$$self.$set = $$props => {
		if ("data" in $$props) $$invalidate(5, data = $$props.data);
		if ("submit" in $$props) $$invalidate(6, submit = $$props.submit);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		EditCard,
		FormBuilder,
		data,
		submit,
		dispatch,
		formFields,
		onSubmit,
		onCancel,
		formValues,
		formErrors
	});

	$$self.$inject_state = $$props => {
		if ("data" in $$props) $$invalidate(5, data = $$props.data);
		if ("submit" in $$props) $$invalidate(6, submit = $$props.submit);
		if ("formFields" in $$props) $$invalidate(2, formFields = $$props.formFields);
		if ("formValues" in $$props) $$invalidate(0, formValues = $$props.formValues);
		if ("formErrors" in $$props) $$invalidate(1, formErrors = $$props.formErrors);
	};

	let formValues;
	let formErrors;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*data*/ 32) {
			 $$invalidate(0, formValues = data || {});
		}
	};

	 $$invalidate(1, formErrors = {});

	return [
		formValues,
		formErrors,
		formFields,
		onSubmit,
		onCancel,
		data,
		submit,
		change_handler
	];
}

class Map$1 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$n, create_fragment$n, safe_not_equal, { data: 5, submit: 6 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Map",
			options,
			id: create_fragment$n.name
		});
	}

	get data() {
		throw new Error("<Map>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set data(value) {
		throw new Error("<Map>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get submit() {
		throw new Error("<Map>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set submit(value) {
		throw new Error("<Map>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/organizations/edit/_About.svelte generated by Svelte v3.24.0 */

// (36:0) <EditCard form="about-form" on:cancel={onCancel}>
function create_default_slot$6(ctx) {
	let formbuilder;
	let current;

	formbuilder = new FormBuilder({
			props: {
				id: "about-form",
				items: /*formFields*/ ctx[2],
				data: /*formValues*/ ctx[0],
				errors: /*formErrors*/ ctx[1],
				submit: /*onSubmit*/ ctx[3]
			},
			$$inline: true
		});

	formbuilder.$on("change", /*change_handler*/ ctx[7]);

	const block = {
		c: function create() {
			create_component(formbuilder.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(formbuilder.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(formbuilder, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const formbuilder_changes = {};
			if (dirty & /*formValues*/ 1) formbuilder_changes.data = /*formValues*/ ctx[0];
			if (dirty & /*formErrors*/ 2) formbuilder_changes.errors = /*formErrors*/ ctx[1];
			formbuilder.$set(formbuilder_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(formbuilder.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(formbuilder.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(formbuilder, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$6.name,
		type: "slot",
		source: "(36:0) <EditCard form=\\\"about-form\\\" on:cancel={onCancel}>",
		ctx
	});

	return block;
}

function create_fragment$o(ctx) {
	let editcard;
	let current;

	editcard = new EditCard({
			props: {
				form: "about-form",
				$$slots: { default: [create_default_slot$6] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	editcard.$on("cancel", /*onCancel*/ ctx[4]);

	const block = {
		c: function create() {
			create_component(editcard.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(editcard.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(editcard, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const editcard_changes = {};

			if (dirty & /*$$scope, formValues, formErrors*/ 515) {
				editcard_changes.$$scope = { dirty, ctx };
			}

			editcard.$set(editcard_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(editcard.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(editcard.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(editcard, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$o.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$o($$self, $$props, $$invalidate) {
	let { data = undefined } = $$props;

	let { submit = async () => {
		
	} } = $$props;

	const dispatch = createEventDispatcher();

	let formFields = [
		{
			label: "Про нас:",
			type: "textarea",
			name: "description",
			meta: {
				rows: 6,
				placeholder: "Ми піклуємось про...",
				maxlength: 250
			}
		}
	];

	async function onSubmit(e) {
		await submit(e);
	}

	function onCancel() {
		$$invalidate(0, formValues = data);
		dispatch("cancel");
	}

	const writable_props = ["data", "submit"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<About> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("About", $$slots, []);

	function change_handler(event) {
		bubble($$self, event);
	}

	$$self.$set = $$props => {
		if ("data" in $$props) $$invalidate(5, data = $$props.data);
		if ("submit" in $$props) $$invalidate(6, submit = $$props.submit);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		EditCard,
		FormBuilder,
		data,
		submit,
		dispatch,
		formFields,
		onSubmit,
		onCancel,
		formValues,
		formErrors
	});

	$$self.$inject_state = $$props => {
		if ("data" in $$props) $$invalidate(5, data = $$props.data);
		if ("submit" in $$props) $$invalidate(6, submit = $$props.submit);
		if ("formFields" in $$props) $$invalidate(2, formFields = $$props.formFields);
		if ("formValues" in $$props) $$invalidate(0, formValues = $$props.formValues);
		if ("formErrors" in $$props) $$invalidate(1, formErrors = $$props.formErrors);
	};

	let formValues;
	let formErrors;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*data*/ 32) {
			 $$invalidate(0, formValues = data || {});
		}
	};

	 $$invalidate(1, formErrors = {});

	return [
		formValues,
		formErrors,
		formFields,
		onSubmit,
		onCancel,
		data,
		submit,
		change_handler
	];
}

class About$1 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$o, create_fragment$o, safe_not_equal, { data: 5, submit: 6 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "About",
			options,
			id: create_fragment$o.name
		});
	}

	get data() {
		throw new Error("<About>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set data(value) {
		throw new Error("<About>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get submit() {
		throw new Error("<About>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set submit(value) {
		throw new Error("<About>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/organizations/edit/_Videos.svelte generated by Svelte v3.24.0 */

// (59:0) <EditCard form="videos-form" on:cancel={onCancel}>
function create_default_slot$7(ctx) {
	let formbuilder;
	let current;

	formbuilder = new FormBuilder({
			props: {
				id: "videos-form",
				items: /*formFields*/ ctx[2],
				data: /*formValues*/ ctx[0],
				errors: /*formErrors*/ ctx[1],
				submit: /*onSubmit*/ ctx[3]
			},
			$$inline: true
		});

	formbuilder.$on("change", /*onChange*/ ctx[4]);

	const block = {
		c: function create() {
			create_component(formbuilder.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(formbuilder.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(formbuilder, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const formbuilder_changes = {};
			if (dirty & /*formFields*/ 4) formbuilder_changes.items = /*formFields*/ ctx[2];
			if (dirty & /*formValues*/ 1) formbuilder_changes.data = /*formValues*/ ctx[0];
			if (dirty & /*formErrors*/ 2) formbuilder_changes.errors = /*formErrors*/ ctx[1];
			formbuilder.$set(formbuilder_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(formbuilder.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(formbuilder.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(formbuilder, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$7.name,
		type: "slot",
		source: "(59:0) <EditCard form=\\\"videos-form\\\" on:cancel={onCancel}>",
		ctx
	});

	return block;
}

function create_fragment$p(ctx) {
	let editcard;
	let current;

	editcard = new EditCard({
			props: {
				form: "videos-form",
				$$slots: { default: [create_default_slot$7] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	editcard.$on("cancel", /*onCancel*/ ctx[5]);

	const block = {
		c: function create() {
			create_component(editcard.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(editcard.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(editcard, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const editcard_changes = {};

			if (dirty & /*$$scope, formFields, formValues, formErrors*/ 8199) {
				editcard_changes.$$scope = { dirty, ctx };
			}

			editcard.$set(editcard_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(editcard.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(editcard.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(editcard, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$p.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$p($$self, $$props, $$invalidate) {
	let { data = undefined } = $$props;

	let { submit = async () => {
		
	} } = $$props;

	const dispatch = createEventDispatcher();

	const defaultField = {
		label: "Відео 1:",
		type: "url",
		name: "videos[0].src",
		meta: {
			placeholder: "https://www.youtube.com/watch?v=oUcAUwptos4&t"
		}
	};

	async function onSubmit(e) {
		await submit(e);
	}

	function shiftValues(values) {
		return {
			...values,
			videos: safeGet(() => values.videos.filter(v => v.src), [])
		};
	}

	function onChange({ detail: { values } }) {
		$$invalidate(8, currentValues = shiftValues(values));

		if (safeGet(() => currentValues.videos.length) !== safeGet(() => formValues.videos.length)) {
			$$invalidate(0, formValues = currentValues);
		}

		dispatch("change", values);
	}

	function onCancel() {
		$$invalidate(8, currentValues = data);
		$$invalidate(0, formValues = data);
		dispatch("cancel");
	}

	const writable_props = ["data", "submit"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Videos> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Videos", $$slots, []);

	$$self.$set = $$props => {
		if ("data" in $$props) $$invalidate(6, data = $$props.data);
		if ("submit" in $$props) $$invalidate(7, submit = $$props.submit);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		safeGet,
		EditCard,
		FormBuilder,
		data,
		submit,
		dispatch,
		defaultField,
		onSubmit,
		shiftValues,
		onChange,
		onCancel,
		currentValues,
		formValues,
		formErrors,
		fieldsAmount,
		formFields
	});

	$$self.$inject_state = $$props => {
		if ("data" in $$props) $$invalidate(6, data = $$props.data);
		if ("submit" in $$props) $$invalidate(7, submit = $$props.submit);
		if ("currentValues" in $$props) $$invalidate(8, currentValues = $$props.currentValues);
		if ("formValues" in $$props) $$invalidate(0, formValues = $$props.formValues);
		if ("formErrors" in $$props) $$invalidate(1, formErrors = $$props.formErrors);
		if ("fieldsAmount" in $$props) $$invalidate(9, fieldsAmount = $$props.fieldsAmount);
		if ("formFields" in $$props) $$invalidate(2, formFields = $$props.formFields);
	};

	let currentValues;
	let formValues;
	let formErrors;
	let fieldsAmount;
	let formFields;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*data*/ 64) {
			 $$invalidate(8, currentValues = data || {});
		}

		if ($$self.$$.dirty & /*data*/ 64) {
			 $$invalidate(0, formValues = data || {});
		}

		if ($$self.$$.dirty & /*currentValues*/ 256) {
			 $$invalidate(9, fieldsAmount = safeGet(() => currentValues.videos.filter(v => v.src).length, 0, true));
		}

		if ($$self.$$.dirty & /*fieldsAmount*/ 512) {
			 $$invalidate(2, formFields = Array.from(new Array(Math.max(2, fieldsAmount + 1))).map((f, i) => ({
				...defaultField,
				label: `Відео ${i + 1}:`,
				name: `videos[${i}].src`
			})));
		}
	};

	 $$invalidate(1, formErrors = {});
	return [formValues, formErrors, formFields, onSubmit, onChange, onCancel, data, submit];
}

class Videos$1 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$p, create_fragment$p, safe_not_equal, { data: 6, submit: 7 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Videos",
			options,
			id: create_fragment$p.name
		});
	}

	get data() {
		throw new Error("<Videos>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set data(value) {
		throw new Error("<Videos>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get submit() {
		throw new Error("<Videos>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set submit(value) {
		throw new Error("<Videos>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/organizations/edit/_Contacts.svelte generated by Svelte v3.24.0 */

// (77:8) {#if item.type === 'custom-socials'}
function create_if_block$6(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Socials");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Socials");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$6.name,
		type: "if",
		source: "(77:8) {#if item.type === 'custom-socials'}",
		ctx
	});

	return block;
}

// (66:4) <FormBuilder          id="contacts-form"         items={formFields}         data={formValues}         errors={formErrors}         submit={onSubmit}         on:change         let:item={item}         let:value={value}         let:onChange={onChange}     >
function create_default_slot_1$3(ctx) {
	let if_block_anchor;
	let if_block = /*item*/ ctx[9].type === "custom-socials" && create_if_block$6(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (/*item*/ ctx[9].type === "custom-socials") {
				if (if_block) ; else {
					if_block = create_if_block$6(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$3.name,
		type: "slot",
		source: "(66:4) <FormBuilder          id=\\\"contacts-form\\\"         items={formFields}         data={formValues}         errors={formErrors}         submit={onSubmit}         on:change         let:item={item}         let:value={value}         let:onChange={onChange}     >",
		ctx
	});

	return block;
}

// (65:0) <EditCard form="contacts-form" on:cancel={onCancel}>
function create_default_slot$8(ctx) {
	let formbuilder;
	let current;

	formbuilder = new FormBuilder({
			props: {
				id: "contacts-form",
				items: /*formFields*/ ctx[2],
				data: /*formValues*/ ctx[0],
				errors: /*formErrors*/ ctx[1],
				submit: /*onSubmit*/ ctx[3],
				$$slots: {
					default: [
						create_default_slot_1$3,
						({ item, value, onChange }) => ({ 9: item, 10: value, 11: onChange }),
						({ item, value, onChange }) => (item ? 512 : 0) | (value ? 1024 : 0) | (onChange ? 2048 : 0)
					]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	formbuilder.$on("change", /*change_handler*/ ctx[7]);

	const block = {
		c: function create() {
			create_component(formbuilder.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(formbuilder.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(formbuilder, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const formbuilder_changes = {};
			if (dirty & /*formValues*/ 1) formbuilder_changes.data = /*formValues*/ ctx[0];
			if (dirty & /*formErrors*/ 2) formbuilder_changes.errors = /*formErrors*/ ctx[1];

			if (dirty & /*$$scope, item*/ 4608) {
				formbuilder_changes.$$scope = { dirty, ctx };
			}

			formbuilder.$set(formbuilder_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(formbuilder.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(formbuilder.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(formbuilder, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$8.name,
		type: "slot",
		source: "(65:0) <EditCard form=\\\"contacts-form\\\" on:cancel={onCancel}>",
		ctx
	});

	return block;
}

function create_fragment$q(ctx) {
	let editcard;
	let current;

	editcard = new EditCard({
			props: {
				form: "contacts-form",
				$$slots: { default: [create_default_slot$8] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	editcard.$on("cancel", /*onCancel*/ ctx[4]);

	const block = {
		c: function create() {
			create_component(editcard.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(editcard.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(editcard, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const editcard_changes = {};

			if (dirty & /*$$scope, formValues, formErrors*/ 4099) {
				editcard_changes.$$scope = { dirty, ctx };
			}

			editcard.$set(editcard_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(editcard.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(editcard.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(editcard, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$q.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$q($$self, $$props, $$invalidate) {
	let { data = undefined } = $$props;

	let { submit = async () => {
		
	} } = $$props;

	const dispatch = createEventDispatcher();

	let formFields = [
		{
			type: "avatar",
			name: "avatar",
			meta: { accept: "image/jpeg,image/png" }
		},
		{
			label: "Телефон:",
			type: "tel",
			name: "phone",
			meta: { placeholder: "+380974354532" }
		},
		{
			label: "Email:",
			type: "email",
			name: "email",
			meta: { placeholder: "mylovedmail@gmail.com" }
		},
		{
			label: "Адреса:",
			type: "search",
			name: "address",
			meta: {
				placeholder: "Почніть вводити...",
				maxlength: 50
			}
		},
		{
			label: "Соцмережі:",
			type: "custom-socials",
			name: "socials"
		}
	];

	async function onSubmit(e) {
		await submit(e);
	}

	function onCancel() {
		$$invalidate(0, formValues = data);
		dispatch("cancel");
	}

	const writable_props = ["data", "submit"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Contacts> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Contacts", $$slots, []);

	function change_handler(event) {
		bubble($$self, event);
	}

	$$self.$set = $$props => {
		if ("data" in $$props) $$invalidate(5, data = $$props.data);
		if ("submit" in $$props) $$invalidate(6, submit = $$props.submit);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		options,
		EditCard,
		FormBuilder,
		data,
		submit,
		dispatch,
		formFields,
		onSubmit,
		onCancel,
		formValues,
		formErrors
	});

	$$self.$inject_state = $$props => {
		if ("data" in $$props) $$invalidate(5, data = $$props.data);
		if ("submit" in $$props) $$invalidate(6, submit = $$props.submit);
		if ("formFields" in $$props) $$invalidate(2, formFields = $$props.formFields);
		if ("formValues" in $$props) $$invalidate(0, formValues = $$props.formValues);
		if ("formErrors" in $$props) $$invalidate(1, formErrors = $$props.formErrors);
	};

	let formValues;
	let formErrors;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*data*/ 32) {
			 $$invalidate(0, formValues = data || {});
		}
	};

	 $$invalidate(1, formErrors = {});

	return [
		formValues,
		formErrors,
		formFields,
		onSubmit,
		onCancel,
		data,
		submit,
		change_handler
	];
}

class Contacts$1 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$q, create_fragment$q, safe_not_equal, { data: 5, submit: 6 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Contacts",
			options,
			id: create_fragment$q.name
		});
	}

	get data() {
		throw new Error("<Contacts>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set data(value) {
		throw new Error("<Contacts>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get submit() {
		throw new Error("<Contacts>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set submit(value) {
		throw new Error("<Contacts>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/organizations/edit/_Documents.svelte generated by Svelte v3.24.0 */

// (35:0) <EditCard form="documents-form" on:cancel={onCancel}>
function create_default_slot$9(ctx) {
	let formbuilder;
	let current;

	formbuilder = new FormBuilder({
			props: {
				id: "documents-form",
				items: /*formFields*/ ctx[2],
				data: /*formValues*/ ctx[0],
				errors: /*formErrors*/ ctx[1],
				submit: /*onSubmit*/ ctx[3]
			},
			$$inline: true
		});

	formbuilder.$on("change", /*change_handler*/ ctx[7]);

	const block = {
		c: function create() {
			create_component(formbuilder.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(formbuilder.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(formbuilder, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const formbuilder_changes = {};
			if (dirty & /*formValues*/ 1) formbuilder_changes.data = /*formValues*/ ctx[0];
			if (dirty & /*formErrors*/ 2) formbuilder_changes.errors = /*formErrors*/ ctx[1];
			formbuilder.$set(formbuilder_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(formbuilder.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(formbuilder.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(formbuilder, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$9.name,
		type: "slot",
		source: "(35:0) <EditCard form=\\\"documents-form\\\" on:cancel={onCancel}>",
		ctx
	});

	return block;
}

function create_fragment$r(ctx) {
	let editcard;
	let current;

	editcard = new EditCard({
			props: {
				form: "documents-form",
				$$slots: { default: [create_default_slot$9] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	editcard.$on("cancel", /*onCancel*/ ctx[4]);

	const block = {
		c: function create() {
			create_component(editcard.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(editcard.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(editcard, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const editcard_changes = {};

			if (dirty & /*$$scope, formValues, formErrors*/ 515) {
				editcard_changes.$$scope = { dirty, ctx };
			}

			editcard.$set(editcard_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(editcard.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(editcard.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(editcard, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$r.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$r($$self, $$props, $$invalidate) {
	let { data = undefined } = $$props;

	let { submit = async () => {
		
	} } = $$props;

	const dispatch = createEventDispatcher();

	let formFields = [
		{
			label: "Сертифікати:",
			type: "files",
			name: "documents",
			meta: {
				multiple: true,
				accept: "image/jpeg,image/png,application/pdf"
			}
		}
	];

	async function onSubmit(e) {
		await submit(e);
	}

	function onCancel() {
		$$invalidate(0, formValues = data);
		dispatch("cancel");
	}

	const writable_props = ["data", "submit"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Documents> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Documents", $$slots, []);

	function change_handler(event) {
		bubble($$self, event);
	}

	$$self.$set = $$props => {
		if ("data" in $$props) $$invalidate(5, data = $$props.data);
		if ("submit" in $$props) $$invalidate(6, submit = $$props.submit);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		EditCard,
		FormBuilder,
		data,
		submit,
		dispatch,
		formFields,
		onSubmit,
		onCancel,
		formValues,
		formErrors
	});

	$$self.$inject_state = $$props => {
		if ("data" in $$props) $$invalidate(5, data = $$props.data);
		if ("submit" in $$props) $$invalidate(6, submit = $$props.submit);
		if ("formFields" in $$props) $$invalidate(2, formFields = $$props.formFields);
		if ("formValues" in $$props) $$invalidate(0, formValues = $$props.formValues);
		if ("formErrors" in $$props) $$invalidate(1, formErrors = $$props.formErrors);
	};

	let formValues;
	let formErrors;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*data*/ 32) {
			 $$invalidate(0, formValues = data || {});
		}
	};

	 $$invalidate(1, formErrors = {});

	return [
		formValues,
		formErrors,
		formFields,
		onSubmit,
		onCancel,
		data,
		submit,
		change_handler
	];
}

class Documents$1 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$r, create_fragment$r, safe_not_equal, { data: 5, submit: 6 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Documents",
			options,
			id: create_fragment$r.name
		});
	}

	get data() {
		throw new Error("<Documents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set data(value) {
		throw new Error("<Documents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get submit() {
		throw new Error("<Documents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set submit(value) {
		throw new Error("<Documents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/organizations/edit/_Description.svelte generated by Svelte v3.24.0 */

// (53:0) <EditCard form="description-form" on:cancel={onCancel}>
function create_default_slot$a(ctx) {
	let formbuilder;
	let current;

	formbuilder = new FormBuilder({
			props: {
				id: "description-form",
				items: /*formFields*/ ctx[2],
				data: /*formValues*/ ctx[0],
				errors: /*formErrors*/ ctx[1],
				submit: /*onSubmit*/ ctx[3]
			},
			$$inline: true
		});

	formbuilder.$on("change", /*change_handler*/ ctx[7]);

	const block = {
		c: function create() {
			create_component(formbuilder.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(formbuilder.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(formbuilder, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const formbuilder_changes = {};
			if (dirty & /*formValues*/ 1) formbuilder_changes.data = /*formValues*/ ctx[0];
			if (dirty & /*formErrors*/ 2) formbuilder_changes.errors = /*formErrors*/ ctx[1];
			formbuilder.$set(formbuilder_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(formbuilder.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(formbuilder.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(formbuilder, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$a.name,
		type: "slot",
		source: "(53:0) <EditCard form=\\\"description-form\\\" on:cancel={onCancel}>",
		ctx
	});

	return block;
}

function create_fragment$s(ctx) {
	let editcard;
	let current;

	editcard = new EditCard({
			props: {
				form: "description-form",
				$$slots: { default: [create_default_slot$a] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	editcard.$on("cancel", /*onCancel*/ ctx[4]);

	const block = {
		c: function create() {
			create_component(editcard.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(editcard.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(editcard, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const editcard_changes = {};

			if (dirty & /*$$scope, formValues, formErrors*/ 515) {
				editcard_changes.$$scope = { dirty, ctx };
			}

			editcard.$set(editcard_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(editcard.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(editcard.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(editcard, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$s.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$s($$self, $$props, $$invalidate) {
	let { data = undefined } = $$props;

	let { submit = async () => {
		
	} } = $$props;

	const dispatch = createEventDispatcher();

	let formFields = [
		{
			label: "Фотогалерея:",
			type: "files",
			name: "avatars",
			meta: { multiple: true }
		},
		{
			label: "Назва організації:",
			type: "text",
			name: "name",
			meta: { placeholder: "Назва...", maxlength: 20 }
		},
		{
			label: "Мета організації:",
			type: "textarea",
			name: "subtitle",
			meta: {
				rows: 6,
				placeholder: "Ми піклуємось про...",
				maxlength: 250
			}
		}
	];

	async function onSubmit(e) {
		await submit(e);
	}

	function onCancel() {
		$$invalidate(0, formValues = data);
		dispatch("cancel");
	}

	const writable_props = ["data", "submit"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Description> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Description", $$slots, []);

	function change_handler(event) {
		bubble($$self, event);
	}

	$$self.$set = $$props => {
		if ("data" in $$props) $$invalidate(5, data = $$props.data);
		if ("submit" in $$props) $$invalidate(6, submit = $$props.submit);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		EditCard,
		FormBuilder,
		data,
		submit,
		dispatch,
		formFields,
		onSubmit,
		onCancel,
		formValues,
		formErrors
	});

	$$self.$inject_state = $$props => {
		if ("data" in $$props) $$invalidate(5, data = $$props.data);
		if ("submit" in $$props) $$invalidate(6, submit = $$props.submit);
		if ("formFields" in $$props) $$invalidate(2, formFields = $$props.formFields);
		if ("formValues" in $$props) $$invalidate(0, formValues = $$props.formValues);
		if ("formErrors" in $$props) $$invalidate(1, formErrors = $$props.formErrors);
	};

	let formValues;
	let formErrors;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*data*/ 32) {
			 $$invalidate(0, formValues = data || {});
		}
	};

	 $$invalidate(1, formErrors = {});

	return [
		formValues,
		formErrors,
		formFields,
		onSubmit,
		onCancel,
		data,
		submit,
		change_handler
	];
}

class Description$2 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$s, create_fragment$s, safe_not_equal, { data: 5, submit: 6 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Description",
			options,
			id: create_fragment$s.name
		});
	}

	get data() {
		throw new Error("<Description>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set data(value) {
		throw new Error("<Description>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get submit() {
		throw new Error("<Description>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set submit(value) {
		throw new Error("<Description>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/organizations/edit/_OrganizationButton.svelte generated by Svelte v3.24.0 */

// (42:0) <EditCard form="organization-form" on:cancel={onCancel}>
function create_default_slot$b(ctx) {
	let formbuilder;
	let current;

	formbuilder = new FormBuilder({
			props: {
				id: "organization-form",
				items: /*formFields*/ ctx[2],
				data: /*formValues*/ ctx[0],
				errors: /*formErrors*/ ctx[1],
				submit: /*onSubmit*/ ctx[3]
			},
			$$inline: true
		});

	formbuilder.$on("change", /*change_handler*/ ctx[7]);

	const block = {
		c: function create() {
			create_component(formbuilder.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(formbuilder.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(formbuilder, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const formbuilder_changes = {};
			if (dirty & /*formValues*/ 1) formbuilder_changes.data = /*formValues*/ ctx[0];
			if (dirty & /*formErrors*/ 2) formbuilder_changes.errors = /*formErrors*/ ctx[1];
			formbuilder.$set(formbuilder_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(formbuilder.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(formbuilder.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(formbuilder, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$b.name,
		type: "slot",
		source: "(42:0) <EditCard form=\\\"organization-form\\\" on:cancel={onCancel}>",
		ctx
	});

	return block;
}

function create_fragment$t(ctx) {
	let editcard;
	let current;

	editcard = new EditCard({
			props: {
				form: "organization-form",
				$$slots: { default: [create_default_slot$b] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	editcard.$on("cancel", /*onCancel*/ ctx[4]);

	const block = {
		c: function create() {
			create_component(editcard.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(editcard.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(editcard, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const editcard_changes = {};

			if (dirty & /*$$scope, formValues, formErrors*/ 515) {
				editcard_changes.$$scope = { dirty, ctx };
			}

			editcard.$set(editcard_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(editcard.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(editcard.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(editcard, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$t.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$t($$self, $$props, $$invalidate) {
	let { data = undefined } = $$props;

	let { submit = async () => {
		
	} } = $$props;

	const dispatch = createEventDispatcher();

	let formFields = [
		{
			type: "avatar",
			name: "avatar",
			meta: { accept: "image/jpeg,image/png" }
		},
		{
			label: "Назва організації:",
			type: "text",
			name: "name",
			meta: { placeholder: "Локі...", maxlength: 20 }
		}
	];

	async function onSubmit(e) {
		await submit(e);
	}

	function onCancel() {
		$$invalidate(0, formValues = data);
		dispatch("cancel");
	}

	const writable_props = ["data", "submit"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<OrganizationButton> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("OrganizationButton", $$slots, []);

	function change_handler(event) {
		bubble($$self, event);
	}

	$$self.$set = $$props => {
		if ("data" in $$props) $$invalidate(5, data = $$props.data);
		if ("submit" in $$props) $$invalidate(6, submit = $$props.submit);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		EditCard,
		FormBuilder,
		data,
		submit,
		dispatch,
		formFields,
		onSubmit,
		onCancel,
		formValues,
		formErrors
	});

	$$self.$inject_state = $$props => {
		if ("data" in $$props) $$invalidate(5, data = $$props.data);
		if ("submit" in $$props) $$invalidate(6, submit = $$props.submit);
		if ("formFields" in $$props) $$invalidate(2, formFields = $$props.formFields);
		if ("formValues" in $$props) $$invalidate(0, formValues = $$props.formValues);
		if ("formErrors" in $$props) $$invalidate(1, formErrors = $$props.formErrors);
	};

	let formValues;
	let formErrors;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*data*/ 32) {
			 $$invalidate(0, formValues = data || {});
		}
	};

	 $$invalidate(1, formErrors = {});

	return [
		formValues,
		formErrors,
		formFields,
		onSubmit,
		onCancel,
		data,
		submit,
		change_handler
	];
}

class OrganizationButton$1 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$t, create_fragment$t, safe_not_equal, { data: 5, submit: 6 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "OrganizationButton",
			options,
			id: create_fragment$t.name
		});
	}

	get data() {
		throw new Error("<OrganizationButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set data(value) {
		throw new Error("<OrganizationButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get submit() {
		throw new Error("<OrganizationButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set submit(value) {
		throw new Error("<OrganizationButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/organizations/[id].svelte generated by Svelte v3.24.0 */

const { console: console_1 } = globals;

const file$h = "src/routes/organizations/[id].svelte";

// (199:16) {#if !isEditMode}
function create_if_block_7(ctx) {
	let icon;
	let current;

	icon = new Icon({
			props: { type: "edit", size: "small", is: "light" },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(icon.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_7.name,
		type: "if",
		source: "(199:16) {#if !isEditMode}",
		ctx
	});

	return block;
}

// (194:8) <Button size="small" is="info" on:click={onToggleMode}>
function create_default_slot_24(ctx) {
	let span;
	let t0_value = (/*isEditMode*/ ctx[0] ? "Зберегти" : "Редагувати") + "";
	let t0;
	let t1;
	let s0;
	let t2;
	let s1;
	let t3;
	let current;
	let if_block = !/*isEditMode*/ ctx[0] && create_if_block_7(ctx);

	const block = {
		c: function create() {
			span = element("span");
			t0 = text(t0_value);
			t1 = space();
			s0 = element("s");
			t2 = space();
			s1 = element("s");
			t3 = space();
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t0 = claim_text(span_nodes, t0_value);
			t1 = claim_space(span_nodes);
			s0 = claim_element(span_nodes, "S", {});
			children(s0).forEach(detach_dev);
			t2 = claim_space(span_nodes);
			s1 = claim_element(span_nodes, "S", {});
			children(s1).forEach(detach_dev);
			t3 = claim_space(span_nodes);
			if (if_block) if_block.l(span_nodes);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(s0, file$h, 196, 16, 5396);
			add_location(s1, file$h, 197, 16, 5420);
			attr_dev(span, "class", "h3 font-secondary font-w-500 flex flex-align-center");
			add_location(span, file$h, 194, 12, 5256);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t0);
			append_dev(span, t1);
			append_dev(span, s0);
			append_dev(span, t2);
			append_dev(span, s1);
			append_dev(span, t3);
			if (if_block) if_block.m(span, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*isEditMode*/ 1) && t0_value !== (t0_value = (/*isEditMode*/ ctx[0] ? "Зберегти" : "Редагувати") + "")) set_data_dev(t0, t0_value);

			if (!/*isEditMode*/ ctx[0]) {
				if (if_block) {
					if (dirty[0] & /*isEditMode*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_7(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(span, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			if (if_block) if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_24.name,
		type: "slot",
		source: "(194:8) <Button size=\\\"small\\\" is=\\\"info\\\" on:click={onToggleMode}>",
		ctx
	});

	return block;
}

// (208:4) <LazyToggle active={isEdit.topInfo}>
function create_default_slot_23(ctx) {
	let organizationbuttonedit;
	let current;

	organizationbuttonedit = new OrganizationButton$1({
			props: {
				data: /*organizationBlock*/ ctx[3],
				submit: /*onSubmit*/ ctx[17].bind(null, "topInfo")
			},
			$$inline: true
		});

	organizationbuttonedit.$on("cancel", /*onCancel*/ ctx[18].bind(null, "topInfo"));

	const block = {
		c: function create() {
			create_component(organizationbuttonedit.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(organizationbuttonedit.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(organizationbuttonedit, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const organizationbuttonedit_changes = {};
			if (dirty[0] & /*organizationBlock*/ 8) organizationbuttonedit_changes.data = /*organizationBlock*/ ctx[3];
			organizationbuttonedit.$set(organizationbuttonedit_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(organizationbuttonedit.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(organizationbuttonedit.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(organizationbuttonedit, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_23.name,
		type: "slot",
		source: "(208:4) <LazyToggle active={isEdit.topInfo}>",
		ctx
	});

	return block;
}

// (216:8) <EditArea on:click={() => isEdit.topInfo = !isEdit.topInfo} off={!isEditMode}>
function create_default_slot_22(ctx) {
	let br;
	let t;
	let organizationbuttonview;
	let current;
	br = new Br({ props: { size: "30" }, $$inline: true });

	organizationbuttonview = new OrganizationButton_1({
			props: {
				organization: /*organizationBlock*/ ctx[3]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(br.$$.fragment);
			t = space();
			create_component(organizationbuttonview.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(br.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(organizationbuttonview.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(br, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(organizationbuttonview, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const organizationbuttonview_changes = {};
			if (dirty[0] & /*organizationBlock*/ 8) organizationbuttonview_changes.organization = /*organizationBlock*/ ctx[3];
			organizationbuttonview.$set(organizationbuttonview_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(br.$$.fragment, local);
			transition_in(organizationbuttonview.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br.$$.fragment, local);
			transition_out(organizationbuttonview.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(br, detaching);
			if (detaching) detach_dev(t);
			destroy_component(organizationbuttonview, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_22.name,
		type: "slot",
		source: "(216:8) <EditArea on:click={() => isEdit.topInfo = !isEdit.topInfo} off={!isEditMode}>",
		ctx
	});

	return block;
}

// (215:4) <LazyToggle active={!isEdit.topInfo} mounted class="full-container">
function create_default_slot_21(ctx) {
	let editarea;
	let current;

	editarea = new EditArea({
			props: {
				off: !/*isEditMode*/ ctx[0],
				$$slots: { default: [create_default_slot_22] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	editarea.$on("click", /*click_handler*/ ctx[20]);

	const block = {
		c: function create() {
			create_component(editarea.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(editarea.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(editarea, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const editarea_changes = {};
			if (dirty[0] & /*isEditMode*/ 1) editarea_changes.off = !/*isEditMode*/ ctx[0];

			if (dirty[0] & /*organizationBlock*/ 8 | dirty[1] & /*$$scope*/ 2) {
				editarea_changes.$$scope = { dirty, ctx };
			}

			editarea.$set(editarea_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(editarea.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(editarea.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(editarea, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_21.name,
		type: "slot",
		source: "(215:4) <LazyToggle active={!isEdit.topInfo} mounted class=\\\"full-container\\\">",
		ctx
	});

	return block;
}

// (221:4) {#if isEditMode}
function create_if_block_6(ctx) {
	let br;
	let current;
	br = new Br({ props: { size: "50" }, $$inline: true });

	const block = {
		c: function create() {
			create_component(br.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(br.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(br, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(br.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(br, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_6.name,
		type: "if",
		source: "(221:4) {#if isEditMode}",
		ctx
	});

	return block;
}

// (229:4) <LazyToggle active={isEdit.description}>
function create_default_slot_20(ctx) {
	let descriptionedit;
	let current;

	descriptionedit = new Description$2({
			props: {
				data: {
					.../*descriptionShort*/ ctx[5],
					avatars: /*carouselTop*/ ctx[4]
				},
				submit: /*onSubmit*/ ctx[17].bind(null, "description")
			},
			$$inline: true
		});

	descriptionedit.$on("cancel", /*onCancel*/ ctx[18].bind(null, "description"));

	const block = {
		c: function create() {
			create_component(descriptionedit.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(descriptionedit.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(descriptionedit, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const descriptionedit_changes = {};

			if (dirty[0] & /*descriptionShort, carouselTop*/ 48) descriptionedit_changes.data = {
				.../*descriptionShort*/ ctx[5],
				avatars: /*carouselTop*/ ctx[4]
			};

			descriptionedit.$set(descriptionedit_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(descriptionedit.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(descriptionedit.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(descriptionedit, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_20.name,
		type: "slot",
		source: "(229:4) <LazyToggle active={isEdit.description}>",
		ctx
	});

	return block;
}

// (238:12) {#if isEditMode}
function create_if_block_5(ctx) {
	let br;
	let current;
	br = new Br({ props: { size: "30" }, $$inline: true });

	const block = {
		c: function create() {
			create_component(br.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(br.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(br, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(br.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(br, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_5.name,
		type: "if",
		source: "(238:12) {#if isEditMode}",
		ctx
	});

	return block;
}

// (237:8) <EditArea on:click={() => isEdit.description = !isEdit.description} off={!isEditMode}>
function create_default_slot_19(ctx) {
	let t;
	let descriptionview;
	let current;
	let if_block = /*isEditMode*/ ctx[0] && create_if_block_5(ctx);

	descriptionview = new Description$1({
			props: {
				carouselTop: /*carouselTop*/ ctx[4],
				title: /*descriptionShort*/ ctx[5].name,
				text: /*descriptionShort*/ ctx[5].subtitle
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			t = space();
			create_component(descriptionview.$$.fragment);
		},
		l: function claim(nodes) {
			if (if_block) if_block.l(nodes);
			t = claim_space(nodes);
			claim_component(descriptionview.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, t, anchor);
			mount_component(descriptionview, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*isEditMode*/ ctx[0]) {
				if (if_block) {
					if (dirty[0] & /*isEditMode*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_5(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(t.parentNode, t);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			const descriptionview_changes = {};
			if (dirty[0] & /*carouselTop*/ 16) descriptionview_changes.carouselTop = /*carouselTop*/ ctx[4];
			if (dirty[0] & /*descriptionShort*/ 32) descriptionview_changes.title = /*descriptionShort*/ ctx[5].name;
			if (dirty[0] & /*descriptionShort*/ 32) descriptionview_changes.text = /*descriptionShort*/ ctx[5].subtitle;
			descriptionview.$set(descriptionview_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(descriptionview.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			transition_out(descriptionview.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(t);
			destroy_component(descriptionview, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_19.name,
		type: "slot",
		source: "(237:8) <EditArea on:click={() => isEdit.description = !isEdit.description} off={!isEditMode}>",
		ctx
	});

	return block;
}

// (236:4) <LazyToggle active={!isEdit.description} mounted class="full-container">
function create_default_slot_18(ctx) {
	let editarea;
	let current;

	editarea = new EditArea({
			props: {
				off: !/*isEditMode*/ ctx[0],
				$$slots: { default: [create_default_slot_19] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	editarea.$on("click", /*click_handler_1*/ ctx[21]);

	const block = {
		c: function create() {
			create_component(editarea.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(editarea.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(editarea, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const editarea_changes = {};
			if (dirty[0] & /*isEditMode*/ 1) editarea_changes.off = !/*isEditMode*/ ctx[0];

			if (dirty[0] & /*carouselTop, descriptionShort, isEditMode*/ 49 | dirty[1] & /*$$scope*/ 2) {
				editarea_changes.$$scope = { dirty, ctx };
			}

			editarea.$set(editarea_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(editarea.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(editarea.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(editarea, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_18.name,
		type: "slot",
		source: "(236:4) <LazyToggle active={!isEdit.description} mounted class=\\\"full-container\\\">",
		ctx
	});

	return block;
}

// (248:4) {#if isEditMode}
function create_if_block_4(ctx) {
	let br;
	let current;
	br = new Br({ props: { size: "30" }, $$inline: true });

	const block = {
		c: function create() {
			create_component(br.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(br.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(br, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(br.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(br, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4.name,
		type: "if",
		source: "(248:4) {#if isEditMode}",
		ctx
	});

	return block;
}

// (254:4) <LazyToggle active={!isEditMode} mounted>
function create_default_slot_17(ctx) {
	let interactionindicators;
	let t0;
	let br0;
	let t1;
	let fundlist0;
	let t2;
	let br1;
	let t3;
	let fundlist1;
	let current;

	interactionindicators = new InteractionIndicators({
			props: {
				likes: /*iconsLine*/ ctx[8].likes,
				views: /*iconsLine*/ ctx[8].views,
				isLiked: /*organization*/ ctx[2].isLiked
			},
			$$inline: true
		});

	br0 = new Br({ props: { size: "50" }, $$inline: true });

	fundlist0 = new FundList({
			props: {
				title: "Фонди тварин",
				items: /*animalFunds*/ ctx[6]
			},
			$$inline: true
		});

	br1 = new Br({ props: { size: "45" }, $$inline: true });

	fundlist1 = new FundList({
			props: {
				title: "Інші фонди",
				items: /*othersFunds*/ ctx[7]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(interactionindicators.$$.fragment);
			t0 = space();
			create_component(br0.$$.fragment);
			t1 = space();
			create_component(fundlist0.$$.fragment);
			t2 = space();
			create_component(br1.$$.fragment);
			t3 = space();
			create_component(fundlist1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(interactionindicators.$$.fragment, nodes);
			t0 = claim_space(nodes);
			claim_component(br0.$$.fragment, nodes);
			t1 = claim_space(nodes);
			claim_component(fundlist0.$$.fragment, nodes);
			t2 = claim_space(nodes);
			claim_component(br1.$$.fragment, nodes);
			t3 = claim_space(nodes);
			claim_component(fundlist1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(interactionindicators, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(br0, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(fundlist0, target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(br1, target, anchor);
			insert_dev(target, t3, anchor);
			mount_component(fundlist1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const interactionindicators_changes = {};
			if (dirty[0] & /*iconsLine*/ 256) interactionindicators_changes.likes = /*iconsLine*/ ctx[8].likes;
			if (dirty[0] & /*iconsLine*/ 256) interactionindicators_changes.views = /*iconsLine*/ ctx[8].views;
			if (dirty[0] & /*organization*/ 4) interactionindicators_changes.isLiked = /*organization*/ ctx[2].isLiked;
			interactionindicators.$set(interactionindicators_changes);
			const fundlist0_changes = {};
			if (dirty[0] & /*animalFunds*/ 64) fundlist0_changes.items = /*animalFunds*/ ctx[6];
			fundlist0.$set(fundlist0_changes);
			const fundlist1_changes = {};
			if (dirty[0] & /*othersFunds*/ 128) fundlist1_changes.items = /*othersFunds*/ ctx[7];
			fundlist1.$set(fundlist1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(interactionindicators.$$.fragment, local);
			transition_in(br0.$$.fragment, local);
			transition_in(fundlist0.$$.fragment, local);
			transition_in(br1.$$.fragment, local);
			transition_in(fundlist1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(interactionindicators.$$.fragment, local);
			transition_out(br0.$$.fragment, local);
			transition_out(fundlist0.$$.fragment, local);
			transition_out(br1.$$.fragment, local);
			transition_out(fundlist1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(interactionindicators, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(br0, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(fundlist0, detaching);
			if (detaching) detach_dev(t2);
			destroy_component(br1, detaching);
			if (detaching) detach_dev(t3);
			destroy_component(fundlist1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_17.name,
		type: "slot",
		source: "(254:4) <LazyToggle active={!isEditMode} mounted>",
		ctx
	});

	return block;
}

// (264:4) <LazyToggle active={isEdit.about}>
function create_default_slot_16(ctx) {
	let aboutedit;
	let current;

	aboutedit = new About$1({
			props: {
				data: /*descriptionShort*/ ctx[5],
				submit: /*onSubmit*/ ctx[17].bind(null, "about")
			},
			$$inline: true
		});

	aboutedit.$on("cancel", /*onCancel*/ ctx[18].bind(null, "about"));

	const block = {
		c: function create() {
			create_component(aboutedit.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(aboutedit.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(aboutedit, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const aboutedit_changes = {};
			if (dirty[0] & /*descriptionShort*/ 32) aboutedit_changes.data = /*descriptionShort*/ ctx[5];
			aboutedit.$set(aboutedit_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(aboutedit.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(aboutedit.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(aboutedit, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_16.name,
		type: "slot",
		source: "(264:4) <LazyToggle active={isEdit.about}>",
		ctx
	});

	return block;
}

// (272:8) <EditArea on:click={() => isEdit.about = !isEdit.about} off={!isEditMode}>
function create_default_slot_15(ctx) {
	let br;
	let t;
	let aboutview;
	let current;
	br = new Br({ props: { size: "30" }, $$inline: true });

	aboutview = new About({
			props: {
				title: "Про нас",
				text: /*descriptionShort*/ ctx[5].description
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(br.$$.fragment);
			t = space();
			create_component(aboutview.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(br.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(aboutview.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(br, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(aboutview, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const aboutview_changes = {};
			if (dirty[0] & /*descriptionShort*/ 32) aboutview_changes.text = /*descriptionShort*/ ctx[5].description;
			aboutview.$set(aboutview_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(br.$$.fragment, local);
			transition_in(aboutview.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br.$$.fragment, local);
			transition_out(aboutview.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(br, detaching);
			if (detaching) detach_dev(t);
			destroy_component(aboutview, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_15.name,
		type: "slot",
		source: "(272:8) <EditArea on:click={() => isEdit.about = !isEdit.about} off={!isEditMode}>",
		ctx
	});

	return block;
}

// (271:4) <LazyToggle active={!isEdit.about} mounted class="full-container">
function create_default_slot_14(ctx) {
	let editarea;
	let current;

	editarea = new EditArea({
			props: {
				off: !/*isEditMode*/ ctx[0],
				$$slots: { default: [create_default_slot_15] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	editarea.$on("click", /*click_handler_2*/ ctx[22]);

	const block = {
		c: function create() {
			create_component(editarea.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(editarea.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(editarea, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const editarea_changes = {};
			if (dirty[0] & /*isEditMode*/ 1) editarea_changes.off = !/*isEditMode*/ ctx[0];

			if (dirty[0] & /*descriptionShort*/ 32 | dirty[1] & /*$$scope*/ 2) {
				editarea_changes.$$scope = { dirty, ctx };
			}

			editarea.$set(editarea_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(editarea.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(editarea.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(editarea, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_14.name,
		type: "slot",
		source: "(271:4) <LazyToggle active={!isEdit.about} mounted class=\\\"full-container\\\">",
		ctx
	});

	return block;
}

// (283:4) <LazyToggle active={!isEditMode} mounted>
function create_default_slot_13(ctx) {
	let share;
	let t0;
	let br0;
	let t1;
	let trust;
	let t2;
	let br1;
	let t3;
	let donators_1;
	let t4;
	let br2;
	let t5;
	let lastnews;
	let current;
	share = new Share({ $$inline: true });
	br0 = new Br({ props: { size: "50" }, $$inline: true });

	trust = new Trust({
			props: { active: /*organization*/ ctx[2].isLiked },
			$$inline: true
		});

	br1 = new Br({ props: { size: "50" }, $$inline: true });

	donators_1 = new Donators({
			props: { items: /*donators*/ ctx[10] },
			$$inline: true
		});

	br2 = new Br({ props: { size: "60" }, $$inline: true });

	lastnews = new LastNews({
			props: {
				items: /*lastNews*/ ctx[11],
				carousel: /*carouselTop*/ ctx[4],
				iconsLine: /*iconsLine*/ ctx[8],
				organization: /*organization*/ ctx[2],
				descriptionShort: /*descriptionShort*/ ctx[5]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(share.$$.fragment);
			t0 = space();
			create_component(br0.$$.fragment);
			t1 = space();
			create_component(trust.$$.fragment);
			t2 = space();
			create_component(br1.$$.fragment);
			t3 = space();
			create_component(donators_1.$$.fragment);
			t4 = space();
			create_component(br2.$$.fragment);
			t5 = space();
			create_component(lastnews.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(share.$$.fragment, nodes);
			t0 = claim_space(nodes);
			claim_component(br0.$$.fragment, nodes);
			t1 = claim_space(nodes);
			claim_component(trust.$$.fragment, nodes);
			t2 = claim_space(nodes);
			claim_component(br1.$$.fragment, nodes);
			t3 = claim_space(nodes);
			claim_component(donators_1.$$.fragment, nodes);
			t4 = claim_space(nodes);
			claim_component(br2.$$.fragment, nodes);
			t5 = claim_space(nodes);
			claim_component(lastnews.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(share, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(br0, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(trust, target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(br1, target, anchor);
			insert_dev(target, t3, anchor);
			mount_component(donators_1, target, anchor);
			insert_dev(target, t4, anchor);
			mount_component(br2, target, anchor);
			insert_dev(target, t5, anchor);
			mount_component(lastnews, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const trust_changes = {};
			if (dirty[0] & /*organization*/ 4) trust_changes.active = /*organization*/ ctx[2].isLiked;
			trust.$set(trust_changes);
			const donators_1_changes = {};
			if (dirty[0] & /*donators*/ 1024) donators_1_changes.items = /*donators*/ ctx[10];
			donators_1.$set(donators_1_changes);
			const lastnews_changes = {};
			if (dirty[0] & /*lastNews*/ 2048) lastnews_changes.items = /*lastNews*/ ctx[11];
			if (dirty[0] & /*carouselTop*/ 16) lastnews_changes.carousel = /*carouselTop*/ ctx[4];
			if (dirty[0] & /*iconsLine*/ 256) lastnews_changes.iconsLine = /*iconsLine*/ ctx[8];
			if (dirty[0] & /*organization*/ 4) lastnews_changes.organization = /*organization*/ ctx[2];
			if (dirty[0] & /*descriptionShort*/ 32) lastnews_changes.descriptionShort = /*descriptionShort*/ ctx[5];
			lastnews.$set(lastnews_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(share.$$.fragment, local);
			transition_in(br0.$$.fragment, local);
			transition_in(trust.$$.fragment, local);
			transition_in(br1.$$.fragment, local);
			transition_in(donators_1.$$.fragment, local);
			transition_in(br2.$$.fragment, local);
			transition_in(lastnews.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(share.$$.fragment, local);
			transition_out(br0.$$.fragment, local);
			transition_out(trust.$$.fragment, local);
			transition_out(br1.$$.fragment, local);
			transition_out(donators_1.$$.fragment, local);
			transition_out(br2.$$.fragment, local);
			transition_out(lastnews.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(share, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(br0, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(trust, detaching);
			if (detaching) detach_dev(t2);
			destroy_component(br1, detaching);
			if (detaching) detach_dev(t3);
			destroy_component(donators_1, detaching);
			if (detaching) detach_dev(t4);
			destroy_component(br2, detaching);
			if (detaching) detach_dev(t5);
			destroy_component(lastnews, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_13.name,
		type: "slot",
		source: "(283:4) <LazyToggle active={!isEditMode} mounted>",
		ctx
	});

	return block;
}

// (301:4) <LazyToggle active={isEdit.documents}>
function create_default_slot_12(ctx) {
	let documentsedit;
	let current;

	documentsedit = new Documents$1({
			props: {
				data: { documents: /*documents*/ ctx[12] },
				submit: /*onSubmit*/ ctx[17].bind(null, "documents")
			},
			$$inline: true
		});

	documentsedit.$on("cancel", /*onCancel*/ ctx[18].bind(null, "documents"));

	const block = {
		c: function create() {
			create_component(documentsedit.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(documentsedit.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(documentsedit, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const documentsedit_changes = {};
			if (dirty[0] & /*documents*/ 4096) documentsedit_changes.data = { documents: /*documents*/ ctx[12] };
			documentsedit.$set(documentsedit_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(documentsedit.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(documentsedit.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(documentsedit, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_12.name,
		type: "slot",
		source: "(301:4) <LazyToggle active={isEdit.documents}>",
		ctx
	});

	return block;
}

// (309:8) <EditArea on:click={() => isEdit.documents = !isEdit.documents} off={!isEditMode}>
function create_default_slot_11(ctx) {
	let br;
	let t;
	let documentsview;
	let current;
	br = new Br({ props: { size: "30" }, $$inline: true });

	documentsview = new Documents({
			props: { items: /*documents*/ ctx[12] },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(br.$$.fragment);
			t = space();
			create_component(documentsview.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(br.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(documentsview.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(br, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(documentsview, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const documentsview_changes = {};
			if (dirty[0] & /*documents*/ 4096) documentsview_changes.items = /*documents*/ ctx[12];
			documentsview.$set(documentsview_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(br.$$.fragment, local);
			transition_in(documentsview.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br.$$.fragment, local);
			transition_out(documentsview.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(br, detaching);
			if (detaching) detach_dev(t);
			destroy_component(documentsview, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_11.name,
		type: "slot",
		source: "(309:8) <EditArea on:click={() => isEdit.documents = !isEdit.documents} off={!isEditMode}>",
		ctx
	});

	return block;
}

// (308:4) <LazyToggle active={!isEdit.documents} mounted class="full-container">
function create_default_slot_10(ctx) {
	let editarea;
	let current;

	editarea = new EditArea({
			props: {
				off: !/*isEditMode*/ ctx[0],
				$$slots: { default: [create_default_slot_11] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	editarea.$on("click", /*click_handler_3*/ ctx[23]);

	const block = {
		c: function create() {
			create_component(editarea.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(editarea.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(editarea, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const editarea_changes = {};
			if (dirty[0] & /*isEditMode*/ 1) editarea_changes.off = !/*isEditMode*/ ctx[0];

			if (dirty[0] & /*documents*/ 4096 | dirty[1] & /*$$scope*/ 2) {
				editarea_changes.$$scope = { dirty, ctx };
			}

			editarea.$set(editarea_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(editarea.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(editarea.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(editarea, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_10.name,
		type: "slot",
		source: "(308:4) <LazyToggle active={!isEdit.documents} mounted class=\\\"full-container\\\">",
		ctx
	});

	return block;
}

// (314:4) {#if isEditMode}
function create_if_block_3(ctx) {
	let br;
	let current;
	br = new Br({ props: { size: "30" }, $$inline: true });

	const block = {
		c: function create() {
			create_component(br.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(br.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(br, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(br.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(br, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(314:4) {#if isEditMode}",
		ctx
	});

	return block;
}

// (322:4) <LazyToggle active={isEdit.videos}>
function create_default_slot_9(ctx) {
	let videosedit;
	let current;

	videosedit = new Videos$1({
			props: {
				data: { videos: /*media*/ ctx[13] },
				submit: /*onSubmit*/ ctx[17].bind(null, "videos")
			},
			$$inline: true
		});

	videosedit.$on("cancel", /*onCancel*/ ctx[18].bind(null, "videos"));

	const block = {
		c: function create() {
			create_component(videosedit.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(videosedit.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(videosedit, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const videosedit_changes = {};
			if (dirty[0] & /*media*/ 8192) videosedit_changes.data = { videos: /*media*/ ctx[13] };
			videosedit.$set(videosedit_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(videosedit.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(videosedit.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(videosedit, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_9.name,
		type: "slot",
		source: "(322:4) <LazyToggle active={isEdit.videos}>",
		ctx
	});

	return block;
}

// (330:8) <EditArea on:click={() => isEdit.videos = !isEdit.videos} off={!isEditMode}>
function create_default_slot_8(ctx) {
	let br;
	let t;
	let videosview;
	let current;
	br = new Br({ props: { size: "15" }, $$inline: true });

	videosview = new Videos_1({
			props: { items: /*media*/ ctx[13] },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(br.$$.fragment);
			t = space();
			create_component(videosview.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(br.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(videosview.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(br, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(videosview, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const videosview_changes = {};
			if (dirty[0] & /*media*/ 8192) videosview_changes.items = /*media*/ ctx[13];
			videosview.$set(videosview_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(br.$$.fragment, local);
			transition_in(videosview.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br.$$.fragment, local);
			transition_out(videosview.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(br, detaching);
			if (detaching) detach_dev(t);
			destroy_component(videosview, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_8.name,
		type: "slot",
		source: "(330:8) <EditArea on:click={() => isEdit.videos = !isEdit.videos} off={!isEditMode}>",
		ctx
	});

	return block;
}

// (329:4) <LazyToggle active={!isEdit.videos} mounted class="full-container">
function create_default_slot_7(ctx) {
	let editarea;
	let current;

	editarea = new EditArea({
			props: {
				off: !/*isEditMode*/ ctx[0],
				$$slots: { default: [create_default_slot_8] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	editarea.$on("click", /*click_handler_4*/ ctx[24]);

	const block = {
		c: function create() {
			create_component(editarea.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(editarea.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(editarea, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const editarea_changes = {};
			if (dirty[0] & /*isEditMode*/ 1) editarea_changes.off = !/*isEditMode*/ ctx[0];

			if (dirty[0] & /*media*/ 8192 | dirty[1] & /*$$scope*/ 2) {
				editarea_changes.$$scope = { dirty, ctx };
			}

			editarea.$set(editarea_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(editarea.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(editarea.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(editarea, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_7.name,
		type: "slot",
		source: "(329:4) <LazyToggle active={!isEdit.videos} mounted class=\\\"full-container\\\">",
		ctx
	});

	return block;
}

// (335:4) {#if isEditMode}
function create_if_block_2(ctx) {
	let br;
	let current;
	br = new Br({ props: { size: "30" }, $$inline: true });

	const block = {
		c: function create() {
			create_component(br.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(br.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(br, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(br.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(br, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(335:4) {#if isEditMode}",
		ctx
	});

	return block;
}

// (343:4) <LazyToggle active={isEdit.contacts}>
function create_default_slot_6(ctx) {
	let contactsedit;
	let current;

	contactsedit = new Contacts$1({
			props: {
				data: {
					.../*organizationBlock*/ ctx[3],
					contacts: /*contacts*/ ctx[9]
				},
				submit: /*onSubmit*/ ctx[17].bind(null, "contacts")
			},
			$$inline: true
		});

	contactsedit.$on("cancel", /*onCancel*/ ctx[18].bind(null, "contacts"));

	const block = {
		c: function create() {
			create_component(contactsedit.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(contactsedit.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(contactsedit, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const contactsedit_changes = {};

			if (dirty[0] & /*organizationBlock, contacts*/ 520) contactsedit_changes.data = {
				.../*organizationBlock*/ ctx[3],
				contacts: /*contacts*/ ctx[9]
			};

			contactsedit.$set(contactsedit_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(contactsedit.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(contactsedit.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(contactsedit, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_6.name,
		type: "slot",
		source: "(343:4) <LazyToggle active={isEdit.contacts}>",
		ctx
	});

	return block;
}

// (351:8) <EditArea on:click={() => isEdit.contacts = !isEdit.contacts} off={!isEditMode}>
function create_default_slot_5(ctx) {
	let br;
	let t;
	let contactsview;
	let current;
	br = new Br({ props: { size: "30" }, $$inline: true });

	contactsview = new Contacts({
			props: {
				contacts: /*contacts*/ ctx[9],
				organization: /*organization*/ ctx[2]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(br.$$.fragment);
			t = space();
			create_component(contactsview.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(br.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(contactsview.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(br, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(contactsview, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const contactsview_changes = {};
			if (dirty[0] & /*contacts*/ 512) contactsview_changes.contacts = /*contacts*/ ctx[9];
			if (dirty[0] & /*organization*/ 4) contactsview_changes.organization = /*organization*/ ctx[2];
			contactsview.$set(contactsview_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(br.$$.fragment, local);
			transition_in(contactsview.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br.$$.fragment, local);
			transition_out(contactsview.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(br, detaching);
			if (detaching) detach_dev(t);
			destroy_component(contactsview, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_5.name,
		type: "slot",
		source: "(351:8) <EditArea on:click={() => isEdit.contacts = !isEdit.contacts} off={!isEditMode}>",
		ctx
	});

	return block;
}

// (350:4) <LazyToggle active={!isEdit.contacts} mounted class="full-container">
function create_default_slot_4(ctx) {
	let editarea;
	let current;

	editarea = new EditArea({
			props: {
				off: !/*isEditMode*/ ctx[0],
				$$slots: { default: [create_default_slot_5] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	editarea.$on("click", /*click_handler_5*/ ctx[25]);

	const block = {
		c: function create() {
			create_component(editarea.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(editarea.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(editarea, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const editarea_changes = {};
			if (dirty[0] & /*isEditMode*/ 1) editarea_changes.off = !/*isEditMode*/ ctx[0];

			if (dirty[0] & /*contacts, organization*/ 516 | dirty[1] & /*$$scope*/ 2) {
				editarea_changes.$$scope = { dirty, ctx };
			}

			editarea.$set(editarea_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(editarea.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(editarea.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(editarea, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4.name,
		type: "slot",
		source: "(350:4) <LazyToggle active={!isEdit.contacts} mounted class=\\\"full-container\\\">",
		ctx
	});

	return block;
}

// (356:4) {#if isEditMode}
function create_if_block_1$4(ctx) {
	let br;
	let current;
	br = new Br({ props: { size: "10" }, $$inline: true });

	const block = {
		c: function create() {
			create_component(br.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(br.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(br, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(br.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(br, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$4.name,
		type: "if",
		source: "(356:4) {#if isEditMode}",
		ctx
	});

	return block;
}

// (364:4) <LazyToggle active={isEdit.map}>
function create_default_slot_3(ctx) {
	let mapedit;
	let current;

	mapedit = new Map$1({
			props: {
				data: { location: /*location*/ ctx[14] },
				submit: /*onSubmit*/ ctx[17].bind(null, "map")
			},
			$$inline: true
		});

	mapedit.$on("cancel", /*onCancel*/ ctx[18].bind(null, "map"));

	const block = {
		c: function create() {
			create_component(mapedit.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(mapedit.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(mapedit, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const mapedit_changes = {};
			if (dirty[0] & /*location*/ 16384) mapedit_changes.data = { location: /*location*/ ctx[14] };
			mapedit.$set(mapedit_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(mapedit.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(mapedit.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(mapedit, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3.name,
		type: "slot",
		source: "(364:4) <LazyToggle active={isEdit.map}>",
		ctx
	});

	return block;
}

// (372:8) <EditArea on:click={() => isEdit.map = !isEdit.map} off={!isEditMode}>
function create_default_slot_2(ctx) {
	let br;
	let t;
	let mapview;
	let current;
	br = new Br({ props: { size: "15" }, $$inline: true });

	mapview = new Map({
			props: {
				location: /*location*/ ctx[14],
				preview: /*isEditMode*/ ctx[0]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(br.$$.fragment);
			t = space();
			create_component(mapview.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(br.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(mapview.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(br, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(mapview, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const mapview_changes = {};
			if (dirty[0] & /*location*/ 16384) mapview_changes.location = /*location*/ ctx[14];
			if (dirty[0] & /*isEditMode*/ 1) mapview_changes.preview = /*isEditMode*/ ctx[0];
			mapview.$set(mapview_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(br.$$.fragment, local);
			transition_in(mapview.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br.$$.fragment, local);
			transition_out(mapview.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(br, detaching);
			if (detaching) detach_dev(t);
			destroy_component(mapview, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2.name,
		type: "slot",
		source: "(372:8) <EditArea on:click={() => isEdit.map = !isEdit.map} off={!isEditMode}>",
		ctx
	});

	return block;
}

// (371:4) <LazyToggle active={!isEdit.map} mounted class="full-container">
function create_default_slot_1$4(ctx) {
	let editarea;
	let current;

	editarea = new EditArea({
			props: {
				off: !/*isEditMode*/ ctx[0],
				$$slots: { default: [create_default_slot_2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	editarea.$on("click", /*click_handler_6*/ ctx[26]);

	const block = {
		c: function create() {
			create_component(editarea.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(editarea.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(editarea, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const editarea_changes = {};
			if (dirty[0] & /*isEditMode*/ 1) editarea_changes.off = !/*isEditMode*/ ctx[0];

			if (dirty[0] & /*location, isEditMode*/ 16385 | dirty[1] & /*$$scope*/ 2) {
				editarea_changes.$$scope = { dirty, ctx };
			}

			editarea.$set(editarea_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(editarea.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(editarea.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(editarea, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$4.name,
		type: "slot",
		source: "(371:4) <LazyToggle active={!isEdit.map} mounted class=\\\"full-container\\\">",
		ctx
	});

	return block;
}

// (377:4) {#if isEditMode}
function create_if_block$7(ctx) {
	let br;
	let current;
	br = new Br({ props: { size: "10" }, $$inline: true });

	const block = {
		c: function create() {
			create_component(br.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(br.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(br, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(br.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(br, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$7.name,
		type: "if",
		source: "(377:4) {#if isEditMode}",
		ctx
	});

	return block;
}

// (384:4) <LazyToggle active={!isEditMode} mounted>
function create_default_slot$c(ctx) {
	let comments_1;
	let t;
	let br;
	let current;

	comments_1 = new Comments_1({
			props: { items: /*commentsData*/ ctx[15].comments },
			$$inline: true
		});

	br = new Br({ props: { size: "40" }, $$inline: true });

	const block = {
		c: function create() {
			create_component(comments_1.$$.fragment);
			t = space();
			create_component(br.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(comments_1.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(br.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(comments_1, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(br, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const comments_1_changes = {};
			if (dirty[0] & /*commentsData*/ 32768) comments_1_changes.items = /*commentsData*/ ctx[15].comments;
			comments_1.$set(comments_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(comments_1.$$.fragment, local);
			transition_in(br.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(comments_1.$$.fragment, local);
			transition_out(br.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(comments_1, detaching);
			if (detaching) detach_dev(t);
			destroy_component(br, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$c.name,
		type: "slot",
		source: "(384:4) <LazyToggle active={!isEditMode} mounted>",
		ctx
	});

	return block;
}

function create_fragment$u(ctx) {
	let t0;
	let section;
	let br0;
	let t1;
	let div0;
	let br1;
	let t2;
	let button;
	let t3;
	let br2;
	let t4;
	let lazytoggle0;
	let t5;
	let lazytoggle1;
	let t6;
	let t7;
	let br3;
	let t8;
	let lazytoggle2;
	let t9;
	let lazytoggle3;
	let t10;
	let t11;
	let br4;
	let t12;
	let lazytoggle4;
	let t13;
	let br5;
	let t14;
	let lazytoggle5;
	let t15;
	let lazytoggle6;
	let t16;
	let br6;
	let t17;
	let lazytoggle7;
	let t18;
	let br7;
	let t19;
	let lazytoggle8;
	let t20;
	let lazytoggle9;
	let t21;
	let t22;
	let br8;
	let t23;
	let lazytoggle10;
	let t24;
	let lazytoggle11;
	let t25;
	let t26;
	let br9;
	let t27;
	let lazytoggle12;
	let t28;
	let lazytoggle13;
	let t29;
	let t30;
	let br10;
	let t31;
	let lazytoggle14;
	let t32;
	let lazytoggle15;
	let t33;
	let t34;
	let br11;
	let t35;
	let lazytoggle16;
	let t36;
	let div1;
	let footer;
	let current;

	br0 = new Br({
			props: { size: "var(--header-height)" },
			$$inline: true
		});

	br1 = new Br({ props: { size: "30" }, $$inline: true });

	button = new Button({
			props: {
				size: "small",
				is: "info",
				$$slots: { default: [create_default_slot_24] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button.$on("click", /*onToggleMode*/ ctx[19]);
	br2 = new Br({ props: { size: "30" }, $$inline: true });

	lazytoggle0 = new LazyToggle({
			props: {
				active: /*isEdit*/ ctx[1].topInfo,
				$$slots: { default: [create_default_slot_23] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	lazytoggle1 = new LazyToggle({
			props: {
				active: !/*isEdit*/ ctx[1].topInfo,
				mounted: true,
				class: "full-container",
				$$slots: { default: [create_default_slot_21] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	let if_block0 = /*isEditMode*/ ctx[0] && create_if_block_6(ctx);
	br3 = new Br({ props: { size: "20" }, $$inline: true });

	lazytoggle2 = new LazyToggle({
			props: {
				active: /*isEdit*/ ctx[1].description,
				$$slots: { default: [create_default_slot_20] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	lazytoggle3 = new LazyToggle({
			props: {
				active: !/*isEdit*/ ctx[1].description,
				mounted: true,
				class: "full-container",
				$$slots: { default: [create_default_slot_18] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	let if_block1 = /*isEditMode*/ ctx[0] && create_if_block_4(ctx);
	br4 = new Br({ props: { size: "10" }, $$inline: true });

	lazytoggle4 = new LazyToggle({
			props: {
				active: !/*isEditMode*/ ctx[0],
				mounted: true,
				$$slots: { default: [create_default_slot_17] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	br5 = new Br({ props: { size: "30" }, $$inline: true });

	lazytoggle5 = new LazyToggle({
			props: {
				active: /*isEdit*/ ctx[1].about,
				$$slots: { default: [create_default_slot_16] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	lazytoggle6 = new LazyToggle({
			props: {
				active: !/*isEdit*/ ctx[1].about,
				mounted: true,
				class: "full-container",
				$$slots: { default: [create_default_slot_14] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	br6 = new Br({ props: { size: "10" }, $$inline: true });

	lazytoggle7 = new LazyToggle({
			props: {
				active: !/*isEditMode*/ ctx[0],
				mounted: true,
				$$slots: { default: [create_default_slot_13] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	br7 = new Br({ props: { size: "60" }, $$inline: true });

	lazytoggle8 = new LazyToggle({
			props: {
				active: /*isEdit*/ ctx[1].documents,
				$$slots: { default: [create_default_slot_12] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	lazytoggle9 = new LazyToggle({
			props: {
				active: !/*isEdit*/ ctx[1].documents,
				mounted: true,
				class: "full-container",
				$$slots: { default: [create_default_slot_10] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	let if_block2 = /*isEditMode*/ ctx[0] && create_if_block_3(ctx);
	br8 = new Br({ props: { size: "40" }, $$inline: true });

	lazytoggle10 = new LazyToggle({
			props: {
				active: /*isEdit*/ ctx[1].videos,
				$$slots: { default: [create_default_slot_9] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	lazytoggle11 = new LazyToggle({
			props: {
				active: !/*isEdit*/ ctx[1].videos,
				mounted: true,
				class: "full-container",
				$$slots: { default: [create_default_slot_7] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	let if_block3 = /*isEditMode*/ ctx[0] && create_if_block_2(ctx);
	br9 = new Br({ props: { size: "40" }, $$inline: true });

	lazytoggle12 = new LazyToggle({
			props: {
				active: /*isEdit*/ ctx[1].contacts,
				$$slots: { default: [create_default_slot_6] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	lazytoggle13 = new LazyToggle({
			props: {
				active: !/*isEdit*/ ctx[1].contacts,
				mounted: true,
				class: "full-container",
				$$slots: { default: [create_default_slot_4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	let if_block4 = /*isEditMode*/ ctx[0] && create_if_block_1$4(ctx);
	br10 = new Br({ props: { size: "60" }, $$inline: true });

	lazytoggle14 = new LazyToggle({
			props: {
				active: /*isEdit*/ ctx[1].map,
				$$slots: { default: [create_default_slot_3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	lazytoggle15 = new LazyToggle({
			props: {
				active: !/*isEdit*/ ctx[1].map,
				mounted: true,
				class: "full-container",
				$$slots: { default: [create_default_slot_1$4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	let if_block5 = /*isEditMode*/ ctx[0] && create_if_block$7(ctx);
	br11 = new Br({ props: { size: "60" }, $$inline: true });

	lazytoggle16 = new LazyToggle({
			props: {
				active: !/*isEditMode*/ ctx[0],
				mounted: true,
				$$slots: { default: [create_default_slot$c] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	footer = new Footer({ $$inline: true });

	const block = {
		c: function create() {
			t0 = space();
			section = element("section");
			create_component(br0.$$.fragment);
			t1 = space();
			div0 = element("div");
			create_component(br1.$$.fragment);
			t2 = space();
			create_component(button.$$.fragment);
			t3 = space();
			create_component(br2.$$.fragment);
			t4 = space();
			create_component(lazytoggle0.$$.fragment);
			t5 = space();
			create_component(lazytoggle1.$$.fragment);
			t6 = space();
			if (if_block0) if_block0.c();
			t7 = space();
			create_component(br3.$$.fragment);
			t8 = space();
			create_component(lazytoggle2.$$.fragment);
			t9 = space();
			create_component(lazytoggle3.$$.fragment);
			t10 = space();
			if (if_block1) if_block1.c();
			t11 = space();
			create_component(br4.$$.fragment);
			t12 = space();
			create_component(lazytoggle4.$$.fragment);
			t13 = space();
			create_component(br5.$$.fragment);
			t14 = space();
			create_component(lazytoggle5.$$.fragment);
			t15 = space();
			create_component(lazytoggle6.$$.fragment);
			t16 = space();
			create_component(br6.$$.fragment);
			t17 = space();
			create_component(lazytoggle7.$$.fragment);
			t18 = space();
			create_component(br7.$$.fragment);
			t19 = space();
			create_component(lazytoggle8.$$.fragment);
			t20 = space();
			create_component(lazytoggle9.$$.fragment);
			t21 = space();
			if (if_block2) if_block2.c();
			t22 = space();
			create_component(br8.$$.fragment);
			t23 = space();
			create_component(lazytoggle10.$$.fragment);
			t24 = space();
			create_component(lazytoggle11.$$.fragment);
			t25 = space();
			if (if_block3) if_block3.c();
			t26 = space();
			create_component(br9.$$.fragment);
			t27 = space();
			create_component(lazytoggle12.$$.fragment);
			t28 = space();
			create_component(lazytoggle13.$$.fragment);
			t29 = space();
			if (if_block4) if_block4.c();
			t30 = space();
			create_component(br10.$$.fragment);
			t31 = space();
			create_component(lazytoggle14.$$.fragment);
			t32 = space();
			create_component(lazytoggle15.$$.fragment);
			t33 = space();
			if (if_block5) if_block5.c();
			t34 = space();
			create_component(br11.$$.fragment);
			t35 = space();
			create_component(lazytoggle16.$$.fragment);
			t36 = space();
			div1 = element("div");
			create_component(footer.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			const head_nodes = query_selector_all("[data-svelte=\"svelte-1oiy4zf\"]", document.head);
			head_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			section = claim_element(nodes, "SECTION", { class: true });
			var section_nodes = children(section);
			claim_component(br0.$$.fragment, section_nodes);
			t1 = claim_space(section_nodes);
			div0 = claim_element(section_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			claim_component(br1.$$.fragment, div0_nodes);
			t2 = claim_space(div0_nodes);
			claim_component(button.$$.fragment, div0_nodes);
			t3 = claim_space(div0_nodes);
			claim_component(br2.$$.fragment, div0_nodes);
			div0_nodes.forEach(detach_dev);
			t4 = claim_space(section_nodes);
			claim_component(lazytoggle0.$$.fragment, section_nodes);
			t5 = claim_space(section_nodes);
			claim_component(lazytoggle1.$$.fragment, section_nodes);
			t6 = claim_space(section_nodes);
			if (if_block0) if_block0.l(section_nodes);
			t7 = claim_space(section_nodes);
			claim_component(br3.$$.fragment, section_nodes);
			t8 = claim_space(section_nodes);
			claim_component(lazytoggle2.$$.fragment, section_nodes);
			t9 = claim_space(section_nodes);
			claim_component(lazytoggle3.$$.fragment, section_nodes);
			t10 = claim_space(section_nodes);
			if (if_block1) if_block1.l(section_nodes);
			t11 = claim_space(section_nodes);
			claim_component(br4.$$.fragment, section_nodes);
			t12 = claim_space(section_nodes);
			claim_component(lazytoggle4.$$.fragment, section_nodes);
			t13 = claim_space(section_nodes);
			claim_component(br5.$$.fragment, section_nodes);
			t14 = claim_space(section_nodes);
			claim_component(lazytoggle5.$$.fragment, section_nodes);
			t15 = claim_space(section_nodes);
			claim_component(lazytoggle6.$$.fragment, section_nodes);
			t16 = claim_space(section_nodes);
			claim_component(br6.$$.fragment, section_nodes);
			t17 = claim_space(section_nodes);
			claim_component(lazytoggle7.$$.fragment, section_nodes);
			t18 = claim_space(section_nodes);
			claim_component(br7.$$.fragment, section_nodes);
			t19 = claim_space(section_nodes);
			claim_component(lazytoggle8.$$.fragment, section_nodes);
			t20 = claim_space(section_nodes);
			claim_component(lazytoggle9.$$.fragment, section_nodes);
			t21 = claim_space(section_nodes);
			if (if_block2) if_block2.l(section_nodes);
			t22 = claim_space(section_nodes);
			claim_component(br8.$$.fragment, section_nodes);
			t23 = claim_space(section_nodes);
			claim_component(lazytoggle10.$$.fragment, section_nodes);
			t24 = claim_space(section_nodes);
			claim_component(lazytoggle11.$$.fragment, section_nodes);
			t25 = claim_space(section_nodes);
			if (if_block3) if_block3.l(section_nodes);
			t26 = claim_space(section_nodes);
			claim_component(br9.$$.fragment, section_nodes);
			t27 = claim_space(section_nodes);
			claim_component(lazytoggle12.$$.fragment, section_nodes);
			t28 = claim_space(section_nodes);
			claim_component(lazytoggle13.$$.fragment, section_nodes);
			t29 = claim_space(section_nodes);
			if (if_block4) if_block4.l(section_nodes);
			t30 = claim_space(section_nodes);
			claim_component(br10.$$.fragment, section_nodes);
			t31 = claim_space(section_nodes);
			claim_component(lazytoggle14.$$.fragment, section_nodes);
			t32 = claim_space(section_nodes);
			claim_component(lazytoggle15.$$.fragment, section_nodes);
			t33 = claim_space(section_nodes);
			if (if_block5) if_block5.l(section_nodes);
			t34 = claim_space(section_nodes);
			claim_component(br11.$$.fragment, section_nodes);
			t35 = claim_space(section_nodes);
			claim_component(lazytoggle16.$$.fragment, section_nodes);
			t36 = claim_space(section_nodes);
			div1 = claim_element(section_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			claim_component(footer.$$.fragment, div1_nodes);
			div1_nodes.forEach(detach_dev);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			document.title = "Charitify - Organization page.";
			attr_dev(div0, "class", "overflow-hidden");
			add_location(div0, file$h, 191, 4, 5126);
			attr_dev(div1, "class", "full-container");
			add_location(div1, file$h, 388, 4, 11410);
			attr_dev(section, "class", "container theme-bg-color-secondary");
			add_location(section, file$h, 188, 0, 5030);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, section, anchor);
			mount_component(br0, section, null);
			append_dev(section, t1);
			append_dev(section, div0);
			mount_component(br1, div0, null);
			append_dev(div0, t2);
			mount_component(button, div0, null);
			append_dev(div0, t3);
			mount_component(br2, div0, null);
			append_dev(section, t4);
			mount_component(lazytoggle0, section, null);
			append_dev(section, t5);
			mount_component(lazytoggle1, section, null);
			append_dev(section, t6);
			if (if_block0) if_block0.m(section, null);
			append_dev(section, t7);
			mount_component(br3, section, null);
			append_dev(section, t8);
			mount_component(lazytoggle2, section, null);
			append_dev(section, t9);
			mount_component(lazytoggle3, section, null);
			append_dev(section, t10);
			if (if_block1) if_block1.m(section, null);
			append_dev(section, t11);
			mount_component(br4, section, null);
			append_dev(section, t12);
			mount_component(lazytoggle4, section, null);
			append_dev(section, t13);
			mount_component(br5, section, null);
			append_dev(section, t14);
			mount_component(lazytoggle5, section, null);
			append_dev(section, t15);
			mount_component(lazytoggle6, section, null);
			append_dev(section, t16);
			mount_component(br6, section, null);
			append_dev(section, t17);
			mount_component(lazytoggle7, section, null);
			append_dev(section, t18);
			mount_component(br7, section, null);
			append_dev(section, t19);
			mount_component(lazytoggle8, section, null);
			append_dev(section, t20);
			mount_component(lazytoggle9, section, null);
			append_dev(section, t21);
			if (if_block2) if_block2.m(section, null);
			append_dev(section, t22);
			mount_component(br8, section, null);
			append_dev(section, t23);
			mount_component(lazytoggle10, section, null);
			append_dev(section, t24);
			mount_component(lazytoggle11, section, null);
			append_dev(section, t25);
			if (if_block3) if_block3.m(section, null);
			append_dev(section, t26);
			mount_component(br9, section, null);
			append_dev(section, t27);
			mount_component(lazytoggle12, section, null);
			append_dev(section, t28);
			mount_component(lazytoggle13, section, null);
			append_dev(section, t29);
			if (if_block4) if_block4.m(section, null);
			append_dev(section, t30);
			mount_component(br10, section, null);
			append_dev(section, t31);
			mount_component(lazytoggle14, section, null);
			append_dev(section, t32);
			mount_component(lazytoggle15, section, null);
			append_dev(section, t33);
			if (if_block5) if_block5.m(section, null);
			append_dev(section, t34);
			mount_component(br11, section, null);
			append_dev(section, t35);
			mount_component(lazytoggle16, section, null);
			append_dev(section, t36);
			append_dev(section, div1);
			mount_component(footer, div1, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const button_changes = {};

			if (dirty[0] & /*isEditMode*/ 1 | dirty[1] & /*$$scope*/ 2) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
			const lazytoggle0_changes = {};
			if (dirty[0] & /*isEdit*/ 2) lazytoggle0_changes.active = /*isEdit*/ ctx[1].topInfo;

			if (dirty[0] & /*organizationBlock*/ 8 | dirty[1] & /*$$scope*/ 2) {
				lazytoggle0_changes.$$scope = { dirty, ctx };
			}

			lazytoggle0.$set(lazytoggle0_changes);
			const lazytoggle1_changes = {};
			if (dirty[0] & /*isEdit*/ 2) lazytoggle1_changes.active = !/*isEdit*/ ctx[1].topInfo;

			if (dirty[0] & /*isEditMode, isEdit, organizationBlock*/ 11 | dirty[1] & /*$$scope*/ 2) {
				lazytoggle1_changes.$$scope = { dirty, ctx };
			}

			lazytoggle1.$set(lazytoggle1_changes);

			if (/*isEditMode*/ ctx[0]) {
				if (if_block0) {
					if (dirty[0] & /*isEditMode*/ 1) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_6(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(section, t7);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			const lazytoggle2_changes = {};
			if (dirty[0] & /*isEdit*/ 2) lazytoggle2_changes.active = /*isEdit*/ ctx[1].description;

			if (dirty[0] & /*descriptionShort, carouselTop*/ 48 | dirty[1] & /*$$scope*/ 2) {
				lazytoggle2_changes.$$scope = { dirty, ctx };
			}

			lazytoggle2.$set(lazytoggle2_changes);
			const lazytoggle3_changes = {};
			if (dirty[0] & /*isEdit*/ 2) lazytoggle3_changes.active = !/*isEdit*/ ctx[1].description;

			if (dirty[0] & /*isEditMode, isEdit, carouselTop, descriptionShort*/ 51 | dirty[1] & /*$$scope*/ 2) {
				lazytoggle3_changes.$$scope = { dirty, ctx };
			}

			lazytoggle3.$set(lazytoggle3_changes);

			if (/*isEditMode*/ ctx[0]) {
				if (if_block1) {
					if (dirty[0] & /*isEditMode*/ 1) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_4(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(section, t11);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			const lazytoggle4_changes = {};
			if (dirty[0] & /*isEditMode*/ 1) lazytoggle4_changes.active = !/*isEditMode*/ ctx[0];

			if (dirty[0] & /*othersFunds, animalFunds, iconsLine, organization*/ 452 | dirty[1] & /*$$scope*/ 2) {
				lazytoggle4_changes.$$scope = { dirty, ctx };
			}

			lazytoggle4.$set(lazytoggle4_changes);
			const lazytoggle5_changes = {};
			if (dirty[0] & /*isEdit*/ 2) lazytoggle5_changes.active = /*isEdit*/ ctx[1].about;

			if (dirty[0] & /*descriptionShort*/ 32 | dirty[1] & /*$$scope*/ 2) {
				lazytoggle5_changes.$$scope = { dirty, ctx };
			}

			lazytoggle5.$set(lazytoggle5_changes);
			const lazytoggle6_changes = {};
			if (dirty[0] & /*isEdit*/ 2) lazytoggle6_changes.active = !/*isEdit*/ ctx[1].about;

			if (dirty[0] & /*isEditMode, isEdit, descriptionShort*/ 35 | dirty[1] & /*$$scope*/ 2) {
				lazytoggle6_changes.$$scope = { dirty, ctx };
			}

			lazytoggle6.$set(lazytoggle6_changes);
			const lazytoggle7_changes = {};
			if (dirty[0] & /*isEditMode*/ 1) lazytoggle7_changes.active = !/*isEditMode*/ ctx[0];

			if (dirty[0] & /*lastNews, carouselTop, iconsLine, organization, descriptionShort, donators*/ 3380 | dirty[1] & /*$$scope*/ 2) {
				lazytoggle7_changes.$$scope = { dirty, ctx };
			}

			lazytoggle7.$set(lazytoggle7_changes);
			const lazytoggle8_changes = {};
			if (dirty[0] & /*isEdit*/ 2) lazytoggle8_changes.active = /*isEdit*/ ctx[1].documents;

			if (dirty[0] & /*documents*/ 4096 | dirty[1] & /*$$scope*/ 2) {
				lazytoggle8_changes.$$scope = { dirty, ctx };
			}

			lazytoggle8.$set(lazytoggle8_changes);
			const lazytoggle9_changes = {};
			if (dirty[0] & /*isEdit*/ 2) lazytoggle9_changes.active = !/*isEdit*/ ctx[1].documents;

			if (dirty[0] & /*isEditMode, isEdit, documents*/ 4099 | dirty[1] & /*$$scope*/ 2) {
				lazytoggle9_changes.$$scope = { dirty, ctx };
			}

			lazytoggle9.$set(lazytoggle9_changes);

			if (/*isEditMode*/ ctx[0]) {
				if (if_block2) {
					if (dirty[0] & /*isEditMode*/ 1) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_3(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(section, t22);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			const lazytoggle10_changes = {};
			if (dirty[0] & /*isEdit*/ 2) lazytoggle10_changes.active = /*isEdit*/ ctx[1].videos;

			if (dirty[0] & /*media*/ 8192 | dirty[1] & /*$$scope*/ 2) {
				lazytoggle10_changes.$$scope = { dirty, ctx };
			}

			lazytoggle10.$set(lazytoggle10_changes);
			const lazytoggle11_changes = {};
			if (dirty[0] & /*isEdit*/ 2) lazytoggle11_changes.active = !/*isEdit*/ ctx[1].videos;

			if (dirty[0] & /*isEditMode, isEdit, media*/ 8195 | dirty[1] & /*$$scope*/ 2) {
				lazytoggle11_changes.$$scope = { dirty, ctx };
			}

			lazytoggle11.$set(lazytoggle11_changes);

			if (/*isEditMode*/ ctx[0]) {
				if (if_block3) {
					if (dirty[0] & /*isEditMode*/ 1) {
						transition_in(if_block3, 1);
					}
				} else {
					if_block3 = create_if_block_2(ctx);
					if_block3.c();
					transition_in(if_block3, 1);
					if_block3.m(section, t26);
				}
			} else if (if_block3) {
				group_outros();

				transition_out(if_block3, 1, 1, () => {
					if_block3 = null;
				});

				check_outros();
			}

			const lazytoggle12_changes = {};
			if (dirty[0] & /*isEdit*/ 2) lazytoggle12_changes.active = /*isEdit*/ ctx[1].contacts;

			if (dirty[0] & /*organizationBlock, contacts*/ 520 | dirty[1] & /*$$scope*/ 2) {
				lazytoggle12_changes.$$scope = { dirty, ctx };
			}

			lazytoggle12.$set(lazytoggle12_changes);
			const lazytoggle13_changes = {};
			if (dirty[0] & /*isEdit*/ 2) lazytoggle13_changes.active = !/*isEdit*/ ctx[1].contacts;

			if (dirty[0] & /*isEditMode, isEdit, contacts, organization*/ 519 | dirty[1] & /*$$scope*/ 2) {
				lazytoggle13_changes.$$scope = { dirty, ctx };
			}

			lazytoggle13.$set(lazytoggle13_changes);

			if (/*isEditMode*/ ctx[0]) {
				if (if_block4) {
					if (dirty[0] & /*isEditMode*/ 1) {
						transition_in(if_block4, 1);
					}
				} else {
					if_block4 = create_if_block_1$4(ctx);
					if_block4.c();
					transition_in(if_block4, 1);
					if_block4.m(section, t30);
				}
			} else if (if_block4) {
				group_outros();

				transition_out(if_block4, 1, 1, () => {
					if_block4 = null;
				});

				check_outros();
			}

			const lazytoggle14_changes = {};
			if (dirty[0] & /*isEdit*/ 2) lazytoggle14_changes.active = /*isEdit*/ ctx[1].map;

			if (dirty[0] & /*location*/ 16384 | dirty[1] & /*$$scope*/ 2) {
				lazytoggle14_changes.$$scope = { dirty, ctx };
			}

			lazytoggle14.$set(lazytoggle14_changes);
			const lazytoggle15_changes = {};
			if (dirty[0] & /*isEdit*/ 2) lazytoggle15_changes.active = !/*isEdit*/ ctx[1].map;

			if (dirty[0] & /*isEditMode, isEdit, location*/ 16387 | dirty[1] & /*$$scope*/ 2) {
				lazytoggle15_changes.$$scope = { dirty, ctx };
			}

			lazytoggle15.$set(lazytoggle15_changes);

			if (/*isEditMode*/ ctx[0]) {
				if (if_block5) {
					if (dirty[0] & /*isEditMode*/ 1) {
						transition_in(if_block5, 1);
					}
				} else {
					if_block5 = create_if_block$7(ctx);
					if_block5.c();
					transition_in(if_block5, 1);
					if_block5.m(section, t34);
				}
			} else if (if_block5) {
				group_outros();

				transition_out(if_block5, 1, 1, () => {
					if_block5 = null;
				});

				check_outros();
			}

			const lazytoggle16_changes = {};
			if (dirty[0] & /*isEditMode*/ 1) lazytoggle16_changes.active = !/*isEditMode*/ ctx[0];

			if (dirty[0] & /*commentsData*/ 32768 | dirty[1] & /*$$scope*/ 2) {
				lazytoggle16_changes.$$scope = { dirty, ctx };
			}

			lazytoggle16.$set(lazytoggle16_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(br0.$$.fragment, local);
			transition_in(br1.$$.fragment, local);
			transition_in(button.$$.fragment, local);
			transition_in(br2.$$.fragment, local);
			transition_in(lazytoggle0.$$.fragment, local);
			transition_in(lazytoggle1.$$.fragment, local);
			transition_in(if_block0);
			transition_in(br3.$$.fragment, local);
			transition_in(lazytoggle2.$$.fragment, local);
			transition_in(lazytoggle3.$$.fragment, local);
			transition_in(if_block1);
			transition_in(br4.$$.fragment, local);
			transition_in(lazytoggle4.$$.fragment, local);
			transition_in(br5.$$.fragment, local);
			transition_in(lazytoggle5.$$.fragment, local);
			transition_in(lazytoggle6.$$.fragment, local);
			transition_in(br6.$$.fragment, local);
			transition_in(lazytoggle7.$$.fragment, local);
			transition_in(br7.$$.fragment, local);
			transition_in(lazytoggle8.$$.fragment, local);
			transition_in(lazytoggle9.$$.fragment, local);
			transition_in(if_block2);
			transition_in(br8.$$.fragment, local);
			transition_in(lazytoggle10.$$.fragment, local);
			transition_in(lazytoggle11.$$.fragment, local);
			transition_in(if_block3);
			transition_in(br9.$$.fragment, local);
			transition_in(lazytoggle12.$$.fragment, local);
			transition_in(lazytoggle13.$$.fragment, local);
			transition_in(if_block4);
			transition_in(br10.$$.fragment, local);
			transition_in(lazytoggle14.$$.fragment, local);
			transition_in(lazytoggle15.$$.fragment, local);
			transition_in(if_block5);
			transition_in(br11.$$.fragment, local);
			transition_in(lazytoggle16.$$.fragment, local);
			transition_in(footer.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br0.$$.fragment, local);
			transition_out(br1.$$.fragment, local);
			transition_out(button.$$.fragment, local);
			transition_out(br2.$$.fragment, local);
			transition_out(lazytoggle0.$$.fragment, local);
			transition_out(lazytoggle1.$$.fragment, local);
			transition_out(if_block0);
			transition_out(br3.$$.fragment, local);
			transition_out(lazytoggle2.$$.fragment, local);
			transition_out(lazytoggle3.$$.fragment, local);
			transition_out(if_block1);
			transition_out(br4.$$.fragment, local);
			transition_out(lazytoggle4.$$.fragment, local);
			transition_out(br5.$$.fragment, local);
			transition_out(lazytoggle5.$$.fragment, local);
			transition_out(lazytoggle6.$$.fragment, local);
			transition_out(br6.$$.fragment, local);
			transition_out(lazytoggle7.$$.fragment, local);
			transition_out(br7.$$.fragment, local);
			transition_out(lazytoggle8.$$.fragment, local);
			transition_out(lazytoggle9.$$.fragment, local);
			transition_out(if_block2);
			transition_out(br8.$$.fragment, local);
			transition_out(lazytoggle10.$$.fragment, local);
			transition_out(lazytoggle11.$$.fragment, local);
			transition_out(if_block3);
			transition_out(br9.$$.fragment, local);
			transition_out(lazytoggle12.$$.fragment, local);
			transition_out(lazytoggle13.$$.fragment, local);
			transition_out(if_block4);
			transition_out(br10.$$.fragment, local);
			transition_out(lazytoggle14.$$.fragment, local);
			transition_out(lazytoggle15.$$.fragment, local);
			transition_out(if_block5);
			transition_out(br11.$$.fragment, local);
			transition_out(lazytoggle16.$$.fragment, local);
			transition_out(footer.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(section);
			destroy_component(br0);
			destroy_component(br1);
			destroy_component(button);
			destroy_component(br2);
			destroy_component(lazytoggle0);
			destroy_component(lazytoggle1);
			if (if_block0) if_block0.d();
			destroy_component(br3);
			destroy_component(lazytoggle2);
			destroy_component(lazytoggle3);
			if (if_block1) if_block1.d();
			destroy_component(br4);
			destroy_component(lazytoggle4);
			destroy_component(br5);
			destroy_component(lazytoggle5);
			destroy_component(lazytoggle6);
			destroy_component(br6);
			destroy_component(lazytoggle7);
			destroy_component(br7);
			destroy_component(lazytoggle8);
			destroy_component(lazytoggle9);
			if (if_block2) if_block2.d();
			destroy_component(br8);
			destroy_component(lazytoggle10);
			destroy_component(lazytoggle11);
			if (if_block3) if_block3.d();
			destroy_component(br9);
			destroy_component(lazytoggle12);
			destroy_component(lazytoggle13);
			if (if_block4) if_block4.d();
			destroy_component(br10);
			destroy_component(lazytoggle14);
			destroy_component(lazytoggle15);
			if (if_block5) if_block5.d();
			destroy_component(br11);
			destroy_component(lazytoggle16);
			destroy_component(footer);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$u.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$u($$self, $$props, $$invalidate) {
	let $page;
	const { page } = stores$1();
	validate_store(page, "page");
	component_subscribe($$self, page, value => $$invalidate(29, $page = value));

	// Organization
	let organizationId = $page.params.id;

	let isEditMode = false;

	let isEdit = {
		topInfo: false,
		description: false,
		about: false,
		documents: false,
		videos: false,
		contacts: false,
		map: false
	};

	// Entities
	let organization = {};

	let comments;
	let funds;

	onMount(async () => {
		await delay(5000);
		$$invalidate(2, organization = await API.getOrganization(organizationId));
		$$invalidate(27, comments = await API.getComments());
		$$invalidate(28, funds = await API.getFunds());
	});

	async function onSubmit(section, values) {
		$$invalidate(1, isEdit[section] = false, isEdit);
		console.log(values);
	}

	function onCancel(section) {
		$$invalidate(1, isEdit[section] = false, isEdit);
	}

	function onToggleMode() {
		$$invalidate(0, isEditMode = !isEditMode);

		if (!isEditMode) {
			$$invalidate(1, isEdit = {
				topInfo: false,
				description: false,
				about: false,
				documents: false,
				videos: false,
				contacts: false,
				map: false
			});
		}
	}

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<U5Bidu5D> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("U5Bidu5D", $$slots, []);
	const click_handler = () => $$invalidate(1, isEdit.topInfo = !isEdit.topInfo, isEdit);
	const click_handler_1 = () => $$invalidate(1, isEdit.description = !isEdit.description, isEdit);
	const click_handler_2 = () => $$invalidate(1, isEdit.about = !isEdit.about, isEdit);
	const click_handler_3 = () => $$invalidate(1, isEdit.documents = !isEdit.documents, isEdit);
	const click_handler_4 = () => $$invalidate(1, isEdit.videos = !isEdit.videos, isEdit);
	const click_handler_5 = () => $$invalidate(1, isEdit.contacts = !isEdit.contacts, isEdit);
	const click_handler_6 = () => $$invalidate(1, isEdit.map = !isEdit.map, isEdit);

	$$self.$capture_state = () => ({
		stores: stores$1,
		onMount,
		API,
		delay,
		safeGet,
		Br,
		Icon,
		Footer,
		Button,
		EditArea,
		LazyToggle,
		Share,
		Trust,
		Comments: Comments_1,
		FundList,
		Donators,
		LastNews,
		InteractionIndicators,
		MapView: Map,
		AboutView: About,
		VideosView: Videos_1,
		ContactsView: Contacts,
		DocumentsView: Documents,
		DescriptionView: Description$1,
		OrganizationButtonView: OrganizationButton_1,
		MapEdit: Map$1,
		AboutEdit: About$1,
		VideosEdit: Videos$1,
		ContactsEdit: Contacts$1,
		DocumentsEdit: Documents$1,
		DescriptionEdit: Description$2,
		OrganizationButtonEdit: OrganizationButton$1,
		page,
		organizationId,
		isEditMode,
		isEdit,
		organization,
		comments,
		funds,
		onSubmit,
		onCancel,
		onToggleMode,
		$page,
		organizationBlock,
		carouselTop,
		descriptionShort,
		animalFunds,
		othersFunds,
		iconsLine,
		descriptionBlock,
		contacts,
		donators,
		lastNews,
		documents,
		media,
		location,
		commentsData
	});

	$$self.$inject_state = $$props => {
		if ("organizationId" in $$props) organizationId = $$props.organizationId;
		if ("isEditMode" in $$props) $$invalidate(0, isEditMode = $$props.isEditMode);
		if ("isEdit" in $$props) $$invalidate(1, isEdit = $$props.isEdit);
		if ("organization" in $$props) $$invalidate(2, organization = $$props.organization);
		if ("comments" in $$props) $$invalidate(27, comments = $$props.comments);
		if ("funds" in $$props) $$invalidate(28, funds = $$props.funds);
		if ("organizationBlock" in $$props) $$invalidate(3, organizationBlock = $$props.organizationBlock);
		if ("carouselTop" in $$props) $$invalidate(4, carouselTop = $$props.carouselTop);
		if ("descriptionShort" in $$props) $$invalidate(5, descriptionShort = $$props.descriptionShort);
		if ("animalFunds" in $$props) $$invalidate(6, animalFunds = $$props.animalFunds);
		if ("othersFunds" in $$props) $$invalidate(7, othersFunds = $$props.othersFunds);
		if ("iconsLine" in $$props) $$invalidate(8, iconsLine = $$props.iconsLine);
		if ("descriptionBlock" in $$props) descriptionBlock = $$props.descriptionBlock;
		if ("contacts" in $$props) $$invalidate(9, contacts = $$props.contacts);
		if ("donators" in $$props) $$invalidate(10, donators = $$props.donators);
		if ("lastNews" in $$props) $$invalidate(11, lastNews = $$props.lastNews);
		if ("documents" in $$props) $$invalidate(12, documents = $$props.documents);
		if ("media" in $$props) $$invalidate(13, media = $$props.media);
		if ("location" in $$props) $$invalidate(14, location = $$props.location);
		if ("commentsData" in $$props) $$invalidate(15, commentsData = $$props.commentsData);
	};

	let organizationBlock;
	let carouselTop;
	let descriptionShort;
	let animalFunds;
	let othersFunds;
	let iconsLine;
	let descriptionBlock;
	let contacts;
	let donators;
	let lastNews;
	let documents;
	let media;
	let location;
	let commentsData;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*organization*/ 4) {
			 $$invalidate(3, organizationBlock = {
				id: organization.id,
				name: organization.name,
				avatar: organization.avatar,
				avatarBig: organization.avatarBig
			});
		}

		if ($$self.$$.dirty[0] & /*organization*/ 4) {
			 $$invalidate(4, carouselTop = (organization.avatars || []).map((a, i) => ({
				src: a.src,
				srcBig: a.src2x,
				alt: a.title
			})));
		}

		if ($$self.$$.dirty[0] & /*organization*/ 4) {
			 $$invalidate(5, descriptionShort = {
				name: organization.name || null,
				subtitle: organization.subtitle || null,
				description: organization.description || null
			});
		}

		if ($$self.$$.dirty[0] & /*funds*/ 268435456) {
			 $$invalidate(6, animalFunds = safeGet(() => funds.filter(f => f.type === "animal").reduce((acc, f) => acc.concat(f, f, f), []).map(f => ({
				id: f.id,
				src: f.avatars[0].src,
				type: f.type,
				title: f.title,
				total: f.need_sum,
				current: f.current_sum,
				currency: f.currency,
				city: f.location.city
			}))));
		}

		if ($$self.$$.dirty[0] & /*funds*/ 268435456) {
			 $$invalidate(7, othersFunds = safeGet(() => funds.filter(f => f.type === "animal").reduce((acc, f) => acc.concat(f, f, f), []).map(f => ({
				id: f.id,
				src: f.avatars[0].src,
				type: f.type,
				title: f.title,
				total: f.need_sum,
				current: f.current_sum,
				currency: f.currency,
				city: f.location.city
			}))));
		}

		if ($$self.$$.dirty[0] & /*organization*/ 4) {
			 $$invalidate(8, iconsLine = {
				likes: organization.likes,
				isLiked: organization.is_liked,
				views: organization.views
			});
		}

		if ($$self.$$.dirty[0] & /*organization*/ 4) {
			 descriptionBlock = {
				title: organization.title,
				text: organization.description
			};
		}

		if ($$self.$$.dirty[0] & /*organization*/ 4) {
			 $$invalidate(9, contacts = safeGet(
				() => organization.contacts.map(c => ({
					title: c.title,
					href: c.value,
					type: c.type
				})),
				[].true
			));
		}

		if ($$self.$$.dirty[0] & /*organization*/ 4) {
			 $$invalidate(10, donators = safeGet(() => organization.donators.map(d => ({
				id: d.id,
				src: d.avatar,
				title: `${d.currency} ${d.amount}`,
				subtitle: d.name,
				checked: d.checked
			}))));
		}

		if ($$self.$$.dirty[0] & /*organization*/ 4) {
			 $$invalidate(11, lastNews = safeGet(() => organization.news.map(n => ({
				id: n.id,
				src: n.src,
				likes: n.likes,
				isLiked: n.is_liked,
				title: n.title,
				subtitle: n.subtitle,
				created_at: n.created_at
			})).slice(0, 3)));
		}

		if ($$self.$$.dirty[0] & /*organization*/ 4) {
			 $$invalidate(12, documents = safeGet(() => organization.documents.map(d => ({
				id: d.id,
				alt: d.title,
				src: d.src,
				src2x: d.src2x
			}))));
		}

		if ($$self.$$.dirty[0] & /*organization*/ 4) {
			 $$invalidate(13, media = safeGet(
				() => organization.media.map(d => ({
					id: d.id,
					alt: d.title,
					src: d.src,
					srcBig: d.src2x,
					description: d.description
				})),
				[],
				true
			));
		}

		if ($$self.$$.dirty[0] & /*organization*/ 4) {
			 $$invalidate(14, location = {
				map: safeGet(() => organization.location.map),
				virtual_tour: safeGet(() => organization.location.virtual_tour)
			});
		}

		if ($$self.$$.dirty[0] & /*comments*/ 134217728) {
			 $$invalidate(15, commentsData = {
				comments: safeGet(() => comments.map(c => ({
					likes: c.likes,
					avatar: c["author.avatar"],
					author: c["author.name"],
					comment: c.comment,
					checked: c.checked,
					reply_to: c.reply_to,
					created_at: c.created_at
				})))
			});
		}
	};

	return [
		isEditMode,
		isEdit,
		organization,
		organizationBlock,
		carouselTop,
		descriptionShort,
		animalFunds,
		othersFunds,
		iconsLine,
		contacts,
		donators,
		lastNews,
		documents,
		media,
		location,
		commentsData,
		page,
		onSubmit,
		onCancel,
		onToggleMode,
		click_handler,
		click_handler_1,
		click_handler_2,
		click_handler_3,
		click_handler_4,
		click_handler_5,
		click_handler_6
	];
}

class U5Bidu5D extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$u, create_fragment$u, safe_not_equal, {}, [-1, -1]);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "U5Bidu5D",
			options,
			id: create_fragment$u.name
		});
	}
}

export default U5Bidu5D;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiW2lkXS43ZmJjOGFjMC5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL3JvdXRlcy9vcmdhbml6YXRpb25zL2NvbXBvbmVudHMvX1RydXN0LnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9yb3V0ZXMvb3JnYW5pemF0aW9ucy9jb21wb25lbnRzL19WaWRlb3Muc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy9vcmdhbml6YXRpb25zL2NvbXBvbmVudHMvX1dlT25NYXAuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy9vcmdhbml6YXRpb25zL2NvbXBvbmVudHMvX0NvbW1lbnRzLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9yb3V0ZXMvb3JnYW5pemF0aW9ucy9jb21wb25lbnRzL19Eb25hdG9ycy5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvcm91dGVzL29yZ2FuaXphdGlvbnMvY29tcG9uZW50cy9fRnVuZExpc3Quc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy9vcmdhbml6YXRpb25zL2NvbXBvbmVudHMvX1RvcENhcm91c2VsLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9yb3V0ZXMvb3JnYW5pemF0aW9ucy9jb21wb25lbnRzL19EZXNjcmlwdGlvblNob3J0LnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9yb3V0ZXMvb3JnYW5pemF0aW9ucy9jb21wb25lbnRzL19JbnRlcmFjdGlvbkluZGljYXRvcnMuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy9vcmdhbml6YXRpb25zL2NvbXBvbmVudHMvX0xhc3ROZXdzLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9yb3V0ZXMvb3JnYW5pemF0aW9ucy9jb21wb25lbnRzL19EZXNjcmlwdGlvbi5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvcm91dGVzL29yZ2FuaXphdGlvbnMvY29tcG9uZW50cy9fVmlydHVhbFRvdXIuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy9vcmdhbml6YXRpb25zL2NvbXBvbmVudHMvX0NlcnRpZmljYXRlcy5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvcm91dGVzL29yZ2FuaXphdGlvbnMvY29tcG9uZW50cy9fQ29udGFjdHNDYXJkLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9yb3V0ZXMvb3JnYW5pemF0aW9ucy9jb21wb25lbnRzL19Pcmdhbml6YXRpb25CdXR0b24uc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy9vcmdhbml6YXRpb25zL3ZpZXcvX01hcC5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvcm91dGVzL29yZ2FuaXphdGlvbnMvdmlldy9fQWJvdXQuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy9vcmdhbml6YXRpb25zL3ZpZXcvX1ZpZGVvcy5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvcm91dGVzL29yZ2FuaXphdGlvbnMvdmlldy9fQ29udGFjdHMuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy9vcmdhbml6YXRpb25zL3ZpZXcvX0RvY3VtZW50cy5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvcm91dGVzL29yZ2FuaXphdGlvbnMvdmlldy9fRGVzY3JpcHRpb24uc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy9vcmdhbml6YXRpb25zL3ZpZXcvX09yZ2FuaXphdGlvbkJ1dHRvbi5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvcm91dGVzL29yZ2FuaXphdGlvbnMvZWRpdC9fTWFwLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9yb3V0ZXMvb3JnYW5pemF0aW9ucy9lZGl0L19BYm91dC5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvcm91dGVzL29yZ2FuaXphdGlvbnMvZWRpdC9fVmlkZW9zLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9yb3V0ZXMvb3JnYW5pemF0aW9ucy9lZGl0L19Db250YWN0cy5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvcm91dGVzL29yZ2FuaXphdGlvbnMvZWRpdC9fRG9jdW1lbnRzLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9yb3V0ZXMvb3JnYW5pemF0aW9ucy9lZGl0L19EZXNjcmlwdGlvbi5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvcm91dGVzL29yZ2FuaXphdGlvbnMvZWRpdC9fT3JnYW5pemF0aW9uQnV0dG9uLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9yb3V0ZXMvb3JnYW5pemF0aW9ucy9baWRdLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0PlxuICAgIGltcG9ydCB7IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJ3N2ZWx0ZSdcbiAgICBpbXBvcnQgeyBUcnVzdEJ1dHRvbiwgQnIgfSBmcm9tICdAY29tcG9uZW50cydcblxuICAgIGNvbnN0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKClcblxuICAgIGV4cG9ydCBsZXQgYWN0aXZlID0gZmFsc2Vcbjwvc2NyaXB0PlxuXG48c2VjdGlvbiBjbGFzcz1cImZsZXggZmxleC1jb2x1bW4gZmxleC1hbGlnbi1jZW50ZXIgZmxleC1qdXN0aWZ5LWNlbnRlclwiPlxuICAgIDxkaXYgc3R5bGU9XCJ3aWR0aDogMTAwcHg7IG1heC13aWR0aDogMTAwJVwiPlxuICAgICAgICA8VHJ1c3RCdXR0b24gaXNBY3RpdmU9e2FjdGl2ZX0gb246Y2xpY2s9e2UgPT4gZGlzcGF0Y2goJ2NsaWNrJywgIWFjdGl2ZSl9Lz5cbiAgICA8L2Rpdj5cbiAgICA8QnIgc2l6ZT1cIjEwXCIvPlxuICAgIDxoMj7QryDQtNC+0LLRltGA0Y/RjjwvaDI+XG48L3NlY3Rpb24+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IEJyLCBDYXJvdXNlbCB9IGZyb20gJ0Bjb21wb25lbnRzJ1xuXG4gICAgZXhwb3J0IGxldCBpdGVtc1xuPC9zY3JpcHQ+XG5cbjxoMT7QktGW0LTQtdC+INC/0YDQviDQvdCw0YE8L2gxPlxuPEJyIHNpemU9XCIyMFwiIC8+XG48c2VjdGlvbiBjbGFzcz1cImZsZXhcIiBzdHlsZT1cImhlaWdodDogMjQwcHhcIj5cbiAgICA8Q2Fyb3VzZWwgaXRlbXM9e2l0ZW1zfSAvPlxuPC9zZWN0aW9uPiIsIjxzY3JpcHQ+XG4gIGltcG9ydCB7IEJyIH0gZnJvbSBcIkBjb21wb25lbnRzXCI7XG4gIFxuICBleHBvcnQgbGV0IHNyY1xuPC9zY3JpcHQ+XG5cbjxoMT7QnNC4INC90LAg0LrQsNGA0YLRljwvaDE+XG48QnIgc2l6ZT1cIjIwXCIgLz5cbjxkaXYgY2xhc3M9XCJmdWxsLWNvbnRhaW5lclwiPlxuICA8aWZyYW1lXG4gICAge3NyY31cbiAgICB0aXRsZT1cItCa0LDRgNGC0LBcIlxuICAgIHdpZHRoPVwiMTAwJVwiXG4gICAgaGVpZ2h0PVwiNDUwXCJcbiAgICBmcmFtZWJvcmRlcj1cIjBcIlxuICAgIHN0eWxlPVwiYm9yZGVyOjA7XCJcbiAgICBhbGxvd2Z1bGxzY3JlZW49XCJcIlxuICAgIGFyaWEtaGlkZGVuPVwiZmFsc2VcIlxuICAgIHRhYmluZGV4PVwiMFwiID48L2lmcmFtZT5cbjwvZGl2PlxuXG48c3R5bGU+XG4gICAgZGl2IHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSh2YXIoLS10aGVtZS1iZy1jb2xvci1vcHBvc2l0ZSksIC4wNCk7XG4gICAgfVxuPC9zdHlsZT5cbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCB7IEJyLCBDb21tZW50cyB9IGZyb20gXCJAY29tcG9uZW50c1wiO1xuXG4gIGV4cG9ydCBsZXQgaXRlbXNcbjwvc2NyaXB0PlxuXG48aDE+0JrQvtC80LXQvdGC0LDRgNGWPC9oMT5cbjxCciBzaXplPVwiNVwiIC8+XG48ZGl2IGNsYXNzPVwiZnVsbC1jb250YWluZXJcIj5cbiAgPENvbW1lbnRzIHtpdGVtc30vPlxuPC9kaXY+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IEJyLCBEb25hdG9yc0xpc3QgfSBmcm9tICdAY29tcG9uZW50cydcblxuICAgIGV4cG9ydCBsZXQgaXRlbXNcbjwvc2NyaXB0PlxuXG48aDE+0J3QsNGI0ZYg0L/RltC60LvRg9Cy0LDQu9GM0L3QuNC60Lg8L2gxPlxuPEJyIHNpemU9XCIyMFwiLz5cbjxkaXYgY2xhc3M9XCJmdWxsLWNvbnRhaW5lclwiPlxuICAgIDxEb25hdG9yc0xpc3QgaXRlbXM9e2l0ZW1zfS8+XG48L2Rpdj4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IEJyLCBGdW5kQ2FyZHMsIE1vZGFsIH0gZnJvbSAnQGNvbXBvbmVudHMnXG5cbiAgICBleHBvcnQgbGV0IHRpdGxlXG4gICAgZXhwb3J0IGxldCBpdGVtc1xuPC9zY3JpcHQ+XG5cbjxoMT57dGl0bGV9PC9oMT5cbjxCciBzaXplPVwiNVwiIC8+XG48ZGl2IGNsYXNzPVwiZnVsbC1jb250YWluZXJcIj5cbiAgICA8RnVuZENhcmRzIHtpdGVtc30vPlxuPC9kaXY+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IENhcm91c2VsIH0gZnJvbSAnQGNvbXBvbmVudHMnXG5cbiAgICBleHBvcnQgbGV0IGl0ZW1zID0gW11cbjwvc2NyaXB0PlxuXG48c2VjdGlvbiBjbGFzcz1cImZsZXhcIiBzdHlsZT1cImhlaWdodDogMjQwcHhcIj5cbiAgICA8Q2Fyb3VzZWwge2l0ZW1zfSBkb3RzQmVsb3c9e2ZhbHNlfS8+XG48L3NlY3Rpb24+IiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBCciwgTG9hZGVyIH0gZnJvbSAnQGNvbXBvbmVudHMnXG5cbiAgICBleHBvcnQgbGV0IHRpdGxlXG4gICAgZXhwb3J0IGxldCB0ZXh0XG48L3NjcmlwdD5cblxueyNpZiB0aXRsZX1cbiAgICA8aDI+e3RpdGxlfTwvaDI+XG57OmVsc2V9XG4gICAgPGRpdiBzdHlsZT1cIndpZHRoOiA4NSVcIj48TG9hZGVyIHR5cGU9XCJoMlwiLz4gIDwvZGl2Plxuey9pZn1cbjxCciBzaXplPVwiMTBcIiAvPlxuXG57I2lmIHRleHR9XG48cHJlIGNsYXNzPVwiZm9udC13LTMwMFwiPlxuICAgIHt0ZXh0fVxuPC9wcmU+XG57OmVsc2V9XG4gICAgPExvYWRlciB0eXBlPVwicHJlXCIvPiAgXG4gICAgPExvYWRlciB0eXBlPVwicHJlXCIvPiAgXG4gICAgPExvYWRlciB0eXBlPVwicHJlXCIvPiAgXG4gICAgPGRpdiBzdHlsZT1cIndpZHRoOiA2MCVcIj48TG9hZGVyIHR5cGU9XCJwcmVcIi8+PC9kaXY+XG57L2lmfSIsIjxzY3JpcHQ+XG4gIGltcG9ydCB7IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciB9IGZyb20gXCJzdmVsdGVcIjtcbiAgaW1wb3J0IHsgSWNvbiwgQnV0dG9uLCBMb2FkZXIgfSBmcm9tIFwiQGNvbXBvbmVudHNcIjtcblxuICBjb25zdCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpXG5cbiAgZXhwb3J0IGxldCBsaWtlcyA9IG51bGw7XG4gIGV4cG9ydCBsZXQgdmlld3MgPSBudWxsO1xuICBleHBvcnQgbGV0IGlzTGlrZWQgPSBmYWxzZTtcbjwvc2NyaXB0PlxuXG48cCBjbGFzcz1cImNvbnRhaW5lciBmbGV4IGZsZXgtanVzdGlmeS1iZXR3ZWVuIGZsZXgtYWxpZ24tY2VudGVyXCI+XG4gIDxCdXR0b24gXG4gICAgY2xhc3M9XCJmbGV4IGZsZXgtYWxpZ24tY2VudGVyXCIgXG4gICAgYXV0b1xuICAgIHNpemU9XCJzbWFsbFwiXG4gICAgc3R5bGU9e2BvcGFjaXR5OiAke2lzTGlrZWQgPyAxIDogLjV9YH1cbiAgICBvbjpjbGljaz17KCkgPT4gZGlzcGF0Y2goJ2NsaWNrJywgIWlzTGlrZWQpfVxuPlxuICAgIDxJY29uIGlzPVwiZGFuZ2VyXCIgdHlwZT1cImhlYXJ0XCIgc2l6ZT1cIm1lZGl1bVwiIC8+XG4gICAgPHMgLz5cbiAgICA8cyAvPlxuICAgIHsjaWYgbGlrZXMgIT09IG51bGx9XG4gICAgICA8c3BhbiBjbGFzcz1cImZvbnQtc2Vjb25kYXJ5IGZvbnQtdy02MDAgaDNcIj57bGlrZXN9PC9zcGFuPlxuICAgIHs6ZWxzZX1cbiAgICAgIDxzcGFuIGNsYXNzPVwiZm9udC1zZWNvbmRhcnkgZm9udC13LTYwMCBoMyByZWxhdGl2ZVwiPlxuICAgICAgICA8c3BhbiBzdHlsZT1cInZpc2liaWxpdHk6IGhpZGRlblwiPjE5OTwvc3Bhbj5cbiAgICAgICAgPExvYWRlciB0eXBlPVwiaDNcIiBhYnNvbHV0ZS8+XG4gICAgICA8L3NwYW4+ICBcbiAgICB7L2lmfVxuICA8L0J1dHRvbj5cblxuICA8c3BhbiBjbGFzcz1cImZsZXhcIj5cbiAgICA8QnV0dG9uIGNsYXNzPVwiZmxleCBmbGV4LWFsaWduLWNlbnRlclwiIGF1dG8gc2l6ZT1cInNtYWxsXCI+XG4gICAgICA8SWNvbiB0eXBlPVwic2hhcmVcIiBzaXplPVwibWVkaXVtXCIgY2xhc3M9XCJ0aGVtZS1zdmctZmlsbFwiIC8+XG4gICAgICA8cyAvPlxuICAgICAgPHMgLz5cbiAgICAgIDxoMyBjbGFzcz1cImZvbnQtdy02MDBcIj7Qn9C+0LTRltC70LjRgtC40YHRjDwvaDM+XG4gICAgPC9CdXR0b24+XG4gIDwvc3Bhbj5cbiAgPHNwYW4gY2xhc3M9XCJmbGV4IGZsZXgtYWxpZ24tY2VudGVyXCI+XG4gICAgPEljb24gdHlwZT1cImV5ZVwiIHNpemU9XCJtZWRpdW1cIiBjbGFzcz1cInRoZW1lLXN2Zy1maWxsXCIgLz5cbiAgICA8cyAvPlxuICAgIDxzIC8+XG4gICAgeyNpZiB2aWV3cyAhPT0gbnVsbH1cbiAgICAgIDxzcGFuIGNsYXNzPVwiZm9udC1zZWNvbmRhcnkgZm9udC13LTYwMCBoM1wiPnt2aWV3c308L3NwYW4+XG4gICAgezplbHNlfVxuICAgICAgPHNwYW4gY2xhc3M9XCJmb250LXNlY29uZGFyeSBmb250LXctNjAwIGgzIHJlbGF0aXZlXCI+XG4gICAgICAgIDxzcGFuIHN0eWxlPVwidmlzaWJpbGl0eTogaGlkZGVuXCI+MTk5PC9zcGFuPlxuICAgICAgICA8TG9hZGVyIHR5cGU9XCJoM1wiIGFic29sdXRlLz5cbiAgICAgIDwvc3Bhbj4gIFxuICAgIHsvaWZ9XG4gIDwvc3Bhbj5cbjwvcD5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgb25Nb3VudCB9IGZyb20gJ3N2ZWx0ZSdcbiAgICBpbXBvcnQgeyBtb2RhbHMgfSBmcm9tICdAc3RvcmUnXG4gICAgaW1wb3J0IHsgYm9keVNjcm9sbCwgc2FmZUdldCB9IGZyb20gJ0B1dGlscydcbiAgICBpbXBvcnQgeyBCciwgTmV3c0xpc3QsIE1vZGFsLCBGYW5jeUJveCwgQ2Fyb3VzZWwsIExvYWRlciB9IGZyb20gJ0Bjb21wb25lbnRzJ1xuICAgIGltcG9ydCBUb3BDYXJvdXNlbCBmcm9tICcuL19Ub3BDYXJvdXNlbC5zdmVsdGUnXG4gICAgaW1wb3J0IFRydXN0IGZyb20gJy4vX1RydXN0LnN2ZWx0ZSdcbiAgICBpbXBvcnQgRGVzY3JpcHRpb25TaG9ydCBmcm9tICcuL19EZXNjcmlwdGlvblNob3J0LnN2ZWx0ZSdcbiAgICBpbXBvcnQgSW50ZXJhY3Rpb25JbmRpY2F0b3JzIGZyb20gJy4vX0ludGVyYWN0aW9uSW5kaWNhdG9ycy5zdmVsdGUnXG4gICAgXG4gICAgZXhwb3J0IGxldCBpdGVtc1xuICAgIGV4cG9ydCBsZXQgY2Fyb3VzZWwgPSBbXVxuICAgIGV4cG9ydCBsZXQgaWNvbnNMaW5lID0ge31cbiAgICBleHBvcnQgbGV0IG9yZ2FuaXphdGlvbiA9IHt9XG4gICAgZXhwb3J0IGxldCBkZXNjcmlwdGlvblNob3J0ID0ge31cblxuICAgIGZ1bmN0aW9uIG9uQ2xpY2sob3BlbiwgZSkge1xuICAgICAgICBtb2RhbHMudXBkYXRlKHMgPT4gKHsgLi4ucywgWydtb2RhbC1sYXN0LW5ld3MnXTogeyBvcGVuLCBpZDogc2FmZUdldCgoKSA9PiBlLmRldGFpbC5pdGVtLmlkKSB9IH0pKVxuICAgIH1cbjwvc2NyaXB0PlxuXG48aDE+0J7RgdGC0LDQvdC90ZYg0L3QvtCy0LjQvdC4PC9oMT5cbjxCciBzaXplPVwiMjBcIiAvPlxuPE5ld3NMaXN0IHtpdGVtc30gb246Y2xpY2s9e29uQ2xpY2suYmluZChudWxsLCB0cnVlKX0vPlxuXG48TW9kYWwgaWQ9XCJsYXN0LW5ld3NcIiBzaXplPVwiZnVsbFwiIHN3aXBlPVwiYWxsXCI+XG4gICAgPHNlY3Rpb24gY2xhc3M9XCJjb250YWluZXIgZmxleCBmbGV4LWNvbHVtbiByZWxhdGl2ZVwiPlxuICAgICAgICA8QnIvPlxuXG4gICAgICAgIHsjaWYgZGVzY3JpcHRpb25TaG9ydC5uYW1lICE9PSBudWxsfVxuICAgICAgICAgICAgPGgxPnsgZGVzY3JpcHRpb25TaG9ydC5uYW1lIH08L2gxPlxuICAgICAgICB7OmVsc2V9XG4gICAgICAgICAgICA8TG9hZGVyIHR5cGU9XCJoMVwiLz5cbiAgICAgICAgey9pZn1cbiAgICAgICAgPEJyIHNpemU9XCI1XCIvPlxuICAgICAgICB7I2lmIGRlc2NyaXB0aW9uU2hvcnQubmFtZSAhPT0gbnVsbH1cbiAgICAgICAgICAgIDxwPnsgZGVzY3JpcHRpb25TaG9ydC5uYW1lIH08L3A+XG4gICAgICAgIHs6ZWxzZX1cbiAgICAgICAgICAgIDxkaXYgc3R5bGU9XCJ3aWR0aDogNDAlXCI+PExvYWRlciB0eXBlPVwicFwiLz48L2Rpdj5cbiAgICAgICAgey9pZn1cbiAgICAgICAgPEJyIHNpemU9XCIyNVwiLz5cbiAgICAgICAgXG4gICAgICAgIDxzZWN0aW9uIGNsYXNzPVwiZmxleFwiIHN0eWxlPVwiaGVpZ2h0OiAyNDBweFwiPlxuICAgICAgICAgICAgPENhcm91c2VsIGl0ZW1zPXtjYXJvdXNlbH0gc3RvcFByb3BhZ2F0aW9uPXt0cnVlfS8+XG4gICAgICAgIDwvc2VjdGlvbj5cblxuICAgICAgICA8QnIgc2l6ZT1cIjI1XCIvPlxuICAgICAgICA8RGVzY3JpcHRpb25TaG9ydCB0ZXh0PXtkZXNjcmlwdGlvblNob3J0LnRleHR9IHRpdGxlPXtkZXNjcmlwdGlvblNob3J0Lm5hbWV9Lz5cbiAgICAgICAgPEJyIHNpemU9XCIxMFwiIC8+XG5cbiAgICAgICAgPEludGVyYWN0aW9uSW5kaWNhdG9ycyBsaWtlcz17aWNvbnNMaW5lLmxpa2VzfSB2aWV3cz17aWNvbnNMaW5lLnZpZXdzfSBpc0xpa2VkPXtvcmdhbml6YXRpb24uaXNMaWtlZH0vPlxuICAgICAgICA8QnIgc2l6ZT1cIjUwXCIgLz5cblxuICAgICAgICA8VHJ1c3QgYWN0aXZlPXtvcmdhbml6YXRpb24uaXNMaWtlZH0vPlxuXG4gICAgICAgIDxCci8+XG4gICAgPC9zZWN0aW9uPlxuPC9Nb2RhbD5cblxuPHN0eWxlPlxuPC9zdHlsZT4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IEJyLCBMb2FkZXIgfSBmcm9tICdAY29tcG9uZW50cydcblxuICAgIGV4cG9ydCBsZXQgdGl0bGUgPSBudWxsXG4gICAgZXhwb3J0IGxldCB0ZXh0ID0gbnVsbFxuPC9zY3JpcHQ+XG5cbnsjaWYgdGl0bGUgIT09IG51bGx9XG4gICAgPGgxPnt0aXRsZX08L2gxPlxuezplbHNlfVxuICAgIDxkaXYgc3R5bGU9XCJ3aWR0aDogODUlXCI+PExvYWRlciB0eXBlPVwiaDFcIi8+ICA8L2Rpdj5cbnsvaWZ9XG48QnIgc2l6ZT1cIjEwXCIgLz5cblxueyNpZiB0ZXh0ICE9PSBudWxsfVxuPHByZSBjbGFzcz1cImZvbnQtdy0zMDBcIj5cbiAgICB7dGV4dH1cbjwvcHJlPlxuezplbHNlfVxuICAgIDxMb2FkZXIgdHlwZT1cInByZVwiLz4gIFxuICAgIDxMb2FkZXIgdHlwZT1cInByZVwiLz4gIFxuICAgIDxMb2FkZXIgdHlwZT1cInByZVwiLz4gIFxuICAgIDxMb2FkZXIgdHlwZT1cInByZVwiLz4gIFxuICAgIDxMb2FkZXIgdHlwZT1cInByZVwiLz4gIFxuICAgIDxkaXYgc3R5bGU9XCJ3aWR0aDogNjAlXCI+PExvYWRlciB0eXBlPVwicHJlXCIvPjwvZGl2Plxuey9pZn0iLCI8c2NyaXB0PlxuICBpbXBvcnQgeyBCciB9IGZyb20gXCJAY29tcG9uZW50c1wiO1xuXG4gIGV4cG9ydCBsZXQgc3JjXG48L3NjcmlwdD5cblxuPGgxPjNEIC0g0KLRg9GAIDM2MMKwPC9oMT5cbjxCciBzaXplPVwiMjBcIiAvPlxuPGRpdiBjbGFzcz1cImZ1bGwtY29udGFpbmVyXCI+XG4gIDxpZnJhbWVcbiAgICB7c3JjfVxuICAgIHRpdGxlPVwiMzYwINGC0YPRgFwiXG4gICAgd2lkdGg9XCIxMDAlXCJcbiAgICBoZWlnaHQ9XCI0NTBcIlxuICAgIGZyYW1lYm9yZGVyPVwiMFwiXG4gICAgc3R5bGU9XCJib3JkZXI6MDtcIlxuICAgIGFsbG93ZnVsbHNjcmVlbj1cIlwiXG4gICAgYXJpYS1oaWRkZW49XCJmYWxzZVwiXG4gICAgdGFiaW5kZXg9XCIwXCIgPjwvaWZyYW1lPlxuPC9kaXY+XG5cbjxzdHlsZT5cbiAgICBkaXYge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKHZhcigtLXRoZW1lLWJnLWNvbG9yLW9wcG9zaXRlKSwgLjA0KTtcbiAgICB9XG48L3N0eWxlPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBCciwgRG9jdW1lbnRzIH0gZnJvbSAnQGNvbXBvbmVudHMnXG5cbiAgICBleHBvcnQgbGV0IGl0ZW1zIFxuPC9zY3JpcHQ+XG5cbjxoMT7QodC10YDRgtC40YTRltC60LDRgtC4PC9oMT5cbjxCciBzaXplPVwiNVwiIC8+XG48ZGl2IGNsYXNzPVwiZnVsbC1jb250YWluZXJcIj5cbiAgICA8RG9jdW1lbnRzIGl0ZW1zPXtpdGVtc30vPlxuPC9kaXY+IiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBCciwgQ2FyZCwgSWNvbiwgQXZhdGFyLCBGYW5jeUJveCwgTG9hZGVyLCBTb2NpYWxzWCwgU29jaWFsc1kgfSBmcm9tICdAY29tcG9uZW50cydcblxuICAgIGV4cG9ydCBsZXQgaXRlbXMgPSBudWxsXG4gICAgZXhwb3J0IGxldCBvcmdOYW1lID0gbnVsbFxuICAgIGV4cG9ydCBsZXQgYXZhdGFyID0gbnVsbFxuICAgIGV4cG9ydCBsZXQgYXZhdGFyQmlnID0gbnVsbFxuXG4gICAgY29uc3QgdG9wID0gWyd0ZWxlZ3JhbScsICdmYWNlYm9vaycsICd2aWJlciddXG5cbiAgICAkOiB0b3BJdGVtcyA9IGl0ZW1zID09PSBudWxsID8gdW5kZWZpbmVkIDogaXRlbXMuZmlsdGVyKGkgPT4gIXRvcC5pbmNsdWRlcyhpLnR5cGUpKVxuICAgICQ6IGJvdHRvbUl0ZW1zID0gaXRlbXMgPT09IG51bGwgPyB1bmRlZmluZWQgOiBpdGVtcy5maWx0ZXIoaSA9PiB0b3AuaW5jbHVkZXMoaS50eXBlKSlcbjwvc2NyaXB0PlxuXG48Q2FyZD5cbiAgICA8c2VjdGlvbiBzdHlsZT1cInBhZGRpbmc6IDAgMjBweFwiPlxuICAgICAgICA8QnIgc2l6ZT1cIjMwXCIgLz5cblxuICAgICAgICA8ZGl2IGNsYXNzPVwiZmxleCBmbGV4LWNvbHVtbiBmbGV4LWFsaWduLWNlbnRlclwiPlxuICAgICAgICAgICAgXG4gICAgICAgICAgICA8c3Bhbj5cbiAgICAgICAgICAgICAgICA8RmFuY3lCb3ggY2xhc3M9XCJmbGV4LWp1c3RpZnktY2VudGVyXCI+XG4gICAgICAgICAgICAgICAgICAgIDxBdmF0YXIgc2l6ZT1cImJpZ1wiIHNyYz17YXZhdGFyfSBhbHQ9XCLQntGA0LPQsNC90ZbQt9Cw0YbRltGPXCIvPlxuICAgICAgICAgICAgICAgICAgICA8c2VjdGlvbiBzbG90PVwiYm94XCIgY2xhc3M9XCJmbGV4IGZ1bGwtd2lkdGggZnVsbC1oZWlnaHRcIiBzdHlsZT1cImhlaWdodDogMTAwdndcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmbGV4IGZsZXgtc2VsZi1zdHJldGNoIGZsZXgtMSBvdmVyZmxvdy1oaWRkZW4gZmxleC1qdXN0aWZ5LXN0cmV0Y2hcIiBzdHlsZT1cInBhZGRpbmc6IHZhcigtLXNjcmVlbi1wYWRkaW5nKSAwXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPEF2YXRhciBzcmM9e2F2YXRhcn0gc3JjQmlnPXthdmF0YXJCaWd9IGFsdD1cImF2YVwiLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8L3NlY3Rpb24+XG4gICAgICAgICAgICAgICAgPC9GYW5jeUJveD5cbiAgICAgICAgICAgIDwvc3Bhbj5cblxuICAgICAgICAgICAgPEJyIHNpemU9XCIyMFwiIC8+XG4gICAgICAgICAgICA8aDI+0J3QsNGI0ZYg0LrQvtC90YLQsNC60YLQuDwvaDI+XG4gICAgICAgICAgICA8QnIgc2l6ZT1cIjVcIiAvPlxuXG4gICAgICAgICAgICB7I2lmIG9yZ05hbWUgIT09IG51bGx9XG4gICAgICAgICAgICAgICAgPHAgY2xhc3M9XCJoMyBmb250LXNlY29uZGFyeSBmb250LXctNTAwXCIgc3R5bGU9XCJvcGFjaXR5OiAuN1wiPlxuICAgICAgICAgICAgICAgICAgICB7b3JnTmFtZX1cbiAgICAgICAgICAgICAgICA8L3A+XG4gICAgICAgICAgICB7OmVsc2V9XG4gICAgICAgICAgICAgICAgPHAgc3R5bGU9XCJ3aWR0aDogNjAlXCI+XG4gICAgICAgICAgICAgICAgICAgIDxMb2FkZXIgdHlwZT1cImgzXCIvPlxuICAgICAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDxCciBzaXplPVwiMzBcIiAvPlxuXG4gICAgICAgIDxTb2NpYWxzWSBpdGVtcz17dG9wSXRlbXN9IC8+ICAgXG5cbiAgICAgICAgPEJyIHNpemU9XCIzMFwiIC8+XG5cbiAgICAgICAgPFNvY2lhbHNYIGl0ZW1zPXtib3R0b21JdGVtc30gLz5cblxuICAgICAgICA8QnIgc2l6ZT1cIjMwXCIgLz5cbiAgICA8L3NlY3Rpb24+XG48L0NhcmQ+XG5cbjxzdHlsZT5cbjwvc3R5bGU+XG4iLCI8c2NyaXB0PlxuICBpbXBvcnQgeyBQaWN0dXJlLCBCdXR0b24sIExvYWRlciB9IGZyb20gXCJAY29tcG9uZW50c1wiO1xuXG4gIGV4cG9ydCBsZXQgaWQgPSBudWxsXG4gIGV4cG9ydCBsZXQgc3JjID0gbnVsbFxuICBleHBvcnQgbGV0IHRpdGxlID0gbnVsbFxuPC9zY3JpcHQ+XG5cbjxCdXR0b24gcmVsPVwicHJlZmV0Y2hcIiBocmVmPXtpZH0gY2xhc3M9XCJ3aGl0ZVwiPlxuICA8ZGl2IGNsYXNzPVwiZmxleCBmbGV4LWFsaWduLWNlbnRlciBmbGV4LWp1c3RpZnktYmV0d2VlbiBmdWxsLXdpZHRoXCI+XG5cbiAgICA8ZGl2IGNsYXNzPVwiZmxleCBmbGV4LWFsaWduLWNlbnRlclwiPlxuICAgICAgPHMgLz5cbiAgICAgIDxkaXYgY2xhc3M9XCJmbGV4XCIgc3R5bGU9XCJtYXgtd2lkdGg6IDQ1cHg7IGhlaWdodDogNDBweDsgb3ZlcmZsb3c6IGhpZGRlblwiPlxuICAgICAgICA8UGljdHVyZVxuICAgICAgICAgIHtzcmN9XG4gICAgICAgICAgc2l6ZT1cImNvbnRhaW5cIlxuICAgICAgICAgIGFsdD1cItGP0LrQtdGB0Ywg0YTQvtGC0L4g0L7RgNCz0LDQvdGW0LfQsNGG0ZbRl1wiIC8+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxzIC8+XG4gICAgICB7I2lmIHRpdGxlICE9PSBudWxsfVxuICAgICAgICA8cyAvPlxuICAgICAgICA8cyAvPlxuICAgICAgICA8aDM+e3RpdGxlfTwvaDM+XG4gICAgICB7OmVsc2V9XG4gICAgICAgIDxzcGFuPjxMb2FkZXIgdHlwZT1cImgzXCIvPjwvc3Bhbj5cbiAgICAgIHsvaWZ9XG4gICAgPC9kaXY+XG4gICAgXG4gIDwvZGl2PlxuPC9CdXR0b24+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IEJyIH0gZnJvbSAnQGNvbXBvbmVudHMnXG4gICAgaW1wb3J0IHsgY2xhc3NuYW1lcyB9IGZyb20gJ0B1dGlscydcbiAgICBpbXBvcnQgeyBWaXJ0dWFsVG91ciwgV2VPbk1hcCB9IGZyb20gJy4uL2NvbXBvbmVudHMnXG5cbiAgICBleHBvcnQgbGV0IGxvY2F0aW9uXG4gICAgZXhwb3J0IGxldCBwcmV2aWV3XG48L3NjcmlwdD5cblxuPHN0eWxlPlxuICAgIC5wcmV2aWV3IDpnbG9iYWwoLmZ1bGwtY29udGFpbmVyKSB7XG4gICAgICAgIGhlaWdodDogMjAwcHg7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBtYXJnaW46IDA7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IHZhcigtLWJvcmRlci1yYWRpdXMtYmlnKTtcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVaKDApO1xuICAgIH1cblxuICAgIC5wcmV2aWV3IDpnbG9iYWwoaWZyYW1lKSB7XG4gICAgICAgIGhlaWdodDogMTAwJSAhaW1wb3J0YW50O1xuICAgIH1cbjwvc3R5bGU+XG5cbjxzZWN0aW9uIGNsYXNzPXtjbGFzc25hbWVzKHsgcHJldmlldyB9KX0+XG4gICAgPFZpcnR1YWxUb3VyIHNyYz17bG9jYXRpb24udmlydHVhbF90b3VyfS8+XG4gICAgPEJyIHNpemU9e3ByZXZpZXcgPyAyMCA6IDYwfSAvPlxuICAgIDxXZU9uTWFwIHNyYz17bG9jYXRpb24ubWFwfS8+XG48L3NlY3Rpb24+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IERlc2NyaXB0aW9uIH0gZnJvbSAnLi4vY29tcG9uZW50cydcblxuICAgIGV4cG9ydCBsZXQgdGl0bGUgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IHRleHQgPSB1bmRlZmluZWRcbjwvc2NyaXB0PlxuXG48RGVzY3JpcHRpb24ge3RpdGxlfSB7dGV4dH0vPlxuXG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IFZpZGVvcyB9IGZyb20gJy4uL2NvbXBvbmVudHMnXG5cbiAgICBleHBvcnQgbGV0IGl0ZW1zXG48L3NjcmlwdD5cblxuPFZpZGVvcyB7aXRlbXN9Lz5cblxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBDb250YWN0c0NhcmQgfSBmcm9tICcuLi9jb21wb25lbnRzJ1xuXG4gICAgZXhwb3J0IGxldCBjb250YWN0c1xuICAgIGV4cG9ydCBsZXQgb3JnYW5pemF0aW9uXG48L3NjcmlwdD5cblxuPENvbnRhY3RzQ2FyZCBcbiAgICBpdGVtcz17Y29udGFjdHN9XG4gICAgb3JnTmFtZT17b3JnYW5pemF0aW9uLnRpdGxlfVxuICAgIGF2YXRhcj17b3JnYW5pemF0aW9uLmF2YXRhcn1cbiAgICBhdmF0YXJCaWc9e29yZ2FuaXphdGlvbi5hdmF0YXJCaWd9XG4vPlxuXG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IENlcnRpZmljYXRlcyB9IGZyb20gJy4uL2NvbXBvbmVudHMnXG5cbiAgICBleHBvcnQgbGV0IGl0ZW1zXG48L3NjcmlwdD5cblxuPENlcnRpZmljYXRlcyB7aXRlbXN9Lz5cblxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBCciB9IGZyb20gJ0Bjb21wb25lbnRzJ1xuICAgIGltcG9ydCB7IFRvcENhcm91c2VsLCBEZXNjcmlwdGlvblNob3J0IH0gZnJvbSAnLi4vY29tcG9uZW50cydcblxuICAgIGV4cG9ydCBsZXQgdGl0bGUgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IHRleHQgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IGNhcm91c2VsVG9wID0gdW5kZWZpbmVkXG48L3NjcmlwdD5cblxuPFRvcENhcm91c2VsIGl0ZW1zPXtjYXJvdXNlbFRvcH0vPlxuPEJyIHNpemU9XCI2MFwiIC8+XG48RGVzY3JpcHRpb25TaG9ydCB7dGl0bGV9IHt0ZXh0fS8+XG5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgQnIgfSBmcm9tICdAY29tcG9uZW50cydcbiAgICBpbXBvcnQgeyBPcmdhbml6YXRpb25CdXR0b24gfSBmcm9tICcuLi9jb21wb25lbnRzJ1xuXG4gICAgZXhwb3J0IGxldCBvcmdhbml6YXRpb25cbjwvc2NyaXB0PlxuXG48T3JnYW5pemF0aW9uQnV0dG9uIGlkPXtvcmdhbml6YXRpb24uaWR9IHNyYz17b3JnYW5pemF0aW9uLmF2YXRhcn0gdGl0bGU9e29yZ2FuaXphdGlvbi5uYW1lfS8+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJ3N2ZWx0ZSdcbiAgICBpbXBvcnQgeyBFZGl0Q2FyZCwgRm9ybUJ1aWxkZXIgfSBmcm9tICdAY29tcG9uZW50cydcblxuICAgIGV4cG9ydCBsZXQgZGF0YSA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgc3VibWl0ID0gYXN5bmMgKCkgPT4ge31cblxuICAgIGNvbnN0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKClcblxuICAgIGxldCBmb3JtRmllbGRzID0gW1xuICAgICAgICB7XG4gICAgICAgICAgICBsYWJlbDogJ9CQ0LTRgNC10YE6JyxcbiAgICAgICAgICAgIHR5cGU6ICd1cmwnLFxuICAgICAgICAgICAgbmFtZTogJ2xvY2F0aW9uLm1hcCcsXG4gICAgICAgICAgICBtZXRhOiB7XG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6ICdodHRwczovL3d3dy5nb29nbGUuY29tLnVhL21hcHMvcGxhY2UvLi4uJyxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbGFiZWw6ICczRCAtINCi0YPRgDonLFxuICAgICAgICAgICAgdHlwZTogJ3VybCcsXG4gICAgICAgICAgICBuYW1lOiAnbG9jYXRpb24udmlydHVhbF90b3VyJyxcbiAgICAgICAgICAgIG1ldGE6IHtcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogJ2h0dHBzOi8vd3d3Lmdvb2dsZS5jb20udWEvbWFwcy9ANDguODk5NDMzMiwyNC43NTY3MTE0Li4uJyxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICBdXG5cbiAgICAkOiBmb3JtVmFsdWVzID0gZGF0YSB8fCB7fVxuICAgICQ6IGZvcm1FcnJvcnMgPSB7fVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gb25TdWJtaXQoZSkge1xuICAgICAgICBhd2FpdCBzdWJtaXQoZSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkNhbmNlbCgpIHtcbiAgICAgICAgZm9ybVZhbHVlcyA9IGRhdGFcbiAgICAgICAgZGlzcGF0Y2goJ2NhbmNlbCcpXG4gICAgfVxuPC9zY3JpcHQ+XG5cbjxFZGl0Q2FyZCBmb3JtPVwibWFwLWZvcm1cIiBvbjpjYW5jZWw9e29uQ2FuY2VsfT5cbiAgICA8Rm9ybUJ1aWxkZXIgXG4gICAgICAgIGlkPVwibWFwLWZvcm1cIlxuICAgICAgICBpdGVtcz17Zm9ybUZpZWxkc31cbiAgICAgICAgZGF0YT17Zm9ybVZhbHVlc31cbiAgICAgICAgZXJyb3JzPXtmb3JtRXJyb3JzfVxuICAgICAgICBzdWJtaXQ9e29uU3VibWl0fVxuICAgICAgICBvbjpjaGFuZ2VcbiAgICAvPlxuPC9FZGl0Q2FyZD5cblxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBjcmVhdGVFdmVudERpc3BhdGNoZXIgfSBmcm9tICdzdmVsdGUnXG4gICAgaW1wb3J0IHsgRWRpdENhcmQsIEZvcm1CdWlsZGVyIH0gZnJvbSAnQGNvbXBvbmVudHMnXG5cbiAgICBleHBvcnQgbGV0IGRhdGEgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IHN1Ym1pdCA9IGFzeW5jICgpID0+IHt9XG5cbiAgICBjb25zdCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpXG5cbiAgICBsZXQgZm9ybUZpZWxkcyA9IFtcbiAgICAgICAge1xuICAgICAgICAgICAgbGFiZWw6ICfQn9GA0L4g0L3QsNGBOicsXG4gICAgICAgICAgICB0eXBlOiAndGV4dGFyZWEnLFxuICAgICAgICAgICAgbmFtZTogJ2Rlc2NyaXB0aW9uJyxcbiAgICAgICAgICAgIG1ldGE6IHtcbiAgICAgICAgICAgICAgICByb3dzOiA2LFxuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiAn0JzQuCDQv9GW0LrQu9GD0ZTQvNC+0YHRjCDQv9GA0L4uLi4nLFxuICAgICAgICAgICAgICAgIG1heGxlbmd0aDogMjUwLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICBdXG5cbiAgICAkOiBmb3JtVmFsdWVzID0gZGF0YSB8fCB7fVxuICAgICQ6IGZvcm1FcnJvcnMgPSB7fVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gb25TdWJtaXQoZSkge1xuICAgICAgICBhd2FpdCBzdWJtaXQoZSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkNhbmNlbCgpIHtcbiAgICAgICAgZm9ybVZhbHVlcyA9IGRhdGFcbiAgICAgICAgZGlzcGF0Y2goJ2NhbmNlbCcpXG4gICAgfVxuPC9zY3JpcHQ+XG5cbjxFZGl0Q2FyZCBmb3JtPVwiYWJvdXQtZm9ybVwiIG9uOmNhbmNlbD17b25DYW5jZWx9PlxuICAgIDxGb3JtQnVpbGRlciBcbiAgICAgICAgaWQ9XCJhYm91dC1mb3JtXCJcbiAgICAgICAgaXRlbXM9e2Zvcm1GaWVsZHN9XG4gICAgICAgIGRhdGE9e2Zvcm1WYWx1ZXN9XG4gICAgICAgIGVycm9ycz17Zm9ybUVycm9yc31cbiAgICAgICAgc3VibWl0PXtvblN1Ym1pdH1cbiAgICAgICAgb246Y2hhbmdlXG4gICAgLz5cbjwvRWRpdENhcmQ+XG5cblxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBjcmVhdGVFdmVudERpc3BhdGNoZXIgfSBmcm9tICdzdmVsdGUnXG4gICAgaW1wb3J0IHsgc2FmZUdldCB9IGZyb20gJ0B1dGlscydcbiAgICBpbXBvcnQgeyBFZGl0Q2FyZCwgRm9ybUJ1aWxkZXIgfSBmcm9tICdAY29tcG9uZW50cydcblxuICAgIGV4cG9ydCBsZXQgZGF0YSA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgc3VibWl0ID0gYXN5bmMgKCkgPT4ge31cblxuICAgIGNvbnN0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKClcblxuICAgIGNvbnN0IGRlZmF1bHRGaWVsZCA9IHtcbiAgICAgICAgbGFiZWw6ICfQktGW0LTQtdC+IDE6JyxcbiAgICAgICAgdHlwZTogJ3VybCcsXG4gICAgICAgIG5hbWU6ICd2aWRlb3NbMF0uc3JjJyxcbiAgICAgICAgbWV0YToge1xuICAgICAgICAgICAgcGxhY2Vob2xkZXI6ICdodHRwczovL3d3dy55b3V0dWJlLmNvbS93YXRjaD92PW9VY0FVd3B0b3M0JnQnLFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgJDogY3VycmVudFZhbHVlcyA9IGRhdGEgfHwge31cbiAgICAkOiBmb3JtVmFsdWVzID0gZGF0YSB8fCB7fVxuICAgICQ6IGZvcm1FcnJvcnMgPSB7fVxuICAgICQ6IGZpZWxkc0Ftb3VudCA9IHNhZmVHZXQoKCkgPT4gY3VycmVudFZhbHVlcy52aWRlb3MuZmlsdGVyKHYgPT4gdi5zcmMpLmxlbmd0aCwgMCwgdHJ1ZSlcbiAgICAkOiBmb3JtRmllbGRzID0gQXJyYXkuZnJvbShuZXcgQXJyYXkoTWF0aC5tYXgoMiwgZmllbGRzQW1vdW50ICsgMSkpKS5tYXAoKGYsIGkpID0+ICh7XG4gICAgICAgIC4uLmRlZmF1bHRGaWVsZCxcbiAgICAgICAgbGFiZWw6IGDQktGW0LTQtdC+ICR7aSArIDF9OmAsXG4gICAgICAgIG5hbWU6IGB2aWRlb3NbJHtpfV0uc3JjYCxcbiAgICB9KSlcblxuICAgIGFzeW5jIGZ1bmN0aW9uIG9uU3VibWl0KGUpIHtcbiAgICAgICAgYXdhaXQgc3VibWl0KGUpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2hpZnRWYWx1ZXModmFsdWVzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi52YWx1ZXMsXG4gICAgICAgICAgICB2aWRlb3M6IHNhZmVHZXQoKCkgPT4gdmFsdWVzLnZpZGVvcy5maWx0ZXIodiA9PiB2LnNyYyksIFtdKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25DaGFuZ2UoeyBkZXRhaWw6IHsgdmFsdWVzIH0gfSkge1xuICAgICAgICBjdXJyZW50VmFsdWVzID0gc2hpZnRWYWx1ZXModmFsdWVzKVxuICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgc2FmZUdldCgoKSA9PiBjdXJyZW50VmFsdWVzLnZpZGVvcy5sZW5ndGgpICE9PVxuICAgICAgICAgICAgICAgIHNhZmVHZXQoKCkgPT4gZm9ybVZhbHVlcy52aWRlb3MubGVuZ3RoKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGZvcm1WYWx1ZXMgPSBjdXJyZW50VmFsdWVzXG4gICAgICAgIH1cbiAgICAgICAgZGlzcGF0Y2goJ2NoYW5nZScsIHZhbHVlcylcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkNhbmNlbCgpIHtcbiAgICAgICAgY3VycmVudFZhbHVlcyA9IGRhdGFcbiAgICAgICAgZm9ybVZhbHVlcyA9IGRhdGFcbiAgICAgICAgZGlzcGF0Y2goJ2NhbmNlbCcpXG4gICAgfVxuPC9zY3JpcHQ+XG5cbjxFZGl0Q2FyZCBmb3JtPVwidmlkZW9zLWZvcm1cIiBvbjpjYW5jZWw9e29uQ2FuY2VsfT5cbiAgICA8Rm9ybUJ1aWxkZXIgXG4gICAgICAgIGlkPVwidmlkZW9zLWZvcm1cIlxuICAgICAgICBpdGVtcz17Zm9ybUZpZWxkc31cbiAgICAgICAgZGF0YT17Zm9ybVZhbHVlc31cbiAgICAgICAgZXJyb3JzPXtmb3JtRXJyb3JzfVxuICAgICAgICBzdWJtaXQ9e29uU3VibWl0fVxuICAgICAgICBvbjpjaGFuZ2U9e29uQ2hhbmdlfVxuICAgIC8+XG48L0VkaXRDYXJkPiAgICBcblxuXG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJ3N2ZWx0ZSdcbiAgICBpbXBvcnQgeyBvcHRpb25zIH0gZnJvbSAnQGNvbmZpZydcbiAgICBpbXBvcnQgeyBFZGl0Q2FyZCwgRm9ybUJ1aWxkZXIgfSBmcm9tICdAY29tcG9uZW50cydcblxuICAgIGV4cG9ydCBsZXQgZGF0YSA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgc3VibWl0ID0gYXN5bmMgKCkgPT4ge31cblxuICAgIGNvbnN0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKClcblxuICAgIGxldCBmb3JtRmllbGRzID0gW1xuICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiAnYXZhdGFyJyxcbiAgICAgICAgICAgIG5hbWU6ICdhdmF0YXInLFxuICAgICAgICAgICAgbWV0YToge1xuICAgICAgICAgICAgICAgIGFjY2VwdDogJ2ltYWdlL2pwZWcsaW1hZ2UvcG5nJyxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbGFiZWw6ICfQotC10LvQtdGE0L7QvTonLFxuICAgICAgICAgICAgdHlwZTogJ3RlbCcsXG4gICAgICAgICAgICBuYW1lOiAncGhvbmUnLFxuICAgICAgICAgICAgbWV0YToge1xuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiAnKzM4MDk3NDM1NDUzMicsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBsYWJlbDogJ0VtYWlsOicsXG4gICAgICAgICAgICB0eXBlOiAnZW1haWwnLFxuICAgICAgICAgICAgbmFtZTogJ2VtYWlsJyxcbiAgICAgICAgICAgIG1ldGE6IHtcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogJ215bG92ZWRtYWlsQGdtYWlsLmNvbScsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxhYmVsOiAn0JDQtNGA0LXRgdCwOicsXG4gICAgICAgICAgICB0eXBlOiAnc2VhcmNoJyxcbiAgICAgICAgICAgIG5hbWU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgIG1ldGE6IHtcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogJ9Cf0L7Rh9C90ZbRgtGMINCy0LLQvtC00LjRgtC4Li4uJyxcbiAgICAgICAgICAgICAgICBtYXhsZW5ndGg6IDUwLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbGFiZWw6ICfQodC+0YbQvNC10YDQtdC20ZY6JyxcbiAgICAgICAgICAgIHR5cGU6ICdjdXN0b20tc29jaWFscycsXG4gICAgICAgICAgICBuYW1lOiAnc29jaWFscycsXG4gICAgICAgIH0sXG4gICAgXVxuXG4gICAgJDogZm9ybVZhbHVlcyA9IGRhdGEgfHwge31cbiAgICAkOiBmb3JtRXJyb3JzID0ge31cblxuICAgIGFzeW5jIGZ1bmN0aW9uIG9uU3VibWl0KGUpIHtcbiAgICAgICAgYXdhaXQgc3VibWl0KGUpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25DYW5jZWwoKSB7XG4gICAgICAgIGZvcm1WYWx1ZXMgPSBkYXRhXG4gICAgICAgIGRpc3BhdGNoKCdjYW5jZWwnKVxuICAgIH1cbjwvc2NyaXB0PlxuXG48RWRpdENhcmQgZm9ybT1cImNvbnRhY3RzLWZvcm1cIiBvbjpjYW5jZWw9e29uQ2FuY2VsfT5cbiAgICA8Rm9ybUJ1aWxkZXIgXG4gICAgICAgIGlkPVwiY29udGFjdHMtZm9ybVwiXG4gICAgICAgIGl0ZW1zPXtmb3JtRmllbGRzfVxuICAgICAgICBkYXRhPXtmb3JtVmFsdWVzfVxuICAgICAgICBlcnJvcnM9e2Zvcm1FcnJvcnN9XG4gICAgICAgIHN1Ym1pdD17b25TdWJtaXR9XG4gICAgICAgIG9uOmNoYW5nZVxuICAgICAgICBsZXQ6aXRlbT17aXRlbX1cbiAgICAgICAgbGV0OnZhbHVlPXt2YWx1ZX1cbiAgICAgICAgbGV0Om9uQ2hhbmdlPXtvbkNoYW5nZX1cbiAgICA+XG4gICAgICAgIHsjaWYgaXRlbS50eXBlID09PSAnY3VzdG9tLXNvY2lhbHMnfVxuICAgICAgICAgICAgU29jaWFsc1xuICAgICAgICB7L2lmfVxuICAgIDwvRm9ybUJ1aWxkZXI+XG48L0VkaXRDYXJkPiBcblxuXG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJ3N2ZWx0ZSdcbiAgICBpbXBvcnQgeyBFZGl0Q2FyZCwgRm9ybUJ1aWxkZXIgfSBmcm9tICdAY29tcG9uZW50cydcblxuICAgIGV4cG9ydCBsZXQgZGF0YSA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgc3VibWl0ID0gYXN5bmMgKCkgPT4ge31cblxuICAgIGNvbnN0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKClcblxuICAgIGxldCBmb3JtRmllbGRzID0gW1xuICAgICAgICB7XG4gICAgICAgICAgICBsYWJlbDogJ9Ch0LXRgNGC0LjRhNGW0LrQsNGC0Lg6JyxcbiAgICAgICAgICAgIHR5cGU6ICdmaWxlcycsXG4gICAgICAgICAgICBuYW1lOiAnZG9jdW1lbnRzJyxcbiAgICAgICAgICAgIG1ldGE6IHtcbiAgICAgICAgICAgICAgICBtdWx0aXBsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBhY2NlcHQ6ICdpbWFnZS9qcGVnLGltYWdlL3BuZyxhcHBsaWNhdGlvbi9wZGYnLFxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIF1cblxuICAgICQ6IGZvcm1WYWx1ZXMgPSBkYXRhIHx8IHt9XG4gICAgJDogZm9ybUVycm9ycyA9IHt9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBvblN1Ym1pdChlKSB7XG4gICAgICAgIGF3YWl0IHN1Ym1pdChlKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uQ2FuY2VsKCkge1xuICAgICAgICBmb3JtVmFsdWVzID0gZGF0YVxuICAgICAgICBkaXNwYXRjaCgnY2FuY2VsJylcbiAgICB9XG48L3NjcmlwdD5cblxuPEVkaXRDYXJkIGZvcm09XCJkb2N1bWVudHMtZm9ybVwiIG9uOmNhbmNlbD17b25DYW5jZWx9PlxuICAgIDxGb3JtQnVpbGRlciBcbiAgICAgICAgaWQ9XCJkb2N1bWVudHMtZm9ybVwiXG4gICAgICAgIGl0ZW1zPXtmb3JtRmllbGRzfVxuICAgICAgICBkYXRhPXtmb3JtVmFsdWVzfVxuICAgICAgICBlcnJvcnM9e2Zvcm1FcnJvcnN9XG4gICAgICAgIHN1Ym1pdD17b25TdWJtaXR9XG4gICAgICAgIG9uOmNoYW5nZVxuICAgIC8+XG48L0VkaXRDYXJkPlxuXG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJ3N2ZWx0ZSdcbiAgICBpbXBvcnQgeyBFZGl0Q2FyZCwgRm9ybUJ1aWxkZXIgfSBmcm9tICdAY29tcG9uZW50cydcblxuICAgIGV4cG9ydCBsZXQgZGF0YSA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgc3VibWl0ID0gYXN5bmMgKCkgPT4ge31cblxuICAgIGNvbnN0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKClcblxuICAgIGxldCBmb3JtRmllbGRzID0gW1xuICAgICAgICB7XG4gICAgICAgICAgICBsYWJlbDogJ9Ck0L7RgtC+0LPQsNC70LXRgNC10Y86JyxcbiAgICAgICAgICAgIHR5cGU6ICdmaWxlcycsXG4gICAgICAgICAgICBuYW1lOiAnYXZhdGFycycsXG4gICAgICAgICAgICBtZXRhOiB7XG4gICAgICAgICAgICAgICAgbXVsdGlwbGU6IHRydWUsXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxhYmVsOiAn0J3QsNC30LLQsCDQvtGA0LPQsNC90ZbQt9Cw0YbRltGXOicsXG4gICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICBuYW1lOiAnbmFtZScsXG4gICAgICAgICAgICBtZXRhOiB7XG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6ICfQndCw0LfQstCwLi4uJyxcbiAgICAgICAgICAgICAgICBtYXhsZW5ndGg6IDIwLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbGFiZWw6ICfQnNC10YLQsCDQvtGA0LPQsNC90ZbQt9Cw0YbRltGXOicsXG4gICAgICAgICAgICB0eXBlOiAndGV4dGFyZWEnLFxuICAgICAgICAgICAgbmFtZTogJ3N1YnRpdGxlJyxcbiAgICAgICAgICAgIG1ldGE6IHtcbiAgICAgICAgICAgICAgICByb3dzOiA2LFxuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiAn0JzQuCDQv9GW0LrQu9GD0ZTQvNC+0YHRjCDQv9GA0L4uLi4nLFxuICAgICAgICAgICAgICAgIG1heGxlbmd0aDogMjUwLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICBdXG5cbiAgICAkOiBmb3JtVmFsdWVzID0gZGF0YSB8fCB7fVxuICAgICQ6IGZvcm1FcnJvcnMgPSB7fVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gb25TdWJtaXQoZSkge1xuICAgICAgICBhd2FpdCBzdWJtaXQoZSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkNhbmNlbCgpIHtcbiAgICAgICAgZm9ybVZhbHVlcyA9IGRhdGFcbiAgICAgICAgZGlzcGF0Y2goJ2NhbmNlbCcpXG4gICAgfVxuPC9zY3JpcHQ+XG5cbjxFZGl0Q2FyZCBmb3JtPVwiZGVzY3JpcHRpb24tZm9ybVwiIG9uOmNhbmNlbD17b25DYW5jZWx9PlxuICAgIDxGb3JtQnVpbGRlciBcbiAgICAgICAgaWQ9XCJkZXNjcmlwdGlvbi1mb3JtXCJcbiAgICAgICAgaXRlbXM9e2Zvcm1GaWVsZHN9XG4gICAgICAgIGRhdGE9e2Zvcm1WYWx1ZXN9XG4gICAgICAgIGVycm9ycz17Zm9ybUVycm9yc31cbiAgICAgICAgc3VibWl0PXtvblN1Ym1pdH1cbiAgICAgICAgb246Y2hhbmdlXG4gICAgLz5cbjwvRWRpdENhcmQ+ICAgXG5cblxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBjcmVhdGVFdmVudERpc3BhdGNoZXIgfSBmcm9tICdzdmVsdGUnXG4gICAgaW1wb3J0IHsgRWRpdENhcmQsIEZvcm1CdWlsZGVyIH0gZnJvbSAnQGNvbXBvbmVudHMnXG5cbiAgICBleHBvcnQgbGV0IGRhdGEgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IHN1Ym1pdCA9IGFzeW5jICgpID0+IHt9XG5cbiAgICBjb25zdCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpXG5cbiAgICBsZXQgZm9ybUZpZWxkcyA9IFtcbiAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogJ2F2YXRhcicsXG4gICAgICAgICAgICBuYW1lOiAnYXZhdGFyJyxcbiAgICAgICAgICAgIG1ldGE6IHtcbiAgICAgICAgICAgICAgICBhY2NlcHQ6ICdpbWFnZS9qcGVnLGltYWdlL3BuZycsXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxhYmVsOiAn0J3QsNC30LLQsCDQvtGA0LPQsNC90ZbQt9Cw0YbRltGXOicsXG4gICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICBuYW1lOiAnbmFtZScsXG4gICAgICAgICAgICBtZXRhOiB7XG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6ICfQm9C+0LrRli4uLicsXG4gICAgICAgICAgICAgICAgbWF4bGVuZ3RoOiAyMCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgXVxuXG4gICAgJDogZm9ybVZhbHVlcyA9IGRhdGEgfHwge31cbiAgICAkOiBmb3JtRXJyb3JzID0ge31cblxuICAgIGFzeW5jIGZ1bmN0aW9uIG9uU3VibWl0KGUpIHtcbiAgICAgICAgYXdhaXQgc3VibWl0KGUpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25DYW5jZWwoKSB7XG4gICAgICAgIGZvcm1WYWx1ZXMgPSBkYXRhXG4gICAgICAgIGRpc3BhdGNoKCdjYW5jZWwnKVxuICAgIH1cbjwvc2NyaXB0PlxuXG48RWRpdENhcmQgZm9ybT1cIm9yZ2FuaXphdGlvbi1mb3JtXCIgb246Y2FuY2VsPXtvbkNhbmNlbH0+XG4gICAgPEZvcm1CdWlsZGVyIFxuICAgICAgICBpZD1cIm9yZ2FuaXphdGlvbi1mb3JtXCJcbiAgICAgICAgaXRlbXM9e2Zvcm1GaWVsZHN9XG4gICAgICAgIGRhdGE9e2Zvcm1WYWx1ZXN9XG4gICAgICAgIGVycm9ycz17Zm9ybUVycm9yc31cbiAgICAgICAgc3VibWl0PXtvblN1Ym1pdH1cbiAgICAgICAgb246Y2hhbmdlXG4gICAgLz5cbjwvRWRpdENhcmQ+ICAgXG5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgc3RvcmVzIH0gZnJvbSBcIkBzYXBwZXIvYXBwXCI7XG4gICAgaW1wb3J0IHsgb25Nb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcbiAgICBpbXBvcnQgeyBBUEkgfSBmcm9tIFwiQHNlcnZpY2VzXCI7XG4gICAgaW1wb3J0IHsgZGVsYXksIHNhZmVHZXQgfSBmcm9tIFwiQHV0aWxzXCI7XG4gICAgaW1wb3J0IHsgXG4gICAgICAgIEJyLCBcbiAgICAgICAgSWNvbiwgXG4gICAgICAgIEZvb3RlciwgXG4gICAgICAgIEJ1dHRvbiwgXG4gICAgICAgIEVkaXRBcmVhLCBcbiAgICAgICAgTGF6eVRvZ2dsZSxcbiAgICB9IGZyb20gJ0Bjb21wb25lbnRzJ1xuICAgIGltcG9ydCB7XG4gICAgICAgIFNoYXJlLFxuICAgICAgICBUcnVzdCxcbiAgICAgICAgQ29tbWVudHMsXG4gICAgICAgIEZ1bmRMaXN0LFxuICAgICAgICBEb25hdG9ycyxcbiAgICAgICAgTGFzdE5ld3MsXG4gICAgICAgIEludGVyYWN0aW9uSW5kaWNhdG9ycyxcbiAgICB9IGZyb20gJy4vY29tcG9uZW50cydcbiAgICBpbXBvcnQge1xuICAgICAgICBNYXBWaWV3LFxuICAgICAgICBBYm91dFZpZXcsXG4gICAgICAgIFZpZGVvc1ZpZXcsXG4gICAgICAgIENvbnRhY3RzVmlldyxcbiAgICAgICAgRG9jdW1lbnRzVmlldyxcbiAgICAgICAgRGVzY3JpcHRpb25WaWV3LFxuICAgICAgICBPcmdhbml6YXRpb25CdXR0b25WaWV3LFxuICAgIH0gZnJvbSAnLi92aWV3J1xuICAgIGltcG9ydCB7XG4gICAgICAgIE1hcEVkaXQsXG4gICAgICAgIEFib3V0RWRpdCxcbiAgICAgICAgVmlkZW9zRWRpdCxcbiAgICAgICAgQ29udGFjdHNFZGl0LFxuICAgICAgICBEb2N1bWVudHNFZGl0LFxuICAgICAgICBEZXNjcmlwdGlvbkVkaXQsXG4gICAgICAgIE9yZ2FuaXphdGlvbkJ1dHRvbkVkaXQsXG4gICAgfSBmcm9tICcuL2VkaXQnXG5cbiAgICBjb25zdCB7IHBhZ2UgfSA9IHN0b3JlcygpO1xuXG4gICAgLy8gT3JnYW5pemF0aW9uXG4gICAgbGV0IG9yZ2FuaXphdGlvbklkID0gJHBhZ2UucGFyYW1zLmlkO1xuICAgIGxldCBpc0VkaXRNb2RlID0gZmFsc2VcbiAgICBsZXQgaXNFZGl0ID0ge1xuICAgICAgICB0b3BJbmZvOiBmYWxzZSxcbiAgICAgICAgZGVzY3JpcHRpb246IGZhbHNlLFxuICAgICAgICBhYm91dDogZmFsc2UsXG4gICAgICAgIGRvY3VtZW50czogZmFsc2UsXG4gICAgICAgIHZpZGVvczogZmFsc2UsXG4gICAgICAgIGNvbnRhY3RzOiBmYWxzZSxcbiAgICAgICAgbWFwOiBmYWxzZSxcbiAgICB9XG5cbiAgICAvLyBFbnRpdGllc1xuICAgIGxldCBvcmdhbml6YXRpb24gPSB7fTtcbiAgICBsZXQgY29tbWVudHNcbiAgICBsZXQgZnVuZHNcbiAgICBcbiAgICAkOiBvcmdhbml6YXRpb25CbG9jayA9IHtcbiAgICAgICAgaWQ6IG9yZ2FuaXphdGlvbi5pZCxcbiAgICAgICAgbmFtZTogb3JnYW5pemF0aW9uLm5hbWUsXG4gICAgICAgIGF2YXRhcjogb3JnYW5pemF0aW9uLmF2YXRhcixcbiAgICAgICAgYXZhdGFyQmlnOiBvcmdhbml6YXRpb24uYXZhdGFyQmlnLFxuICAgIH07XG4gICAgJDogY2Fyb3VzZWxUb3AgPSAob3JnYW5pemF0aW9uLmF2YXRhcnMgfHwgW10pLm1hcCgoYSwgaSkgPT4gKHsgc3JjOiBhLnNyYywgc3JjQmlnOiBhLnNyYzJ4LCBhbHQ6IGEudGl0bGUgfSkpO1xuICAgICQ6IGRlc2NyaXB0aW9uU2hvcnQgPSB7XG4gICAgICAgIG5hbWU6IG9yZ2FuaXphdGlvbi5uYW1lIHx8IG51bGwsXG4gICAgICAgIHN1YnRpdGxlOiBvcmdhbml6YXRpb24uc3VidGl0bGUgfHwgbnVsbCxcbiAgICAgICAgZGVzY3JpcHRpb246IG9yZ2FuaXphdGlvbi5kZXNjcmlwdGlvbiB8fCBudWxsLFxuICAgIH07XG4gICAgJDogYW5pbWFsRnVuZHMgPSBzYWZlR2V0KCgpID0+IGZ1bmRzLmZpbHRlcihmID0+IGYudHlwZSA9PT0gJ2FuaW1hbCcpLnJlZHVjZSgoYWNjLCBmKSA9PiBhY2MuY29uY2F0KGYsIGYsIGYpLCBbXSkubWFwKGYgPT4gKHtcbiAgICAgICAgaWQ6IGYuaWQsXG4gICAgICAgIHNyYzogZi5hdmF0YXJzWzBdLnNyYyxcbiAgICAgICAgdHlwZTogZi50eXBlLFxuICAgICAgICB0aXRsZTogZi50aXRsZSxcbiAgICAgICAgdG90YWw6IGYubmVlZF9zdW0sXG4gICAgICAgIGN1cnJlbnQ6IGYuY3VycmVtdF9zdW0sXG4gICAgICAgIGN1cnJlbmN5OiBmLmN1cnJlbmN5LFxuICAgICAgICBjaXR5OiBmLmxvY2F0aW9uLmNpdHksXG4gICAgfSkpKVxuICAgICQ6IG90aGVyc0Z1bmRzID0gc2FmZUdldCgoKSA9PiBmdW5kcy5maWx0ZXIoZiA9PiBmLnR5cGUgPT09ICdhbmltYWwnKS5yZWR1Y2UoKGFjYywgZikgPT4gYWNjLmNvbmNhdChmLCBmLCBmKSwgW10pLm1hcChmID0+ICh7XG4gICAgICAgIGlkOiBmLmlkLFxuICAgICAgICBzcmM6IGYuYXZhdGFyc1swXS5zcmMsXG4gICAgICAgIHR5cGU6IGYudHlwZSxcbiAgICAgICAgdGl0bGU6IGYudGl0bGUsXG4gICAgICAgIHRvdGFsOiBmLm5lZWRfc3VtLFxuICAgICAgICBjdXJyZW50OiBmLmN1cnJlbXRfc3VtLFxuICAgICAgICBjdXJyZW5jeTogZi5jdXJyZW5jeSxcbiAgICAgICAgY2l0eTogZi5sb2NhdGlvbi5jaXR5LFxuICAgIH0pKSlcbiAgICAkOiBpY29uc0xpbmUgPSB7XG4gICAgICAgIGxpa2VzOiBvcmdhbml6YXRpb24ubGlrZXMsXG4gICAgICAgIGlzTGlrZWQ6IG9yZ2FuaXphdGlvbi5pc19saWtlZCxcbiAgICAgICAgdmlld3M6IG9yZ2FuaXphdGlvbi52aWV3cyxcbiAgICB9O1xuICAgICQ6IGRlc2NyaXB0aW9uQmxvY2sgPSB7XG4gICAgICAgIHRpdGxlOiBvcmdhbml6YXRpb24udGl0bGUsXG4gICAgICAgIHRleHQ6IG9yZ2FuaXphdGlvbi5kZXNjcmlwdGlvbixcbiAgICB9O1xuICAgICQ6IGNvbnRhY3RzID0gc2FmZUdldCgoKSA9PiBvcmdhbml6YXRpb24uY29udGFjdHMubWFwKGMgPT4gKHtcbiAgICAgICAgdGl0bGU6IGMudGl0bGUsXG4gICAgICAgIGhyZWY6IGMudmFsdWUsXG4gICAgICAgIHR5cGU6IGMudHlwZSxcbiAgICB9KSksIFtdLiB0cnVlKVxuICAgICQ6IGRvbmF0b3JzID0gc2FmZUdldCgoKSA9PiBvcmdhbml6YXRpb24uZG9uYXRvcnMubWFwKGQgPT4gKHtcbiAgICAgICAgaWQ6IGQuaWQsXG4gICAgICAgIHNyYzogZC5hdmF0YXIsXG4gICAgICAgIHRpdGxlOiBgJHtkLmN1cnJlbmN5fSAke2QuYW1vdW50fWAsXG4gICAgICAgIHN1YnRpdGxlOiBkLm5hbWUsXG4gICAgICAgIGNoZWNrZWQ6IGQuY2hlY2tlZCxcbiAgICB9KSkpO1xuICAgICQ6IGxhc3ROZXdzID0gc2FmZUdldCgoKSA9PiBvcmdhbml6YXRpb24ubmV3cy5tYXAobiA9PiAoe1xuICAgICAgICBpZDogbi5pZCxcbiAgICAgICAgc3JjOiBuLnNyYyxcbiAgICAgICAgbGlrZXM6IG4ubGlrZXMsXG4gICAgICAgIGlzTGlrZWQ6IG4uaXNfbGlrZWQsXG4gICAgICAgIHRpdGxlOiBuLnRpdGxlLFxuICAgICAgICBzdWJ0aXRsZTogbi5zdWJ0aXRsZSxcbiAgICAgICAgY3JlYXRlZF9hdDogbi5jcmVhdGVkX2F0LFxuICAgIH0pKS5zbGljZSgwLCAzKSk7XG4gICAgJDogZG9jdW1lbnRzID0gc2FmZUdldCgoKSA9PiBvcmdhbml6YXRpb24uZG9jdW1lbnRzLm1hcChkID0+ICh7XG4gICAgICAgIGlkOiBkLmlkLFxuICAgICAgICBhbHQ6IGQudGl0bGUsXG4gICAgICAgIHNyYzogZC5zcmMsXG4gICAgICAgIHNyYzJ4OiBkLnNyYzJ4LFxuICAgIH0pKSk7XG4gICAgJDogbWVkaWEgPSBzYWZlR2V0KCgpID0+IG9yZ2FuaXphdGlvbi5tZWRpYS5tYXAoZCA9PiAoe1xuICAgICAgICBpZDogZC5pZCxcbiAgICAgICAgYWx0OiBkLnRpdGxlLFxuICAgICAgICBzcmM6IGQuc3JjLFxuICAgICAgICBzcmNCaWc6IGQuc3JjMngsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBkLmRlc2NyaXB0aW9uLFxuICAgIH0pKSwgW10sIHRydWUpO1xuICAgICQ6IGxvY2F0aW9uID0ge1xuICAgICAgICBtYXA6IHNhZmVHZXQoKCkgPT4gb3JnYW5pemF0aW9uLmxvY2F0aW9uLm1hcCksXG4gICAgICAgIHZpcnR1YWxfdG91cjogc2FmZUdldCgoKSA9PiBvcmdhbml6YXRpb24ubG9jYXRpb24udmlydHVhbF90b3VyKSxcbiAgICB9O1xuICAgICQ6IGNvbW1lbnRzRGF0YSA9IHtcbiAgICAgICAgY29tbWVudHM6IHNhZmVHZXQoKCkgPT4gY29tbWVudHMubWFwKGMgPT4gKHtcbiAgICAgICAgICAgIGxpa2VzOiBjLmxpa2VzLFxuICAgICAgICAgICAgYXZhdGFyOiBjWydhdXRob3IuYXZhdGFyJ10sXG4gICAgICAgICAgICBhdXRob3I6IGNbJ2F1dGhvci5uYW1lJ10sXG4gICAgICAgICAgICBjb21tZW50OiBjLmNvbW1lbnQsXG4gICAgICAgICAgICBjaGVja2VkOiBjLmNoZWNrZWQsXG4gICAgICAgICAgICByZXBseV90bzogYy5yZXBseV90byxcbiAgICAgICAgICAgIGNyZWF0ZWRfYXQ6IGMuY3JlYXRlZF9hdCxcbiAgICAgICAgfSkpKSxcbiAgICB9O1xuXG4gICAgb25Nb3VudChhc3luYyAoKSA9PiB7XG4gICAgICAgIGF3YWl0IGRlbGF5KDUwMDApXG4gICAgICAgIG9yZ2FuaXphdGlvbiA9IGF3YWl0IEFQSS5nZXRPcmdhbml6YXRpb24ob3JnYW5pemF0aW9uSWQpO1xuICAgICAgICBjb21tZW50cyA9IGF3YWl0IEFQSS5nZXRDb21tZW50cygpXG4gICAgICAgIGZ1bmRzID0gYXdhaXQgQVBJLmdldEZ1bmRzKClcbiAgICB9KTtcblxuICAgIGFzeW5jIGZ1bmN0aW9uIG9uU3VibWl0KHNlY3Rpb24sIHZhbHVlcykge1xuICAgICAgICBpc0VkaXRbc2VjdGlvbl0gPSBmYWxzZVxuICAgICAgICBjb25zb2xlLmxvZyh2YWx1ZXMpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25DYW5jZWwoc2VjdGlvbikge1xuICAgICAgICBpc0VkaXRbc2VjdGlvbl0gPSBmYWxzZVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uVG9nZ2xlTW9kZSgpIHtcbiAgICAgICAgaXNFZGl0TW9kZSA9ICFpc0VkaXRNb2RlXG4gICAgICAgIGlmICghaXNFZGl0TW9kZSkge1xuICAgICAgICAgICAgaXNFZGl0ID0ge1xuICAgICAgICAgICAgICAgIHRvcEluZm86IGZhbHNlLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBhYm91dDogZmFsc2UsXG4gICAgICAgICAgICAgICAgZG9jdW1lbnRzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB2aWRlb3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbnRhY3RzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBtYXA6IGZhbHNlLFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuPC9zY3JpcHQ+XG5cbjxzdmVsdGU6aGVhZD5cbiAgICA8dGl0bGU+Q2hhcml0aWZ5IC0gT3JnYW5pemF0aW9uIHBhZ2UuPC90aXRsZT5cbjwvc3ZlbHRlOmhlYWQ+XG5cbjxzZWN0aW9uIGNsYXNzPVwiY29udGFpbmVyIHRoZW1lLWJnLWNvbG9yLXNlY29uZGFyeVwiPlxuICAgIDxCciBzaXplPVwidmFyKC0taGVhZGVyLWhlaWdodClcIi8+XG5cbiAgICA8ZGl2IGNsYXNzPVwib3ZlcmZsb3ctaGlkZGVuXCI+XG4gICAgICAgIDxCciBzaXplPVwiMzBcIi8+XG4gICAgICAgIDxCdXR0b24gc2l6ZT1cInNtYWxsXCIgaXM9XCJpbmZvXCIgb246Y2xpY2s9e29uVG9nZ2xlTW9kZX0+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImgzIGZvbnQtc2Vjb25kYXJ5IGZvbnQtdy01MDAgZmxleCBmbGV4LWFsaWduLWNlbnRlclwiPlxuICAgICAgICAgICAgICAgIHtpc0VkaXRNb2RlID8gJ9CX0LHQtdGA0LXQs9GC0LgnIDogJ9Cg0LXQtNCw0LPRg9Cy0LDRgtC4J31cbiAgICAgICAgICAgICAgICA8cz48L3M+XG4gICAgICAgICAgICAgICAgPHM+PC9zPlxuICAgICAgICAgICAgICAgIHsjaWYgIWlzRWRpdE1vZGV9XG4gICAgICAgICAgICAgICAgICAgIDxJY29uIHR5cGU9XCJlZGl0XCIgc2l6ZT1cInNtYWxsXCIgaXM9XCJsaWdodFwiLz5cbiAgICAgICAgICAgICAgICB7L2lmfVxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgPEJyIHNpemU9XCIzMFwiLz5cbiAgICA8L2Rpdj5cblxuICAgIDwhLS0gVG9wIG9yZ2FuaXphdGlvbiBpbmZvIC0tPlxuICAgIDxMYXp5VG9nZ2xlIGFjdGl2ZT17aXNFZGl0LnRvcEluZm99PlxuICAgICAgICA8T3JnYW5pemF0aW9uQnV0dG9uRWRpdCBcbiAgICAgICAgICAgIGRhdGE9e29yZ2FuaXphdGlvbkJsb2NrfVxuICAgICAgICAgICAgc3VibWl0PXtvblN1Ym1pdC5iaW5kKG51bGwsICd0b3BJbmZvJyl9IFxuICAgICAgICAgICAgb246Y2FuY2VsPXtvbkNhbmNlbC5iaW5kKG51bGwsICd0b3BJbmZvJyl9IFxuICAgICAgICAvPlxuICAgIDwvTGF6eVRvZ2dsZT5cbiAgICA8TGF6eVRvZ2dsZSBhY3RpdmU9eyFpc0VkaXQudG9wSW5mb30gbW91bnRlZCBjbGFzcz1cImZ1bGwtY29udGFpbmVyXCI+XG4gICAgICAgIDxFZGl0QXJlYSBvbjpjbGljaz17KCkgPT4gaXNFZGl0LnRvcEluZm8gPSAhaXNFZGl0LnRvcEluZm99IG9mZj17IWlzRWRpdE1vZGV9PiAgICBcbiAgICAgICAgICAgIDxCciBzaXplPVwiMzBcIi8+XG4gICAgICAgICAgICA8T3JnYW5pemF0aW9uQnV0dG9uVmlldyBvcmdhbml6YXRpb249e29yZ2FuaXphdGlvbkJsb2NrfS8+XG4gICAgICAgIDwvRWRpdEFyZWE+XG4gICAgPC9MYXp5VG9nZ2xlPlxuICAgIHsjaWYgaXNFZGl0TW9kZX1cbiAgICAgICAgPEJyIHNpemU9XCI1MFwiIC8+XG4gICAgey9pZn1cbiAgICA8IS0tIEVORDogVG9wIG9yZ2FuaXphdGlvbiBpbmZvIC0tPlxuXG4gICAgPEJyIHNpemU9XCIyMFwiIC8+XG4gICAgXG4gICAgPCEtLSBEZXNjcmlwdGlvbiAtLT5cbiAgICA8TGF6eVRvZ2dsZSBhY3RpdmU9e2lzRWRpdC5kZXNjcmlwdGlvbn0+XG4gICAgICAgIDxEZXNjcmlwdGlvbkVkaXQgXG4gICAgICAgICAgICBkYXRhPXt7IC4uLmRlc2NyaXB0aW9uU2hvcnQsIGF2YXRhcnM6IGNhcm91c2VsVG9wIH19XG4gICAgICAgICAgICBzdWJtaXQ9e29uU3VibWl0LmJpbmQobnVsbCwgJ2Rlc2NyaXB0aW9uJyl9IFxuICAgICAgICAgICAgb246Y2FuY2VsPXtvbkNhbmNlbC5iaW5kKG51bGwsICdkZXNjcmlwdGlvbicpfSBcbiAgICAgICAgLz5cbiAgICA8L0xhenlUb2dnbGU+XG4gICAgPExhenlUb2dnbGUgYWN0aXZlPXshaXNFZGl0LmRlc2NyaXB0aW9ufSBtb3VudGVkIGNsYXNzPVwiZnVsbC1jb250YWluZXJcIj5cbiAgICAgICAgPEVkaXRBcmVhIG9uOmNsaWNrPXsoKSA9PiBpc0VkaXQuZGVzY3JpcHRpb24gPSAhaXNFZGl0LmRlc2NyaXB0aW9ufSBvZmY9eyFpc0VkaXRNb2RlfT5cbiAgICAgICAgICAgIHsjaWYgaXNFZGl0TW9kZX1cbiAgICAgICAgICAgICAgICA8QnIgc2l6ZT1cIjMwXCIgLz5cbiAgICAgICAgICAgIHsvaWZ9ICBcbiAgICAgICAgICAgIDxEZXNjcmlwdGlvblZpZXcgXG4gICAgICAgICAgICAgICAge2Nhcm91c2VsVG9wfVxuICAgICAgICAgICAgICAgIHRpdGxlPXtkZXNjcmlwdGlvblNob3J0Lm5hbWV9IFxuICAgICAgICAgICAgICAgIHRleHQ9e2Rlc2NyaXB0aW9uU2hvcnQuc3VidGl0bGV9XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L0VkaXRBcmVhPlxuICAgIDwvTGF6eVRvZ2dsZT5cbiAgICB7I2lmIGlzRWRpdE1vZGV9XG4gICAgICAgIDxCciBzaXplPVwiMzBcIiAvPlxuICAgIHsvaWZ9XG4gICAgPCEtLSBFTkQ6IERlc2NyaXB0aW9uIC0tPlxuXG4gICAgPEJyIHNpemU9XCIxMFwiIC8+XG4gICAgPExhenlUb2dnbGUgYWN0aXZlPXshaXNFZGl0TW9kZX0gbW91bnRlZD5cbiAgICAgICAgPEludGVyYWN0aW9uSW5kaWNhdG9ycyBsaWtlcz17aWNvbnNMaW5lLmxpa2VzfSB2aWV3cz17aWNvbnNMaW5lLnZpZXdzfSBpc0xpa2VkPXtvcmdhbml6YXRpb24uaXNMaWtlZH0vPlxuICAgICAgICA8QnIgc2l6ZT1cIjUwXCIvPlxuICAgICAgICA8RnVuZExpc3QgdGl0bGU9XCLQpNC+0L3QtNC4INGC0LLQsNGA0LjQvVwiIGl0ZW1zPXthbmltYWxGdW5kc30vPlxuICAgICAgICA8QnIgc2l6ZT1cIjQ1XCIgLz5cbiAgICAgICAgPEZ1bmRMaXN0IHRpdGxlPVwi0IbQvdGI0ZYg0YTQvtC90LTQuFwiIGl0ZW1zPXtvdGhlcnNGdW5kc30vPlxuICAgIDwvTGF6eVRvZ2dsZT5cbiAgICA8QnIgc2l6ZT1cIjMwXCIgLz5cbiAgICBcbiAgICA8IS0tIEFib3V0IC0tPlxuICAgIDxMYXp5VG9nZ2xlIGFjdGl2ZT17aXNFZGl0LmFib3V0fT5cbiAgICAgICAgPEFib3V0RWRpdCBcbiAgICAgICAgICAgIGRhdGE9e2Rlc2NyaXB0aW9uU2hvcnR9XG4gICAgICAgICAgICBzdWJtaXQ9e29uU3VibWl0LmJpbmQobnVsbCwgJ2Fib3V0Jyl9IFxuICAgICAgICAgICAgb246Y2FuY2VsPXtvbkNhbmNlbC5iaW5kKG51bGwsICdhYm91dCcpfSBcbiAgICAgICAgLz5cbiAgICA8L0xhenlUb2dnbGU+XG4gICAgPExhenlUb2dnbGUgYWN0aXZlPXshaXNFZGl0LmFib3V0fSBtb3VudGVkIGNsYXNzPVwiZnVsbC1jb250YWluZXJcIj5cbiAgICAgICAgPEVkaXRBcmVhIG9uOmNsaWNrPXsoKSA9PiBpc0VkaXQuYWJvdXQgPSAhaXNFZGl0LmFib3V0fSBvZmY9eyFpc0VkaXRNb2RlfT4gICAgXG4gICAgICAgICAgICA8QnIgc2l6ZT1cIjMwXCIvPlxuICAgICAgICAgICAgPEFib3V0Vmlld1xuICAgICAgICAgICAgICAgIHRpdGxlPVwi0J/RgNC+INC90LDRgVwiXG4gICAgICAgICAgICAgICAgdGV4dD17ZGVzY3JpcHRpb25TaG9ydC5kZXNjcmlwdGlvbn1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvRWRpdEFyZWE+XG4gICAgPC9MYXp5VG9nZ2xlPlxuICAgIDwhLS0gRU5EOiBBYm91dCAtLT5cblxuICAgIDxCciBzaXplPVwiMTBcIiAvPlxuICAgIDxMYXp5VG9nZ2xlIGFjdGl2ZT17IWlzRWRpdE1vZGV9IG1vdW50ZWQ+XG4gICAgICAgIDxTaGFyZSAvPlxuICAgICAgICA8QnIgc2l6ZT1cIjUwXCIgLz5cbiAgICAgICAgPFRydXN0IGFjdGl2ZT17b3JnYW5pemF0aW9uLmlzTGlrZWR9Lz5cbiAgICAgICAgPEJyIHNpemU9XCI1MFwiIC8+XG4gICAgICAgIDxEb25hdG9ycyBpdGVtcz17ZG9uYXRvcnN9Lz5cbiAgICAgICAgPEJyIHNpemU9XCI2MFwiIC8+XG4gICAgICAgIDxMYXN0TmV3cyBcbiAgICAgICAgICAgIGl0ZW1zPXtsYXN0TmV3c30gXG4gICAgICAgICAgICBjYXJvdXNlbD17Y2Fyb3VzZWxUb3B9XG4gICAgICAgICAgICBpY29uc0xpbmU9e2ljb25zTGluZX1cbiAgICAgICAgICAgIG9yZ2FuaXphdGlvbj17b3JnYW5pemF0aW9ufVxuICAgICAgICAgICAgZGVzY3JpcHRpb25TaG9ydD17ZGVzY3JpcHRpb25TaG9ydH1cbiAgICAgICAgLz5cbiAgICA8L0xhenlUb2dnbGU+XG4gICAgPEJyIHNpemU9XCI2MFwiIC8+XG5cbiAgICA8IS0tIERvY3VtZW50cyAtLT5cbiAgICA8TGF6eVRvZ2dsZSBhY3RpdmU9e2lzRWRpdC5kb2N1bWVudHN9PlxuICAgICAgICA8RG9jdW1lbnRzRWRpdCBcbiAgICAgICAgICAgIGRhdGE9e3sgZG9jdW1lbnRzIH19XG4gICAgICAgICAgICBzdWJtaXQ9e29uU3VibWl0LmJpbmQobnVsbCwgJ2RvY3VtZW50cycpfSBcbiAgICAgICAgICAgIG9uOmNhbmNlbD17b25DYW5jZWwuYmluZChudWxsLCAnZG9jdW1lbnRzJyl9IFxuICAgICAgICAvPlxuICAgIDwvTGF6eVRvZ2dsZT5cbiAgICA8TGF6eVRvZ2dsZSBhY3RpdmU9eyFpc0VkaXQuZG9jdW1lbnRzfSBtb3VudGVkIGNsYXNzPVwiZnVsbC1jb250YWluZXJcIj5cbiAgICAgICAgPEVkaXRBcmVhIG9uOmNsaWNrPXsoKSA9PiBpc0VkaXQuZG9jdW1lbnRzID0gIWlzRWRpdC5kb2N1bWVudHN9IG9mZj17IWlzRWRpdE1vZGV9PiAgICBcbiAgICAgICAgICAgIDxCciBzaXplPVwiMzBcIi8+XG4gICAgICAgICAgICA8RG9jdW1lbnRzVmlldyBpdGVtcz17ZG9jdW1lbnRzfS8+XG4gICAgICAgIDwvRWRpdEFyZWE+XG4gICAgPC9MYXp5VG9nZ2xlPlxuICAgIHsjaWYgaXNFZGl0TW9kZX1cbiAgICAgICAgPEJyIHNpemU9XCIzMFwiIC8+XG4gICAgey9pZn1cbiAgICA8IS0tIEVORDogRG9jdW1lbnRzIC0tPlxuICAgIFxuICAgIDxCciBzaXplPVwiNDBcIiAvPlxuXG4gICAgPCEtLSBWaWRlb3MgLS0+XG4gICAgPExhenlUb2dnbGUgYWN0aXZlPXtpc0VkaXQudmlkZW9zfT5cbiAgICAgICAgPFZpZGVvc0VkaXQgXG4gICAgICAgICAgICBkYXRhPXt7IHZpZGVvczogbWVkaWEgfX1cbiAgICAgICAgICAgIHN1Ym1pdD17b25TdWJtaXQuYmluZChudWxsLCAndmlkZW9zJyl9XG4gICAgICAgICAgICBvbjpjYW5jZWw9e29uQ2FuY2VsLmJpbmQobnVsbCwgJ3ZpZGVvcycpfSBcbiAgICAgICAgLz5cbiAgICA8L0xhenlUb2dnbGU+XG4gICAgPExhenlUb2dnbGUgYWN0aXZlPXshaXNFZGl0LnZpZGVvc30gbW91bnRlZCBjbGFzcz1cImZ1bGwtY29udGFpbmVyXCI+XG4gICAgICAgIDxFZGl0QXJlYSBvbjpjbGljaz17KCkgPT4gaXNFZGl0LnZpZGVvcyA9ICFpc0VkaXQudmlkZW9zfSBvZmY9eyFpc0VkaXRNb2RlfT4gICAgXG4gICAgICAgICAgICA8QnIgc2l6ZT1cIjE1XCIvPlxuICAgICAgICAgICAgPFZpZGVvc1ZpZXcgaXRlbXM9e21lZGlhfS8+XG4gICAgICAgIDwvRWRpdEFyZWE+XG4gICAgPC9MYXp5VG9nZ2xlPlxuICAgIHsjaWYgaXNFZGl0TW9kZX1cbiAgICAgICAgPEJyIHNpemU9XCIzMFwiIC8+XG4gICAgey9pZn1cbiAgICA8IS0tIEVORDogVmlkZW9zIC0tPlxuICAgIFxuICAgIDxCciBzaXplPVwiNDBcIiAvPlxuXG4gICAgPCEtLSBDb250YWN0cyAtLT5cbiAgICA8TGF6eVRvZ2dsZSBhY3RpdmU9e2lzRWRpdC5jb250YWN0c30+XG4gICAgICAgIDxDb250YWN0c0VkaXQgXG4gICAgICAgICAgICBkYXRhPXt7IC4uLm9yZ2FuaXphdGlvbkJsb2NrLCBjb250YWN0cyB9fVxuICAgICAgICAgICAgc3VibWl0PXtvblN1Ym1pdC5iaW5kKG51bGwsICdjb250YWN0cycpfVxuICAgICAgICAgICAgb246Y2FuY2VsPXtvbkNhbmNlbC5iaW5kKG51bGwsICdjb250YWN0cycpfVxuICAgICAgICAvPlxuICAgIDwvTGF6eVRvZ2dsZT5cbiAgICA8TGF6eVRvZ2dsZSBhY3RpdmU9eyFpc0VkaXQuY29udGFjdHN9IG1vdW50ZWQgY2xhc3M9XCJmdWxsLWNvbnRhaW5lclwiPlxuICAgICAgICA8RWRpdEFyZWEgb246Y2xpY2s9eygpID0+IGlzRWRpdC5jb250YWN0cyA9ICFpc0VkaXQuY29udGFjdHN9IG9mZj17IWlzRWRpdE1vZGV9PlxuICAgICAgICAgICAgPEJyIHNpemU9XCIzMFwiLz5cbiAgICAgICAgICAgIDxDb250YWN0c1ZpZXcge2NvbnRhY3RzfSB7b3JnYW5pemF0aW9ufS8+XG4gICAgICAgIDwvRWRpdEFyZWE+XG4gICAgPC9MYXp5VG9nZ2xlPlxuICAgIHsjaWYgaXNFZGl0TW9kZX1cbiAgICAgICAgPEJyIHNpemU9XCIxMFwiIC8+XG4gICAgey9pZn1cbiAgICA8IS0tIEVORDogQ29udGFjdHMgLS0+XG5cbiAgICA8QnIgc2l6ZT1cIjYwXCIgLz5cblxuICAgIDwhLS0gTWFwIC0tPlxuICAgIDxMYXp5VG9nZ2xlIGFjdGl2ZT17aXNFZGl0Lm1hcH0+XG4gICAgICAgIDxNYXBFZGl0IFxuICAgICAgICAgICAgZGF0YT17eyBsb2NhdGlvbiB9fVxuICAgICAgICAgICAgc3VibWl0PXtvblN1Ym1pdC5iaW5kKG51bGwsICdtYXAnKX0gXG4gICAgICAgICAgICBvbjpjYW5jZWw9e29uQ2FuY2VsLmJpbmQobnVsbCwgJ21hcCcpfSBcbiAgICAgICAgLz5cbiAgICA8L0xhenlUb2dnbGU+XG4gICAgPExhenlUb2dnbGUgYWN0aXZlPXshaXNFZGl0Lm1hcH0gbW91bnRlZCBjbGFzcz1cImZ1bGwtY29udGFpbmVyXCI+XG4gICAgICAgIDxFZGl0QXJlYSBvbjpjbGljaz17KCkgPT4gaXNFZGl0Lm1hcCA9ICFpc0VkaXQubWFwfSBvZmY9eyFpc0VkaXRNb2RlfT4gICAgXG4gICAgICAgICAgICA8QnIgc2l6ZT1cIjE1XCIvPlxuICAgICAgICAgICAgPE1hcFZpZXcge2xvY2F0aW9ufSBwcmV2aWV3PXtpc0VkaXRNb2RlfS8+XG4gICAgICAgIDwvRWRpdEFyZWE+XG4gICAgPC9MYXp5VG9nZ2xlPlxuICAgIHsjaWYgaXNFZGl0TW9kZX1cbiAgICAgICAgPEJyIHNpemU9XCIxMFwiIC8+XG4gICAgey9pZn1cbiAgICA8IS0tIEVORDogTWFwIC0tPlxuICAgIFxuICAgIDxCciBzaXplPVwiNjBcIiAvPlxuXG4gICAgPExhenlUb2dnbGUgYWN0aXZlPXshaXNFZGl0TW9kZX0gbW91bnRlZD5cbiAgICAgICAgPENvbW1lbnRzIGl0ZW1zPXtjb21tZW50c0RhdGEuY29tbWVudHN9Lz5cbiAgICAgICAgPEJyIHNpemU9XCI0MFwiIC8+XG4gICAgPC9MYXp5VG9nZ2xlPlxuXG4gICAgPGRpdiBjbGFzcz1cImZ1bGwtY29udGFpbmVyXCI+XG4gICAgICAgIDxGb290ZXIgLz5cbiAgICA8L2Rpdj5cbjwvc2VjdGlvbj5cbiJdLCJuYW1lcyI6WyJzdG9yZXMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O2lDQVcrQixHQUFNOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7dUVBQU4sR0FBTTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BUDNCLFFBQVEsR0FBRyxxQkFBcUI7T0FFM0IsTUFBTSxHQUFHLEtBQUs7Ozs7Ozs7Ozt1QkFLb0IsQ0FBQyxJQUFJLFFBQVEsQ0FBQyxPQUFPLEdBQUcsTUFBTTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzZCQ0YxRCxHQUFLOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsrREFBTCxHQUFLOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FOWCxLQUFLOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQ0FQLEdBQUc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0NBSCxLQUFLOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs2QkNNTyxHQUFLOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O21FQUFMLEdBQUs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQU5mLEtBQUs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt1QkNJZixHQUFLOzs7Ozs7Ozs7Ozt1Q0FBTCxHQUFLOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7bUVBQUwsR0FBSzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FKSyxLQUFLO09BQ0wsS0FBSzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2VDR2EsS0FBSzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BSnZCLEtBQUs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3NCQ0tYLEdBQUs7Ozs7OztzQ0FBTCxHQUFLOzs7Ozs7Ozs7Ozs7c0RBQUwsR0FBSzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3FCQVFULEdBQUk7Ozs7OztzQ0FBSixHQUFJOzs7Ozs7Ozs7Ozs7O29EQUFKLEdBQUk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0JBVEosR0FBSzs7Ozs7Ozs7Ozs7ZUFPTCxHQUFJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FYTSxLQUFLO09BQ0wsSUFBSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztzQkNtQitCLEdBQUs7Ozs7Ozt3Q0FBTCxHQUFLOzs7Ozs7Ozs7Ozs7O3NEQUFMLEdBQUs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0JBRDlDLEdBQUssUUFBSyxJQUFJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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
