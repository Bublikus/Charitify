function noop() { }
const identity = x => x;
function assign(tar, src) {
    // @ts-ignore
    for (const k in src)
        tar[k] = src[k];
    return tar;
}
function add_location(element, file, line, column, char) {
    element.__svelte_meta = {
        loc: { file, line, column, char }
    };
}
function run(fn) {
    return fn();
}
function blank_object() {
    return Object.create(null);
}
function run_all(fns) {
    fns.forEach(run);
}
function is_function(thing) {
    return typeof thing === 'function';
}
function safe_not_equal(a, b) {
    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
}
function validate_store(store, name) {
    if (store != null && typeof store.subscribe !== 'function') {
        throw new Error(`'${name}' is not a store with a 'subscribe' method`);
    }
}
function subscribe(store, ...callbacks) {
    if (store == null) {
        return noop;
    }
    const unsub = store.subscribe(...callbacks);
    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function get_store_value(store) {
    let value;
    subscribe(store, _ => value = _)();
    return value;
}
function component_subscribe(component, store, callback) {
    component.$$.on_destroy.push(subscribe(store, callback));
}
function create_slot(definition, ctx, $$scope, fn) {
    if (definition) {
        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
        return definition[0](slot_ctx);
    }
}
function get_slot_context(definition, ctx, $$scope, fn) {
    return definition[1] && fn
        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
        : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
    if (definition[2] && fn) {
        const lets = definition[2](fn(dirty));
        if ($$scope.dirty === undefined) {
            return lets;
        }
        if (typeof lets === 'object') {
            const merged = [];
            const len = Math.max($$scope.dirty.length, lets.length);
            for (let i = 0; i < len; i += 1) {
                merged[i] = $$scope.dirty[i] | lets[i];
            }
            return merged;
        }
        return $$scope.dirty | lets;
    }
    return $$scope.dirty;
}
function update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {
    const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);
    if (slot_changes) {
        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
        slot.p(slot_context, slot_changes);
    }
}
function exclude_internal_props(props) {
    const result = {};
    for (const k in props)
        if (k[0] !== '$')
            result[k] = props[k];
    return result;
}
function null_to_empty(value) {
    return value == null ? '' : value;
}
const has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
function action_destroyer(action_result) {
    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
}

const is_client = typeof window !== 'undefined';
let now = is_client
    ? () => window.performance.now()
    : () => Date.now();
let raf = is_client ? cb => requestAnimationFrame(cb) : noop;

const tasks = new Set();
function run_tasks(now) {
    tasks.forEach(task => {
        if (!task.c(now)) {
            tasks.delete(task);
            task.f();
        }
    });
    if (tasks.size !== 0)
        raf(run_tasks);
}
/**
 * Creates a new task that runs on each raf frame
 * until it returns a falsy value or is aborted
 */
function loop(callback) {
    let task;
    if (tasks.size === 0)
        raf(run_tasks);
    return {
        promise: new Promise(fulfill => {
            tasks.add(task = { c: callback, f: fulfill });
        }),
        abort() {
            tasks.delete(task);
        }
    };
}

function append(target, node) {
    target.appendChild(node);
}
function insert(target, node, anchor) {
    target.insertBefore(node, anchor || null);
}
function detach(node) {
    node.parentNode.removeChild(node);
}
function destroy_each(iterations, detaching) {
    for (let i = 0; i < iterations.length; i += 1) {
        if (iterations[i])
            iterations[i].d(detaching);
    }
}
function element(name) {
    return document.createElement(name);
}
function object_without_properties(obj, exclude) {
    const target = {};
    for (const k in obj) {
        if (has_prop(obj, k)
            // @ts-ignore
            && exclude.indexOf(k) === -1) {
            // @ts-ignore
            target[k] = obj[k];
        }
    }
    return target;
}
function svg_element(name) {
    return document.createElementNS('http://www.w3.org/2000/svg', name);
}
function text(data) {
    return document.createTextNode(data);
}
function space() {
    return text(' ');
}
function empty() {
    return text('');
}
function listen(node, event, handler, options) {
    node.addEventListener(event, handler, options);
    return () => node.removeEventListener(event, handler, options);
}
function prevent_default(fn) {
    return function (event) {
        event.preventDefault();
        // @ts-ignore
        return fn.call(this, event);
    };
}
function attr(node, attribute, value) {
    if (value == null)
        node.removeAttribute(attribute);
    else if (node.getAttribute(attribute) !== value)
        node.setAttribute(attribute, value);
}
function set_attributes(node, attributes) {
    // @ts-ignore
    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
    for (const key in attributes) {
        if (attributes[key] == null) {
            node.removeAttribute(key);
        }
        else if (key === 'style') {
            node.style.cssText = attributes[key];
        }
        else if (key === '__value') {
            node.value = node[key] = attributes[key];
        }
        else if (descriptors[key] && descriptors[key].set) {
            node[key] = attributes[key];
        }
        else {
            attr(node, key, attributes[key]);
        }
    }
}
function children(element) {
    return Array.from(element.childNodes);
}
function claim_element(nodes, name, attributes, svg) {
    for (let i = 0; i < nodes.length; i += 1) {
        const node = nodes[i];
        if (node.nodeName === name) {
            let j = 0;
            const remove = [];
            while (j < node.attributes.length) {
                const attribute = node.attributes[j++];
                if (!attributes[attribute.name]) {
                    remove.push(attribute.name);
                }
            }
            for (let k = 0; k < remove.length; k++) {
                node.removeAttribute(remove[k]);
            }
            return nodes.splice(i, 1)[0];
        }
    }
    return svg ? svg_element(name) : element(name);
}
function claim_text(nodes, data) {
    for (let i = 0; i < nodes.length; i += 1) {
        const node = nodes[i];
        if (node.nodeType === 3) {
            node.data = '' + data;
            return nodes.splice(i, 1)[0];
        }
    }
    return text(data);
}
function claim_space(nodes) {
    return claim_text(nodes, ' ');
}
function set_input_value(input, value) {
    input.value = value == null ? '' : value;
}
function set_style(node, key, value, important) {
    node.style.setProperty(key, value, important ? 'important' : '');
}
function select_option(select, value) {
    for (let i = 0; i < select.options.length; i += 1) {
        const option = select.options[i];
        if (option.__value === value) {
            option.selected = true;
            return;
        }
    }
}
function select_value(select) {
    const selected_option = select.querySelector(':checked') || select.options[0];
    return selected_option && selected_option.__value;
}
function toggle_class(element, name, toggle) {
    element.classList[toggle ? 'add' : 'remove'](name);
}
function custom_event(type, detail) {
    const e = document.createEvent('CustomEvent');
    e.initCustomEvent(type, false, false, detail);
    return e;
}
function query_selector_all(selector, parent = document.body) {
    return Array.from(parent.querySelectorAll(selector));
}

const active_docs = new Set();
let active = 0;
// https://github.com/darkskyapp/string-hash/blob/master/index.js
function hash(str) {
    let hash = 5381;
    let i = str.length;
    while (i--)
        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
    return hash >>> 0;
}
function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
    const step = 16.666 / duration;
    let keyframes = '{\n';
    for (let p = 0; p <= 1; p += step) {
        const t = a + (b - a) * ease(p);
        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
    }
    const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
    const name = `__svelte_${hash(rule)}_${uid}`;
    const doc = node.ownerDocument;
    active_docs.add(doc);
    const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = doc.head.appendChild(element('style')).sheet);
    const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});
    if (!current_rules[name]) {
        current_rules[name] = true;
        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
    }
    const animation = node.style.animation || '';
    node.style.animation = `${animation ? `${animation}, ` : ``}${name} ${duration}ms linear ${delay}ms 1 both`;
    active += 1;
    return name;
}
function delete_rule(node, name) {
    const previous = (node.style.animation || '').split(', ');
    const next = previous.filter(name
        ? anim => anim.indexOf(name) < 0 // remove specific animation
        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
    );
    const deleted = previous.length - next.length;
    if (deleted) {
        node.style.animation = next.join(', ');
        active -= deleted;
        if (!active)
            clear_rules();
    }
}
function clear_rules() {
    raf(() => {
        if (active)
            return;
        active_docs.forEach(doc => {
            const stylesheet = doc.__svelte_stylesheet;
            let i = stylesheet.cssRules.length;
            while (i--)
                stylesheet.deleteRule(i);
            doc.__svelte_rules = {};
        });
        active_docs.clear();
    });
}

let current_component;
function set_current_component(component) {
    current_component = component;
}
function get_current_component() {
    if (!current_component)
        throw new Error(`Function called outside component initialization`);
    return current_component;
}
function onMount(fn) {
    get_current_component().$$.on_mount.push(fn);
}
function afterUpdate(fn) {
    get_current_component().$$.after_update.push(fn);
}
function onDestroy(fn) {
    get_current_component().$$.on_destroy.push(fn);
}
function createEventDispatcher() {
    const component = get_current_component();
    return (type, detail) => {
        const callbacks = component.$$.callbacks[type];
        if (callbacks) {
            // TODO are there situations where events could be dispatched
            // in a server (non-DOM) environment?
            const event = custom_event(type, detail);
            callbacks.slice().forEach(fn => {
                fn.call(component, event);
            });
        }
    };
}
function setContext(key, context) {
    get_current_component().$$.context.set(key, context);
}
function getContext(key) {
    return get_current_component().$$.context.get(key);
}
// TODO figure out if we still want to support
// shorthand events, or if we want to implement
// a real bubbling mechanism
function bubble(component, event) {
    const callbacks = component.$$.callbacks[event.type];
    if (callbacks) {
        callbacks.slice().forEach(fn => fn(event));
    }
}

const dirty_components = [];
const binding_callbacks = [];
const render_callbacks = [];
const flush_callbacks = [];
const resolved_promise = Promise.resolve();
let update_scheduled = false;
function schedule_update() {
    if (!update_scheduled) {
        update_scheduled = true;
        resolved_promise.then(flush);
    }
}
function tick() {
    schedule_update();
    return resolved_promise;
}
function add_render_callback(fn) {
    render_callbacks.push(fn);
}
function add_flush_callback(fn) {
    flush_callbacks.push(fn);
}
let flushing = false;
const seen_callbacks = new Set();
function flush() {
    if (flushing)
        return;
    flushing = true;
    do {
        // first, call beforeUpdate functions
        // and update components
        for (let i = 0; i < dirty_components.length; i += 1) {
            const component = dirty_components[i];
            set_current_component(component);
            update(component.$$);
        }
        dirty_components.length = 0;
        while (binding_callbacks.length)
            binding_callbacks.pop()();
        // then, once components are updated, call
        // afterUpdate functions. This may cause
        // subsequent updates...
        for (let i = 0; i < render_callbacks.length; i += 1) {
            const callback = render_callbacks[i];
            if (!seen_callbacks.has(callback)) {
                // ...so guard against infinite loops
                seen_callbacks.add(callback);
                callback();
            }
        }
        render_callbacks.length = 0;
    } while (dirty_components.length);
    while (flush_callbacks.length) {
        flush_callbacks.pop()();
    }
    update_scheduled = false;
    flushing = false;
    seen_callbacks.clear();
}
function update($$) {
    if ($$.fragment !== null) {
        $$.update();
        run_all($$.before_update);
        const dirty = $$.dirty;
        $$.dirty = [-1];
        $$.fragment && $$.fragment.p($$.ctx, dirty);
        $$.after_update.forEach(add_render_callback);
    }
}

let promise;
function wait() {
    if (!promise) {
        promise = Promise.resolve();
        promise.then(() => {
            promise = null;
        });
    }
    return promise;
}
function dispatch(node, direction, kind) {
    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
}
const outroing = new Set();
let outros;
function group_outros() {
    outros = {
        r: 0,
        c: [],
        p: outros // parent group
    };
}
function check_outros() {
    if (!outros.r) {
        run_all(outros.c);
    }
    outros = outros.p;
}
function transition_in(block, local) {
    if (block && block.i) {
        outroing.delete(block);
        block.i(local);
    }
}
function transition_out(block, local, detach, callback) {
    if (block && block.o) {
        if (outroing.has(block))
            return;
        outroing.add(block);
        outros.c.push(() => {
            outroing.delete(block);
            if (callback) {
                if (detach)
                    block.d(1);
                callback();
            }
        });
        block.o(local);
    }
}
const null_transition = { duration: 0 };
function create_in_transition(node, fn, params) {
    let config = fn(node, params);
    let running = false;
    let animation_name;
    let task;
    let uid = 0;
    function cleanup() {
        if (animation_name)
            delete_rule(node, animation_name);
    }
    function go() {
        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
        if (css)
            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
        tick(0, 1);
        const start_time = now() + delay;
        const end_time = start_time + duration;
        if (task)
            task.abort();
        running = true;
        add_render_callback(() => dispatch(node, true, 'start'));
        task = loop(now => {
            if (running) {
                if (now >= end_time) {
                    tick(1, 0);
                    dispatch(node, true, 'end');
                    cleanup();
                    return running = false;
                }
                if (now >= start_time) {
                    const t = easing((now - start_time) / duration);
                    tick(t, 1 - t);
                }
            }
            return running;
        });
    }
    let started = false;
    return {
        start() {
            if (started)
                return;
            delete_rule(node);
            if (is_function(config)) {
                config = config();
                wait().then(go);
            }
            else {
                go();
            }
        },
        invalidate() {
            started = false;
        },
        end() {
            if (running) {
                cleanup();
                running = false;
            }
        }
    };
}

const globals = (typeof window !== 'undefined'
    ? window
    : typeof globalThis !== 'undefined'
        ? globalThis
        : global);

function get_spread_update(levels, updates) {
    const update = {};
    const to_null_out = {};
    const accounted_for = { $$scope: 1 };
    let i = levels.length;
    while (i--) {
        const o = levels[i];
        const n = updates[i];
        if (n) {
            for (const key in o) {
                if (!(key in n))
                    to_null_out[key] = 1;
            }
            for (const key in n) {
                if (!accounted_for[key]) {
                    update[key] = n[key];
                    accounted_for[key] = 1;
                }
            }
            levels[i] = n;
        }
        else {
            for (const key in o) {
                accounted_for[key] = 1;
            }
        }
    }
    for (const key in to_null_out) {
        if (!(key in update))
            update[key] = undefined;
    }
    return update;
}
function get_spread_object(spread_props) {
    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
}

function bind(component, name, callback) {
    const index = component.$$.props[name];
    if (index !== undefined) {
        component.$$.bound[index] = callback;
        callback(component.$$.ctx[index]);
    }
}
function create_component(block) {
    block && block.c();
}
function claim_component(block, parent_nodes) {
    block && block.l(parent_nodes);
}
function mount_component(component, target, anchor) {
    const { fragment, on_mount, on_destroy, after_update } = component.$$;
    fragment && fragment.m(target, anchor);
    // onMount happens before the initial afterUpdate
    add_render_callback(() => {
        const new_on_destroy = on_mount.map(run).filter(is_function);
        if (on_destroy) {
            on_destroy.push(...new_on_destroy);
        }
        else {
            // Edge case - component was destroyed immediately,
            // most likely as a result of a binding initialising
            run_all(new_on_destroy);
        }
        component.$$.on_mount = [];
    });
    after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
    const $$ = component.$$;
    if ($$.fragment !== null) {
        run_all($$.on_destroy);
        $$.fragment && $$.fragment.d(detaching);
        // TODO null out other refs, including component.$$ (but need to
        // preserve final state?)
        $$.on_destroy = $$.fragment = null;
        $$.ctx = [];
    }
}
function make_dirty(component, i) {
    if (component.$$.dirty[0] === -1) {
        dirty_components.push(component);
        schedule_update();
        component.$$.dirty.fill(0);
    }
    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
}
function init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {
    const parent_component = current_component;
    set_current_component(component);
    const prop_values = options.props || {};
    const $$ = component.$$ = {
        fragment: null,
        ctx: null,
        // state
        props,
        update: noop,
        not_equal,
        bound: blank_object(),
        // lifecycle
        on_mount: [],
        on_destroy: [],
        before_update: [],
        after_update: [],
        context: new Map(parent_component ? parent_component.$$.context : []),
        // everything else
        callbacks: blank_object(),
        dirty
    };
    let ready = false;
    $$.ctx = instance
        ? instance(component, prop_values, (i, ret, ...rest) => {
            const value = rest.length ? rest[0] : ret;
            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                if ($$.bound[i])
                    $$.bound[i](value);
                if (ready)
                    make_dirty(component, i);
            }
            return ret;
        })
        : [];
    $$.update();
    ready = true;
    run_all($$.before_update);
    // `false` as a special case of no DOM component
    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
    if (options.target) {
        if (options.hydrate) {
            const nodes = children(options.target);
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.l(nodes);
            nodes.forEach(detach);
        }
        else {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.c();
        }
        if (options.intro)
            transition_in(component.$$.fragment);
        mount_component(component, options.target, options.anchor);
        flush();
    }
    set_current_component(parent_component);
}
class SvelteComponent {
    $destroy() {
        destroy_component(this, 1);
        this.$destroy = noop;
    }
    $on(type, callback) {
        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
        callbacks.push(callback);
        return () => {
            const index = callbacks.indexOf(callback);
            if (index !== -1)
                callbacks.splice(index, 1);
        };
    }
    $set() {
        // overridden by instance, if it has props
    }
}

function dispatch_dev(type, detail) {
    document.dispatchEvent(custom_event(type, Object.assign({ version: '3.24.0' }, detail)));
}
function append_dev(target, node) {
    dispatch_dev("SvelteDOMInsert", { target, node });
    append(target, node);
}
function insert_dev(target, node, anchor) {
    dispatch_dev("SvelteDOMInsert", { target, node, anchor });
    insert(target, node, anchor);
}
function detach_dev(node) {
    dispatch_dev("SvelteDOMRemove", { node });
    detach(node);
}
function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
    const modifiers = options === true ? ["capture"] : options ? Array.from(Object.keys(options)) : [];
    if (has_prevent_default)
        modifiers.push('preventDefault');
    if (has_stop_propagation)
        modifiers.push('stopPropagation');
    dispatch_dev("SvelteDOMAddEventListener", { node, event, handler, modifiers });
    const dispose = listen(node, event, handler, options);
    return () => {
        dispatch_dev("SvelteDOMRemoveEventListener", { node, event, handler, modifiers });
        dispose();
    };
}
function attr_dev(node, attribute, value) {
    attr(node, attribute, value);
    if (value == null)
        dispatch_dev("SvelteDOMRemoveAttribute", { node, attribute });
    else
        dispatch_dev("SvelteDOMSetAttribute", { node, attribute, value });
}
function prop_dev(node, property, value) {
    node[property] = value;
    dispatch_dev("SvelteDOMSetProperty", { node, property, value });
}
function set_data_dev(text, data) {
    data = '' + data;
    if (text.wholeText === data)
        return;
    dispatch_dev("SvelteDOMSetData", { node: text, data });
    text.data = data;
}
function validate_each_argument(arg) {
    if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
        let msg = '{#each} only iterates over array-like objects.';
        if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
            msg += ' You can use a spread to convert this iterable into an array.';
        }
        throw new Error(msg);
    }
}
function validate_slots(name, slot, keys) {
    for (const slot_key of Object.keys(slot)) {
        if (!~keys.indexOf(slot_key)) {
            console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
        }
    }
}
class SvelteComponentDev extends SvelteComponent {
    constructor(options) {
        if (!options || (!options.target && !options.$$inline)) {
            throw new Error(`'target' is a required option`);
        }
        super();
    }
    $destroy() {
        super.$destroy();
        this.$destroy = () => {
            console.warn(`Component was already destroyed`); // eslint-disable-line no-console
        };
    }
    $capture_state() { }
    $inject_state() { }
}

const subscriber_queue = [];
/**
 * Create a `Writable` store that allows both updating and reading by subscription.
 * @param {*=}value initial value
 * @param {StartStopNotifier=}start start and stop notifications for subscriptions
 */
function writable(value, start = noop) {
    let stop;
    const subscribers = [];
    function set(new_value) {
        if (safe_not_equal(value, new_value)) {
            value = new_value;
            if (stop) { // store is ready
                const run_queue = !subscriber_queue.length;
                for (let i = 0; i < subscribers.length; i += 1) {
                    const s = subscribers[i];
                    s[1]();
                    subscriber_queue.push(s, value);
                }
                if (run_queue) {
                    for (let i = 0; i < subscriber_queue.length; i += 2) {
                        subscriber_queue[i][0](subscriber_queue[i + 1]);
                    }
                    subscriber_queue.length = 0;
                }
            }
        }
    }
    function update(fn) {
        set(fn(value));
    }
    function subscribe(run, invalidate = noop) {
        const subscriber = [run, invalidate];
        subscribers.push(subscriber);
        if (subscribers.length === 1) {
            stop = start(set) || noop;
        }
        run(value);
        return () => {
            const index = subscribers.indexOf(subscriber);
            if (index !== -1) {
                subscribers.splice(index, 1);
            }
            if (subscribers.length === 0) {
                stop();
                stop = null;
            }
        };
    }
    return { set, update, subscribe };
}

const CONTEXT_KEY = {};

const preload = () => ({});

/* src/components/Br.svelte generated by Svelte v3.24.0 */

const file = "src/components/Br.svelte";

function add_css() {
	var style = element("style");
	style.id = "svelte-1wzhmg3-style";
	style.textContent = "br{display:block;height:0;content:\"\\00a0\";-webkit-box-sizing:content-box;box-sizing:content-box}br.tiny{margin-top:calc(1em * 0.29)}br.small{margin-top:calc(1em * 0.57)}br.medium,br{margin-top:calc(1em * 1.14)}br.big{margin-top:calc(1em * 2.28)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQnIuc3ZlbHRlIiwic291cmNlcyI6WyJCci5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdD5cbiAgZXhwb3J0IGxldCBzaXplID0gJzFlbSc7XG5cbiAgJDogZm9yYW10dGVkU2l6ZSA9IE51bWJlci5pc0Zpbml0ZSgrc2l6ZSkgPyBgJHtzaXplfXB4YCA6IHR5cGVvZiBzaXplID09PSAnc3RyaW5nJyA/IHNpemUgOiBudWxsXG48L3NjcmlwdD5cblxuPGRpdiBjbGFzcz1cIm92ZXJmbG93LWhpZGRlblwiPlxuICA8YnIgc3R5bGU9e2BtYXJnaW4tdG9wOiAke2ZvcmFtdHRlZFNpemV9YH0gY2xhc3M9eyQkcHJvcHMuY2xhc3N9Lz5cbjwvZGl2PlxuXG48c3R5bGU+XG46Z2xvYmFsKGJyKSB7XG4gIGRpc3BsYXk6IGJsb2NrO1xuICBoZWlnaHQ6IDA7XG4gIGNvbnRlbnQ6IFwiXFwwMGEwXCI7XG4gIC13ZWJraXQtYm94LXNpemluZzogY29udGVudC1ib3g7XG4gICAgICAgICAgYm94LXNpemluZzogY29udGVudC1ib3g7XG59XG5cbjpnbG9iYWwoYnIudGlueSkge1xuICBtYXJnaW4tdG9wOiBjYWxjKDFlbSAqIDAuMjkpOyAvKiA0cHggKi9cbn1cblxuOmdsb2JhbChici5zbWFsbCkge1xuICBtYXJnaW4tdG9wOiBjYWxjKDFlbSAqIDAuNTcpOyAvKiA4cHggKi9cbn1cblxuOmdsb2JhbChici5tZWRpdW0pLFxuOmdsb2JhbChicikge1xuICBtYXJnaW4tdG9wOiBjYWxjKDFlbSAqIDEuMTQpOyAvKiAxNnB4ICovXG59XG5cbjpnbG9iYWwoYnIuYmlnKSB7XG4gIG1hcmdpbi10b3A6IGNhbGMoMWVtICogMi4yOCk7IC8qIDMycHggKi9cbn08L3N0eWxlPlxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQVdRLEVBQUUsQUFBRSxDQUFDLEFBQ1gsT0FBTyxDQUFFLEtBQUssQ0FDZCxNQUFNLENBQUUsQ0FBQyxDQUNULE9BQU8sQ0FBRSxPQUFPLENBQ2hCLGtCQUFrQixDQUFFLFdBQVcsQ0FDdkIsVUFBVSxDQUFFLFdBQVcsQUFDakMsQ0FBQyxBQUVPLE9BQU8sQUFBRSxDQUFDLEFBQ2hCLFVBQVUsQ0FBRSxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEFBQzlCLENBQUMsQUFFTyxRQUFRLEFBQUUsQ0FBQyxBQUNqQixVQUFVLENBQUUsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxBQUM5QixDQUFDLEFBRU8sU0FBUyxBQUFDLENBQ1YsRUFBRSxBQUFFLENBQUMsQUFDWCxVQUFVLENBQUUsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxBQUM5QixDQUFDLEFBRU8sTUFBTSxBQUFFLENBQUMsQUFDZixVQUFVLENBQUUsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxBQUM5QixDQUFDIn0= */";
	append_dev(document.head, style);
}

function create_fragment(ctx) {
	let div;
	let br;
	let br_style_value;
	let br_class_value;

	const block = {
		c: function create() {
			div = element("div");
			br = element("br");
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			br = claim_element(div_nodes, "BR", { style: true, class: true });
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(br, "style", br_style_value = `margin-top: ${/*foramttedSize*/ ctx[0]}`);
			attr_dev(br, "class", br_class_value = /*$$props*/ ctx[1].class);
			add_location(br, file, 7, 2, 179);
			attr_dev(div, "class", "overflow-hidden");
			add_location(div, file, 6, 0, 147);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, br);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*foramttedSize*/ 1 && br_style_value !== (br_style_value = `margin-top: ${/*foramttedSize*/ ctx[0]}`)) {
				attr_dev(br, "style", br_style_value);
			}

			if (dirty & /*$$props*/ 2 && br_class_value !== (br_class_value = /*$$props*/ ctx[1].class)) {
				attr_dev(br, "class", br_class_value);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { size = "1em" } = $$props;
	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Br", $$slots, []);

	$$self.$set = $$new_props => {
		$$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("size" in $$new_props) $$invalidate(2, size = $$new_props.size);
	};

	$$self.$capture_state = () => ({ size, foramttedSize });

	$$self.$inject_state = $$new_props => {
		$$invalidate(1, $$props = assign(assign({}, $$props), $$new_props));
		if ("size" in $$props) $$invalidate(2, size = $$new_props.size);
		if ("foramttedSize" in $$props) $$invalidate(0, foramttedSize = $$new_props.foramttedSize);
	};

	let foramttedSize;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 4) {
			 $$invalidate(0, foramttedSize = Number.isFinite(+size)
			? `${size}px`
			: typeof size === "string" ? size : null);
		}
	};

	$$props = exclude_internal_props($$props);
	return [foramttedSize, $$props, size];
}

class Br extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document.getElementById("svelte-1wzhmg3-style")) add_css();
		init(this, options, instance, create_fragment, safe_not_equal, { size: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Br",
			options,
			id: create_fragment.name
		});
	}

	get size() {
		throw new Error("<Br>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<Br>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Built-in value references. */
var Symbol$1 = root.Symbol;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

/** Used for built-in method references. */
var objectProto$1 = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString$1 = objectProto$1.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString$1.call(value);
}

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag$1 && symToStringTag$1 in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto$1 = Function.prototype,
    objectProto$2 = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString$1 = funcProto$1.toString;

/** Used to check objects for own properties. */
var hasOwnProperty$1 = objectProto$2.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString$1.call(hasOwnProperty$1).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto$3 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$2 = objectProto$3.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty$2.call(data, key) ? data[key] : undefined;
}

/** Used for built-in method references. */
var objectProto$4 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$3 = objectProto$4.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty$3.call(data, key);
}

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED$1 : value;
  return this;
}

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/* Built-in method references that are verified to be native. */
var Map$1 = getNative(root, 'Map');

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map$1 || ListCache),
    'string': new Hash
  };
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = MapCache;

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46 /* . */) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

/** Used as references for various `Number` constants. */
var INFINITY$1 = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY$1) ? '-0' : result;
}

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

/** Used for built-in method references. */
var objectProto$5 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$4 = objectProto$5.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$4.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */
function baseSet(object, path, value, customizer) {
  if (!isObject(object)) {
    return object;
  }
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    var key = toKey(path[index]),
        newValue = value;

    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : undefined;
      if (newValue === undefined) {
        newValue = isObject(objValue)
          ? objValue
          : (isIndex(path[index + 1]) ? [] : {});
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}

/**
 * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
 * it's created. Arrays are created for missing index properties while objects
 * are created for all other missing properties. Use `_.setWith` to customize
 * `path` creation.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.set(object, 'a[0].b.c', 4);
 * console.log(object.a[0].b.c);
 * // => 4
 *
 * _.set(object, ['x', '0', 'y', 'z'], 5);
 * console.log(object.x[0].y.z);
 * // => 5
 */
function set(object, path, value) {
  return object == null ? object : baseSet(object, path, value);
}

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map$1 || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED$2);
  return this;
}

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(array);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

/** Built-in value references. */
var Uint8Array$1 = root.Uint8Array;

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$1 = 1,
    COMPARE_UNORDERED_FLAG$1 = 2;

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag$1 = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : undefined,
    symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array$1(object), new Uint8Array$1(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG$1;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag$1:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

/** Used for built-in method references. */
var objectProto$6 = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto$6.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

/** Used for built-in method references. */
var objectProto$7 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$5 = objectProto$7.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable$1 = objectProto$7.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty$5.call(value, 'callee') &&
    !propertyIsEnumerable$1.call(value, 'callee');
};

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer$1 = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER$1 = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
}

/** `Object#toString` result references. */
var argsTag$1 = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag$1 = '[object Boolean]',
    dateTag$1 = '[object Date]',
    errorTag$1 = '[object Error]',
    funcTag$1 = '[object Function]',
    mapTag$1 = '[object Map]',
    numberTag$1 = '[object Number]',
    objectTag = '[object Object]',
    regexpTag$1 = '[object RegExp]',
    setTag$1 = '[object Set]',
    stringTag$1 = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag$1 = '[object ArrayBuffer]',
    dataViewTag$1 = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag$1] = typedArrayTags[boolTag$1] =
typedArrayTags[dataViewTag$1] = typedArrayTags[dateTag$1] =
typedArrayTags[errorTag$1] = typedArrayTags[funcTag$1] =
typedArrayTags[mapTag$1] = typedArrayTags[numberTag$1] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag$1] =
typedArrayTags[setTag$1] = typedArrayTags[stringTag$1] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/** Detect free variable `exports`. */
var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports$1 && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule$1 && freeModule$1.require && freeModule$1.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

/** Used for built-in method references. */
var objectProto$8 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$6 = objectProto$8.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty$6.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

/** Used for built-in method references. */
var objectProto$9 = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$9;

  return value === proto;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

/** Used for built-in method references. */
var objectProto$a = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$7 = objectProto$a.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$7.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$2 = 1;

/** Used for built-in method references. */
var objectProto$b = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$8 = objectProto$b.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty$8.call(other, key))) {
      return false;
    }
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(object);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

/* Built-in method references that are verified to be native. */
var DataView$1 = getNative(root, 'DataView');

/* Built-in method references that are verified to be native. */
var Promise$1 = getNative(root, 'Promise');

/* Built-in method references that are verified to be native. */
var Set$1 = getNative(root, 'Set');

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

/** `Object#toString` result references. */
var mapTag$2 = '[object Map]',
    objectTag$1 = '[object Object]',
    promiseTag = '[object Promise]',
    setTag$2 = '[object Set]',
    weakMapTag$1 = '[object WeakMap]';

var dataViewTag$2 = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView$1),
    mapCtorString = toSource(Map$1),
    promiseCtorString = toSource(Promise$1),
    setCtorString = toSource(Set$1),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag$2) ||
    (Map$1 && getTag(new Map$1) != mapTag$2) ||
    (Promise$1 && getTag(Promise$1.resolve()) != promiseTag) ||
    (Set$1 && getTag(new Set$1) != setTag$2) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag$1)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag$1 ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag$2;
        case mapCtorString: return mapTag$2;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag$2;
        case weakMapCtorString: return weakMapTag$1;
      }
    }
    return result;
  };
}

var getTag$1 = getTag;

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$3 = 1;

/** `Object#toString` result references. */
var argsTag$2 = '[object Arguments]',
    arrayTag$1 = '[object Array]',
    objectTag$2 = '[object Object]';

/** Used for built-in method references. */
var objectProto$c = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$9 = objectProto$c.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag$1 : getTag$1(object),
      othTag = othIsArr ? arrayTag$1 : getTag$1(other);

  objTag = objTag == argsTag$2 ? objectTag$2 : objTag;
  othTag = othTag == argsTag$2 ? objectTag$2 : othTag;

  var objIsObj = objTag == objectTag$2,
      othIsObj = othTag == objectTag$2,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG$3)) {
    var objIsWrapped = objIsObj && hasOwnProperty$9.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty$9.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$4 = 1,
    COMPARE_UNORDERED_FLAG$2 = 2;

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack;
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined
            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$4 | COMPARE_UNORDERED_FLAG$2, customizer, stack)
            : result
          )) {
        return false;
      }
    }
  }
  return true;
}

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !isObject(value);
}

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];

    result[length] = [key, value, isStrictComparable(value)];
  }
  return result;
}

/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue &&
      (srcValue !== undefined || (key in Object(object)));
  };
}

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) &&
    (isArray(object) || isArguments(object));
}

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$5 = 1,
    COMPARE_UNORDERED_FLAG$3 = 2;

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get(object, path);
    return (objValue === undefined && objValue === srcValue)
      ? hasIn(object, path)
      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$5 | COMPARE_UNORDERED_FLAG$3);
  };
}

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity$1(value) {
  return value;
}

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep(path) {
  return function(object) {
    return baseGet(object, path);
  };
}

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return identity$1;
  }
  if (typeof value == 'object') {
    return isArray(value)
      ? baseMatchesProperty(value[0], value[1])
      : baseMatches(value);
  }
  return property(value);
}

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}

/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while ((fromRight ? index-- : ++index < length)) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}

/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */
var baseEach = createBaseEach(baseForOwn);

/**
 * The base implementation of `_.map` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function baseMap(collection, iteratee) {
  var index = -1,
      result = isArrayLike(collection) ? Array(collection.length) : [];

  baseEach(collection, function(value, key, collection) {
    result[++index] = iteratee(value, key, collection);
  });
  return result;
}

/**
 * Creates an array of values by running each element in `collection` thru
 * `iteratee`. The iteratee is invoked with three arguments:
 * (value, index|key, collection).
 *
 * Many lodash methods are guarded to work as iteratees for methods like
 * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
 *
 * The guarded methods are:
 * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
 * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
 * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
 * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 * @example
 *
 * function square(n) {
 *   return n * n;
 * }
 *
 * _.map([4, 8], square);
 * // => [16, 64]
 *
 * _.map({ 'a': 4, 'b': 8 }, square);
 * // => [16, 64] (iteration order is not guaranteed)
 *
 * var users = [
 *   { 'user': 'barney' },
 *   { 'user': 'fred' }
 * ];
 *
 * // The `_.property` iteratee shorthand.
 * _.map(users, 'user');
 * // => ['barney', 'fred']
 */
function map(collection, iteratee) {
  var func = isArray(collection) ? arrayMap : baseMap;
  return func(collection, baseIteratee(iteratee));
}

/**
 * Creates a `_.find` or `_.findLast` function.
 *
 * @private
 * @param {Function} findIndexFunc The function to find the collection index.
 * @returns {Function} Returns the new find function.
 */
function createFind(findIndexFunc) {
  return function(collection, predicate, fromIndex) {
    var iterable = Object(collection);
    if (!isArrayLike(collection)) {
      var iteratee = baseIteratee(predicate);
      collection = keys(collection);
      predicate = function(key) { return iteratee(iterable[key], key, iterable); };
    }
    var index = findIndexFunc(collection, predicate, fromIndex);
    return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
  };
}

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

/** Used as references for various `Number` constants. */
var INFINITY$2 = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY$2 || value === -INFINITY$2) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger(value) {
  var result = toFinite(value),
      remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * This method is like `_.find` except that it returns the index of the first
 * element `predicate` returns truthy for instead of the element itself.
 *
 * @static
 * @memberOf _
 * @since 1.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {number} Returns the index of the found element, else `-1`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'active': false },
 *   { 'user': 'fred',    'active': false },
 *   { 'user': 'pebbles', 'active': true }
 * ];
 *
 * _.findIndex(users, function(o) { return o.user == 'barney'; });
 * // => 0
 *
 * // The `_.matches` iteratee shorthand.
 * _.findIndex(users, { 'user': 'fred', 'active': false });
 * // => 1
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.findIndex(users, ['active', false]);
 * // => 0
 *
 * // The `_.property` iteratee shorthand.
 * _.findIndex(users, 'active');
 * // => 2
 */
function findIndex(array, predicate, fromIndex) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return -1;
  }
  var index = fromIndex == null ? 0 : toInteger(fromIndex);
  if (index < 0) {
    index = nativeMax(length + index, 0);
  }
  return baseFindIndex(array, baseIteratee(predicate), index);
}

/**
 * Iterates over elements of `collection`, returning the first element
 * `predicate` returns truthy for. The predicate is invoked with three
 * arguments: (value, index|key, collection).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {*} Returns the matched element, else `undefined`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'age': 36, 'active': true },
 *   { 'user': 'fred',    'age': 40, 'active': false },
 *   { 'user': 'pebbles', 'age': 1,  'active': true }
 * ];
 *
 * _.find(users, function(o) { return o.age < 40; });
 * // => object for 'barney'
 *
 * // The `_.matches` iteratee shorthand.
 * _.find(users, { 'age': 1, 'active': true });
 * // => object for 'pebbles'
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.find(users, ['active', false]);
 * // => object for 'fred'
 *
 * // The `_.property` iteratee shorthand.
 * _.find(users, 'active');
 * // => object for 'barney'
 */
var find = createFind(findIndex);

/** `Object#toString` result references. */
var mapTag$3 = '[object Map]',
    setTag$3 = '[object Set]';

/** Used for built-in method references. */
var objectProto$d = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$a = objectProto$d.hasOwnProperty;

/**
 * Checks if `value` is an empty object, collection, map, or set.
 *
 * Objects are considered empty if they have no own enumerable string keyed
 * properties.
 *
 * Array-like values such as `arguments` objects, arrays, buffers, strings, or
 * jQuery-like collections are considered empty if they have a `length` of `0`.
 * Similarly, maps and sets are considered empty if they have a `size` of `0`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
 * @example
 *
 * _.isEmpty(null);
 * // => true
 *
 * _.isEmpty(true);
 * // => true
 *
 * _.isEmpty(1);
 * // => true
 *
 * _.isEmpty([1, 2, 3]);
 * // => false
 *
 * _.isEmpty({ 'a': 1 });
 * // => false
 */
function isEmpty(value) {
  if (value == null) {
    return true;
  }
  if (isArrayLike(value) &&
      (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
        isBuffer(value) || isTypedArray(value) || isArguments(value))) {
    return !value.length;
  }
  var tag = getTag$1(value);
  if (tag == mapTag$3 || tag == setTag$3) {
    return !value.size;
  }
  if (isPrototype(value)) {
    return !baseKeys(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty$a.call(value, key)) {
      return false;
    }
  }
  return true;
}

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

/** Used for built-in method references. */
var objectProto$e = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$b = objectProto$e.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty$b.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn$1(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn$1(source), object);
}

/** Detect free variable `exports`. */
var freeExports$2 = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule$2 = freeExports$2 && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;

/** Built-in value references. */
var Buffer$2 = moduleExports$2 ? root.Buffer : undefined,
    allocUnsafe = Buffer$2 ? Buffer$2.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols$1 = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols$1 ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }
  return result;
};

/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn(source), object);
}

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn$1, getSymbolsIn);
}

/** Used for built-in method references. */
var objectProto$f = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$c = objectProto$f.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty$c.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
  return result;
}

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

/** Used to convert symbols to primitives and strings. */
var symbolProto$2 = Symbol$1 ? Symbol$1.prototype : undefined,
    symbolValueOf$1 = symbolProto$2 ? symbolProto$2.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
}

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

/** `Object#toString` result references. */
var boolTag$2 = '[object Boolean]',
    dateTag$2 = '[object Date]',
    mapTag$4 = '[object Map]',
    numberTag$2 = '[object Number]',
    regexpTag$2 = '[object RegExp]',
    setTag$4 = '[object Set]',
    stringTag$2 = '[object String]',
    symbolTag$2 = '[object Symbol]';

var arrayBufferTag$2 = '[object ArrayBuffer]',
    dataViewTag$3 = '[object DataView]',
    float32Tag$1 = '[object Float32Array]',
    float64Tag$1 = '[object Float64Array]',
    int8Tag$1 = '[object Int8Array]',
    int16Tag$1 = '[object Int16Array]',
    int32Tag$1 = '[object Int32Array]',
    uint8Tag$1 = '[object Uint8Array]',
    uint8ClampedTag$1 = '[object Uint8ClampedArray]',
    uint16Tag$1 = '[object Uint16Array]',
    uint32Tag$1 = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag$2:
      return cloneArrayBuffer(object);

    case boolTag$2:
    case dateTag$2:
      return new Ctor(+object);

    case dataViewTag$3:
      return cloneDataView(object, isDeep);

    case float32Tag$1: case float64Tag$1:
    case int8Tag$1: case int16Tag$1: case int32Tag$1:
    case uint8Tag$1: case uint8ClampedTag$1: case uint16Tag$1: case uint32Tag$1:
      return cloneTypedArray(object, isDeep);

    case mapTag$4:
      return new Ctor;

    case numberTag$2:
    case stringTag$2:
      return new Ctor(object);

    case regexpTag$2:
      return cloneRegExp(object);

    case setTag$4:
      return new Ctor;

    case symbolTag$2:
      return cloneSymbol(object);
  }
}

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

/** `Object#toString` result references. */
var mapTag$5 = '[object Map]';

/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */
function baseIsMap(value) {
  return isObjectLike(value) && getTag$1(value) == mapTag$5;
}

/* Node.js helper references. */
var nodeIsMap = nodeUtil && nodeUtil.isMap;

/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */
var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

/** `Object#toString` result references. */
var setTag$5 = '[object Set]';

/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */
function baseIsSet(value) {
  return isObjectLike(value) && getTag$1(value) == setTag$5;
}

/* Node.js helper references. */
var nodeIsSet = nodeUtil && nodeUtil.isSet;

/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */
var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/** `Object#toString` result references. */
var argsTag$3 = '[object Arguments]',
    arrayTag$2 = '[object Array]',
    boolTag$3 = '[object Boolean]',
    dateTag$3 = '[object Date]',
    errorTag$2 = '[object Error]',
    funcTag$2 = '[object Function]',
    genTag$1 = '[object GeneratorFunction]',
    mapTag$6 = '[object Map]',
    numberTag$3 = '[object Number]',
    objectTag$3 = '[object Object]',
    regexpTag$3 = '[object RegExp]',
    setTag$6 = '[object Set]',
    stringTag$3 = '[object String]',
    symbolTag$3 = '[object Symbol]',
    weakMapTag$2 = '[object WeakMap]';

var arrayBufferTag$3 = '[object ArrayBuffer]',
    dataViewTag$4 = '[object DataView]',
    float32Tag$2 = '[object Float32Array]',
    float64Tag$2 = '[object Float64Array]',
    int8Tag$2 = '[object Int8Array]',
    int16Tag$2 = '[object Int16Array]',
    int32Tag$2 = '[object Int32Array]',
    uint8Tag$2 = '[object Uint8Array]',
    uint8ClampedTag$2 = '[object Uint8ClampedArray]',
    uint16Tag$2 = '[object Uint16Array]',
    uint32Tag$2 = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag$3] = cloneableTags[arrayTag$2] =
cloneableTags[arrayBufferTag$3] = cloneableTags[dataViewTag$4] =
cloneableTags[boolTag$3] = cloneableTags[dateTag$3] =
cloneableTags[float32Tag$2] = cloneableTags[float64Tag$2] =
cloneableTags[int8Tag$2] = cloneableTags[int16Tag$2] =
cloneableTags[int32Tag$2] = cloneableTags[mapTag$6] =
cloneableTags[numberTag$3] = cloneableTags[objectTag$3] =
cloneableTags[regexpTag$3] = cloneableTags[setTag$6] =
cloneableTags[stringTag$3] = cloneableTags[symbolTag$3] =
cloneableTags[uint8Tag$2] = cloneableTags[uint8ClampedTag$2] =
cloneableTags[uint16Tag$2] = cloneableTags[uint32Tag$2] = true;
cloneableTags[errorTag$2] = cloneableTags[funcTag$2] =
cloneableTags[weakMapTag$2] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag$1(value),
        isFunc = tag == funcTag$2 || tag == genTag$1;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag$3 || tag == argsTag$3 || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat
          ? copySymbolsIn(value, baseAssignIn(result, value))
          : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (isSet(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap(value)) {
    value.forEach(function(subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
  }

  var keysFunc = isFull
    ? (isFlat ? getAllKeysIn : getAllKeys)
    : (isFlat ? keysIn : keys);

  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG$1 = 1,
    CLONE_SYMBOLS_FLAG$1 = 4;

/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */
function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG$1 | CLONE_SYMBOLS_FLAG$1);
}



var _ = /*#__PURE__*/Object.freeze({
    __proto__: null,
    get: get,
    set: set,
    map: map,
    find: find,
    isEmpty: isEmpty,
    cloneDeep: cloneDeep
});

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

// Older browsers don't support event options, feature detect it.

// Adopted and modified solution from Bohdan Didukh (2017)
// https://stackoverflow.com/questions/41594997/ios-10-safari-prevent-scrolling-behind-a-fixed-overlay-and-maintain-scroll-posi

var hasPassiveEvents = false;
if (typeof window !== 'undefined') {
  var passiveTestOptions = {
    get passive() {
      hasPassiveEvents = true;
      return undefined;
    }
  };
  window.addEventListener('testPassive', null, passiveTestOptions);
  window.removeEventListener('testPassive', null, passiveTestOptions);
}

var isIosDevice = typeof window !== 'undefined' && window.navigator && window.navigator.platform && (/iP(ad|hone|od)/.test(window.navigator.platform) || window.navigator.platform === 'MacIntel' && window.navigator.maxTouchPoints > 1);


var locks = [];
var documentListenerAdded = false;
var initialClientY = -1;
var previousBodyOverflowSetting = void 0;
var previousBodyPaddingRight = void 0;

// returns true if `el` should be allowed to receive touchmove events.
var allowTouchMove = function allowTouchMove(el) {
  return locks.some(function (lock) {
    if (lock.options.allowTouchMove && lock.options.allowTouchMove(el)) {
      return true;
    }

    return false;
  });
};

var preventDefault = function preventDefault(rawEvent) {
  var e = rawEvent || window.event;

  // For the case whereby consumers adds a touchmove event listener to document.
  // Recall that we do document.addEventListener('touchmove', preventDefault, { passive: false })
  // in disableBodyScroll - so if we provide this opportunity to allowTouchMove, then
  // the touchmove event on document will break.
  if (allowTouchMove(e.target)) {
    return true;
  }

  // Do not prevent if the event has more than one touch (usually meaning this is a multi touch gesture like pinch to zoom).
  if (e.touches.length > 1) return true;

  if (e.preventDefault) e.preventDefault();

  return false;
};

var setOverflowHidden = function setOverflowHidden(options) {
  // Setting overflow on body/documentElement synchronously in Desktop Safari slows down
  // the responsiveness for some reason. Setting within a setTimeout fixes this.
  setTimeout(function () {
    // If previousBodyPaddingRight is already set, don't set it again.
    if (previousBodyPaddingRight === undefined) {
      var _reserveScrollBarGap = !!options && options.reserveScrollBarGap === true;
      var scrollBarGap = window.innerWidth - document.documentElement.clientWidth;

      if (_reserveScrollBarGap && scrollBarGap > 0) {
        previousBodyPaddingRight = document.body.style.paddingRight;
        document.body.style.paddingRight = scrollBarGap + 'px';
      }
    }

    // If previousBodyOverflowSetting is already set, don't set it again.
    if (previousBodyOverflowSetting === undefined) {
      previousBodyOverflowSetting = document.body.style.overflow;
      document.body.style.overflow = 'hidden';
    }
  });
};

var restoreOverflowSetting = function restoreOverflowSetting() {
  // Setting overflow on body/documentElement synchronously in Desktop Safari slows down
  // the responsiveness for some reason. Setting within a setTimeout fixes this.
  setTimeout(function () {
    if (previousBodyPaddingRight !== undefined) {
      document.body.style.paddingRight = previousBodyPaddingRight;

      // Restore previousBodyPaddingRight to undefined so setOverflowHidden knows it
      // can be set again.
      previousBodyPaddingRight = undefined;
    }

    if (previousBodyOverflowSetting !== undefined) {
      document.body.style.overflow = previousBodyOverflowSetting;

      // Restore previousBodyOverflowSetting to undefined
      // so setOverflowHidden knows it can be set again.
      previousBodyOverflowSetting = undefined;
    }
  });
};

// https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollHeight#Problems_and_solutions
var isTargetElementTotallyScrolled = function isTargetElementTotallyScrolled(targetElement) {
  return targetElement ? targetElement.scrollHeight - targetElement.scrollTop <= targetElement.clientHeight : false;
};

var handleScroll = function handleScroll(event, targetElement) {
  var clientY = event.targetTouches[0].clientY - initialClientY;

  if (allowTouchMove(event.target)) {
    return false;
  }

  if (targetElement && targetElement.scrollTop === 0 && clientY > 0) {
    // element is at the top of its scroll.
    return preventDefault(event);
  }

  if (isTargetElementTotallyScrolled(targetElement) && clientY < 0) {
    // element is at the bottom of its scroll.
    return preventDefault(event);
  }

  event.stopPropagation();
  return true;
};

var disableBodyScroll = function disableBodyScroll(targetElement, options) {
  if (isIosDevice) {
    // targetElement must be provided, and disableBodyScroll must not have been
    // called on this targetElement before.
    if (!targetElement) {
      // eslint-disable-next-line no-console
      console.error('disableBodyScroll unsuccessful - targetElement must be provided when calling disableBodyScroll on IOS devices.');
      return;
    }

    if (targetElement && !locks.some(function (lock) {
      return lock.targetElement === targetElement;
    })) {
      var lock = {
        targetElement: targetElement,
        options: options || {}
      };

      locks = [].concat(_toConsumableArray(locks), [lock]);

      targetElement.ontouchstart = function (event) {
        if (event.targetTouches.length === 1) {
          // detect single touch.
          initialClientY = event.targetTouches[0].clientY;
        }
      };
      targetElement.ontouchmove = function (event) {
        if (event.targetTouches.length === 1) {
          // detect single touch.
          handleScroll(event, targetElement);
        }
      };

      if (!documentListenerAdded) {
        document.addEventListener('touchmove', preventDefault, hasPassiveEvents ? { passive: false } : undefined);
        documentListenerAdded = true;
      }
    }
  } else {
    setOverflowHidden(options);
    var _lock = {
      targetElement: targetElement,
      options: options || {}
    };

    locks = [].concat(_toConsumableArray(locks), [_lock]);
  }
};

var enableBodyScroll = function enableBodyScroll(targetElement) {
  if (isIosDevice) {
    if (!targetElement) {
      // eslint-disable-next-line no-console
      console.error('enableBodyScroll unsuccessful - targetElement must be provided when calling enableBodyScroll on IOS devices.');
      return;
    }

    targetElement.ontouchstart = null;
    targetElement.ontouchmove = null;

    locks = locks.filter(function (lock) {
      return lock.targetElement !== targetElement;
    });

    if (documentListenerAdded && locks.length === 0) {
      document.removeEventListener('touchmove', preventDefault, hasPassiveEvents ? { passive: false } : undefined);

      documentListenerAdded = false;
    }
  } else {
    locks = locks.filter(function (lock) {
      return lock.targetElement !== targetElement;
    });
    if (!locks.length) {
      restoreOverflowSetting();
    }
  }
};

const DURATION = 500;
let scroll;
let scrollCheckInterval;
function preventInertialScroll(e) {
    if (e && e.touches.length !== 1) return

    function scrollTo(top) {
        // document.documentElement.scrollTop = scroll
        window.scrollTo({
            top,
            left: 0,
            behavior: 'smooth'
        });
    }

    function recursive() {
        if (document.documentElement.scrollTop !== scroll) {
            scrollTo(scroll);
            requestAnimationFrame(recursive);
        } else {
            const time = performance.now();
            function stopScroll() {
                if (performance.now() - time < DURATION) {
                    scrollTo(scroll);
                    requestAnimationFrame(stopScroll);
                }
            }
            stopScroll();
        }
    }
    recursive();
}

/**
 * 
 * @attr body-scroll-lock-ignore - to ignor lock.
 * 
 * @param {HTMLElement} container
 * @param {{
 *  extraLock?: boolean (false)
 * }} config
 */
function disableScroll(container, config = {}) {
    if (typeof window !== 'undefined') {
        document.body.classList.add('body-scroll-lock');

        if (config.extraLock) {
            scroll = document.documentElement.scrollTop;
            document.documentElement.ontouchstart = () => scroll = document.documentElement.scrollTop;
            document.documentElement.ontouchmove = preventInertialScroll;
            document.documentElement.ontouchend = preventInertialScroll;
            scrollCheckInterval = setInterval(() => {
                if (document.documentElement.scrollTop !== scroll) {
                    preventInertialScroll();
                }
            }, DURATION);
        }
    }

    disableBodyScroll(container, {
        allowTouchMove: el => {
            while (el && el !== document.body) {
                if (el.getAttribute('body-scroll-lock-ignore') !== null) {
                    return true;
                }
                el = el.parentNode;
            }
        },
    });
}

function enableScroll(container, config = {}) {
    if (typeof window !== 'undefined') {
        document.body.classList.remove('body-scroll-lock');

        if (config.extraLock) {
            document.documentElement.ontouchstart = null;
            document.documentElement.ontouchmove = null;
            document.documentElement.ontouchend = null;
            clearInterval(scrollCheckInterval);
        }
    }

    enableBodyScroll(container);
}

var bodyScroll = /*#__PURE__*/Object.freeze({
    __proto__: null,
    disableScroll: disableScroll,
    enableScroll: enableScroll
});

function uuidv4() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        let r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });
}

async function delay (ms, isError) {
  return new Promise((res, rej) => setTimeout(isError ? rej : res, ms))
}

/**
 *
 * @function safeGet
 *
 * @description Safe getting of an any value of a nested objects.
 *
 * @param expressionFn {function} - The function with an expression which returns result of the safe getting.
 * @param defaultValue {any} - The default value when result is undefined.
 * @param isDefaultTyped {boolean} - Wheter is the result from an expression must be the same type as the default value.
 *
 * @examples
 * // Some data.
 * const very = {
 *  nested: {
 *   object: [{
 *     with: {
 *       arrays: 'stuff'
 *     }
 *   }]
 *  }
 * }
 *
 * // Getting.
 * 1. safeGet(() => very.nested.object[0].with.arrays);
 * 2. safeGet(() => very.nested.object[0].with.arrays, { default: 'value' });
 * 3. safeGet(() => very.nested.object[0].with.arrays, { default: 'value' }, true);
 *
 * // Return.
 * 1. 'stuff'
 * 2. 'stuff'
 * 3. { default: 'value' }
 */
function safeGet(expressionFn, defaultValue, isDefaultTyped = false) {
  // Check whether a and b have the same type. (util)
  function isSameType(a, b) {
    const rules = [
      (a, b) => typeof a === typeof b,
      (a, b) => (+a === a) === (+b === b),              // whether one is NaN
      (a, b) => (a === null) === (b === null),          // null is object type too
      (a, b) => Array.isArray(a) === Array.isArray(b),  // array is object type too
    ];
    return !rules.some(ruleFn => !ruleFn(a, b))
  }
  // Core of safe getting. Executing a function. Default values.
  function get(expressionFn, defaultValue, isDefaultTyped) {
    try {
      const result = expressionFn.call(this);
      if (isDefaultTyped) {
        return isSameType(result, defaultValue) ? result : defaultValue
      } else {
        return result === undefined ? defaultValue : result
      }
    } catch (e) {
      return defaultValue
    }
  }
  // Safe getting of the expressionFn.
  if (typeof expressionFn === 'function') {
    return get(expressionFn, defaultValue, isDefaultTyped)
  } else {
    console.warn('You need to use a function as the first argument.');
  }
  return defaultValue
}

function waitUntil(fn, { timeout = 5000, interval = 500 } = {}) {
  let timer = null;
  let intervalTimer = null;
  return new Promise(function (res, rej) {
    timer = setTimeout(rej, timeout, new Error('Error: Timeout'));
    intervalTimer = setInterval(async () => {
      try {
        const result = await fn();
        clearTimeout(timer);
        clearInterval(intervalTimer);
        res(result);
      } catch (_e) {}
    }, interval);
  })
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var classnames = createCommonjsModule(function (module) {
/*!
  Copyright (c) 2017 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {

	var hasOwn = {}.hasOwnProperty;

	function classNames () {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg) && arg.length) {
				var inner = classNames.apply(null, arg);
				if (inner) {
					classes.push(inner);
				}
			} else if (argType === 'object') {
				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if ( module.exports) {
		classNames.default = classNames;
		module.exports = classNames;
	} else {
		window.classNames = classNames;
	}
}());
});

function toCSSString(styles = {}) {
  return Object.entries(styles)
    .filter(([_propName, propValue]) => propValue !== undefined && propValue !== null)
    .reduce((styleString, [propName, propValue]) => {
      propName = propName.replace(/[A-Z]/g, match => `-${match.toLowerCase()}`);
      return `${styleString}${propName}:${propValue};`
    }, '')
}

function getScrollPercent(container, child) {
    const p = container;
    const c = child;
    const st = 'scrollTop';
    const sl = 'scrollLeft';
    const sh = 'scrollHeight';
    const sw = 'scrollWidth';
    return {
        x:  (p[sl] || c[sl]) / (((p[sw] || c[sw]) - p.clientWidth) || 1) * 100,
        y:  (p[st] || c[st]) / (((p[sh] || c[sh]) - p.clientHeight) || 1) * 100,
        p,
        c,
        st,
        sl,
        sh,
        sw,
    }
}

function formatTextToBullets(text) {
    const lines = typeof text === 'string' ? text.split(/[\n\r]/gm) : [];
    const plainTextLines = lines.map(line => line.replace(/^(•\s+)/g, ''));
    const filteredLines = plainTextLines.filter(line => line !== '•');
    const formattedLines = filteredLines.map(line => `• ${line}`);
    return formattedLines.join('\n')
}

function disableDoubleTapZoom(elements) {
    [].concat(elements || []).forEach((el) => {
        let lastTouchEnd = 0;
		el.addEventListener('touchend', function(event) {
			const now = (new Date()).getTime();
			if (now - lastTouchEnd <= 300) {
				event.preventDefault();
			}
			lastTouchEnd = now;
		}, false);
    });
}

function stopPropagationInRanges(el, ranges = { x: [0, 100], y: [0, 100] }, onChange) {
    el.ontouchstart = controllScroll;
    el.ontouchmove = controllScroll;
    el.ontouchend = controllScroll;
    
    function controllScroll(e) {
        const params = getScrollPercent(el, el.children[0]);
        if (
            params.x >= ranges.x[0] && params.x <= ranges.x[1] &&
            params.y >= ranges.y[0] && params.y <= ranges.y[1]
        ) {
            e.stopPropagation();
        }
        if (typeof onChange === 'function') {
            return onChange({ ...params, e })
        }
    }
}

var setup = {
  BACKEND_URL: 'mock', // '/Charitify/', // charitify-application.page.link/?link=https://charitify-application.firebaseio.com&apn=package_name

  MAPBOX_KEY: 'mapbox',
};

/* node_modules/svelte-icons/components/IconBase.svelte generated by Svelte v3.24.0 */

const file$1 = "node_modules/svelte-icons/components/IconBase.svelte";

function add_css$1() {
	var style = element("style");
	style.id = "svelte-vfq7n1-style";
	style.textContent = "svg.svelte-vfq7n1{stroke:currentColor;fill:currentColor;stroke-width:0;width:100%;height:auto;max-height:100%}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSWNvbkJhc2Uuc3ZlbHRlIiwic291cmNlcyI6WyJJY29uQmFzZS5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdD5cbiAgZXhwb3J0IGxldCB0aXRsZSA9IG51bGw7XG4gIGV4cG9ydCBsZXQgdmlld0JveDtcbjwvc2NyaXB0PlxuXG48c3R5bGU+XG5zdmcge1xuICBzdHJva2U6IGN1cnJlbnRDb2xvcjtcbiAgZmlsbDogY3VycmVudENvbG9yO1xuICBzdHJva2Utd2lkdGg6IDA7XG4gIHdpZHRoOiAxMDAlO1xuICBoZWlnaHQ6IGF1dG87XG4gIG1heC1oZWlnaHQ6IDEwMCU7XG59PC9zdHlsZT5cblxuPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIge3ZpZXdCb3h9PlxuICB7I2lmIHRpdGxlfVxuICAgIDx0aXRsZT57dGl0bGV9PC90aXRsZT5cbiAgey9pZn1cbiAgPHNsb3QgLz5cbjwvc3ZnPlxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQU1BLEdBQUcsY0FBQyxDQUFDLEFBQ0gsTUFBTSxDQUFFLFlBQVksQ0FDcEIsSUFBSSxDQUFFLFlBQVksQ0FDbEIsWUFBWSxDQUFFLENBQUMsQ0FDZixLQUFLLENBQUUsSUFBSSxDQUNYLE1BQU0sQ0FBRSxJQUFJLENBQ1osVUFBVSxDQUFFLElBQUksQUFDbEIsQ0FBQyJ9 */";
	append_dev(document.head, style);
}

// (17:2) {#if title}
function create_if_block(ctx) {
	let title_1;
	let t;

	const block = {
		c: function create() {
			title_1 = svg_element("title");
			t = text(/*title*/ ctx[0]);
			this.h();
		},
		l: function claim(nodes) {
			title_1 = claim_element(nodes, "title", {}, 1);
			var title_1_nodes = children(title_1);
			t = claim_text(title_1_nodes, /*title*/ ctx[0]);
			title_1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(title_1, file$1, 17, 4, 279);
		},
		m: function mount(target, anchor) {
			insert_dev(target, title_1, anchor);
			append_dev(title_1, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*title*/ 1) set_data_dev(t, /*title*/ ctx[0]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(title_1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(17:2) {#if title}",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let svg;
	let if_block_anchor;
	let current;
	let if_block = /*title*/ ctx[0] && create_if_block(ctx);
	const default_slot_template = /*$$slots*/ ctx[3].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

	const block = {
		c: function create() {
			svg = svg_element("svg");
			if (if_block) if_block.c();
			if_block_anchor = empty();
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			svg = claim_element(nodes, "svg", { xmlns: true, viewBox: true, class: true }, 1);
			var svg_nodes = children(svg);
			if (if_block) if_block.l(svg_nodes);
			if_block_anchor = empty();
			if (default_slot) default_slot.l(svg_nodes);
			svg_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "viewBox", /*viewBox*/ ctx[1]);
			attr_dev(svg, "class", "svelte-vfq7n1");
			add_location(svg, file$1, 15, 0, 210);
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			if (if_block) if_block.m(svg, null);
			append_dev(svg, if_block_anchor);

			if (default_slot) {
				default_slot.m(svg, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*title*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(svg, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 4) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[2], dirty, null, null);
				}
			}

			if (!current || dirty & /*viewBox*/ 2) {
				attr_dev(svg, "viewBox", /*viewBox*/ ctx[1]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
			if (if_block) if_block.d();
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let { title = null } = $$props;
	let { viewBox } = $$props;
	const writable_props = ["title", "viewBox"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconBase> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IconBase", $$slots, ['default']);

	$$self.$set = $$props => {
		if ("title" in $$props) $$invalidate(0, title = $$props.title);
		if ("viewBox" in $$props) $$invalidate(1, viewBox = $$props.viewBox);
		if ("$$scope" in $$props) $$invalidate(2, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({ title, viewBox });

	$$self.$inject_state = $$props => {
		if ("title" in $$props) $$invalidate(0, title = $$props.title);
		if ("viewBox" in $$props) $$invalidate(1, viewBox = $$props.viewBox);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [title, viewBox, $$scope, $$slots];
}

class IconBase extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document.getElementById("svelte-vfq7n1-style")) add_css$1();
		init(this, options, instance$1, create_fragment$1, safe_not_equal, { title: 0, viewBox: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IconBase",
			options,
			id: create_fragment$1.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*viewBox*/ ctx[1] === undefined && !("viewBox" in props)) {
			console.warn("<IconBase> was created without expected prop 'viewBox'");
		}
	}

	get title() {
		throw new Error("<IconBase>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<IconBase>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get viewBox() {
		throw new Error("<IconBase>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set viewBox(value) {
		throw new Error("<IconBase>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/svelte-icons/fa/FaAt.svelte generated by Svelte v3.24.0 */
const file$2 = "node_modules/svelte-icons/fa/FaAt.svelte";

// (4:8) <IconBase viewBox="0 0 512 512" {...$$props}>
function create_default_slot(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_element(nodes, "path", { d: true }, 1);
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M256 8C118.941 8 8 118.919 8 256c0 137.059 110.919 248 248 248 48.154 0 95.342-14.14 135.408-40.223 12.005-7.815 14.625-24.288 5.552-35.372l-10.177-12.433c-7.671-9.371-21.179-11.667-31.373-5.129C325.92 429.757 291.314 440 256 440c-101.458 0-184-82.542-184-184S154.542 72 256 72c100.139 0 184 57.619 184 160 0 38.786-21.093 79.742-58.17 83.693-17.349-.454-16.91-12.857-13.476-30.024l23.433-121.11C394.653 149.75 383.308 136 368.225 136h-44.981a13.518 13.518 0 0 0-13.432 11.993l-.01.092c-14.697-17.901-40.448-21.775-59.971-21.775-74.58 0-137.831 62.234-137.831 151.46 0 65.303 36.785 105.87 96 105.87 26.984 0 57.369-15.637 74.991-38.333 9.522 34.104 40.613 34.103 70.71 34.103C462.609 379.41 504 307.798 504 232 504 95.653 394.023 8 256 8zm-21.68 304.43c-22.249 0-36.07-15.623-36.07-40.771 0-44.993 30.779-72.729 58.63-72.729 22.292 0 35.601 15.241 35.601 40.77 0 45.061-33.875 72.73-58.161 72.73z");
			add_location(path, file$2, 4, 10, 153);
		},
		m: function mount(target, anchor) {
			insert_dev(target, path, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(4:8) <IconBase viewBox=\\\"0 0 512 512\\\" {...$$props}>",
		ctx
	});

	return block;
}

function create_fragment$2(ctx) {
	let iconbase;
	let current;
	const iconbase_spread_levels = [{ viewBox: "0 0 512 512" }, /*$$props*/ ctx[0]];

	let iconbase_props = {
		$$slots: { default: [create_default_slot] },
		$$scope: { ctx }
	};

	for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
		iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
	}

	iconbase = new IconBase({ props: iconbase_props, $$inline: true });

	const block = {
		c: function create() {
			create_component(iconbase.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(iconbase.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(iconbase, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const iconbase_changes = (dirty & /*$$props*/ 1)
			? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(/*$$props*/ ctx[0])])
			: {};

			if (dirty & /*$$scope*/ 2) {
				iconbase_changes.$$scope = { dirty, ctx };
			}

			iconbase.$set(iconbase_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconbase.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconbase.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconbase, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	let { $$slots = {}, $$scope } = $$props;
	validate_slots("FaAt", $$slots, []);

	$$self.$set = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
	};

	$$self.$capture_state = () => ({ IconBase });

	$$self.$inject_state = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);
	return [$$props];
}

class FaAt extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "FaAt",
			options,
			id: create_fragment$2.name
		});
	}
}

/* node_modules/svelte-icons/fa/FaMoon.svelte generated by Svelte v3.24.0 */
const file$3 = "node_modules/svelte-icons/fa/FaMoon.svelte";

// (4:8) <IconBase viewBox="0 0 512 512" {...$$props}>
function create_default_slot$1(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_element(nodes, "path", { d: true }, 1);
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M283.211 512c78.962 0 151.079-35.925 198.857-94.792 7.068-8.708-.639-21.43-11.562-19.35-124.203 23.654-238.262-71.576-238.262-196.954 0-72.222 38.662-138.635 101.498-174.394 9.686-5.512 7.25-20.197-3.756-22.23A258.156 258.156 0 0 0 283.211 0c-141.309 0-256 114.511-256 256 0 141.309 114.511 256 256 256z");
			add_location(path, file$3, 4, 10, 153);
		},
		m: function mount(target, anchor) {
			insert_dev(target, path, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$1.name,
		type: "slot",
		source: "(4:8) <IconBase viewBox=\\\"0 0 512 512\\\" {...$$props}>",
		ctx
	});

	return block;
}

function create_fragment$3(ctx) {
	let iconbase;
	let current;
	const iconbase_spread_levels = [{ viewBox: "0 0 512 512" }, /*$$props*/ ctx[0]];

	let iconbase_props = {
		$$slots: { default: [create_default_slot$1] },
		$$scope: { ctx }
	};

	for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
		iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
	}

	iconbase = new IconBase({ props: iconbase_props, $$inline: true });

	const block = {
		c: function create() {
			create_component(iconbase.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(iconbase.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(iconbase, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const iconbase_changes = (dirty & /*$$props*/ 1)
			? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(/*$$props*/ ctx[0])])
			: {};

			if (dirty & /*$$scope*/ 2) {
				iconbase_changes.$$scope = { dirty, ctx };
			}

			iconbase.$set(iconbase_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconbase.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconbase.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconbase, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3($$self, $$props, $$invalidate) {
	let { $$slots = {}, $$scope } = $$props;
	validate_slots("FaMoon", $$slots, []);

	$$self.$set = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
	};

	$$self.$capture_state = () => ({ IconBase });

	$$self.$inject_state = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);
	return [$$props];
}

class FaMoon extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3, create_fragment$3, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "FaMoon",
			options,
			id: create_fragment$3.name
		});
	}
}

/* node_modules/svelte-icons/md/MdLink.svelte generated by Svelte v3.24.0 */
const file$4 = "node_modules/svelte-icons/md/MdLink.svelte";

// (4:8) <IconBase viewBox="0 0 24 24" {...$$props}>
function create_default_slot$2(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_element(nodes, "path", { d: true }, 1);
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z");
			add_location(path, file$4, 4, 10, 151);
		},
		m: function mount(target, anchor) {
			insert_dev(target, path, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$2.name,
		type: "slot",
		source: "(4:8) <IconBase viewBox=\\\"0 0 24 24\\\" {...$$props}>",
		ctx
	});

	return block;
}

function create_fragment$4(ctx) {
	let iconbase;
	let current;
	const iconbase_spread_levels = [{ viewBox: "0 0 24 24" }, /*$$props*/ ctx[0]];

	let iconbase_props = {
		$$slots: { default: [create_default_slot$2] },
		$$scope: { ctx }
	};

	for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
		iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
	}

	iconbase = new IconBase({ props: iconbase_props, $$inline: true });

	const block = {
		c: function create() {
			create_component(iconbase.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(iconbase.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(iconbase, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const iconbase_changes = (dirty & /*$$props*/ 1)
			? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(/*$$props*/ ctx[0])])
			: {};

			if (dirty & /*$$scope*/ 2) {
				iconbase_changes.$$scope = { dirty, ctx };
			}

			iconbase.$set(iconbase_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconbase.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconbase.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconbase, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4($$self, $$props, $$invalidate) {
	let { $$slots = {}, $$scope } = $$props;
	validate_slots("MdLink", $$slots, []);

	$$self.$set = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
	};

	$$self.$capture_state = () => ({ IconBase });

	$$self.$inject_state = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);
	return [$$props];
}

class MdLink extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4, create_fragment$4, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "MdLink",
			options,
			id: create_fragment$4.name
		});
	}
}

/* node_modules/svelte-icons/gi/GiMale.svelte generated by Svelte v3.24.0 */
const file$5 = "node_modules/svelte-icons/gi/GiMale.svelte";

// (4:8) <IconBase viewBox="0 0 512 512" {...$$props}>
function create_default_slot$3(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_element(nodes, "path", { d: true }, 1);
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M292.563 65.656v40h85.156l-81.658 82.656-12.937 13.125c-9.054-6.765-18.936-12.412-29.406-16.75-16.478-6.825-34.23-10.343-52.064-10.343-17.835 0-35.553 3.52-52.03 10.344-16.48 6.824-31.514 16.858-44.126 29.468-12.613 12.612-22.643 27.647-29.47 44.125-6.825 16.48-10.373 34.228-10.374 52.064 0 17.836 3.52 35.553 10.344 52.03 6.825 16.48 16.888 31.514 29.5 44.126 12.612 12.612 27.647 22.643 44.125 29.47 16.478 6.824 34.195 10.374 52.03 10.374 17.837 0 35.586-3.55 52.064-10.375 16.477-6.827 31.512-16.857 44.124-29.47 12.61-12.612 22.644-27.647 29.47-44.125 6.823-16.478 10.343-34.196 10.342-52.03 0-17.836-3.518-35.587-10.344-52.064-4.183-10.098-9.583-19.646-16.03-28.436l13.218-13.406 81.844-82.875v85.875h40V65.656H292.562zm-90.907 148.688c12.533 0 25.17 2.516 36.75 7.312 11.58 4.797 22.263 11.95 31.125 20.813 8.863 8.86 16.017 19.545 20.814 31.124 4.796 11.58 7.312 24.217 7.312 36.75 0 12.533-2.517 25.14-7.312 36.72-4.796 11.577-11.92 22.292-20.78 31.155-8.864 8.862-19.578 16.014-31.158 20.81-11.58 4.798-24.216 7.313-36.75 7.314-12.533 0-25.14-2.516-36.72-7.313-11.578-4.795-22.292-11.95-31.155-20.81-8.86-8.864-16.015-19.578-20.81-31.158-4.798-11.58-7.314-24.185-7.314-36.718 0-12.534 2.516-25.17 7.313-36.75l.093-.22c4.796-11.494 11.91-22.13 20.718-30.937 8.808-8.805 19.444-15.892 30.94-20.687l.218-.094c11.58-4.795 24.185-7.313 36.718-7.312z");
			add_location(path, file$5, 4, 10, 153);
		},
		m: function mount(target, anchor) {
			insert_dev(target, path, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$3.name,
		type: "slot",
		source: "(4:8) <IconBase viewBox=\\\"0 0 512 512\\\" {...$$props}>",
		ctx
	});

	return block;
}

function create_fragment$5(ctx) {
	let iconbase;
	let current;
	const iconbase_spread_levels = [{ viewBox: "0 0 512 512" }, /*$$props*/ ctx[0]];

	let iconbase_props = {
		$$slots: { default: [create_default_slot$3] },
		$$scope: { ctx }
	};

	for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
		iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
	}

	iconbase = new IconBase({ props: iconbase_props, $$inline: true });

	const block = {
		c: function create() {
			create_component(iconbase.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(iconbase.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(iconbase, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const iconbase_changes = (dirty & /*$$props*/ 1)
			? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(/*$$props*/ ctx[0])])
			: {};

			if (dirty & /*$$scope*/ 2) {
				iconbase_changes.$$scope = { dirty, ctx };
			}

			iconbase.$set(iconbase_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconbase.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconbase.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconbase, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$5.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$5($$self, $$props, $$invalidate) {
	let { $$slots = {}, $$scope } = $$props;
	validate_slots("GiMale", $$slots, []);

	$$self.$set = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
	};

	$$self.$capture_state = () => ({ IconBase });

	$$self.$inject_state = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);
	return [$$props];
}

class GiMale extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$5, create_fragment$5, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "GiMale",
			options,
			id: create_fragment$5.name
		});
	}
}

/* node_modules/svelte-icons/md/MdEdit.svelte generated by Svelte v3.24.0 */
const file$6 = "node_modules/svelte-icons/md/MdEdit.svelte";

// (4:8) <IconBase viewBox="0 0 24 24" {...$$props}>
function create_default_slot$4(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_element(nodes, "path", { d: true }, 1);
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z");
			add_location(path, file$6, 4, 10, 151);
		},
		m: function mount(target, anchor) {
			insert_dev(target, path, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$4.name,
		type: "slot",
		source: "(4:8) <IconBase viewBox=\\\"0 0 24 24\\\" {...$$props}>",
		ctx
	});

	return block;
}

function create_fragment$6(ctx) {
	let iconbase;
	let current;
	const iconbase_spread_levels = [{ viewBox: "0 0 24 24" }, /*$$props*/ ctx[0]];

	let iconbase_props = {
		$$slots: { default: [create_default_slot$4] },
		$$scope: { ctx }
	};

	for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
		iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
	}

	iconbase = new IconBase({ props: iconbase_props, $$inline: true });

	const block = {
		c: function create() {
			create_component(iconbase.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(iconbase.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(iconbase, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const iconbase_changes = (dirty & /*$$props*/ 1)
			? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(/*$$props*/ ctx[0])])
			: {};

			if (dirty & /*$$scope*/ 2) {
				iconbase_changes.$$scope = { dirty, ctx };
			}

			iconbase.$set(iconbase_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconbase.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconbase.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconbase, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$6.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$6($$self, $$props, $$invalidate) {
	let { $$slots = {}, $$scope } = $$props;
	validate_slots("MdEdit", $$slots, []);

	$$self.$set = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
	};

	$$self.$capture_state = () => ({ IconBase });

	$$self.$inject_state = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);
	return [$$props];
}

class MdEdit extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$6, create_fragment$6, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "MdEdit",
			options,
			id: create_fragment$6.name
		});
	}
}

/* node_modules/svelte-icons/fa/FaHeart.svelte generated by Svelte v3.24.0 */
const file$7 = "node_modules/svelte-icons/fa/FaHeart.svelte";

// (4:8) <IconBase viewBox="0 0 512 512" {...$$props}>
function create_default_slot$5(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_element(nodes, "path", { d: true }, 1);
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M462.3 62.6C407.5 15.9 326 24.3 275.7 76.2L256 96.5l-19.7-20.3C186.1 24.3 104.5 15.9 49.7 62.6c-62.8 53.6-66.1 149.8-9.9 207.9l193.5 199.8c12.5 12.9 32.8 12.9 45.3 0l193.5-199.8c56.3-58.1 53-154.3-9.8-207.9z");
			add_location(path, file$7, 4, 10, 153);
		},
		m: function mount(target, anchor) {
			insert_dev(target, path, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$5.name,
		type: "slot",
		source: "(4:8) <IconBase viewBox=\\\"0 0 512 512\\\" {...$$props}>",
		ctx
	});

	return block;
}

function create_fragment$7(ctx) {
	let iconbase;
	let current;
	const iconbase_spread_levels = [{ viewBox: "0 0 512 512" }, /*$$props*/ ctx[0]];

	let iconbase_props = {
		$$slots: { default: [create_default_slot$5] },
		$$scope: { ctx }
	};

	for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
		iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
	}

	iconbase = new IconBase({ props: iconbase_props, $$inline: true });

	const block = {
		c: function create() {
			create_component(iconbase.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(iconbase.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(iconbase, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const iconbase_changes = (dirty & /*$$props*/ 1)
			? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(/*$$props*/ ctx[0])])
			: {};

			if (dirty & /*$$scope*/ 2) {
				iconbase_changes.$$scope = { dirty, ctx };
			}

			iconbase.$set(iconbase_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconbase.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconbase.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconbase, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$7.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$7($$self, $$props, $$invalidate) {
	let { $$slots = {}, $$scope } = $$props;
	validate_slots("FaHeart", $$slots, []);

	$$self.$set = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
	};

	$$self.$capture_state = () => ({ IconBase });

	$$self.$inject_state = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);
	return [$$props];
}

class FaHeart extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$7, create_fragment$7, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "FaHeart",
			options,
			id: create_fragment$7.name
		});
	}
}

/* node_modules/svelte-icons/fa/FaViber.svelte generated by Svelte v3.24.0 */
const file$8 = "node_modules/svelte-icons/fa/FaViber.svelte";

// (4:8) <IconBase viewBox="0 0 512 512" {...$$props}>
function create_default_slot$6(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_element(nodes, "path", { d: true }, 1);
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M444 49.9C431.3 38.2 379.9.9 265.3.4c0 0-135.1-8.1-200.9 52.3C27.8 89.3 14.9 143 13.5 209.5c-1.4 66.5-3.1 191.1 117 224.9h.1l-.1 51.6s-.8 20.9 13 25.1c16.6 5.2 26.4-10.7 42.3-27.8 8.7-9.4 20.7-23.2 29.8-33.7 82.2 6.9 145.3-8.9 152.5-11.2 16.6-5.4 110.5-17.4 125.7-142 15.8-128.6-7.6-209.8-49.8-246.5zM457.9 287c-12.9 104-89 110.6-103 115.1-6 1.9-61.5 15.7-131.2 11.2 0 0-52 62.7-68.2 79-5.3 5.3-11.1 4.8-11-5.7 0-6.9.4-85.7.4-85.7-.1 0-.1 0 0 0-101.8-28.2-95.8-134.3-94.7-189.8 1.1-55.5 11.6-101 42.6-131.6 55.7-50.5 170.4-43 170.4-43 96.9.4 143.3 29.6 154.1 39.4 35.7 30.6 53.9 103.8 40.6 211.1zm-139-80.8c.4 8.6-12.5 9.2-12.9.6-1.1-22-11.4-32.7-32.6-33.9-8.6-.5-7.8-13.4.7-12.9 27.9 1.5 43.4 17.5 44.8 46.2zm20.3 11.3c1-42.4-25.5-75.6-75.8-79.3-8.5-.6-7.6-13.5.9-12.9 58 4.2 88.9 44.1 87.8 92.5-.1 8.6-13.1 8.2-12.9-.3zm47 13.4c.1 8.6-12.9 8.7-12.9.1-.6-81.5-54.9-125.9-120.8-126.4-8.5-.1-8.5-12.9 0-12.9 73.7.5 133 51.4 133.7 139.2zM374.9 329v.2c-10.8 19-31 40-51.8 33.3l-.2-.3c-21.1-5.9-70.8-31.5-102.2-56.5-16.2-12.8-31-27.9-42.4-42.4-10.3-12.9-20.7-28.2-30.8-46.6-21.3-38.5-26-55.7-26-55.7-6.7-20.8 14.2-41 33.3-51.8h.2c9.2-4.8 18-3.2 23.9 3.9 0 0 12.4 14.8 17.7 22.1 5 6.8 11.7 17.7 15.2 23.8 6.1 10.9 2.3 22-3.7 26.6l-12 9.6c-6.1 4.9-5.3 14-5.3 14s17.8 67.3 84.3 84.3c0 0 9.1.8 14-5.3l9.6-12c4.6-6 15.7-9.8 26.6-3.7 14.7 8.3 33.4 21.2 45.8 32.9 7 5.7 8.6 14.4 3.8 23.6z");
			add_location(path, file$8, 4, 10, 153);
		},
		m: function mount(target, anchor) {
			insert_dev(target, path, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$6.name,
		type: "slot",
		source: "(4:8) <IconBase viewBox=\\\"0 0 512 512\\\" {...$$props}>",
		ctx
	});

	return block;
}

function create_fragment$8(ctx) {
	let iconbase;
	let current;
	const iconbase_spread_levels = [{ viewBox: "0 0 512 512" }, /*$$props*/ ctx[0]];

	let iconbase_props = {
		$$slots: { default: [create_default_slot$6] },
		$$scope: { ctx }
	};

	for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
		iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
	}

	iconbase = new IconBase({ props: iconbase_props, $$inline: true });

	const block = {
		c: function create() {
			create_component(iconbase.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(iconbase.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(iconbase, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const iconbase_changes = (dirty & /*$$props*/ 1)
			? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(/*$$props*/ ctx[0])])
			: {};

			if (dirty & /*$$scope*/ 2) {
				iconbase_changes.$$scope = { dirty, ctx };
			}

			iconbase.$set(iconbase_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconbase.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconbase.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconbase, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$8.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$8($$self, $$props, $$invalidate) {
	let { $$slots = {}, $$scope } = $$props;
	validate_slots("FaViber", $$slots, []);

	$$self.$set = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
	};

	$$self.$capture_state = () => ({ IconBase });

	$$self.$inject_state = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);
	return [$$props];
}

class FaViber extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$8, create_fragment$8, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "FaViber",
			options,
			id: create_fragment$8.name
		});
	}
}

/* node_modules/svelte-icons/fa/FaShare.svelte generated by Svelte v3.24.0 */
const file$9 = "node_modules/svelte-icons/fa/FaShare.svelte";

// (4:8) <IconBase viewBox="0 0 512 512" {...$$props}>
function create_default_slot$7(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_element(nodes, "path", { d: true }, 1);
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M503.691 189.836L327.687 37.851C312.281 24.546 288 35.347 288 56.015v80.053C127.371 137.907 0 170.1 0 322.326c0 61.441 39.581 122.309 83.333 154.132 13.653 9.931 33.111-2.533 28.077-18.631C66.066 312.814 132.917 274.316 288 272.085V360c0 20.7 24.3 31.453 39.687 18.164l176.004-152c11.071-9.562 11.086-26.753 0-36.328z");
			add_location(path, file$9, 4, 10, 153);
		},
		m: function mount(target, anchor) {
			insert_dev(target, path, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$7.name,
		type: "slot",
		source: "(4:8) <IconBase viewBox=\\\"0 0 512 512\\\" {...$$props}>",
		ctx
	});

	return block;
}

function create_fragment$9(ctx) {
	let iconbase;
	let current;
	const iconbase_spread_levels = [{ viewBox: "0 0 512 512" }, /*$$props*/ ctx[0]];

	let iconbase_props = {
		$$slots: { default: [create_default_slot$7] },
		$$scope: { ctx }
	};

	for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
		iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
	}

	iconbase = new IconBase({ props: iconbase_props, $$inline: true });

	const block = {
		c: function create() {
			create_component(iconbase.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(iconbase.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(iconbase, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const iconbase_changes = (dirty & /*$$props*/ 1)
			? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(/*$$props*/ ctx[0])])
			: {};

			if (dirty & /*$$scope*/ 2) {
				iconbase_changes.$$scope = { dirty, ctx };
			}

			iconbase.$set(iconbase_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconbase.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconbase.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconbase, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$9.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$9($$self, $$props, $$invalidate) {
	let { $$slots = {}, $$scope } = $$props;
	validate_slots("FaShare", $$slots, []);

	$$self.$set = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
	};

	$$self.$capture_state = () => ({ IconBase });

	$$self.$inject_state = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);
	return [$$props];
}

class FaShare extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$9, create_fragment$9, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "FaShare",
			options,
			id: create_fragment$9.name
		});
	}
}

/* node_modules/svelte-icons/md/MdCheck.svelte generated by Svelte v3.24.0 */
const file$a = "node_modules/svelte-icons/md/MdCheck.svelte";

// (4:8) <IconBase viewBox="0 0 24 24" {...$$props}>
function create_default_slot$8(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_element(nodes, "path", { d: true }, 1);
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z");
			add_location(path, file$a, 4, 10, 151);
		},
		m: function mount(target, anchor) {
			insert_dev(target, path, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$8.name,
		type: "slot",
		source: "(4:8) <IconBase viewBox=\\\"0 0 24 24\\\" {...$$props}>",
		ctx
	});

	return block;
}

function create_fragment$a(ctx) {
	let iconbase;
	let current;
	const iconbase_spread_levels = [{ viewBox: "0 0 24 24" }, /*$$props*/ ctx[0]];

	let iconbase_props = {
		$$slots: { default: [create_default_slot$8] },
		$$scope: { ctx }
	};

	for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
		iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
	}

	iconbase = new IconBase({ props: iconbase_props, $$inline: true });

	const block = {
		c: function create() {
			create_component(iconbase.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(iconbase.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(iconbase, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const iconbase_changes = (dirty & /*$$props*/ 1)
			? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(/*$$props*/ ctx[0])])
			: {};

			if (dirty & /*$$scope*/ 2) {
				iconbase_changes.$$scope = { dirty, ctx };
			}

			iconbase.$set(iconbase_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconbase.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconbase.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconbase, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$a.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$a($$self, $$props, $$invalidate) {
	let { $$slots = {}, $$scope } = $$props;
	validate_slots("MdCheck", $$slots, []);

	$$self.$set = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
	};

	$$self.$capture_state = () => ({ IconBase });

	$$self.$inject_state = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);
	return [$$props];
}

class MdCheck extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$a, create_fragment$a, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "MdCheck",
			options,
			id: create_fragment$a.name
		});
	}
}

/* node_modules/svelte-icons/gi/GiFemale.svelte generated by Svelte v3.24.0 */
const file$b = "node_modules/svelte-icons/gi/GiFemale.svelte";

// (4:8) <IconBase viewBox="0 0 512 512" {...$$props}>
function create_default_slot$9(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_element(nodes, "path", { d: true }, 1);
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M256 25.438c-17.84 0-35.582 3.547-52.063 10.375-16.48 6.827-31.512 16.853-44.125 29.468-12.612 12.617-22.645 27.675-29.468 44.157C123.52 125.92 119.994 143.66 120 161.5c.005 17.832 3.547 35.558 10.375 52.03 6.828 16.474 16.858 31.488 29.47 44.095 12.61 12.607 27.65 22.646 44.124 29.47l.218.092c10.032 4.135 20.52 7.02 31.218 8.657l.125 18.906.314 49.188H165.97v40h70.124l.375 62.875.124 20 40-.25-.125-20-.376-62.625h69.937v-40h-70.186l-.313-49.438-.124-18.47c11.188-1.61 22.154-4.6 32.625-8.936 16.476-6.823 31.515-16.862 44.126-29.47 12.61-12.606 22.64-27.62 29.47-44.093 6.827-16.472 10.37-34.198 10.374-52.03.005-17.84-3.52-35.58-10.344-52.063-6.823-16.482-16.856-31.54-29.47-44.156-12.61-12.614-27.643-22.64-44.123-29.468-16.48-6.827-34.224-10.374-52.063-10.374zm0 40c12.536 0 25.17 2.514 36.75 7.312 11.58 4.798 22.294 11.947 31.156 20.813 8.863 8.865 15.987 19.573 20.78 31.156 4.796 11.58 7.318 24.213 7.314 36.75-.004 12.53-2.515 25.173-7.313 36.75-4.797 11.575-11.95 22.264-20.812 31.124-8.862 8.86-19.58 16.018-31.156 20.812-11.58 4.795-24.19 7.28-36.72 7.28-12.53.002-25.14-2.485-36.72-7.28-11.576-4.794-22.293-11.953-31.155-20.812-8.862-8.86-16.015-19.55-20.813-31.125-4.797-11.577-7.308-24.22-7.312-36.75-.004-12.537 2.518-25.17 7.313-36.75 4.794-11.584 11.918-22.292 20.78-31.157 8.863-8.866 19.576-16.015 31.157-20.813 11.58-4.798 24.214-7.313 36.75-7.313z");
			add_location(path, file$b, 4, 10, 153);
		},
		m: function mount(target, anchor) {
			insert_dev(target, path, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$9.name,
		type: "slot",
		source: "(4:8) <IconBase viewBox=\\\"0 0 512 512\\\" {...$$props}>",
		ctx
	});

	return block;
}

function create_fragment$b(ctx) {
	let iconbase;
	let current;
	const iconbase_spread_levels = [{ viewBox: "0 0 512 512" }, /*$$props*/ ctx[0]];

	let iconbase_props = {
		$$slots: { default: [create_default_slot$9] },
		$$scope: { ctx }
	};

	for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
		iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
	}

	iconbase = new IconBase({ props: iconbase_props, $$inline: true });

	const block = {
		c: function create() {
			create_component(iconbase.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(iconbase.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(iconbase, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const iconbase_changes = (dirty & /*$$props*/ 1)
			? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(/*$$props*/ ctx[0])])
			: {};

			if (dirty & /*$$scope*/ 2) {
				iconbase_changes.$$scope = { dirty, ctx };
			}

			iconbase.$set(iconbase_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconbase.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconbase.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconbase, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$b.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$b($$self, $$props, $$invalidate) {
	let { $$slots = {}, $$scope } = $$props;
	validate_slots("GiFemale", $$slots, []);

	$$self.$set = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
	};

	$$self.$capture_state = () => ({ IconBase });

	$$self.$inject_state = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);
	return [$$props];
}

class GiFemale extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$b, create_fragment$b, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "GiFemale",
			options,
			id: create_fragment$b.name
		});
	}
}

/* node_modules/svelte-icons/io/IoMdSend.svelte generated by Svelte v3.24.0 */
const file$c = "node_modules/svelte-icons/io/IoMdSend.svelte";

// (4:8) <IconBase viewBox="0 0 512 512" {...$$props}>
function create_default_slot$a(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_element(nodes, "path", { d: true }, 1);
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M48 448l416-192L48 64v149.333L346 256 48 298.667z");
			add_location(path, file$c, 4, 10, 153);
		},
		m: function mount(target, anchor) {
			insert_dev(target, path, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$a.name,
		type: "slot",
		source: "(4:8) <IconBase viewBox=\\\"0 0 512 512\\\" {...$$props}>",
		ctx
	});

	return block;
}

function create_fragment$c(ctx) {
	let iconbase;
	let current;
	const iconbase_spread_levels = [{ viewBox: "0 0 512 512" }, /*$$props*/ ctx[0]];

	let iconbase_props = {
		$$slots: { default: [create_default_slot$a] },
		$$scope: { ctx }
	};

	for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
		iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
	}

	iconbase = new IconBase({ props: iconbase_props, $$inline: true });

	const block = {
		c: function create() {
			create_component(iconbase.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(iconbase.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(iconbase, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const iconbase_changes = (dirty & /*$$props*/ 1)
			? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(/*$$props*/ ctx[0])])
			: {};

			if (dirty & /*$$scope*/ 2) {
				iconbase_changes.$$scope = { dirty, ctx };
			}

			iconbase.$set(iconbase_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconbase.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconbase.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconbase, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$c.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$c($$self, $$props, $$invalidate) {
	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IoMdSend", $$slots, []);

	$$self.$set = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
	};

	$$self.$capture_state = () => ({ IconBase });

	$$self.$inject_state = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);
	return [$$props];
}

class IoMdSend extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$c, create_fragment$c, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IoMdSend",
			options,
			id: create_fragment$c.name
		});
	}
}

/* node_modules/svelte-icons/go/GoSearch.svelte generated by Svelte v3.24.0 */
const file$d = "node_modules/svelte-icons/go/GoSearch.svelte";

// (4:8) <IconBase viewBox="0 0 16 16" {...$$props}>
function create_default_slot$b(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_element(nodes, "path", { d: true }, 1);
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M15.7 13.3l-3.81-3.83A5.93 5.93 0 0 0 13 6c0-3.31-2.69-6-6-6S1 2.69 1 6s2.69 6 6 6c1.3 0 2.48-.41 3.47-1.11l3.83 3.81c.19.2.45.3.7.3.25 0 .52-.09.7-.3a.996.996 0 0 0 0-1.41v.01zM7 10.7c-2.59 0-4.7-2.11-4.7-4.7 0-2.59 2.11-4.7 4.7-4.7 2.59 0 4.7 2.11 4.7 4.7 0 2.59-2.11 4.7-4.7 4.7z");
			add_location(path, file$d, 4, 10, 151);
		},
		m: function mount(target, anchor) {
			insert_dev(target, path, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$b.name,
		type: "slot",
		source: "(4:8) <IconBase viewBox=\\\"0 0 16 16\\\" {...$$props}>",
		ctx
	});

	return block;
}

function create_fragment$d(ctx) {
	let iconbase;
	let current;
	const iconbase_spread_levels = [{ viewBox: "0 0 16 16" }, /*$$props*/ ctx[0]];

	let iconbase_props = {
		$$slots: { default: [create_default_slot$b] },
		$$scope: { ctx }
	};

	for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
		iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
	}

	iconbase = new IconBase({ props: iconbase_props, $$inline: true });

	const block = {
		c: function create() {
			create_component(iconbase.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(iconbase.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(iconbase, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const iconbase_changes = (dirty & /*$$props*/ 1)
			? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(/*$$props*/ ctx[0])])
			: {};

			if (dirty & /*$$scope*/ 2) {
				iconbase_changes.$$scope = { dirty, ctx };
			}

			iconbase.$set(iconbase_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconbase.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconbase.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconbase, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$d.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$d($$self, $$props, $$invalidate) {
	let { $$slots = {}, $$scope } = $$props;
	validate_slots("GoSearch", $$slots, []);

	$$self.$set = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
	};

	$$self.$capture_state = () => ({ IconBase });

	$$self.$inject_state = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);
	return [$$props];
}

class GoSearch extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$d, create_fragment$d, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "GoSearch",
			options,
			id: create_fragment$d.name
		});
	}
}

/* node_modules/svelte-icons/io/IoMdClose.svelte generated by Svelte v3.24.0 */
const file$e = "node_modules/svelte-icons/io/IoMdClose.svelte";

// (4:8) <IconBase viewBox="0 0 512 512" {...$$props}>
function create_default_slot$c(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_element(nodes, "path", { d: true }, 1);
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M405 136.798L375.202 107 256 226.202 136.798 107 107 136.798 226.202 256 107 375.202 136.798 405 256 285.798 375.202 405 405 375.202 285.798 256z");
			add_location(path, file$e, 4, 10, 153);
		},
		m: function mount(target, anchor) {
			insert_dev(target, path, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$c.name,
		type: "slot",
		source: "(4:8) <IconBase viewBox=\\\"0 0 512 512\\\" {...$$props}>",
		ctx
	});

	return block;
}

function create_fragment$e(ctx) {
	let iconbase;
	let current;
	const iconbase_spread_levels = [{ viewBox: "0 0 512 512" }, /*$$props*/ ctx[0]];

	let iconbase_props = {
		$$slots: { default: [create_default_slot$c] },
		$$scope: { ctx }
	};

	for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
		iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
	}

	iconbase = new IconBase({ props: iconbase_props, $$inline: true });

	const block = {
		c: function create() {
			create_component(iconbase.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(iconbase.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(iconbase, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const iconbase_changes = (dirty & /*$$props*/ 1)
			? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(/*$$props*/ ctx[0])])
			: {};

			if (dirty & /*$$scope*/ 2) {
				iconbase_changes.$$scope = { dirty, ctx };
			}

			iconbase.$set(iconbase_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconbase.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconbase.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconbase, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$e.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$e($$self, $$props, $$invalidate) {
	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IoMdClose", $$slots, []);

	$$self.$set = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
	};

	$$self.$capture_state = () => ({ IconBase });

	$$self.$inject_state = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);
	return [$$props];
}

class IoMdClose extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$e, create_fragment$e, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IoMdClose",
			options,
			id: create_fragment$e.name
		});
	}
}

/* node_modules/svelte-icons/fa/FaPhoneAlt.svelte generated by Svelte v3.24.0 */
const file$f = "node_modules/svelte-icons/fa/FaPhoneAlt.svelte";

// (4:8) <IconBase viewBox="0 0 512 512" {...$$props}>
function create_default_slot$d(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_element(nodes, "path", { d: true }, 1);
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M497.39 361.8l-112-48a24 24 0 0 0-28 6.9l-49.6 60.6A370.66 370.66 0 0 1 130.6 204.11l60.6-49.6a23.94 23.94 0 0 0 6.9-28l-48-112A24.16 24.16 0 0 0 122.6.61l-104 24A24 24 0 0 0 0 48c0 256.5 207.9 464 464 464a24 24 0 0 0 23.4-18.6l24-104a24.29 24.29 0 0 0-14.01-27.6z");
			add_location(path, file$f, 4, 10, 153);
		},
		m: function mount(target, anchor) {
			insert_dev(target, path, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$d.name,
		type: "slot",
		source: "(4:8) <IconBase viewBox=\\\"0 0 512 512\\\" {...$$props}>",
		ctx
	});

	return block;
}

function create_fragment$f(ctx) {
	let iconbase;
	let current;
	const iconbase_spread_levels = [{ viewBox: "0 0 512 512" }, /*$$props*/ ctx[0]];

	let iconbase_props = {
		$$slots: { default: [create_default_slot$d] },
		$$scope: { ctx }
	};

	for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
		iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
	}

	iconbase = new IconBase({ props: iconbase_props, $$inline: true });

	const block = {
		c: function create() {
			create_component(iconbase.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(iconbase.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(iconbase, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const iconbase_changes = (dirty & /*$$props*/ 1)
			? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(/*$$props*/ ctx[0])])
			: {};

			if (dirty & /*$$scope*/ 2) {
				iconbase_changes.$$scope = { dirty, ctx };
			}

			iconbase.$set(iconbase_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconbase.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconbase.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconbase, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$f.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$f($$self, $$props, $$invalidate) {
	let { $$slots = {}, $$scope } = $$props;
	validate_slots("FaPhoneAlt", $$slots, []);

	$$self.$set = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
	};

	$$self.$capture_state = () => ({ IconBase });

	$$self.$inject_state = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);
	return [$$props];
}

class FaPhoneAlt extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$f, create_fragment$f, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "FaPhoneAlt",
			options,
			id: create_fragment$f.name
		});
	}
}

/* node_modules/svelte-icons/fa/FaFacebookF.svelte generated by Svelte v3.24.0 */
const file$g = "node_modules/svelte-icons/fa/FaFacebookF.svelte";

// (4:8) <IconBase viewBox="0 0 320 512" {...$$props}>
function create_default_slot$e(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_element(nodes, "path", { d: true }, 1);
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M279.14 288l14.22-92.66h-88.91v-60.13c0-25.35 12.42-50.06 52.24-50.06h40.42V6.26S260.43 0 225.36 0c-73.22 0-121.08 44.38-121.08 124.72v70.62H22.89V288h81.39v224h100.17V288z");
			add_location(path, file$g, 4, 10, 153);
		},
		m: function mount(target, anchor) {
			insert_dev(target, path, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$e.name,
		type: "slot",
		source: "(4:8) <IconBase viewBox=\\\"0 0 320 512\\\" {...$$props}>",
		ctx
	});

	return block;
}

function create_fragment$g(ctx) {
	let iconbase;
	let current;
	const iconbase_spread_levels = [{ viewBox: "0 0 320 512" }, /*$$props*/ ctx[0]];

	let iconbase_props = {
		$$slots: { default: [create_default_slot$e] },
		$$scope: { ctx }
	};

	for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
		iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
	}

	iconbase = new IconBase({ props: iconbase_props, $$inline: true });

	const block = {
		c: function create() {
			create_component(iconbase.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(iconbase.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(iconbase, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const iconbase_changes = (dirty & /*$$props*/ 1)
			? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(/*$$props*/ ctx[0])])
			: {};

			if (dirty & /*$$scope*/ 2) {
				iconbase_changes.$$scope = { dirty, ctx };
			}

			iconbase.$set(iconbase_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconbase.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconbase.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconbase, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$g.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$g($$self, $$props, $$invalidate) {
	let { $$slots = {}, $$scope } = $$props;
	validate_slots("FaFacebookF", $$slots, []);

	$$self.$set = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
	};

	$$self.$capture_state = () => ({ IconBase });

	$$self.$inject_state = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);
	return [$$props];
}

class FaFacebookF extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$g, create_fragment$g, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "FaFacebookF",
			options,
			id: create_fragment$g.name
		});
	}
}

/* node_modules/svelte-icons/fa/FaRegSquare.svelte generated by Svelte v3.24.0 */
const file$h = "node_modules/svelte-icons/fa/FaRegSquare.svelte";

// (4:8) <IconBase viewBox="0 0 448 512" {...$$props}>
function create_default_slot$f(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_element(nodes, "path", { d: true }, 1);
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zm-6 400H54c-3.3 0-6-2.7-6-6V86c0-3.3 2.7-6 6-6h340c3.3 0 6 2.7 6 6v340c0 3.3-2.7 6-6 6z");
			add_location(path, file$h, 4, 10, 153);
		},
		m: function mount(target, anchor) {
			insert_dev(target, path, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$f.name,
		type: "slot",
		source: "(4:8) <IconBase viewBox=\\\"0 0 448 512\\\" {...$$props}>",
		ctx
	});

	return block;
}

function create_fragment$h(ctx) {
	let iconbase;
	let current;
	const iconbase_spread_levels = [{ viewBox: "0 0 448 512" }, /*$$props*/ ctx[0]];

	let iconbase_props = {
		$$slots: { default: [create_default_slot$f] },
		$$scope: { ctx }
	};

	for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
		iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
	}

	iconbase = new IconBase({ props: iconbase_props, $$inline: true });

	const block = {
		c: function create() {
			create_component(iconbase.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(iconbase.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(iconbase, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const iconbase_changes = (dirty & /*$$props*/ 1)
			? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(/*$$props*/ ctx[0])])
			: {};

			if (dirty & /*$$scope*/ 2) {
				iconbase_changes.$$scope = { dirty, ctx };
			}

			iconbase.$set(iconbase_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconbase.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconbase.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconbase, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$h.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$h($$self, $$props, $$invalidate) {
	let { $$slots = {}, $$scope } = $$props;
	validate_slots("FaRegSquare", $$slots, []);

	$$self.$set = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
	};

	$$self.$capture_state = () => ({ IconBase });

	$$self.$inject_state = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);
	return [$$props];
}

class FaRegSquare extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$h, create_fragment$h, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "FaRegSquare",
			options,
			id: create_fragment$h.name
		});
	}
}

/* node_modules/svelte-icons/ti/TiStarburst.svelte generated by Svelte v3.24.0 */
const file$i = "node_modules/svelte-icons/ti/TiStarburst.svelte";

// (4:8) <IconBase viewBox="0 0 24 24" {...$$props}>
function create_default_slot$g(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_element(nodes, "path", { d: true }, 1);
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M19.064 10.109l1.179-2.387c.074-.149.068-.327-.015-.471-.083-.145-.234-.238-.401-.249l-2.656-.172-.172-2.656c-.011-.167-.104-.317-.249-.401-.145-.084-.322-.09-.472-.015l-2.385 1.18-1.477-2.215c-.186-.278-.646-.278-.832 0l-1.477 2.215-2.385-1.18c-.151-.075-.327-.069-.472.015-.145.083-.238.234-.249.401l-.171 2.656-2.657.171c-.167.011-.318.104-.401.249-.084.145-.089.322-.015.472l1.179 2.386-2.214 1.477c-.139.093-.223.249-.223.416s.083.323.223.416l2.215 1.477-1.18 2.386c-.074.15-.068.327.015.472.083.144.234.238.401.248l2.656.171.171 2.657c.011.167.104.317.249.401.144.083.32.088.472.015l2.386-1.179 1.477 2.214c.093.139.249.223.416.223s.323-.083.416-.223l1.477-2.214 2.386 1.179c.15.073.327.068.472-.015s.238-.234.249-.401l.171-2.656 2.656-.172c.167-.011.317-.104.401-.249.083-.145.089-.322.015-.472l-1.179-2.385 2.214-1.478c.139-.093.223-.249.223-.416s-.083-.323-.223-.416l-2.214-1.475z");
			add_location(path, file$i, 4, 10, 151);
		},
		m: function mount(target, anchor) {
			insert_dev(target, path, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$g.name,
		type: "slot",
		source: "(4:8) <IconBase viewBox=\\\"0 0 24 24\\\" {...$$props}>",
		ctx
	});

	return block;
}

function create_fragment$i(ctx) {
	let iconbase;
	let current;
	const iconbase_spread_levels = [{ viewBox: "0 0 24 24" }, /*$$props*/ ctx[0]];

	let iconbase_props = {
		$$slots: { default: [create_default_slot$g] },
		$$scope: { ctx }
	};

	for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
		iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
	}

	iconbase = new IconBase({ props: iconbase_props, $$inline: true });

	const block = {
		c: function create() {
			create_component(iconbase.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(iconbase.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(iconbase, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const iconbase_changes = (dirty & /*$$props*/ 1)
			? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(/*$$props*/ ctx[0])])
			: {};

			if (dirty & /*$$scope*/ 2) {
				iconbase_changes.$$scope = { dirty, ctx };
			}

			iconbase.$set(iconbase_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconbase.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconbase.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconbase, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$i.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$i($$self, $$props, $$invalidate) {
	let { $$slots = {}, $$scope } = $$props;
	validate_slots("TiStarburst", $$slots, []);

	$$self.$set = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
	};

	$$self.$capture_state = () => ({ IconBase });

	$$self.$inject_state = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);
	return [$$props];
}

class TiStarburst extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$i, create_fragment$i, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "TiStarburst",
			options,
			id: create_fragment$i.name
		});
	}
}

/* node_modules/svelte-icons/fa/FaDollarSign.svelte generated by Svelte v3.24.0 */
const file$j = "node_modules/svelte-icons/fa/FaDollarSign.svelte";

// (4:8) <IconBase viewBox="0 0 288 512" {...$$props}>
function create_default_slot$h(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_element(nodes, "path", { d: true }, 1);
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M209.2 233.4l-108-31.6C88.7 198.2 80 186.5 80 173.5c0-16.3 13.2-29.5 29.5-29.5h66.3c12.2 0 24.2 3.7 34.2 10.5 6.1 4.1 14.3 3.1 19.5-2l34.8-34c7.1-6.9 6.1-18.4-1.8-24.5C238 74.8 207.4 64.1 176 64V16c0-8.8-7.2-16-16-16h-32c-8.8 0-16 7.2-16 16v48h-2.5C45.8 64-5.4 118.7.5 183.6c4.2 46.1 39.4 83.6 83.8 96.6l102.5 30c12.5 3.7 21.2 15.3 21.2 28.3 0 16.3-13.2 29.5-29.5 29.5h-66.3C100 368 88 364.3 78 357.5c-6.1-4.1-14.3-3.1-19.5 2l-34.8 34c-7.1 6.9-6.1 18.4 1.8 24.5 24.5 19.2 55.1 29.9 86.5 30v48c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16v-48.2c46.6-.9 90.3-28.6 105.7-72.7 21.5-61.6-14.6-124.8-72.5-141.7z");
			add_location(path, file$j, 4, 10, 153);
		},
		m: function mount(target, anchor) {
			insert_dev(target, path, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$h.name,
		type: "slot",
		source: "(4:8) <IconBase viewBox=\\\"0 0 288 512\\\" {...$$props}>",
		ctx
	});

	return block;
}

function create_fragment$j(ctx) {
	let iconbase;
	let current;
	const iconbase_spread_levels = [{ viewBox: "0 0 288 512" }, /*$$props*/ ctx[0]];

	let iconbase_props = {
		$$slots: { default: [create_default_slot$h] },
		$$scope: { ctx }
	};

	for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
		iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
	}

	iconbase = new IconBase({ props: iconbase_props, $$inline: true });

	const block = {
		c: function create() {
			create_component(iconbase.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(iconbase.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(iconbase, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const iconbase_changes = (dirty & /*$$props*/ 1)
			? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(/*$$props*/ ctx[0])])
			: {};

			if (dirty & /*$$scope*/ 2) {
				iconbase_changes.$$scope = { dirty, ctx };
			}

			iconbase.$set(iconbase_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconbase.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconbase.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconbase, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$j.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$j($$self, $$props, $$invalidate) {
	let { $$slots = {}, $$scope } = $$props;
	validate_slots("FaDollarSign", $$slots, []);

	$$self.$set = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
	};

	$$self.$capture_state = () => ({ IconBase });

	$$self.$inject_state = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);
	return [$$props];
}

class FaDollarSign extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$j, create_fragment$j, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "FaDollarSign",
			options,
			id: create_fragment$j.name
		});
	}
}

/* node_modules/svelte-icons/fa/FaCalendarAlt.svelte generated by Svelte v3.24.0 */
const file$k = "node_modules/svelte-icons/fa/FaCalendarAlt.svelte";

// (4:8) <IconBase viewBox="0 0 448 512" {...$$props}>
function create_default_slot$i(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_element(nodes, "path", { d: true }, 1);
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M0 464c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V192H0v272zm320-196c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v40c0 6.6-5.4 12-12 12h-40c-6.6 0-12-5.4-12-12v-40zm0 128c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v40c0 6.6-5.4 12-12 12h-40c-6.6 0-12-5.4-12-12v-40zM192 268c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v40c0 6.6-5.4 12-12 12h-40c-6.6 0-12-5.4-12-12v-40zm0 128c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v40c0 6.6-5.4 12-12 12h-40c-6.6 0-12-5.4-12-12v-40zM64 268c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v40c0 6.6-5.4 12-12 12H76c-6.6 0-12-5.4-12-12v-40zm0 128c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v40c0 6.6-5.4 12-12 12H76c-6.6 0-12-5.4-12-12v-40zM400 64h-48V16c0-8.8-7.2-16-16-16h-32c-8.8 0-16 7.2-16 16v48H160V16c0-8.8-7.2-16-16-16h-32c-8.8 0-16 7.2-16 16v48H48C21.5 64 0 85.5 0 112v48h448v-48c0-26.5-21.5-48-48-48z");
			add_location(path, file$k, 4, 10, 153);
		},
		m: function mount(target, anchor) {
			insert_dev(target, path, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$i.name,
		type: "slot",
		source: "(4:8) <IconBase viewBox=\\\"0 0 448 512\\\" {...$$props}>",
		ctx
	});

	return block;
}

function create_fragment$k(ctx) {
	let iconbase;
	let current;
	const iconbase_spread_levels = [{ viewBox: "0 0 448 512" }, /*$$props*/ ctx[0]];

	let iconbase_props = {
		$$slots: { default: [create_default_slot$i] },
		$$scope: { ctx }
	};

	for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
		iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
	}

	iconbase = new IconBase({ props: iconbase_props, $$inline: true });

	const block = {
		c: function create() {
			create_component(iconbase.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(iconbase.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(iconbase, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const iconbase_changes = (dirty & /*$$props*/ 1)
			? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(/*$$props*/ ctx[0])])
			: {};

			if (dirty & /*$$scope*/ 2) {
				iconbase_changes.$$scope = { dirty, ctx };
			}

			iconbase.$set(iconbase_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconbase.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconbase.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconbase, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$k.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$k($$self, $$props, $$invalidate) {
	let { $$slots = {}, $$scope } = $$props;
	validate_slots("FaCalendarAlt", $$slots, []);

	$$self.$set = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
	};

	$$self.$capture_state = () => ({ IconBase });

	$$self.$inject_state = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);
	return [$$props];
}

class FaCalendarAlt extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$k, create_fragment$k, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "FaCalendarAlt",
			options,
			id: create_fragment$k.name
		});
	}
}

/* node_modules/svelte-icons/fa/FaCheckSquare.svelte generated by Svelte v3.24.0 */
const file$l = "node_modules/svelte-icons/fa/FaCheckSquare.svelte";

// (4:8) <IconBase viewBox="0 0 448 512" {...$$props}>
function create_default_slot$j(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_element(nodes, "path", { d: true }, 1);
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M400 480H48c-26.51 0-48-21.49-48-48V80c0-26.51 21.49-48 48-48h352c26.51 0 48 21.49 48 48v352c0 26.51-21.49 48-48 48zm-204.686-98.059l184-184c6.248-6.248 6.248-16.379 0-22.627l-22.627-22.627c-6.248-6.248-16.379-6.249-22.628 0L184 302.745l-70.059-70.059c-6.248-6.248-16.379-6.248-22.628 0l-22.627 22.627c-6.248 6.248-6.248 16.379 0 22.627l104 104c6.249 6.25 16.379 6.25 22.628.001z");
			add_location(path, file$l, 4, 10, 153);
		},
		m: function mount(target, anchor) {
			insert_dev(target, path, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$j.name,
		type: "slot",
		source: "(4:8) <IconBase viewBox=\\\"0 0 448 512\\\" {...$$props}>",
		ctx
	});

	return block;
}

function create_fragment$l(ctx) {
	let iconbase;
	let current;
	const iconbase_spread_levels = [{ viewBox: "0 0 448 512" }, /*$$props*/ ctx[0]];

	let iconbase_props = {
		$$slots: { default: [create_default_slot$j] },
		$$scope: { ctx }
	};

	for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
		iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
	}

	iconbase = new IconBase({ props: iconbase_props, $$inline: true });

	const block = {
		c: function create() {
			create_component(iconbase.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(iconbase.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(iconbase, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const iconbase_changes = (dirty & /*$$props*/ 1)
			? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(/*$$props*/ ctx[0])])
			: {};

			if (dirty & /*$$scope*/ 2) {
				iconbase_changes.$$scope = { dirty, ctx };
			}

			iconbase.$set(iconbase_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconbase.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconbase.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconbase, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$l.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$l($$self, $$props, $$invalidate) {
	let { $$slots = {}, $$scope } = $$props;
	validate_slots("FaCheckSquare", $$slots, []);

	$$self.$set = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
	};

	$$self.$capture_state = () => ({ IconBase });

	$$self.$inject_state = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);
	return [$$props];
}

class FaCheckSquare extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$l, create_fragment$l, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "FaCheckSquare",
			options,
			id: create_fragment$l.name
		});
	}
}

/* node_modules/svelte-icons/md/MdCloudUpload.svelte generated by Svelte v3.24.0 */
const file$m = "node_modules/svelte-icons/md/MdCloudUpload.svelte";

// (4:8) <IconBase viewBox="0 0 24 24" {...$$props}>
function create_default_slot$k(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_element(nodes, "path", { d: true }, 1);
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM14 13v4h-4v-4H7l5-5 5 5h-3z");
			add_location(path, file$m, 4, 10, 151);
		},
		m: function mount(target, anchor) {
			insert_dev(target, path, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$k.name,
		type: "slot",
		source: "(4:8) <IconBase viewBox=\\\"0 0 24 24\\\" {...$$props}>",
		ctx
	});

	return block;
}

function create_fragment$m(ctx) {
	let iconbase;
	let current;
	const iconbase_spread_levels = [{ viewBox: "0 0 24 24" }, /*$$props*/ ctx[0]];

	let iconbase_props = {
		$$slots: { default: [create_default_slot$k] },
		$$scope: { ctx }
	};

	for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
		iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
	}

	iconbase = new IconBase({ props: iconbase_props, $$inline: true });

	const block = {
		c: function create() {
			create_component(iconbase.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(iconbase.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(iconbase, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const iconbase_changes = (dirty & /*$$props*/ 1)
			? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(/*$$props*/ ctx[0])])
			: {};

			if (dirty & /*$$scope*/ 2) {
				iconbase_changes.$$scope = { dirty, ctx };
			}

			iconbase.$set(iconbase_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconbase.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconbase.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconbase, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$m.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$m($$self, $$props, $$invalidate) {
	let { $$slots = {}, $$scope } = $$props;
	validate_slots("MdCloudUpload", $$slots, []);

	$$self.$set = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
	};

	$$self.$capture_state = () => ({ IconBase });

	$$self.$inject_state = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);
	return [$$props];
}

class MdCloudUpload extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$m, create_fragment$m, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "MdCloudUpload",
			options,
			id: create_fragment$m.name
		});
	}
}

/* node_modules/svelte-icons/md/MdRemoveRedEye.svelte generated by Svelte v3.24.0 */
const file$n = "node_modules/svelte-icons/md/MdRemoveRedEye.svelte";

// (4:8) <IconBase viewBox="0 0 24 24" {...$$props}>
function create_default_slot$l(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_element(nodes, "path", { d: true }, 1);
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z");
			add_location(path, file$n, 4, 10, 151);
		},
		m: function mount(target, anchor) {
			insert_dev(target, path, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$l.name,
		type: "slot",
		source: "(4:8) <IconBase viewBox=\\\"0 0 24 24\\\" {...$$props}>",
		ctx
	});

	return block;
}

function create_fragment$n(ctx) {
	let iconbase;
	let current;
	const iconbase_spread_levels = [{ viewBox: "0 0 24 24" }, /*$$props*/ ctx[0]];

	let iconbase_props = {
		$$slots: { default: [create_default_slot$l] },
		$$scope: { ctx }
	};

	for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
		iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
	}

	iconbase = new IconBase({ props: iconbase_props, $$inline: true });

	const block = {
		c: function create() {
			create_component(iconbase.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(iconbase.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(iconbase, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const iconbase_changes = (dirty & /*$$props*/ 1)
			? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(/*$$props*/ ctx[0])])
			: {};

			if (dirty & /*$$scope*/ 2) {
				iconbase_changes.$$scope = { dirty, ctx };
			}

			iconbase.$set(iconbase_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconbase.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconbase.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconbase, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$n.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$n($$self, $$props, $$invalidate) {
	let { $$slots = {}, $$scope } = $$props;
	validate_slots("MdRemoveRedEye", $$slots, []);

	$$self.$set = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
	};

	$$self.$capture_state = () => ({ IconBase });

	$$self.$inject_state = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);
	return [$$props];
}

class MdRemoveRedEye extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$n, create_fragment$n, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "MdRemoveRedEye",
			options,
			id: create_fragment$n.name
		});
	}
}

/* node_modules/svelte-icons/fa/FaMapMarkerAlt.svelte generated by Svelte v3.24.0 */
const file$o = "node_modules/svelte-icons/fa/FaMapMarkerAlt.svelte";

// (4:8) <IconBase viewBox="0 0 384 512" {...$$props}>
function create_default_slot$m(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_element(nodes, "path", { d: true }, 1);
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M172.268 501.67C26.97 291.031 0 269.413 0 192 0 85.961 85.961 0 192 0s192 85.961 192 192c0 77.413-26.97 99.031-172.268 309.67-9.535 13.774-29.93 13.773-39.464 0zM192 272c44.183 0 80-35.817 80-80s-35.817-80-80-80-80 35.817-80 80 35.817 80 80 80z");
			add_location(path, file$o, 4, 10, 153);
		},
		m: function mount(target, anchor) {
			insert_dev(target, path, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$m.name,
		type: "slot",
		source: "(4:8) <IconBase viewBox=\\\"0 0 384 512\\\" {...$$props}>",
		ctx
	});

	return block;
}

function create_fragment$o(ctx) {
	let iconbase;
	let current;
	const iconbase_spread_levels = [{ viewBox: "0 0 384 512" }, /*$$props*/ ctx[0]];

	let iconbase_props = {
		$$slots: { default: [create_default_slot$m] },
		$$scope: { ctx }
	};

	for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
		iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
	}

	iconbase = new IconBase({ props: iconbase_props, $$inline: true });

	const block = {
		c: function create() {
			create_component(iconbase.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(iconbase.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(iconbase, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const iconbase_changes = (dirty & /*$$props*/ 1)
			? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(/*$$props*/ ctx[0])])
			: {};

			if (dirty & /*$$scope*/ 2) {
				iconbase_changes.$$scope = { dirty, ctx };
			}

			iconbase.$set(iconbase_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconbase.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconbase.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconbase, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$o.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$o($$self, $$props, $$invalidate) {
	let { $$slots = {}, $$scope } = $$props;
	validate_slots("FaMapMarkerAlt", $$slots, []);

	$$self.$set = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
	};

	$$self.$capture_state = () => ({ IconBase });

	$$self.$inject_state = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);
	return [$$props];
}

class FaMapMarkerAlt extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$o, create_fragment$o, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "FaMapMarkerAlt",
			options,
			id: create_fragment$o.name
		});
	}
}

/* node_modules/svelte-icons/fa/FaTelegramPlane.svelte generated by Svelte v3.24.0 */
const file$p = "node_modules/svelte-icons/fa/FaTelegramPlane.svelte";

// (4:8) <IconBase viewBox="0 0 448 512" {...$$props}>
function create_default_slot$n(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_element(nodes, "path", { d: true }, 1);
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M446.7 98.6l-67.6 318.8c-5.1 22.5-18.4 28.1-37.3 17.5l-103-75.9-49.7 47.8c-5.5 5.5-10.1 10.1-20.7 10.1l7.4-104.9 190.9-172.5c8.3-7.4-1.8-11.5-12.9-4.1L117.8 284 16.2 252.2c-22.1-6.9-22.5-22.1 4.6-32.7L418.2 66.4c18.4-6.9 34.5 4.1 28.5 32.2z");
			add_location(path, file$p, 4, 10, 153);
		},
		m: function mount(target, anchor) {
			insert_dev(target, path, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$n.name,
		type: "slot",
		source: "(4:8) <IconBase viewBox=\\\"0 0 448 512\\\" {...$$props}>",
		ctx
	});

	return block;
}

function create_fragment$p(ctx) {
	let iconbase;
	let current;
	const iconbase_spread_levels = [{ viewBox: "0 0 448 512" }, /*$$props*/ ctx[0]];

	let iconbase_props = {
		$$slots: { default: [create_default_slot$n] },
		$$scope: { ctx }
	};

	for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
		iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
	}

	iconbase = new IconBase({ props: iconbase_props, $$inline: true });

	const block = {
		c: function create() {
			create_component(iconbase.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(iconbase.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(iconbase, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const iconbase_changes = (dirty & /*$$props*/ 1)
			? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(/*$$props*/ ctx[0])])
			: {};

			if (dirty & /*$$scope*/ 2) {
				iconbase_changes.$$scope = { dirty, ctx };
			}

			iconbase.$set(iconbase_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconbase.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconbase.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconbase, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$p.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$p($$self, $$props, $$invalidate) {
	let { $$slots = {}, $$scope } = $$props;
	validate_slots("FaTelegramPlane", $$slots, []);

	$$self.$set = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
	};

	$$self.$capture_state = () => ({ IconBase });

	$$self.$inject_state = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);
	return [$$props];
}

class FaTelegramPlane extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$p, create_fragment$p, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "FaTelegramPlane",
			options,
			id: create_fragment$p.name
		});
	}
}

/* node_modules/svelte-icons/fa/FaLongArrowAltUp.svelte generated by Svelte v3.24.0 */
const file$q = "node_modules/svelte-icons/fa/FaLongArrowAltUp.svelte";

// (4:8) <IconBase viewBox="0 0 256 512" {...$$props}>
function create_default_slot$o(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_element(nodes, "path", { d: true }, 1);
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M88 166.059V468c0 6.627 5.373 12 12 12h56c6.627 0 12-5.373 12-12V166.059h46.059c21.382 0 32.09-25.851 16.971-40.971l-86.059-86.059c-9.373-9.373-24.569-9.373-33.941 0l-86.059 86.059c-15.119 15.119-4.411 40.971 16.971 40.971H88z");
			add_location(path, file$q, 4, 10, 153);
		},
		m: function mount(target, anchor) {
			insert_dev(target, path, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$o.name,
		type: "slot",
		source: "(4:8) <IconBase viewBox=\\\"0 0 256 512\\\" {...$$props}>",
		ctx
	});

	return block;
}

function create_fragment$q(ctx) {
	let iconbase;
	let current;
	const iconbase_spread_levels = [{ viewBox: "0 0 256 512" }, /*$$props*/ ctx[0]];

	let iconbase_props = {
		$$slots: { default: [create_default_slot$o] },
		$$scope: { ctx }
	};

	for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
		iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
	}

	iconbase = new IconBase({ props: iconbase_props, $$inline: true });

	const block = {
		c: function create() {
			create_component(iconbase.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(iconbase.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(iconbase, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const iconbase_changes = (dirty & /*$$props*/ 1)
			? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(/*$$props*/ ctx[0])])
			: {};

			if (dirty & /*$$scope*/ 2) {
				iconbase_changes.$$scope = { dirty, ctx };
			}

			iconbase.$set(iconbase_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconbase.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconbase.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconbase, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$q.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$q($$self, $$props, $$invalidate) {
	let { $$slots = {}, $$scope } = $$props;
	validate_slots("FaLongArrowAltUp", $$slots, []);

	$$self.$set = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
	};

	$$self.$capture_state = () => ({ IconBase });

	$$self.$inject_state = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);
	return [$$props];
}

class FaLongArrowAltUp extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$q, create_fragment$q, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "FaLongArrowAltUp",
			options,
			id: create_fragment$q.name
		});
	}
}

/* node_modules/svelte-icons/fa/FaLongArrowAltDown.svelte generated by Svelte v3.24.0 */
const file$r = "node_modules/svelte-icons/fa/FaLongArrowAltDown.svelte";

// (4:8) <IconBase viewBox="0 0 256 512" {...$$props}>
function create_default_slot$p(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_element(nodes, "path", { d: true }, 1);
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M168 345.941V44c0-6.627-5.373-12-12-12h-56c-6.627 0-12 5.373-12 12v301.941H41.941c-21.382 0-32.09 25.851-16.971 40.971l86.059 86.059c9.373 9.373 24.569 9.373 33.941 0l86.059-86.059c15.119-15.119 4.411-40.971-16.971-40.971H168z");
			add_location(path, file$r, 4, 10, 153);
		},
		m: function mount(target, anchor) {
			insert_dev(target, path, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$p.name,
		type: "slot",
		source: "(4:8) <IconBase viewBox=\\\"0 0 256 512\\\" {...$$props}>",
		ctx
	});

	return block;
}

function create_fragment$r(ctx) {
	let iconbase;
	let current;
	const iconbase_spread_levels = [{ viewBox: "0 0 256 512" }, /*$$props*/ ctx[0]];

	let iconbase_props = {
		$$slots: { default: [create_default_slot$p] },
		$$scope: { ctx }
	};

	for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
		iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
	}

	iconbase = new IconBase({ props: iconbase_props, $$inline: true });

	const block = {
		c: function create() {
			create_component(iconbase.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(iconbase.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(iconbase, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const iconbase_changes = (dirty & /*$$props*/ 1)
			? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(/*$$props*/ ctx[0])])
			: {};

			if (dirty & /*$$scope*/ 2) {
				iconbase_changes.$$scope = { dirty, ctx };
			}

			iconbase.$set(iconbase_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconbase.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconbase.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconbase, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$r.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$r($$self, $$props, $$invalidate) {
	let { $$slots = {}, $$scope } = $$props;
	validate_slots("FaLongArrowAltDown", $$slots, []);

	$$self.$set = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
	};

	$$self.$capture_state = () => ({ IconBase });

	$$self.$inject_state = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);
	return [$$props];
}

class FaLongArrowAltDown extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$r, create_fragment$r, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "FaLongArrowAltDown",
			options,
			id: create_fragment$r.name
		});
	}
}

/* node_modules/svelte-icons/fa/FaLongArrowAltLeft.svelte generated by Svelte v3.24.0 */
const file$s = "node_modules/svelte-icons/fa/FaLongArrowAltLeft.svelte";

// (4:8) <IconBase viewBox="0 0 448 512" {...$$props}>
function create_default_slot$q(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_element(nodes, "path", { d: true }, 1);
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M134.059 296H436c6.627 0 12-5.373 12-12v-56c0-6.627-5.373-12-12-12H134.059v-46.059c0-21.382-25.851-32.09-40.971-16.971L7.029 239.029c-9.373 9.373-9.373 24.569 0 33.941l86.059 86.059c15.119 15.119 40.971 4.411 40.971-16.971V296z");
			add_location(path, file$s, 4, 10, 153);
		},
		m: function mount(target, anchor) {
			insert_dev(target, path, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$q.name,
		type: "slot",
		source: "(4:8) <IconBase viewBox=\\\"0 0 448 512\\\" {...$$props}>",
		ctx
	});

	return block;
}

function create_fragment$s(ctx) {
	let iconbase;
	let current;
	const iconbase_spread_levels = [{ viewBox: "0 0 448 512" }, /*$$props*/ ctx[0]];

	let iconbase_props = {
		$$slots: { default: [create_default_slot$q] },
		$$scope: { ctx }
	};

	for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
		iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
	}

	iconbase = new IconBase({ props: iconbase_props, $$inline: true });

	const block = {
		c: function create() {
			create_component(iconbase.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(iconbase.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(iconbase, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const iconbase_changes = (dirty & /*$$props*/ 1)
			? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(/*$$props*/ ctx[0])])
			: {};

			if (dirty & /*$$scope*/ 2) {
				iconbase_changes.$$scope = { dirty, ctx };
			}

			iconbase.$set(iconbase_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconbase.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconbase.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconbase, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$s.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$s($$self, $$props, $$invalidate) {
	let { $$slots = {}, $$scope } = $$props;
	validate_slots("FaLongArrowAltLeft", $$slots, []);

	$$self.$set = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
	};

	$$self.$capture_state = () => ({ IconBase });

	$$self.$inject_state = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);
	return [$$props];
}

class FaLongArrowAltLeft extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$s, create_fragment$s, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "FaLongArrowAltLeft",
			options,
			id: create_fragment$s.name
		});
	}
}

/* node_modules/svelte-icons/fa/FaLongArrowAltRight.svelte generated by Svelte v3.24.0 */
const file$t = "node_modules/svelte-icons/fa/FaLongArrowAltRight.svelte";

// (4:8) <IconBase viewBox="0 0 448 512" {...$$props}>
function create_default_slot$r(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_element(nodes, "path", { d: true }, 1);
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M313.941 216H12c-6.627 0-12 5.373-12 12v56c0 6.627 5.373 12 12 12h301.941v46.059c0 21.382 25.851 32.09 40.971 16.971l86.059-86.059c9.373-9.373 9.373-24.569 0-33.941l-86.059-86.059c-15.119-15.119-40.971-4.411-40.971 16.971V216z");
			add_location(path, file$t, 4, 10, 153);
		},
		m: function mount(target, anchor) {
			insert_dev(target, path, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$r.name,
		type: "slot",
		source: "(4:8) <IconBase viewBox=\\\"0 0 448 512\\\" {...$$props}>",
		ctx
	});

	return block;
}

function create_fragment$t(ctx) {
	let iconbase;
	let current;
	const iconbase_spread_levels = [{ viewBox: "0 0 448 512" }, /*$$props*/ ctx[0]];

	let iconbase_props = {
		$$slots: { default: [create_default_slot$r] },
		$$scope: { ctx }
	};

	for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
		iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
	}

	iconbase = new IconBase({ props: iconbase_props, $$inline: true });

	const block = {
		c: function create() {
			create_component(iconbase.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(iconbase.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(iconbase, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const iconbase_changes = (dirty & /*$$props*/ 1)
			? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(/*$$props*/ ctx[0])])
			: {};

			if (dirty & /*$$scope*/ 2) {
				iconbase_changes.$$scope = { dirty, ctx };
			}

			iconbase.$set(iconbase_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconbase.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconbase.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconbase, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$t.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$t($$self, $$props, $$invalidate) {
	let { $$slots = {}, $$scope } = $$props;
	validate_slots("FaLongArrowAltRight", $$slots, []);

	$$self.$set = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
	};

	$$self.$capture_state = () => ({ IconBase });

	$$self.$inject_state = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);
	return [$$props];
}

class FaLongArrowAltRight extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$t, create_fragment$t, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "FaLongArrowAltRight",
			options,
			id: create_fragment$t.name
		});
	}
}

/* node_modules/svelte-icons/md/MdKeyboardArrowUp.svelte generated by Svelte v3.24.0 */
const file$u = "node_modules/svelte-icons/md/MdKeyboardArrowUp.svelte";

// (4:8) <IconBase viewBox="0 0 24 24" {...$$props}>
function create_default_slot$s(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_element(nodes, "path", { d: true }, 1);
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z");
			add_location(path, file$u, 4, 10, 151);
		},
		m: function mount(target, anchor) {
			insert_dev(target, path, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$s.name,
		type: "slot",
		source: "(4:8) <IconBase viewBox=\\\"0 0 24 24\\\" {...$$props}>",
		ctx
	});

	return block;
}

function create_fragment$u(ctx) {
	let iconbase;
	let current;
	const iconbase_spread_levels = [{ viewBox: "0 0 24 24" }, /*$$props*/ ctx[0]];

	let iconbase_props = {
		$$slots: { default: [create_default_slot$s] },
		$$scope: { ctx }
	};

	for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
		iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
	}

	iconbase = new IconBase({ props: iconbase_props, $$inline: true });

	const block = {
		c: function create() {
			create_component(iconbase.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(iconbase.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(iconbase, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const iconbase_changes = (dirty & /*$$props*/ 1)
			? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(/*$$props*/ ctx[0])])
			: {};

			if (dirty & /*$$scope*/ 2) {
				iconbase_changes.$$scope = { dirty, ctx };
			}

			iconbase.$set(iconbase_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconbase.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconbase.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconbase, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$u.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$u($$self, $$props, $$invalidate) {
	let { $$slots = {}, $$scope } = $$props;
	validate_slots("MdKeyboardArrowUp", $$slots, []);

	$$self.$set = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
	};

	$$self.$capture_state = () => ({ IconBase });

	$$self.$inject_state = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);
	return [$$props];
}

class MdKeyboardArrowUp extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$u, create_fragment$u, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "MdKeyboardArrowUp",
			options,
			id: create_fragment$u.name
		});
	}
}

/* node_modules/svelte-icons/md/MdKeyboardArrowLeft.svelte generated by Svelte v3.24.0 */
const file$v = "node_modules/svelte-icons/md/MdKeyboardArrowLeft.svelte";

// (4:8) <IconBase viewBox="0 0 24 24" {...$$props}>
function create_default_slot$t(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_element(nodes, "path", { d: true }, 1);
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M15.41 16.09l-4.58-4.59 4.58-4.59L14 5.5l-6 6 6 6z");
			add_location(path, file$v, 4, 10, 151);
		},
		m: function mount(target, anchor) {
			insert_dev(target, path, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$t.name,
		type: "slot",
		source: "(4:8) <IconBase viewBox=\\\"0 0 24 24\\\" {...$$props}>",
		ctx
	});

	return block;
}

function create_fragment$v(ctx) {
	let iconbase;
	let current;
	const iconbase_spread_levels = [{ viewBox: "0 0 24 24" }, /*$$props*/ ctx[0]];

	let iconbase_props = {
		$$slots: { default: [create_default_slot$t] },
		$$scope: { ctx }
	};

	for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
		iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
	}

	iconbase = new IconBase({ props: iconbase_props, $$inline: true });

	const block = {
		c: function create() {
			create_component(iconbase.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(iconbase.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(iconbase, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const iconbase_changes = (dirty & /*$$props*/ 1)
			? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(/*$$props*/ ctx[0])])
			: {};

			if (dirty & /*$$scope*/ 2) {
				iconbase_changes.$$scope = { dirty, ctx };
			}

			iconbase.$set(iconbase_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconbase.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconbase.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconbase, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$v.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$v($$self, $$props, $$invalidate) {
	let { $$slots = {}, $$scope } = $$props;
	validate_slots("MdKeyboardArrowLeft", $$slots, []);

	$$self.$set = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
	};

	$$self.$capture_state = () => ({ IconBase });

	$$self.$inject_state = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);
	return [$$props];
}

class MdKeyboardArrowLeft extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$v, create_fragment$v, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "MdKeyboardArrowLeft",
			options,
			id: create_fragment$v.name
		});
	}
}

/* node_modules/svelte-icons/md/MdKeyboardArrowDown.svelte generated by Svelte v3.24.0 */
const file$w = "node_modules/svelte-icons/md/MdKeyboardArrowDown.svelte";

// (4:8) <IconBase viewBox="0 0 24 24" {...$$props}>
function create_default_slot$u(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_element(nodes, "path", { d: true }, 1);
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M7.41 7.84L12 12.42l4.59-4.58L18 9.25l-6 6-6-6z");
			add_location(path, file$w, 4, 10, 151);
		},
		m: function mount(target, anchor) {
			insert_dev(target, path, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$u.name,
		type: "slot",
		source: "(4:8) <IconBase viewBox=\\\"0 0 24 24\\\" {...$$props}>",
		ctx
	});

	return block;
}

function create_fragment$w(ctx) {
	let iconbase;
	let current;
	const iconbase_spread_levels = [{ viewBox: "0 0 24 24" }, /*$$props*/ ctx[0]];

	let iconbase_props = {
		$$slots: { default: [create_default_slot$u] },
		$$scope: { ctx }
	};

	for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
		iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
	}

	iconbase = new IconBase({ props: iconbase_props, $$inline: true });

	const block = {
		c: function create() {
			create_component(iconbase.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(iconbase.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(iconbase, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const iconbase_changes = (dirty & /*$$props*/ 1)
			? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(/*$$props*/ ctx[0])])
			: {};

			if (dirty & /*$$scope*/ 2) {
				iconbase_changes.$$scope = { dirty, ctx };
			}

			iconbase.$set(iconbase_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconbase.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconbase.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconbase, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$w.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$w($$self, $$props, $$invalidate) {
	let { $$slots = {}, $$scope } = $$props;
	validate_slots("MdKeyboardArrowDown", $$slots, []);

	$$self.$set = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
	};

	$$self.$capture_state = () => ({ IconBase });

	$$self.$inject_state = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);
	return [$$props];
}

class MdKeyboardArrowDown extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$w, create_fragment$w, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "MdKeyboardArrowDown",
			options,
			id: create_fragment$w.name
		});
	}
}

/* node_modules/svelte-icons/md/MdKeyboardArrowRight.svelte generated by Svelte v3.24.0 */
const file$x = "node_modules/svelte-icons/md/MdKeyboardArrowRight.svelte";

// (4:8) <IconBase viewBox="0 0 24 24" {...$$props}>
function create_default_slot$v(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_element(nodes, "path", { d: true }, 1);
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z");
			add_location(path, file$x, 4, 10, 151);
		},
		m: function mount(target, anchor) {
			insert_dev(target, path, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$v.name,
		type: "slot",
		source: "(4:8) <IconBase viewBox=\\\"0 0 24 24\\\" {...$$props}>",
		ctx
	});

	return block;
}

function create_fragment$x(ctx) {
	let iconbase;
	let current;
	const iconbase_spread_levels = [{ viewBox: "0 0 24 24" }, /*$$props*/ ctx[0]];

	let iconbase_props = {
		$$slots: { default: [create_default_slot$v] },
		$$scope: { ctx }
	};

	for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
		iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
	}

	iconbase = new IconBase({ props: iconbase_props, $$inline: true });

	const block = {
		c: function create() {
			create_component(iconbase.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(iconbase.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(iconbase, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const iconbase_changes = (dirty & /*$$props*/ 1)
			? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(/*$$props*/ ctx[0])])
			: {};

			if (dirty & /*$$scope*/ 2) {
				iconbase_changes.$$scope = { dirty, ctx };
			}

			iconbase.$set(iconbase_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconbase.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconbase.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconbase, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$x.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$x($$self, $$props, $$invalidate) {
	let { $$slots = {}, $$scope } = $$props;
	validate_slots("MdKeyboardArrowRight", $$slots, []);

	$$self.$set = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
	};

	$$self.$capture_state = () => ({ IconBase });

	$$self.$inject_state = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);
	return [$$props];
}

class MdKeyboardArrowRight extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$x, create_fragment$x, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "MdKeyboardArrowRight",
			options,
			id: create_fragment$x.name
		});
	}
}

/* node_modules/svelte-icons/io/IoIosCheckmarkCircle.svelte generated by Svelte v3.24.0 */
const file$y = "node_modules/svelte-icons/io/IoIosCheckmarkCircle.svelte";

// (4:8) <IconBase viewBox="0 0 512 512" {...$$props}>
function create_default_slot$w(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_element(nodes, "path", { d: true }, 1);
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M256 48C141.1 48 48 141.1 48 256s93.1 208 208 208 208-93.1 208-208S370.9 48 256 48zm106.5 150.5L228.8 332.8h-.1c-1.7 1.7-6.3 5.5-11.6 5.5-3.8 0-8.1-2.1-11.7-5.7l-56-56c-1.6-1.6-1.6-4.1 0-5.7l17.8-17.8c.8-.8 1.8-1.2 2.8-1.2 1 0 2 .4 2.8 1.2l44.4 44.4 122-122.9c.8-.8 1.8-1.2 2.8-1.2 1.1 0 2.1.4 2.8 1.2l17.5 18.1c1.8 1.7 1.8 4.2.2 5.8z");
			add_location(path, file$y, 4, 10, 153);
		},
		m: function mount(target, anchor) {
			insert_dev(target, path, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$w.name,
		type: "slot",
		source: "(4:8) <IconBase viewBox=\\\"0 0 512 512\\\" {...$$props}>",
		ctx
	});

	return block;
}

function create_fragment$y(ctx) {
	let iconbase;
	let current;
	const iconbase_spread_levels = [{ viewBox: "0 0 512 512" }, /*$$props*/ ctx[0]];

	let iconbase_props = {
		$$slots: { default: [create_default_slot$w] },
		$$scope: { ctx }
	};

	for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
		iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
	}

	iconbase = new IconBase({ props: iconbase_props, $$inline: true });

	const block = {
		c: function create() {
			create_component(iconbase.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(iconbase.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(iconbase, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const iconbase_changes = (dirty & /*$$props*/ 1)
			? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(/*$$props*/ ctx[0])])
			: {};

			if (dirty & /*$$scope*/ 2) {
				iconbase_changes.$$scope = { dirty, ctx };
			}

			iconbase.$set(iconbase_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconbase.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconbase.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconbase, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$y.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$y($$self, $$props, $$invalidate) {
	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IoIosCheckmarkCircle", $$slots, []);

	$$self.$set = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
	};

	$$self.$capture_state = () => ({ IconBase });

	$$self.$inject_state = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);
	return [$$props];
}

class IoIosCheckmarkCircle extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$y, create_fragment$y, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IoIosCheckmarkCircle",
			options,
			id: create_fragment$y.name
		});
	}
}

/* node_modules/svelte-icons/io/IoIosCloseCircleOutline.svelte generated by Svelte v3.24.0 */
const file$z = "node_modules/svelte-icons/io/IoIosCloseCircleOutline.svelte";

// (4:8) <IconBase viewBox="0 0 512 512" {...$$props}>
function create_default_slot$x(ctx) {
	let path0;
	let t;
	let path1;

	const block = {
		c: function create() {
			path0 = svg_element("path");
			t = space();
			path1 = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path0 = claim_element(nodes, "path", { d: true }, 1);
			children(path0).forEach(detach_dev);
			t = claim_space(nodes);
			path1 = claim_element(nodes, "path", { d: true }, 1);
			children(path1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path0, "d", "M331.3 308.7L278.6 256l52.7-52.7c6.2-6.2 6.2-16.4 0-22.6-6.2-6.2-16.4-6.2-22.6 0L256 233.4l-52.7-52.7c-6.2-6.2-15.6-7.1-22.6 0-7.1 7.1-6 16.6 0 22.6l52.7 52.7-52.7 52.7c-6.7 6.7-6.4 16.3 0 22.6 6.4 6.4 16.4 6.2 22.6 0l52.7-52.7 52.7 52.7c6.2 6.2 16.4 6.2 22.6 0 6.3-6.2 6.3-16.4 0-22.6z");
			add_location(path0, file$z, 4, 10, 153);
			attr_dev(path1, "d", "M256 76c48.1 0 93.3 18.7 127.3 52.7S436 207.9 436 256s-18.7 93.3-52.7 127.3S304.1 436 256 436c-48.1 0-93.3-18.7-127.3-52.7S76 304.1 76 256s18.7-93.3 52.7-127.3S207.9 76 256 76m0-28C141.1 48 48 141.1 48 256s93.1 208 208 208 208-93.1 208-208S370.9 48 256 48z");
			add_location(path1, file$z, 5, 0, 453);
		},
		m: function mount(target, anchor) {
			insert_dev(target, path0, anchor);
			insert_dev(target, t, anchor);
			insert_dev(target, path1, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(path0);
			if (detaching) detach_dev(t);
			if (detaching) detach_dev(path1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$x.name,
		type: "slot",
		source: "(4:8) <IconBase viewBox=\\\"0 0 512 512\\\" {...$$props}>",
		ctx
	});

	return block;
}

function create_fragment$z(ctx) {
	let iconbase;
	let current;
	const iconbase_spread_levels = [{ viewBox: "0 0 512 512" }, /*$$props*/ ctx[0]];

	let iconbase_props = {
		$$slots: { default: [create_default_slot$x] },
		$$scope: { ctx }
	};

	for (let i = 0; i < iconbase_spread_levels.length; i += 1) {
		iconbase_props = assign(iconbase_props, iconbase_spread_levels[i]);
	}

	iconbase = new IconBase({ props: iconbase_props, $$inline: true });

	const block = {
		c: function create() {
			create_component(iconbase.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(iconbase.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(iconbase, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const iconbase_changes = (dirty & /*$$props*/ 1)
			? get_spread_update(iconbase_spread_levels, [iconbase_spread_levels[0], get_spread_object(/*$$props*/ ctx[0])])
			: {};

			if (dirty & /*$$scope*/ 2) {
				iconbase_changes.$$scope = { dirty, ctx };
			}

			iconbase.$set(iconbase_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconbase.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconbase.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconbase, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$z.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$z($$self, $$props, $$invalidate) {
	let { $$slots = {}, $$scope } = $$props;
	validate_slots("IoIosCloseCircleOutline", $$slots, []);

	$$self.$set = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
	};

	$$self.$capture_state = () => ({ IconBase });

	$$self.$inject_state = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);
	return [$$props];
}

class IoIosCloseCircleOutline extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$z, create_fragment$z, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IoIosCloseCircleOutline",
			options,
			id: create_fragment$z.name
		});
	}
}

var icons = {
    email: FaAt,
    edit: MdEdit,
    link: MdLink,
    moon: FaMoon,
    male: GiMale,
    send: IoMdSend,
    share: FaShare,
    heart: FaHeart,
    viber: FaViber,
    close: IoMdClose,
    box: FaRegSquare,
    search: GoSearch,
    female: GiFemale,
    phone: FaPhoneAlt,
    coin: FaDollarSign,
    eye: MdRemoveRedEye,
    polygon: TiStarburst,
    facebook: FaFacebookF,
    upload: MdCloudUpload,
    'check-flag': MdCheck,
    calendar: FaCalendarAlt,
    location: FaMapMarkerAlt,
    telegram: FaTelegramPlane,
    'box-checked': FaCheckSquare,
    'arrow-up': FaLongArrowAltUp,
    'arrow-left': FaLongArrowAltLeft,
    'arrow-down': FaLongArrowAltDown,
    'arrow-right': FaLongArrowAltRight,
    'caret-up': MdKeyboardArrowUp,
    'caret-left': MdKeyboardArrowLeft,
    'caret-down': MdKeyboardArrowDown,
    'caret-right': MdKeyboardArrowRight,
    'checked-circle': IoIosCheckmarkCircle,
    'cancel-circle': IoIosCloseCircleOutline,
};

/**
 *
 * @description API URLs builders.
 */
var endpoints = {
    USER: (id) => `user.json`,
    USERS: () => `users.json`,

    RECENT: (id) => `recent.json`,
    RECENTS: () => `recents.json`,

    COMMENT: (id) => `comment.json`,
    COMMENTS: () => `comments.json`,

    FUND: (id) => `fund.json`,
    FUNDS: () => `funds.json`,

    ORGANIZATION: (id) => `organization.json`,
    ORGANIZATIONS: () => `organizations.json`,

    IMAGES_UPLOAD: () => `/images/upload`,
};
// export default {
//     USER: (id) => `apiusers/${id || ':id'}`,
//     USERS: () => `apiusers`,
//
//     RECENT: (id) => `apirecents/${id || ':id'}`,
//     RECENTS: () => `apirecents`,
//
//     COMMENT: (id) => `apicomments/${id || ':id'}`,
//     COMMENTS: () => `apicomments`,
//
//     FUND: (id) => `apifunds/${id || ':id'}`,
//     FUNDS: () => `apifunds`,
//
//     ORGANIZATION: (id) => `apiorganizations/${id || ':id'}`,
//     ORGANIZATIONS: () => `apiorganizations`,
// }

const vaccinations = [
    {
        text: 'Від кліщів',
        value: 'from-fungi'
    },
    {
        text: 'Від сказу',
        value: 'from-rabies'
    },
    {
        text: 'Від парагрипу',
        value: 'from-parainfluenza'
    },
    {
        text: 'Від чуми м\'ясоїдних',
        value: 'from-carnivorous-plague'
    },
    {
        text: 'Від парвовіроз',
        value: 'from-parvovirus'
    },
    {
        text: 'Від аденовіроз',
        value: 'from-adenovirus'
    },
    {
        text: 'Від лептоспіроз',
        value: 'from-leptospirosis'
    },
];

var options = /*#__PURE__*/Object.freeze({
    __proto__: null,
    vaccinations: vaccinations
});

/* src/components/Icon.svelte generated by Svelte v3.24.0 */
const file$A = "src/components/Icon.svelte";

function add_css$2() {
	var style = element("style");
	style.id = "svelte-1v3w8cp-style";
	style.textContent = ".ico.svelte-1v3w8cp{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-item-align:stretch;align-self:stretch;display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;vertical-align:middle}.ico.svelte-1v3w8cp:not(.custom){color:rgba(var(--theme-svg-fill))}.tiny.svelte-1v3w8cp{width:13px;height:13px;-webkit-box-flex:0;-ms-flex:none;flex:none;-ms-flex-item-align:auto;align-self:auto}.small.svelte-1v3w8cp{width:18px;height:18px;-webkit-box-flex:0;-ms-flex:none;flex:none;-ms-flex-item-align:auto;align-self:auto}.medium.svelte-1v3w8cp{width:24px;height:24px;-webkit-box-flex:0;-ms-flex:none;flex:none;-ms-flex-item-align:auto;align-self:auto}.big.svelte-1v3w8cp{width:30px;height:30px;-webkit-box-flex:0;-ms-flex:none;flex:none;-ms-flex-item-align:auto;align-self:auto}.large.svelte-1v3w8cp{width:40px;height:40px;-webkit-box-flex:0;-ms-flex:none;flex:none;-ms-flex-item-align:auto;align-self:auto}.ico.primary.svelte-1v3w8cp{color:rgb(var(--color-success))}.ico.danger.svelte-1v3w8cp{color:rgb(var(--color-danger))}.ico.info.svelte-1v3w8cp{color:rgb(var(--color-info))}.ico.light.svelte-1v3w8cp{color:rgb(var(--color-white))}.ico.dark.svelte-1v3w8cp{color:rgb(var(--color-black))}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSWNvbi5zdmVsdGUiLCJzb3VyY2VzIjpbIkljb24uc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzY3JpcHQ+XG4gICAgLyoqXG4gICAgICogQGluZm8gc2VlIG1vcmUgaWNvbnM6IGh0dHBzOi8vd3d3LnN2ZWx0ZS1pY29ucy5naWJkaWcuY29tL1xuICAgICAqL1xuICAgIGltcG9ydCB7IGNsYXNzbmFtZXMsIHRvQ1NTU3RyaW5nIH0gZnJvbSAnQHV0aWxzJ1xuICAgIGltcG9ydCB7IGljb25zIH0gZnJvbSAnQGNvbmZpZydcblxuXG4gICAgZXhwb3J0IGxldCB0eXBlXG4gICAgZXhwb3J0IGxldCBpcyA9IG51bGwgLy8gcHJpbWFyeXxpbmZvfGRhbmdlcnxsaWdodHxkYXJrXG4gICAgZXhwb3J0IGxldCBzaXplID0gbnVsbCAvLyBzbWFsbHxtZWRpdW18YmlnXG4gICAgZXhwb3J0IGxldCByb3RhdGUgPSAwXG4gICAgZXhwb3J0IGxldCBzdHlsZSA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgaWQgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IHRpdGxlID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCBhcmlhTGFiZWwgPSB1bmRlZmluZWRcblxuICAgIGxldCB0aXRsZVByb3AgPSB0aXRsZSB8fCBhcmlhTGFiZWxcbiAgICBsZXQgYXJpYUxhYmVsUHJvcCA9IGFyaWFMYWJlbCB8fCB0aXRsZVxuICAgIGxldCBzdHlsZVByb3AgPSB0b0NTU1N0cmluZyh7IHRyYW5zZm9ybTogISFyb3RhdGUgPyBgcm90YXRlWigke3JvdGF0ZX1kZWcpYCA6IG51bGwsIC4uLnN0eWxlIH0pXG5cbiAgICAkOiBjbGFzc1Byb3AgPSBjbGFzc25hbWVzKCdpY28nLCBpcywgc2l6ZSwgJCRwcm9wcy5jbGFzcylcbjwvc2NyaXB0PlxuXG48aSB7aWR9IHRpdGxlPXt0aXRsZVByb3B9IHN0eWxlPXtzdHlsZVByb3B9IGNsYXNzPXtjbGFzc1Byb3B9PlxuICAgIDxzdmVsdGU6Y29tcG9uZW50IHRoaXM9e2ljb25zW3R5cGVdfS8+XG48L2k+XG5cbjxzdHlsZT5cbi5pY28ge1xuICAgIC13ZWJraXQtYm94LWZsZXg6IDE7XG4gICAgICAgIC1tcy1mbGV4LXBvc2l0aXZlOiAxO1xuICAgICAgICAgICAgZmxleC1ncm93OiAxO1xuICAgIC1tcy1mbGV4LWl0ZW0tYWxpZ246IHN0cmV0Y2g7XG4gICAgICAgIGFsaWduLXNlbGY6IHN0cmV0Y2g7XG4gICAgZGlzcGxheTogLXdlYmtpdC1pbmxpbmUtYm94O1xuICAgIGRpc3BsYXk6IC1tcy1pbmxpbmUtZmxleGJveDtcbiAgICBkaXNwbGF5OiBpbmxpbmUtZmxleDtcbiAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xufVxuXG4uaWNvOm5vdCguY3VzdG9tKSB7XG4gICAgY29sb3I6IHJnYmEodmFyKC0tdGhlbWUtc3ZnLWZpbGwpKTtcbn1cblxuLyogLS0tLS0tLS0tLS0tPT09PT09PT09KCBTaXplICk9PT09PT09PT0tLS0tLS0tLS0tLS0gKi9cbi50aW55IHtcbiAgICB3aWR0aDogMTNweDtcbiAgICBoZWlnaHQ6IDEzcHg7XG4gICAgLXdlYmtpdC1ib3gtZmxleDogMDtcbiAgICAgICAgLW1zLWZsZXg6IG5vbmU7XG4gICAgICAgICAgICBmbGV4OiBub25lO1xuICAgIC1tcy1mbGV4LWl0ZW0tYWxpZ246IGF1dG87XG4gICAgICAgIGFsaWduLXNlbGY6IGF1dG87XG59XG5cbi5zbWFsbCB7XG4gICAgd2lkdGg6IDE4cHg7XG4gICAgaGVpZ2h0OiAxOHB4O1xuICAgIC13ZWJraXQtYm94LWZsZXg6IDA7XG4gICAgICAgIC1tcy1mbGV4OiBub25lO1xuICAgICAgICAgICAgZmxleDogbm9uZTtcbiAgICAtbXMtZmxleC1pdGVtLWFsaWduOiBhdXRvO1xuICAgICAgICBhbGlnbi1zZWxmOiBhdXRvO1xufVxuXG4ubWVkaXVtIHtcbiAgICB3aWR0aDogMjRweDtcbiAgICBoZWlnaHQ6IDI0cHg7XG4gICAgLXdlYmtpdC1ib3gtZmxleDogMDtcbiAgICAgICAgLW1zLWZsZXg6IG5vbmU7XG4gICAgICAgICAgICBmbGV4OiBub25lO1xuICAgIC1tcy1mbGV4LWl0ZW0tYWxpZ246IGF1dG87XG4gICAgICAgIGFsaWduLXNlbGY6IGF1dG87XG59XG5cbi5iaWcge1xuICAgIHdpZHRoOiAzMHB4O1xuICAgIGhlaWdodDogMzBweDtcbiAgICAtd2Via2l0LWJveC1mbGV4OiAwO1xuICAgICAgICAtbXMtZmxleDogbm9uZTtcbiAgICAgICAgICAgIGZsZXg6IG5vbmU7XG4gICAgLW1zLWZsZXgtaXRlbS1hbGlnbjogYXV0bztcbiAgICAgICAgYWxpZ24tc2VsZjogYXV0bztcbn1cblxuLmxhcmdlIHtcbiAgICB3aWR0aDogNDBweDtcbiAgICBoZWlnaHQ6IDQwcHg7XG4gICAgLXdlYmtpdC1ib3gtZmxleDogMDtcbiAgICAgICAgLW1zLWZsZXg6IG5vbmU7XG4gICAgICAgICAgICBmbGV4OiBub25lO1xuICAgIC1tcy1mbGV4LWl0ZW0tYWxpZ246IGF1dG87XG4gICAgICAgIGFsaWduLXNlbGY6IGF1dG87XG59XG5cbi8qIC0tLS0tLS0tLS0tLT09PT09PT09PSggQ29sb3IgKT09PT09PT09PS0tLS0tLS0tLS0tLSAqL1xuLmljby5wcmltYXJ5IHtcbiAgICBjb2xvcjogcmdiKHZhcigtLWNvbG9yLXN1Y2Nlc3MpKTtcbn1cblxuLmljby5kYW5nZXIge1xuICAgIGNvbG9yOiByZ2IodmFyKC0tY29sb3ItZGFuZ2VyKSk7XG59XG5cbi5pY28uaW5mbyB7XG4gICAgY29sb3I6IHJnYih2YXIoLS1jb2xvci1pbmZvKSk7XG59XG5cbi5pY28ubGlnaHQge1xuICAgIGNvbG9yOiByZ2IodmFyKC0tY29sb3Itd2hpdGUpKTtcbn1cblxuLmljby5kYXJrIHtcbiAgICBjb2xvcjogcmdiKHZhcigtLWNvbG9yLWJsYWNrKSk7XG59PC9zdHlsZT5cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUE2QkEsSUFBSSxlQUFDLENBQUMsQUFDRixnQkFB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 */";
	append_dev(document.head, style);
}

function create_fragment$A(ctx) {
	let i;
	let switch_instance;
	let i_class_value;
	let current;
	var switch_value = icons[/*type*/ ctx[0]];

	function switch_props(ctx) {
		return { $$inline: true };
	}

	if (switch_value) {
		switch_instance = new switch_value(switch_props());
	}

	const block = {
		c: function create() {
			i = element("i");
			if (switch_instance) create_component(switch_instance.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			i = claim_element(nodes, "I", {
				id: true,
				title: true,
				style: true,
				class: true
			});

			var i_nodes = children(i);
			if (switch_instance) claim_component(switch_instance.$$.fragment, i_nodes);
			i_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(i, "id", /*id*/ ctx[1]);
			attr_dev(i, "title", /*titleProp*/ ctx[3]);
			attr_dev(i, "style", /*styleProp*/ ctx[4]);
			attr_dev(i, "class", i_class_value = "" + (null_to_empty(/*classProp*/ ctx[2]) + " svelte-1v3w8cp"));
			add_location(i, file$A, 24, 0, 724);
		},
		m: function mount(target, anchor) {
			insert_dev(target, i, anchor);

			if (switch_instance) {
				mount_component(switch_instance, i, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (switch_value !== (switch_value = icons[/*type*/ ctx[0]])) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props());
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, i, null);
				} else {
					switch_instance = null;
				}
			}

			if (!current || dirty & /*id*/ 2) {
				attr_dev(i, "id", /*id*/ ctx[1]);
			}

			if (!current || dirty & /*classProp*/ 4 && i_class_value !== (i_class_value = "" + (null_to_empty(/*classProp*/ ctx[2]) + " svelte-1v3w8cp"))) {
				attr_dev(i, "class", i_class_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(i);
			if (switch_instance) destroy_component(switch_instance);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$A.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$A($$self, $$props, $$invalidate) {
	let { type } = $$props;
	let { is = null } = $$props; // primary|info|danger|light|dark
	let { size = null } = $$props; // small|medium|big
	let { rotate = 0 } = $$props;
	let { style = undefined } = $$props;
	let { id = undefined } = $$props;
	let { title = undefined } = $$props;
	let { ariaLabel = undefined } = $$props;
	let titleProp = title || ariaLabel;
	let ariaLabelProp = ariaLabel || title;

	let styleProp = toCSSString({
		transform: !!rotate ? `rotateZ(${rotate}deg)` : null,
		...style
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Icon", $$slots, []);

	$$self.$set = $$new_props => {
		$$invalidate(12, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("type" in $$new_props) $$invalidate(0, type = $$new_props.type);
		if ("is" in $$new_props) $$invalidate(5, is = $$new_props.is);
		if ("size" in $$new_props) $$invalidate(6, size = $$new_props.size);
		if ("rotate" in $$new_props) $$invalidate(7, rotate = $$new_props.rotate);
		if ("style" in $$new_props) $$invalidate(8, style = $$new_props.style);
		if ("id" in $$new_props) $$invalidate(1, id = $$new_props.id);
		if ("title" in $$new_props) $$invalidate(9, title = $$new_props.title);
		if ("ariaLabel" in $$new_props) $$invalidate(10, ariaLabel = $$new_props.ariaLabel);
	};

	$$self.$capture_state = () => ({
		classnames,
		toCSSString,
		icons,
		type,
		is,
		size,
		rotate,
		style,
		id,
		title,
		ariaLabel,
		titleProp,
		ariaLabelProp,
		styleProp,
		classProp
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(12, $$props = assign(assign({}, $$props), $$new_props));
		if ("type" in $$props) $$invalidate(0, type = $$new_props.type);
		if ("is" in $$props) $$invalidate(5, is = $$new_props.is);
		if ("size" in $$props) $$invalidate(6, size = $$new_props.size);
		if ("rotate" in $$props) $$invalidate(7, rotate = $$new_props.rotate);
		if ("style" in $$props) $$invalidate(8, style = $$new_props.style);
		if ("id" in $$props) $$invalidate(1, id = $$new_props.id);
		if ("title" in $$props) $$invalidate(9, title = $$new_props.title);
		if ("ariaLabel" in $$props) $$invalidate(10, ariaLabel = $$new_props.ariaLabel);
		if ("titleProp" in $$props) $$invalidate(3, titleProp = $$new_props.titleProp);
		if ("ariaLabelProp" in $$props) ariaLabelProp = $$new_props.ariaLabelProp;
		if ("styleProp" in $$props) $$invalidate(4, styleProp = $$new_props.styleProp);
		if ("classProp" in $$props) $$invalidate(2, classProp = $$new_props.classProp);
	};

	let classProp;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(2, classProp = classnames("ico", is, size, $$props.class));
	};

	$$props = exclude_internal_props($$props);

	return [
		type,
		id,
		classProp,
		titleProp,
		styleProp,
		is,
		size,
		rotate,
		style,
		title,
		ariaLabel
	];
}

class Icon extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document.getElementById("svelte-1v3w8cp-style")) add_css$2();

		init(this, options, instance$A, create_fragment$A, safe_not_equal, {
			type: 0,
			is: 5,
			size: 6,
			rotate: 7,
			style: 8,
			id: 1,
			title: 9,
			ariaLabel: 10
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Icon",
			options,
			id: create_fragment$A.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*type*/ ctx[0] === undefined && !("type" in props)) {
			console.warn("<Icon> was created without expected prop 'type'");
		}
	}

	get type() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set type(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get is() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set is(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get rotate() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set rotate(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get id() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get title() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ariaLabel() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ariaLabel(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/Form.svelte generated by Svelte v3.24.0 */

const file$B = "src/components/Form.svelte";

function create_fragment$B(ctx) {
	let form;
	let form_class_value;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*$$slots*/ ctx[10].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);

	const block = {
		c: function create() {
			form = element("form");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			form = claim_element(nodes, "FORM", {
				id: true,
				name: true,
				method: true,
				autocomplete: true,
				title: true,
				class: true,
				"aria-label": true
			});

			var form_nodes = children(form);
			if (default_slot) default_slot.l(form_nodes);
			form_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(form, "id", /*id*/ ctx[1]);
			attr_dev(form, "name", /*name*/ ctx[0]);
			attr_dev(form, "method", /*method*/ ctx[2]);
			attr_dev(form, "autocomplete", /*autocomplete*/ ctx[3]);
			attr_dev(form, "title", /*titleProp*/ ctx[4]);
			attr_dev(form, "class", form_class_value = /*$$props*/ ctx[6].class);
			attr_dev(form, "aria-label", /*ariaLabelProp*/ ctx[5]);
			add_location(form, file$B, 12, 0, 309);
		},
		m: function mount(target, anchor) {
			insert_dev(target, form, anchor);

			if (default_slot) {
				default_slot.m(form, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen_dev(form, "submit", prevent_default(/*submit_handler*/ ctx[11]), false, true, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 512) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[9], dirty, null, null);
				}
			}

			if (!current || dirty & /*id*/ 2) {
				attr_dev(form, "id", /*id*/ ctx[1]);
			}

			if (!current || dirty & /*name*/ 1) {
				attr_dev(form, "name", /*name*/ ctx[0]);
			}

			if (!current || dirty & /*method*/ 4) {
				attr_dev(form, "method", /*method*/ ctx[2]);
			}

			if (!current || dirty & /*autocomplete*/ 8) {
				attr_dev(form, "autocomplete", /*autocomplete*/ ctx[3]);
			}

			if (!current || dirty & /*$$props*/ 64 && form_class_value !== (form_class_value = /*$$props*/ ctx[6].class)) {
				attr_dev(form, "class", form_class_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(form);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$B.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$B($$self, $$props, $$invalidate) {
	let { name = undefined } = $$props;
	let { id = undefined } = $$props;
	let { title = undefined } = $$props;
	let { ariaLabel = undefined } = $$props;
	let { method = undefined } = $$props;
	let { autocomplete = undefined } = $$props;
	let titleProp = title || ariaLabel;
	let ariaLabelProp = ariaLabel || title;
	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Form", $$slots, ['default']);

	function submit_handler(event) {
		bubble($$self, event);
	}

	$$self.$set = $$new_props => {
		$$invalidate(6, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("name" in $$new_props) $$invalidate(0, name = $$new_props.name);
		if ("id" in $$new_props) $$invalidate(1, id = $$new_props.id);
		if ("title" in $$new_props) $$invalidate(7, title = $$new_props.title);
		if ("ariaLabel" in $$new_props) $$invalidate(8, ariaLabel = $$new_props.ariaLabel);
		if ("method" in $$new_props) $$invalidate(2, method = $$new_props.method);
		if ("autocomplete" in $$new_props) $$invalidate(3, autocomplete = $$new_props.autocomplete);
		if ("$$scope" in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		name,
		id,
		title,
		ariaLabel,
		method,
		autocomplete,
		titleProp,
		ariaLabelProp
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(6, $$props = assign(assign({}, $$props), $$new_props));
		if ("name" in $$props) $$invalidate(0, name = $$new_props.name);
		if ("id" in $$props) $$invalidate(1, id = $$new_props.id);
		if ("title" in $$props) $$invalidate(7, title = $$new_props.title);
		if ("ariaLabel" in $$props) $$invalidate(8, ariaLabel = $$new_props.ariaLabel);
		if ("method" in $$props) $$invalidate(2, method = $$new_props.method);
		if ("autocomplete" in $$props) $$invalidate(3, autocomplete = $$new_props.autocomplete);
		if ("titleProp" in $$props) $$invalidate(4, titleProp = $$new_props.titleProp);
		if ("ariaLabelProp" in $$props) $$invalidate(5, ariaLabelProp = $$new_props.ariaLabelProp);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);

	return [
		name,
		id,
		method,
		autocomplete,
		titleProp,
		ariaLabelProp,
		$$props,
		title,
		ariaLabel,
		$$scope,
		$$slots,
		submit_handler
	];
}

class Form extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$B, create_fragment$B, safe_not_equal, {
			name: 0,
			id: 1,
			title: 7,
			ariaLabel: 8,
			method: 2,
			autocomplete: 3
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Form",
			options,
			id: create_fragment$B.name
		});
	}

	get name() {
		throw new Error("<Form>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set name(value) {
		throw new Error("<Form>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get id() {
		throw new Error("<Form>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<Form>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get title() {
		throw new Error("<Form>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<Form>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ariaLabel() {
		throw new Error("<Form>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ariaLabel(value) {
		throw new Error("<Form>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get method() {
		throw new Error("<Form>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set method(value) {
		throw new Error("<Form>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get autocomplete() {
		throw new Error("<Form>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set autocomplete(value) {
		throw new Error("<Form>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/Card.svelte generated by Svelte v3.24.0 */
const file$C = "src/components/Card.svelte";

function add_css$3() {
	var style = element("style");
	style.id = "svelte-1ivni0f-style";
	style.textContent = ".card.svelte-1ivni0f{width:100%;overflow:hidden;position:relative;-webkit-transform:translateZ(0);transform:translateZ(0);-webkit-box-shadow:var(--shadow-secondary);box-shadow:var(--shadow-secondary);border-radius:var(--border-radius-big);background-color:rgba(var(--theme-color-primary))}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2FyZC5zdmVsdGUiLCJzb3VyY2VzIjpbIkNhcmQuc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgY2xhc3NuYW1lcyB9IGZyb20gJ0B1dGlscydcblxuICAgICQ6IGNsYXNzUHJvcCA9IGNsYXNzbmFtZXMoJ2NhcmQnLCAkJHByb3BzLmNsYXNzKVxuPC9zY3JpcHQ+XG5cbjxzZWN0aW9uIGNsYXNzPXtjbGFzc1Byb3B9IHN0eWxlPXskJHByb3BzLnN0eWxlfT5cbiAgICA8c2xvdD48L3Nsb3Q+XG48L3NlY3Rpb24+XG5cbjxzdHlsZT5cbi5jYXJkIHtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWigwKTtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWigwKTtcbiAgICAtd2Via2l0LWJveC1zaGFkb3c6IHZhcigtLXNoYWRvdy1zZWNvbmRhcnkpO1xuICAgICAgICAgICAgYm94LXNoYWRvdzogdmFyKC0tc2hhZG93LXNlY29uZGFyeSk7XG4gICAgYm9yZGVyLXJhZGl1czogdmFyKC0tYm9yZGVyLXJhZGl1cy1iaWcpO1xuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEodmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeSkpO1xufTwvc3R5bGU+XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBV0EsS0FBSyxlQUFDLENBQUMsQUFDSCxLQUFLLENBQUUsSUFBSSxDQUNYLFFBQVEsQ0FBRSxNQUFNLENBQ2hCLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLGlCQUFpQixDQUFFLFdBQVcsQ0FBQyxDQUFDLENBQ3hCLFNBQVMsQ0FBRSxXQUFXLENBQUMsQ0FBQyxDQUNoQyxrQkFBa0IsQ0FBRSxJQUFJLGtCQUFrQixDQUFDLENBQ25DLFVBQVUsQ0FBRSxJQUFJLGtCQUFrQixDQUFDLENBQzNDLGFBQWEsQ0FBRSxJQUFJLG1CQUFtQixDQUFDLENBQ3ZDLGdCQUFnQixDQUFFLEtBQUssSUFBSSxxQkFBcUIsQ0FBQyxDQUFDLEFBQ3RELENBQUMifQ== */";
	append_dev(document.head, style);
}

function create_fragment$C(ctx) {
	let section;
	let section_class_value;
	let section_style_value;
	let current;
	const default_slot_template = /*$$slots*/ ctx[3].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

	const block = {
		c: function create() {
			section = element("section");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { class: true, style: true });
			var section_nodes = children(section);
			if (default_slot) default_slot.l(section_nodes);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(section, "class", section_class_value = "" + (null_to_empty(/*classProp*/ ctx[0]) + " svelte-1ivni0f"));
			attr_dev(section, "style", section_style_value = /*$$props*/ ctx[1].style);
			add_location(section, file$C, 6, 0, 114);
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);

			if (default_slot) {
				default_slot.m(section, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 4) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[2], dirty, null, null);
				}
			}

			if (!current || dirty & /*classProp*/ 1 && section_class_value !== (section_class_value = "" + (null_to_empty(/*classProp*/ ctx[0]) + " svelte-1ivni0f"))) {
				attr_dev(section, "class", section_class_value);
			}

			if (!current || dirty & /*$$props*/ 2 && section_style_value !== (section_style_value = /*$$props*/ ctx[1].style)) {
				attr_dev(section, "style", section_style_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$C.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$C($$self, $$props, $$invalidate) {
	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Card", $$slots, ['default']);

	$$self.$set = $$new_props => {
		$$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("$$scope" in $$new_props) $$invalidate(2, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({ classnames, classProp });

	$$self.$inject_state = $$new_props => {
		$$invalidate(1, $$props = assign(assign({}, $$props), $$new_props));
		if ("classProp" in $$props) $$invalidate(0, classProp = $$new_props.classProp);
	};

	let classProp;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(0, classProp = classnames("card", $$props.class));
	};

	$$props = exclude_internal_props($$props);
	return [classProp, $$props, $$scope, $$slots];
}

class Card extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document.getElementById("svelte-1ivni0f-style")) add_css$3();
		init(this, options, instance$C, create_fragment$C, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Card",
			options,
			id: create_fragment$C.name
		});
	}
}

function cubicOut(t) {
    const f = t - 1.0;
    return f * f * f + 1.0;
}

function fly(node, { delay = 0, duration = 400, easing = cubicOut, x = 0, y = 0, opacity = 0 }) {
    const style = getComputedStyle(node);
    const target_opacity = +style.opacity;
    const transform = style.transform === 'none' ? '' : style.transform;
    const od = target_opacity * (1 - opacity);
    return {
        delay,
        duration,
        easing,
        css: (t, u) => `
			transform: ${transform} translate(${(1 - t) * x}px, ${(1 - t) * y}px);
			opacity: ${target_opacity - (od * u)}`
    };
}
function slide(node, { delay = 0, duration = 400, easing = cubicOut }) {
    const style = getComputedStyle(node);
    const opacity = +style.opacity;
    const height = parseFloat(style.height);
    const padding_top = parseFloat(style.paddingTop);
    const padding_bottom = parseFloat(style.paddingBottom);
    const margin_top = parseFloat(style.marginTop);
    const margin_bottom = parseFloat(style.marginBottom);
    const border_top_width = parseFloat(style.borderTopWidth);
    const border_bottom_width = parseFloat(style.borderBottomWidth);
    return {
        delay,
        duration,
        easing,
        css: t => `overflow: hidden;` +
            `opacity: ${Math.min(t * 20, 1) * opacity};` +
            `height: ${t * height}px;` +
            `padding-top: ${t * padding_top}px;` +
            `padding-bottom: ${t * padding_bottom}px;` +
            `margin-top: ${t * margin_top}px;` +
            `margin-bottom: ${t * margin_bottom}px;` +
            `border-top-width: ${t * border_top_width}px;` +
            `border-bottom-width: ${t * border_bottom_width}px;`
    };
}

(function(self) {

var irrelevant = (function (exports) {
  var support = {
    searchParams: 'URLSearchParams' in self,
    iterable: 'Symbol' in self && 'iterator' in Symbol,
    blob:
      'FileReader' in self &&
      'Blob' in self &&
      (function() {
        try {
          new Blob();
          return true
        } catch (e) {
          return false
        }
      })(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  };

  function isDataView(obj) {
    return obj && DataView.prototype.isPrototypeOf(obj)
  }

  if (support.arrayBuffer) {
    var viewClasses = [
      '[object Int8Array]',
      '[object Uint8Array]',
      '[object Uint8ClampedArray]',
      '[object Int16Array]',
      '[object Uint16Array]',
      '[object Int32Array]',
      '[object Uint32Array]',
      '[object Float32Array]',
      '[object Float64Array]'
    ];

    var isArrayBufferView =
      ArrayBuffer.isView ||
      function(obj) {
        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
      };
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name);
    }
    if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value);
    }
    return value
  }

  // Build a destructive iterator for the value list
  function iteratorFor(items) {
    var iterator = {
      next: function() {
        var value = items.shift();
        return {done: value === undefined, value: value}
      }
    };

    if (support.iterable) {
      iterator[Symbol.iterator] = function() {
        return iterator
      };
    }

    return iterator
  }

  function Headers(headers) {
    this.map = {};

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value);
      }, this);
    } else if (Array.isArray(headers)) {
      headers.forEach(function(header) {
        this.append(header[0], header[1]);
      }, this);
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name]);
      }, this);
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name);
    value = normalizeValue(value);
    var oldValue = this.map[name];
    this.map[name] = oldValue ? oldValue + ', ' + value : value;
  };

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)];
  };

  Headers.prototype.get = function(name) {
    name = normalizeName(name);
    return this.has(name) ? this.map[name] : null
  };

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  };

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = normalizeValue(value);
  };

  Headers.prototype.forEach = function(callback, thisArg) {
    for (var name in this.map) {
      if (this.map.hasOwnProperty(name)) {
        callback.call(thisArg, this.map[name], name, this);
      }
    }
  };

  Headers.prototype.keys = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push(name);
    });
    return iteratorFor(items)
  };

  Headers.prototype.values = function() {
    var items = [];
    this.forEach(function(value) {
      items.push(value);
    });
    return iteratorFor(items)
  };

  Headers.prototype.entries = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push([name, value]);
    });
    return iteratorFor(items)
  };

  if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true;
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result);
      };
      reader.onerror = function() {
        reject(reader.error);
      };
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsArrayBuffer(blob);
    return promise
  }

  function readBlobAsText(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsText(blob);
    return promise
  }

  function readArrayBufferAsText(buf) {
    var view = new Uint8Array(buf);
    var chars = new Array(view.length);

    for (var i = 0; i < view.length; i++) {
      chars[i] = String.fromCharCode(view[i]);
    }
    return chars.join('')
  }

  function bufferClone(buf) {
    if (buf.slice) {
      return buf.slice(0)
    } else {
      var view = new Uint8Array(buf.byteLength);
      view.set(new Uint8Array(buf));
      return view.buffer
    }
  }

  function Body() {
    this.bodyUsed = false;

    this._initBody = function(body) {
      this._bodyInit = body;
      if (!body) {
        this._bodyText = '';
      } else if (typeof body === 'string') {
        this._bodyText = body;
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body;
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body;
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString();
      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
        this._bodyArrayBuffer = bufferClone(body.buffer);
        // IE 10-11 can't handle a DataView body.
        this._bodyInit = new Blob([this._bodyArrayBuffer]);
      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
        this._bodyArrayBuffer = bufferClone(body);
      } else {
        this._bodyText = body = Object.prototype.toString.call(body);
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8');
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type);
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
        }
      }
    };

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this);
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      };

      this.arrayBuffer = function() {
        if (this._bodyArrayBuffer) {
          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
        } else {
          return this.blob().then(readBlobAsArrayBuffer)
        }
      };
    }

    this.text = function() {
      var rejected = consumed(this);
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return readBlobAsText(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as text')
      } else {
        return Promise.resolve(this._bodyText)
      }
    };

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      };
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    };

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

  function normalizeMethod(method) {
    var upcased = method.toUpperCase();
    return methods.indexOf(upcased) > -1 ? upcased : method
  }

  function Request(input, options) {
    options = options || {};
    var body = options.body;

    if (input instanceof Request) {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url;
      this.credentials = input.credentials;
      if (!options.headers) {
        this.headers = new Headers(input.headers);
      }
      this.method = input.method;
      this.mode = input.mode;
      this.signal = input.signal;
      if (!body && input._bodyInit != null) {
        body = input._bodyInit;
        input.bodyUsed = true;
      }
    } else {
      this.url = String(input);
    }

    this.credentials = options.credentials || this.credentials || 'same-origin';
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers);
    }
    this.method = normalizeMethod(options.method || this.method || 'GET');
    this.mode = options.mode || this.mode || null;
    this.signal = options.signal || this.signal;
    this.referrer = null;

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body);
  }

  Request.prototype.clone = function() {
    return new Request(this, {body: this._bodyInit})
  };

  function decode(body) {
    var form = new FormData();
    body
      .trim()
      .split('&')
      .forEach(function(bytes) {
        if (bytes) {
          var split = bytes.split('=');
          var name = split.shift().replace(/\+/g, ' ');
          var value = split.join('=').replace(/\+/g, ' ');
          form.append(decodeURIComponent(name), decodeURIComponent(value));
        }
      });
    return form
  }

  function parseHeaders(rawHeaders) {
    var headers = new Headers();
    // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
    // https://tools.ietf.org/html/rfc7230#section-3.2
    var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
    preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
      var parts = line.split(':');
      var key = parts.shift().trim();
      if (key) {
        var value = parts.join(':').trim();
        headers.append(key, value);
      }
    });
    return headers
  }

  Body.call(Request.prototype);

  function Response(bodyInit, options) {
    if (!options) {
      options = {};
    }

    this.type = 'default';
    this.status = options.status === undefined ? 200 : options.status;
    this.ok = this.status >= 200 && this.status < 300;
    this.statusText = 'statusText' in options ? options.statusText : 'OK';
    this.headers = new Headers(options.headers);
    this.url = options.url || '';
    this._initBody(bodyInit);
  }

  Body.call(Response.prototype);

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  };

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''});
    response.type = 'error';
    return response
  };

  var redirectStatuses = [301, 302, 303, 307, 308];

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  };

  exports.DOMException = self.DOMException;
  try {
    new exports.DOMException();
  } catch (err) {
    exports.DOMException = function(message, name) {
      this.message = message;
      this.name = name;
      var error = Error(message);
      this.stack = error.stack;
    };
    exports.DOMException.prototype = Object.create(Error.prototype);
    exports.DOMException.prototype.constructor = exports.DOMException;
  }

  function fetch(input, init) {
    return new Promise(function(resolve, reject) {
      var request = new Request(input, init);

      if (request.signal && request.signal.aborted) {
        return reject(new exports.DOMException('Aborted', 'AbortError'))
      }

      var xhr = new XMLHttpRequest();

      function abortXhr() {
        xhr.abort();
      }

      xhr.onload = function() {
        var options = {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
        };
        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
        var body = 'response' in xhr ? xhr.response : xhr.responseText;
        resolve(new Response(body, options));
      };

      xhr.onerror = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.ontimeout = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.onabort = function() {
        reject(new exports.DOMException('Aborted', 'AbortError'));
      };

      xhr.open(request.method, request.url, true);

      if (request.credentials === 'include') {
        xhr.withCredentials = true;
      } else if (request.credentials === 'omit') {
        xhr.withCredentials = false;
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob';
      }

      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value);
      });

      if (request.signal) {
        request.signal.addEventListener('abort', abortXhr);

        xhr.onreadystatechange = function() {
          // DONE (success or failure)
          if (xhr.readyState === 4) {
            request.signal.removeEventListener('abort', abortXhr);
          }
        };
      }

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
    })
  }

  fetch.polyfill = true;

  if (!self.fetch) {
    self.fetch = fetch;
    self.Headers = Headers;
    self.Request = Request;
    self.Response = Response;
  }

  exports.Headers = Headers;
  exports.Request = Request;
  exports.Response = Response;
  exports.fetch = fetch;

  return exports;

}({}));
})(typeof self !== 'undefined' ? self : commonjsGlobal);

var btoa$1 = createCommonjsModule(function (module) {
(function () {

  function btoa(str) {
    var buffer;

    if (str instanceof Buffer) {
      buffer = str;
    } else {
      buffer = Buffer.from(str.toString(), 'binary');
    }

    return buffer.toString('base64');
  }

  module.exports = btoa;
}());
});

var dist = createCommonjsModule(function (module, exports) {
!function(t,e){module.exports=e();}(commonjsGlobal,(function(){var t=function(t){if(Array.isArray(t))return t};var e=function(t,e){if(Symbol.iterator in Object(t)||"[object Arguments]"===Object.prototype.toString.call(t)){var r=[],n=!0,o=!1,i=void 0;try{for(var c,u=t[Symbol.iterator]();!(n=(c=u.next()).done)&&(r.push(c.value),!e||r.length!==e);n=!0);}catch(t){o=!0,i=t;}finally{try{n||null==u.return||u.return();}finally{if(o)throw i}}return r}};var r=function(){throw new TypeError("Invalid attempt to destructure non-iterable instance")};var n=function(n,o){return t(n)||e(n,o)||r()};var o=function(t,e){return t(e={exports:{}},e.exports),e.exports}((function(t){function e(r){return "function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?t.exports=e=function(t){return typeof t}:t.exports=e=function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},e(r)}t.exports=e;})),i=function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=t.headers,r=void 0===e?{}:e,n=(t.body,t.method),i=void 0===n?"get":n,c=t.auth;var u=new Headers(r);if(u.get("content-type")||"get"===i||u.set("content-type","application/json"),c)if("object"===o(c)){var a,s=c.username,f=c.password;if(!s)throw new Error("Username required for basic authentication");if(!f)throw new Error("Password required for basic authentication");a="btoa"in window?btoa:btoa$1,u.set("Authorization","Basic "+a("".concat(s,":").concat(f)));}else u.set("Authorization","Bearer ".concat(c));return u},c=function(t){if(t)return Object.entries(t).reduce((function(t,e,r){var o=n(e,2),i=o[0],c=o[1],u=0===r?"".concat(i,"=").concat(encodeURIComponent(c)):"&".concat(i,"=").concat(encodeURIComponent(c));return "".concat(t).concat(u)}),"")},u=function(t){var e=t.url,r=t.queries;return r?"".concat(e,"?").concat(c(r)):e},a=function(t){if("get"!==t.method){var e=t.headers.get("content-type");if(e)return e.includes("x-www-form-urlencoded")?c(t.body):e.includes("json")?JSON.stringify(t.body):t.body}},s=function(t){return t.headers.entries?function(t){var e={},r=!0,o=!1,i=void 0;try{for(var c,u=t.headers.entries()[Symbol.iterator]();!(r=(c=u.next()).done);r=!0){var a=n(c.value,2),s=a[0],f=a[1];e[s]=f;}}catch(t){o=!0,i=t;}finally{try{r||null==u.return||u.return();}finally{if(o)throw i}}return e}(t):function(t){var e={},r=t.headers._headers;for(var n in r)e[n]=r[n].join("");return e}(t)},f=function(t,e){var r=("function"==typeof t.clone?t.clone():void 0)||t;return t[e]().then((function(t){return function(t,e){var r={body:e,headers:s(t),response:t,status:t.status,statusText:t.statusText};return t.ok?Promise.resolve(r):Promise.reject(r)}(r,t)}))},d=function(t){var e=t.headers.get("content-type");if(e.includes("json"))return f(t,"json");if(e.includes("text"))return f(t,"text");if(e.includes("image"))return f(t,"blob");throw new Error("zlFetch does not support content-type ".concat(e," yet"))},l=function(t){return "Failed to fetch"===t.message?Promise.reject({error:t}):Promise.reject(t)};for(var y=function(t,e){var r=function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=Object.assign({},t);return e.url=u(e),e.method=e.method||"get",e.headers=i(e),e.body=a(e),delete e.auth,e}(Object.assign({url:t},e));return fetch(r.url,r).then(d).catch(l)},h=function(){var t=v[p];y[t]=function(e,r){return r=Object.assign({method:t},r),y(e,r)};},p=0,v=["get","post","put","patch","delete"];p<v.length;p++)h();return y}));
});

class APIService {
  /**
   *
   * @typedef Config {{
   *   adapter: Function, (zlFetch)
   *
   *   basePath: string,
   *
   *   requestInterceptor([
   *     endpoint: string,
   *     params?: object,
   *     config?: object,
   *   ]): {*},
   *   responseInterceptor() {
   *     body: {*},
   *     headers: object,
   *     response: {Response},
   *     status: number,
   *     statusText: string,
   *   },
   *   errorInterceptor() {{
   *     body: {*},
   *     headers: object,
   *     response: {Response},
   *     status: number,
   *     statusText: string,
   *   }},
   * }}
   * @param config {Config}
   */
  constructor(config = {}) {
    this._adapter = config.adapter || dist;

    this._base_path = config.basePath ? config.basePath.replace(/\/$/, '') : '';

    this._requestInterceptor = config.requestInterceptor || (async (...args) => args);
    this._responseInterceptor = config.responseInterceptor || (async (...args) => args);
    this._errorInterceptor = config.errorInterceptor || Promise.reject;
  }

  /**
   *
   * @param method {'get'|'put'|'post'|'delete'|'patch'}
   * @param args {*[]}
   */
  get newRequest() {
    const methods = ['get', 'put', 'post', 'delete', 'patch'];

    return methods.reduce((acc, method) => {
      acc[method] = this.withInterceptors.bind(this, this._adapter[method]);
      return acc
    }, {})
  }

  async withInterceptors(caller, ...args) {
    const newArgs1 = await this.requestInterceptor(...args);
    const newArgs2 = await this._requestInterceptor(...newArgs1);

    return caller(...newArgs2)
      .then(async (response) => {
        const newResponse = await this._responseInterceptor(response);
        return await this.handleResponse(newResponse)
      })
      .catch(async (reject) => {
        try {
          return await this._errorInterceptor(reject)
        } catch (error) {
          throw error
        }
      })
      .catch(this.handleReject)
  }

  async requestInterceptor(...args) {
    if (typeof args[0] === 'string') { // If URL then concat BASE_PATH.
      args[0] = `${this._base_path}/${args[0]}`;
    }
    return [...args]
  }

  async handleResponse(response) {
    return response.body
  }

  async handleReject(reject) {
    throw reject
  }
}

/**
 *
 * @description API class for making REST API requests in a browser.
 */
class ApiClass extends APIService {
  /**
   *
   * @param config {Config}
   */
  constructor(config) {
    super(config);
  }

  /**
   *
   * @description Users
   */
  getUser(id, params, config) {
    return this.newRequest.get(endpoints.USER(id), params, config)
  }

  getUsers(params, config) {
    return this.newRequest.get(endpoints.USERS(), params, config)
  }

  postUser(id, body, config) {
    return this.newRequest.post(endpoints.USER(id), body, config)
  }

  putUser(id, body, config) {
    return this.newRequest.put(endpoints.USER(id), body, config)
  }

  deleteUser(id, config) {
    return this.newRequest.delete(endpoints.USER(id), config)
  }

  /**
   *
   * @description Recent
   */
  getRecent(id, params, config) {
    return this.newRequest.get(endpoints.RECENT(id), params, config)
  }

  getRecents(params, config) {
    return this.newRequest.get(endpoints.RECENTS(), params, config)
  }

  postRecent(id, body, config) {
    return this.newRequest.post(endpoints.RECENT(id), body, config)
  }

  putRecent(id, body, config) {
    return this.newRequest.put(endpoints.RECENT(id), body, config)
  }

  deleteRecent(id, config) {
    return this.newRequest.delete(endpoints.RECENT(id), config)
  }

  /**
   *
   * @description Comments
   */
  getComment(id, params, config) {
    return this.newRequest.get(endpoints.COMMENT(id), params, config)
  }

  getComments(params, config) {
    return this.newRequest.get(endpoints.COMMENTS(), params, config)
  }

  postComment(id, body, config) {
    return this.newRequest.post(endpoints.COMMENT(id), body, config)
  }

  putComment(id, body, config) {
    return this.newRequest.put(endpoints.COMMENT(id), body, config)
  }

  deleteComment(id, config) {
    return this.newRequest.delete(endpoints.COMMENT(id), config)
  }

  /**
   *
   * @description Fund
   */
  getFund(id, params, config) {
    return this.newRequest.get(endpoints.FUND(id), params, config)
  }

  getFunds(params, config) {
    return this.newRequest.get(endpoints.FUNDS(), params, config)
  }

  postFund(id, body, config) {
    return this.newRequest.post(endpoints.FUND(id), body, config)
  }

  putFund(id, body, config) {
    return this.newRequest.put(endpoints.FUND(id), body, config)
  }

  deleteFund(id, config) {
    return this.newRequest.delete(endpoints.FUND(id), config)
  }

  /**
   *
   * @description Organization
   */
  getOrganization(id, params, config) {
    return this.newRequest.get(endpoints.ORGANIZATION(id), params, config)
  }

  getOrganizations(params, config) {
    return this.newRequest.get(endpoints.ORGANIZATIONS(), params, config)
  }

  postOrganization(id, body, config) {
    return this.newRequest.post(endpoints.ORGANIZATION(id), body, config)
  }

  putOrganization(id, body, config) {
    return this.newRequest.put(endpoints.ORGANIZATION(id), body, config)
  }

  deleteOrganization(id, config) {
    return this.newRequest.delete(endpoints.ORGANIZATION(id), config)
  }

  /**
   *
   * @description Media
   */
  uploadImage(body, config) {
    return this.newRequest.post(endpoints.IMAGES_UPLOAD(), body, config)
  }

}

/**
 *
 * @constructor {Config}
 */
var API = new ApiClass({
  basePath: setup.BACKEND_URL,
  responseInterceptor: res => (console.info('response -------\n', res), res),
  errorInterceptor: rej => {
    console.warn('request error -------\n', rej);

    if (rej && rej.error && rej.error.message === 'Failed to fetch') {
      console.log('Lost internet connection');
      showOfflineMessage();
    }

    throw rej
  },
});

function showOfflineMessage() {
  try {
    let timer = null;
    const offlineEl = document.querySelector('#offline-message');
    if (!timer) {
      offlineEl.classList.add('active');
      timer = setTimeout(() => {
        offlineEl.classList.remove('active');
        clearTimeout(timer);
      }, 5000);
    }
  } catch (err) {
    console.warn(err);
  }
}

var dayjs_min = createCommonjsModule(function (module, exports) {
!function(t,e){module.exports=e();}(commonjsGlobal,function(){var t="millisecond",e="second",n="minute",r="hour",i="day",s="week",u="month",a="quarter",o="year",h=/^(\d{4})-?(\d{1,2})?-?(\d{0,2})[^0-9]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?.?(\d{1,3})?$/,f=/\[([^\]]+)]|Y{2,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,c=function(t,e,n){var r=String(t);return !r||r.length>=e?t:""+Array(e+1-r.length).join(n)+t},d={s:c,z:function(t){var e=-t.utcOffset(),n=Math.abs(e),r=Math.floor(n/60),i=n%60;return (e<=0?"+":"-")+c(r,2,"0")+":"+c(i,2,"0")},m:function(t,e){var n=12*(e.year()-t.year())+(e.month()-t.month()),r=t.clone().add(n,u),i=e-r<0,s=t.clone().add(n+(i?-1:1),u);return Number(-(n+(e-r)/(i?r-s:s-r))||0)},a:function(t){return t<0?Math.ceil(t)||0:Math.floor(t)},p:function(h){return {M:u,y:o,w:s,d:i,D:"date",h:r,m:n,s:e,ms:t,Q:a}[h]||String(h||"").toLowerCase().replace(/s$/,"")},u:function(t){return void 0===t}},$={name:"en",weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_")},l="en",m={};m[l]=$;var y=function(t){return t instanceof v},M=function(t,e,n){var r;if(!t)return l;if("string"==typeof t)m[t]&&(r=t),e&&(m[t]=e,r=t);else {var i=t.name;m[i]=t,r=i;}return !n&&r&&(l=r),r||!n&&l},g=function(t,e){if(y(t))return t.clone();var n="object"==typeof e?e:{};return n.date=t,n.args=arguments,new v(n)},D=d;D.l=M,D.i=y,D.w=function(t,e){return g(t,{locale:e.$L,utc:e.$u,$offset:e.$offset})};var v=function(){function c(t){this.$L=this.$L||M(t.locale,null,!0),this.parse(t);}var d=c.prototype;return d.parse=function(t){this.$d=function(t){var e=t.date,n=t.utc;if(null===e)return new Date(NaN);if(D.u(e))return new Date;if(e instanceof Date)return new Date(e);if("string"==typeof e&&!/Z$/i.test(e)){var r=e.match(h);if(r){var i=r[2]-1||0;return n?new Date(Date.UTC(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,r[7]||0)):new Date(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,r[7]||0)}}return new Date(e)}(t),this.init();},d.init=function(){var t=this.$d;this.$y=t.getFullYear(),this.$M=t.getMonth(),this.$D=t.getDate(),this.$W=t.getDay(),this.$H=t.getHours(),this.$m=t.getMinutes(),this.$s=t.getSeconds(),this.$ms=t.getMilliseconds();},d.$utils=function(){return D},d.isValid=function(){return !("Invalid Date"===this.$d.toString())},d.isSame=function(t,e){var n=g(t);return this.startOf(e)<=n&&n<=this.endOf(e)},d.isAfter=function(t,e){return g(t)<this.startOf(e)},d.isBefore=function(t,e){return this.endOf(e)<g(t)},d.$g=function(t,e,n){return D.u(t)?this[e]:this.set(n,t)},d.year=function(t){return this.$g(t,"$y",o)},d.month=function(t){return this.$g(t,"$M",u)},d.day=function(t){return this.$g(t,"$W",i)},d.date=function(t){return this.$g(t,"$D","date")},d.hour=function(t){return this.$g(t,"$H",r)},d.minute=function(t){return this.$g(t,"$m",n)},d.second=function(t){return this.$g(t,"$s",e)},d.millisecond=function(e){return this.$g(e,"$ms",t)},d.unix=function(){return Math.floor(this.valueOf()/1e3)},d.valueOf=function(){return this.$d.getTime()},d.startOf=function(t,a){var h=this,f=!!D.u(a)||a,c=D.p(t),d=function(t,e){var n=D.w(h.$u?Date.UTC(h.$y,e,t):new Date(h.$y,e,t),h);return f?n:n.endOf(i)},$=function(t,e){return D.w(h.toDate()[t].apply(h.toDate("s"),(f?[0,0,0,0]:[23,59,59,999]).slice(e)),h)},l=this.$W,m=this.$M,y=this.$D,M="set"+(this.$u?"UTC":"");switch(c){case o:return f?d(1,0):d(31,11);case u:return f?d(1,m):d(0,m+1);case s:var g=this.$locale().weekStart||0,v=(l<g?l+7:l)-g;return d(f?y-v:y+(6-v),m);case i:case"date":return $(M+"Hours",0);case r:return $(M+"Minutes",1);case n:return $(M+"Seconds",2);case e:return $(M+"Milliseconds",3);default:return this.clone()}},d.endOf=function(t){return this.startOf(t,!1)},d.$set=function(s,a){var h,f=D.p(s),c="set"+(this.$u?"UTC":""),d=(h={},h[i]=c+"Date",h.date=c+"Date",h[u]=c+"Month",h[o]=c+"FullYear",h[r]=c+"Hours",h[n]=c+"Minutes",h[e]=c+"Seconds",h[t]=c+"Milliseconds",h)[f],$=f===i?this.$D+(a-this.$W):a;if(f===u||f===o){var l=this.clone().set("date",1);l.$d[d]($),l.init(),this.$d=l.set("date",Math.min(this.$D,l.daysInMonth())).$d;}else d&&this.$d[d]($);return this.init(),this},d.set=function(t,e){return this.clone().$set(t,e)},d.get=function(t){return this[D.p(t)]()},d.add=function(t,a){var h,f=this;t=Number(t);var c=D.p(a),d=function(e){var n=g(f);return D.w(n.date(n.date()+Math.round(e*t)),f)};if(c===u)return this.set(u,this.$M+t);if(c===o)return this.set(o,this.$y+t);if(c===i)return d(1);if(c===s)return d(7);var $=(h={},h[n]=6e4,h[r]=36e5,h[e]=1e3,h)[c]||1,l=this.$d.getTime()+t*$;return D.w(l,this)},d.subtract=function(t,e){return this.add(-1*t,e)},d.format=function(t){var e=this;if(!this.isValid())return "Invalid Date";var n=t||"YYYY-MM-DDTHH:mm:ssZ",r=D.z(this),i=this.$locale(),s=this.$H,u=this.$m,a=this.$M,o=i.weekdays,h=i.months,c=function(t,r,i,s){return t&&(t[r]||t(e,n))||i[r].substr(0,s)},d=function(t){return D.s(s%12||12,t,"0")},$=i.meridiem||function(t,e,n){var r=t<12?"AM":"PM";return n?r.toLowerCase():r},l={YY:String(this.$y).slice(-2),YYYY:this.$y,M:a+1,MM:D.s(a+1,2,"0"),MMM:c(i.monthsShort,a,h,3),MMMM:c(h,a),D:this.$D,DD:D.s(this.$D,2,"0"),d:String(this.$W),dd:c(i.weekdaysMin,this.$W,o,2),ddd:c(i.weekdaysShort,this.$W,o,3),dddd:o[this.$W],H:String(s),HH:D.s(s,2,"0"),h:d(1),hh:d(2),a:$(s,u,!0),A:$(s,u,!1),m:String(u),mm:D.s(u,2,"0"),s:String(this.$s),ss:D.s(this.$s,2,"0"),SSS:D.s(this.$ms,3,"0"),Z:r};return n.replace(f,function(t,e){return e||l[t]||r.replace(":","")})},d.utcOffset=function(){return 15*-Math.round(this.$d.getTimezoneOffset()/15)},d.diff=function(t,h,f){var c,d=D.p(h),$=g(t),l=6e4*($.utcOffset()-this.utcOffset()),m=this-$,y=D.m(this,$);return y=(c={},c[o]=y/12,c[u]=y,c[a]=y/3,c[s]=(m-l)/6048e5,c[i]=(m-l)/864e5,c[r]=m/36e5,c[n]=m/6e4,c[e]=m/1e3,c)[d]||m,f?y:D.a(y)},d.daysInMonth=function(){return this.endOf(u).$D},d.$locale=function(){return m[this.$L]},d.locale=function(t,e){if(!t)return this.$L;var n=this.clone(),r=M(t,e,!0);return r&&(n.$L=r),n},d.clone=function(){return D.w(this.$d,this)},d.toDate=function(){return new Date(this.valueOf())},d.toJSON=function(){return this.isValid()?this.toISOString():null},d.toISOString=function(){return this.$d.toISOString()},d.toString=function(){return this.$d.toUTCString()},c}();return g.prototype=v.prototype,g.extend=function(t,e){return t(e,v,g),g},g.locale=M,g.isDayjs=y,g.unix=function(t){return g(1e3*t)},g.en=m[l],g.Ls=m,g});
});

var relativeTime = createCommonjsModule(function (module, exports) {
!function(r,t){module.exports=t();}(commonjsGlobal,function(){return function(r,t,e){r=r||{};var n=t.prototype,o={future:"in %s",past:"%s ago",s:"a few seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"};e.en.relativeTime=o;var d=function(t,n,d,i){for(var u,a,s,f=d.$locale().relativeTime||o,l=r.thresholds||[{l:"s",r:44,d:"second"},{l:"m",r:89},{l:"mm",r:44,d:"minute"},{l:"h",r:89},{l:"hh",r:21,d:"hour"},{l:"d",r:35},{l:"dd",r:25,d:"day"},{l:"M",r:45},{l:"MM",r:10,d:"month"},{l:"y",r:17},{l:"yy",d:"year"}],h=l.length,m=0;m<h;m+=1){var c=l[m];c.d&&(u=i?e(t).diff(d,c.d,!0):d.diff(t,c.d,!0));var y=(r.rounding||Math.round)(Math.abs(u));if(s=u>0,y<=c.r||!c.r){y<=1&&m>0&&(c=l[m-1]);var p=f[c.l];a="string"==typeof p?p.replace("%d",y):p(y,n,c.l,s);break}}return n?a:(s?f.future:f.past).replace("%s",a)};n.to=function(r,t){return d(r,t,this,!0)},n.from=function(r,t){return d(r,t,this)};var i=function(r){return r.$u?e.utc():e()};n.toNow=function(r){return this.to(i(this),r)},n.fromNow=function(r){return this.from(i(this),r)};}});
});

var utc = createCommonjsModule(function (module, exports) {
!function(t,i){module.exports=i();}(commonjsGlobal,function(){return function(t,i,e){var s=(new Date).getTimezoneOffset(),n=i.prototype;e.utc=function(t){return new i({date:t,utc:!0,args:arguments})},n.utc=function(){return e(this.toDate(),{locale:this.$L,utc:!0})},n.local=function(){return e(this.toDate(),{locale:this.$L,utc:!1})};var u=n.parse;n.parse=function(t){t.utc&&(this.$u=!0),this.$utils().u(t.$offset)||(this.$offset=t.$offset),u.call(this,t);};var o=n.init;n.init=function(){if(this.$u){var t=this.$d;this.$y=t.getUTCFullYear(),this.$M=t.getUTCMonth(),this.$D=t.getUTCDate(),this.$W=t.getUTCDay(),this.$H=t.getUTCHours(),this.$m=t.getUTCMinutes(),this.$s=t.getUTCSeconds(),this.$ms=t.getUTCMilliseconds();}else o.call(this);};var f=n.utcOffset;n.utcOffset=function(t){var i=this.$utils().u;if(i(t))return this.$u?0:i(this.$offset)?f.call(this):this.$offset;var e,n=Math.abs(t)<=16?60*t:t;return 0!==t?(e=this.local().add(n+s,"minute")).$offset=n:e=this.utc(),e};var r=n.format;n.format=function(t){var i=t||(this.$u?"YYYY-MM-DDTHH:mm:ss[Z]":"");return r.call(this,i)},n.valueOf=function(){var t=this.$utils().u(this.$offset)?0:this.$offset+s;return this.$d.valueOf()-6e4*t},n.isUTC=function(){return !!this.$u},n.toISOString=function(){return this.toDate().toISOString()},n.toString=function(){return this.toDate().toUTCString()};var a=n.toDate;n.toDate=function(t){return "s"===t&&this.$offset?e(this.format("YYYY-MM-DD HH:mm:ss:SSS")).toDate():a.call(this)};}});
});

var weekday = createCommonjsModule(function (module, exports) {
!function(e,t){module.exports=t();}(commonjsGlobal,function(){return function(e,t){t.prototype.weekday=function(e){var t=this.$locale().weekStart||0,n=this.$W,i=(n<t?n+7:n)-t;return this.$utils().u(e)?i:this.subtract(i,"day").add(e,"day")};}});
});

var en = createCommonjsModule(function (module, exports) {
!function(e,n){module.exports=n();}(commonjsGlobal,function(){return {name:"en",weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_")}});
});

var ru = createCommonjsModule(function (module, exports) {
!function(_,t){module.exports=t(dayjs_min);}(commonjsGlobal,function(_){_=_&&_.hasOwnProperty("default")?_.default:_;var t="января_февраля_марта_апреля_мая_июня_июля_августа_сентября_октября_ноября_декабря".split("_"),e="январь_февраль_март_апрель_май_июнь_июль_август_сентябрь_октябрь_ноябрь_декабрь".split("_"),n="янв._февр._мар._апр._мая_июня_июля_авг._сент._окт._нояб._дек.".split("_"),s="янв._февр._март_апр._май_июнь_июль_авг._сент._окт._нояб._дек.".split("_"),r=/D[oD]?(\[[^[\]]*\]|\s)+MMMM?/;function o(_,t,e){var n,s;return "m"===e?t?"минута":"минуту":_+" "+(n=+_,s={mm:t?"минута_минуты_минут":"минуту_минуты_минут",hh:"час_часа_часов",dd:"день_дня_дней",MM:"месяц_месяца_месяцев",yy:"год_года_лет"}[e].split("_"),n%10==1&&n%100!=11?s[0]:n%10>=2&&n%10<=4&&(n%100<10||n%100>=20)?s[1]:s[2])}var d=function(_,n){return r.test(n)?t[_.month()]:e[_.month()]};d.s=e,d.f=t;var i=function(_,t){return r.test(t)?n[_.month()]:s[_.month()]};i.s=s,i.f=n;var m={name:"ru",weekdays:"воскресенье_понедельник_вторник_среда_четверг_пятница_суббота".split("_"),weekdaysShort:"вск_пнд_втр_срд_чтв_птн_сбт".split("_"),weekdaysMin:"вс_пн_вт_ср_чт_пт_сб".split("_"),months:d,monthsShort:i,weekStart:1,formats:{LT:"H:mm",LTS:"H:mm:ss",L:"DD.MM.YYYY",LL:"D MMMM YYYY г.",LLL:"D MMMM YYYY г., H:mm",LLLL:"dddd, D MMMM YYYY г., H:mm"},relativeTime:{future:"через %s",past:"%s назад",s:"несколько секунд",m:o,mm:o,h:"час",hh:o,d:"день",dd:o,M:"месяц",MM:o,y:"год",yy:o},ordinal:function(_){return _}};return _.locale(m,null,!0),m});
});

var uk = createCommonjsModule(function (module, exports) {
!function(_,t){module.exports=t(dayjs_min);}(commonjsGlobal,function(_){_=_&&_.hasOwnProperty("default")?_.default:_;var t="січня_лютого_березня_квітня_травня_червня_липня_серпня_вересня_жовтня_листопада_грудня".split("_"),e="січень_лютий_березень_квітень_травень_червень_липень_серпень_вересень_жовтень_листопад_грудень".split("_"),s=/D[oD]?(\[[^[\]]*\]|\s)+MMMM?/;function n(_,t,e){var s,n;return "m"===e?t?"хвилина":"хвилину":"h"===e?t?"година":"годину":_+" "+(s=+_,n={ss:t?"секунда_секунди_секунд":"секунду_секунди_секунд",mm:t?"хвилина_хвилини_хвилин":"хвилину_хвилини_хвилин",hh:t?"година_години_годин":"годину_години_годин",dd:"день_дні_днів",MM:"місяць_місяці_місяців",yy:"рік_роки_років"}[e].split("_"),s%10==1&&s%100!=11?n[0]:s%10>=2&&s%10<=4&&(s%100<10||s%100>=20)?n[1]:n[2])}var d=function(_,n){return s.test(n)?t[_.month()]:e[_.month()]};d.s=e,d.f=t;var i={name:"uk",weekdays:"неділя_понеділок_вівторок_середа_четвер_п’ятниця_субота".split("_"),weekdaysShort:"ндл_пнд_втр_срд_чтв_птн_сбт".split("_"),weekdaysMin:"нд_пн_вт_ср_чт_пт_сб".split("_"),months:d,monthsShort:"сiч_лют_бер_квiт_трав_черв_лип_серп_вер_жовт_лист_груд".split("_"),weekStart:1,relativeTime:{future:"за %s",past:"%s тому",s:"декілька секунд",m:n,mm:n,h:n,hh:n,d:"день",dd:n,M:"місяць",MM:n,y:"рік",yy:n},ordinal:function(_){return _},formats:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D MMMM YYYY р.",LLL:"D MMMM YYYY р., HH:mm",LLLL:"dddd, D MMMM YYYY р., HH:mm"}};return _.locale(i,null,!0),i});
});

dayjs_min.extend(relativeTime); // use RelativeTime pluggin
dayjs_min.extend(utc); // use UTC pluggin
dayjs_min.extend(weekday); // use Weekday pluggin

dayjs_min.locale('en'); // use Engllish
dayjs_min.locale('ru'); // use Russian
dayjs_min.locale('uk'); // use Ukrainian

class Swipe {
  constructor(element) {
    this.isMoveStart = false;
    this.isTwoFingers = false;

    this.xDown = null;
    this.yDown = null;
    this.element = typeof (element) === 'string' ? document.querySelector(element) : element;

    this.element.addEventListener('touchstart', this.touchStartHandler.bind(this), false);
    this.element.addEventListener('touchend', this.touchEndHandler.bind(this), false);

    this.element.addEventListener('gesturestart', () => {
      this.isTwoFingers = true;
    });

    this.element.addEventListener('gestureend', () => {
      this.isTwoFingers = false;
    });
  }

  touchStartHandler(evt) {
    if (this.isTwoFingers) return

    this.isMoveStart = true;

    this.xDown = evt.touches[0].clientX;
    this.yDown = evt.touches[0].clientY;

    try {
      this.onTouchStart(this.xDown, this.yDown, evt, this.element);
    } catch(err) { /* ignore throwing of unknown functions */ }
  }

  touchEndHandler(evt) {
    if (this.isTwoFingers) return

    this.isMoveStart = false;

    this.xDown = null;
    this.yDown = null;

    try {
      const xUp = evt.changedTouches[0].clientX;
      const yUp = evt.changedTouches[0].clientY;
      this.onTouchEnd(xUp, yUp, evt, this.element);
    } catch(err) { /* ignore throwing of unknown functions */ }
  }

  onLeft(callback) {
    this.onLeft = callback;

    return this;
  }

  onRight(callback) {
    this.onRight = callback;

    return this;
  }

  onUp(callback) {
    this.onUp = callback;

    return this;
  }

  onDown(callback) {
    this.onDown = callback;

    return this;
  }

  onTouchStart(callback) {
    this.onTouchStart = callback;

    return this;
  }

  onTouchEnd(callback) {
    this.onTouchEnd = callback;

    return this;
  }

  handleTouchMove(evt) {
    if (!this.isMoveStart || this.isTwoFingers) {
      return
    }

    const xUp = evt.touches[0].clientX;
    const yUp = evt.touches[0].clientY;

    this.xDiff = xUp - this.xDown;
    this.yDiff = yUp - this.yDown;

    try {
      if ( Math.abs( this.xDiff ) > Math.abs( this.yDiff ) ) { // Most significant.
        if ( this.xDiff < 0 ) {
          return this.onLeft(this.xDown, xUp, evt, this.element);
        } else {
          return this.onRight(this.xDown, xUp, evt, this.element);
        }
      } else {
        if ( this.yDiff < 0 ) {
          return this.onUp(this.yDown, yUp, evt, this.element);
        } else {
          return this.onDown(this.yDown, yUp, evt, this.element);
        }
      }
    } catch(err) { /* ignore throwing of unknown functions */ }
  }

  handleMove(e) {
    return requestAnimationFrame(() => this.handleTouchMove(e))
  }

  stop() {
    this.element.removeEventListener('touchmove', this.handleMove.bind(this), false);

    return this
  }

  run() {
    this.element.addEventListener('touchmove', this.handleMove.bind(this), false);

    return this
  }
}

var js_storage = createCommonjsModule(function (module, exports) {
/*
 * JS Storage Plugin
 *
 * Copyright (c) 2019 Julien Maurel
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/mit-license.php
 *
 * Project home:
 * https://github.com/julien-maurel/js-storage
 *
 * Version: 1.1.0
 */
(function (factory) {
    var registeredInModuleLoader = false;
    {
        module.exports = factory();
        registeredInModuleLoader = true;
    }
    if (!registeredInModuleLoader) {
        var OldStorages = window.Storages;
        var api = window.Storages = factory();
        api.noConflict = function () {
            window.Storages = OldStorages;
            return api;
        };
    }
}(function () {
    // Variables used by utilities functions (like isPlainObject...)
    var class2type = {};
    var toString = class2type.toString;
    var hasOwn = class2type.hasOwnProperty;
    var fnToString = hasOwn.toString;
    var ObjectFunctionString = fnToString.call(Object);
    var getProto = Object.getPrototypeOf;
    var apis = {};

    // Prefix to use with cookie fallback
    var cookie_local_prefix = "ls_";
    var cookie_session_prefix = "ss_";

    // Get items from a storage
    function _get() {
        var storage = this._type, l = arguments.length, s = window[storage], a = arguments, a0 = a[0], vi, ret, tmp, i, j;
        if (l < 1) {
            throw new Error('Minimum 1 argument must be given');
        } else if (Array.isArray(a0)) {
            // If second argument is an array, return an object with value of storage for each item in this array
            ret = {};
            for (i in a0) {
                if (a0.hasOwnProperty(i)) {
                    vi = a0[i];
                    try {
                        ret[vi] = JSON.parse(s.getItem(vi));
                    } catch (e) {
                        ret[vi] = s.getItem(vi);
                    }
                }
            }
            return ret;
        } else if (l == 1) {
            // If only 1 argument, return value directly
            try {
                return JSON.parse(s.getItem(a0));
            } catch (e) {
                return s.getItem(a0);
            }
        } else {
            // If more than 1 argument, parse storage to retrieve final value to return it
            // Get first level
            try {
                ret = JSON.parse(s.getItem(a0));
                if (!ret) {
                    throw new ReferenceError(a0 + ' is not defined in this storage');
                }
            } catch (e) {
                throw new ReferenceError(a0 + ' is not defined in this storage');
            }
            // Parse next levels
            for (i = 1; i < l - 1; i++) {
                ret = ret[a[i]];
                if (ret === undefined) {
                    throw new ReferenceError([].slice.call(a, 0, i + 1).join('.') + ' is not defined in this storage');
                }
            }
            // If last argument is an array, return an object with value for each item in this array
            // Else return value normally
            if (Array.isArray(a[i])) {
                tmp = ret;
                ret = {};
                for (j in a[i]) {
                    if (a[i].hasOwnProperty(j)) {
                        ret[a[i][j]] = tmp[a[i][j]];
                    }
                }
                return ret;
            } else {
                return ret[a[i]];
            }
        }
    }

    // Set items of a storage
    function _set() {
        var storage = this._type, l = arguments.length, s = window[storage], a = arguments, a0 = a[0], a1 = a[1], vi, to_store = isNaN(a1) ? {} : [], type, tmp, i;
        if (l < 1 || !_isPlainObject(a0) && l < 2) {
            throw new Error('Minimum 2 arguments must be given or first parameter must be an object');
        } else if (_isPlainObject(a0)) {
            // If first argument is an object, set values of storage for each property of this object
            for (i in a0) {
                if (a0.hasOwnProperty(i)) {
                    vi = a0[i];
                    if (!_isPlainObject(vi) && !this.alwaysUseJson) {
                        s.setItem(i, vi);
                    } else {
                        s.setItem(i, JSON.stringify(vi));
                    }
                }
            }
            return a0;
        } else if (l == 2) {
            // If only 2 arguments, set value of storage directly
            if (typeof a1 === 'object' || this.alwaysUseJson) {
                s.setItem(a0, JSON.stringify(a1));
            } else {
                s.setItem(a0, a1);
            }
            return a1;
        } else {
            // If more than 3 arguments, parse storage to retrieve final node and set value
            // Get first level
            try {
                tmp = s.getItem(a0);
                if (tmp != null) {
                    to_store = JSON.parse(tmp);
                }
            } catch (e) {
            }
            tmp = to_store;
            // Parse next levels and set value
            for (i = 1; i < l - 2; i++) {
                vi = a[i];
                type = isNaN(a[i + 1]) ? "object" : "array";
                if (!tmp[vi] || type == "object" && !_isPlainObject(tmp[vi]) || type == "array" && !Array.isArray(tmp[vi])) {
                    if (type == "array") tmp[vi] = [];
                    else tmp[vi] = {};
                }
                tmp = tmp[vi];
            }
            tmp[a[i]] = a[i + 1];
            s.setItem(a0, JSON.stringify(to_store));
            return to_store;
        }
    }

    // Remove items from a storage
    function _remove() {
        var storage = this._type, l = arguments.length, s = window[storage], a = arguments, a0 = a[0], to_store, tmp, i, j;
        if (l < 1) {
            throw new Error('Minimum 1 argument must be given');
        } else if (Array.isArray(a0)) {
            // If first argument is an array, remove values from storage for each item of this array
            for (i in a0) {
                if (a0.hasOwnProperty(i)) {
                    s.removeItem(a0[i]);
                }
            }
            return true;
        } else if (l == 1) {
            // If only 2 arguments, remove value from storage directly
            s.removeItem(a0);
            return true;
        } else {
            // If more than 2 arguments, parse storage to retrieve final node and remove value
            // Get first level
            try {
                to_store = tmp = JSON.parse(s.getItem(a0));
            } catch (e) {
                throw new ReferenceError(a0 + ' is not defined in this storage');
            }
            // Parse next levels and remove value
            for (i = 1; i < l - 1; i++) {
                tmp = tmp[a[i]];
                if (tmp === undefined) {
                    throw new ReferenceError([].slice.call(a, 1, i).join('.') + ' is not defined in this storage');
                }
            }
            // If last argument is an array,remove value for each item in this array
            // Else remove value normally
            if (Array.isArray(a[i])) {
                for (j in a[i]) {
                    if (a[i].hasOwnProperty(j)) {
                        delete tmp[a[i][j]];
                    }
                }
            } else {
                delete tmp[a[i]];
            }
            s.setItem(a0, JSON.stringify(to_store));
            return true;
        }
    }

    // Remove all items from a storage
    function _removeAll(reinit_ns) {
        var keys = _keys.call(this), i;
        for (i in keys) {
            if (keys.hasOwnProperty(i)) {
                _remove.call(this, keys[i]);
            }
        }
        // Reinitialize all namespace storages
        if (reinit_ns) {
            for (i in apis.namespaceStorages) {
                if (apis.namespaceStorages.hasOwnProperty(i)) {
                    _createNamespace(i);
                }
            }
        }
    }

    // Check if items of a storage are empty
    function _isEmpty() {
        var l = arguments.length, a = arguments, a0 = a[0], i;
        if (l == 0) {
            // If no argument, test if storage is empty
            return (_keys.call(this).length == 0);
        } else if (Array.isArray(a0)) {
            // If first argument is an array, test each item of this array and return true only if all items are empty
            for (i = 0; i < a0.length; i++) {
                if (!_isEmpty.call(this, a0[i])) {
                    return false;
                }
            }
            return true;
        } else {
            // If at least 1 argument, try to get value and test it
            try {
                var v = _get.apply(this, arguments);
                // Convert result to an object (if last argument is an array, _get return already an object) and test each item
                if (!Array.isArray(a[l - 1])) {
                    v = {'totest': v};
                }
                for (i in v) {
                    if (v.hasOwnProperty(i) && !(
                            (_isPlainObject(v[i]) && _isEmptyObject(v[i])) ||
                            (Array.isArray(v[i]) && !v[i].length) ||
                            (typeof v[i] !== 'boolean' && !v[i])
                        )) {
                        return false;
                    }
                }
                return true;
            } catch (e) {
                return true;
            }
        }
    }

    // Check if items of a storage exist
    function _isSet() {
        var l = arguments.length, a = arguments, a0 = a[0], i;
        if (l < 1) {
            throw new Error('Minimum 1 argument must be given');
        }
        if (Array.isArray(a0)) {
            // If first argument is an array, test each item of this array and return true only if all items exist
            for (i = 0; i < a0.length; i++) {
                if (!_isSet.call(this, a0[i])) {
                    return false;
                }
            }
            return true;
        } else {
            // For other case, try to get value and test it
            try {
                var v = _get.apply(this, arguments);
                // Convert result to an object (if last argument is an array, _get return already an object) and test each item
                if (!Array.isArray(a[l - 1])) {
                    v = {'totest': v};
                }
                for (i in v) {
                    if (v.hasOwnProperty(i) && !(v[i] !== undefined && v[i] !== null)) {
                        return false;
                    }
                }
                return true;
            } catch (e) {
                return false;
            }
        }
    }

    // Get keys of a storage or of an item of the storage
    function _keys() {
        var storage = this._type, l = arguments.length, s = window[storage], keys = [], o = {};
        // If at least 1 argument, get value from storage to retrieve keys
        // Else, use storage to retrieve keys
        if (l > 0) {
            o = _get.apply(this, arguments);
        } else {
            o = s;
        }
        if (o && o._cookie) {
            // If storage is a cookie, use js-cookie to retrieve keys
            var cookies = Cookies.get();
            for (var key in cookies) {
                if (cookies.hasOwnProperty(key) && key != '') {
                    keys.push(key.replace(o._prefix, ''));
                }
            }
        } else {
            for (var i in o) {
                if (o.hasOwnProperty(i)) {
                    keys.push(i);
                }
            }
        }
        return keys;
    }

    // Create new namespace storage
    function _createNamespace(name) {
        if (!name || typeof name != "string") {
            throw new Error('First parameter must be a string');
        }
        if (storage_available) {
            if (!window.localStorage.getItem(name)) {
                window.localStorage.setItem(name, '{}');
            }
            if (!window.sessionStorage.getItem(name)) {
                window.sessionStorage.setItem(name, '{}');
            }
        } else {
            if (!window.localCookieStorage.getItem(name)) {
                window.localCookieStorage.setItem(name, '{}');
            }
            if (!window.sessionCookieStorage.getItem(name)) {
                window.sessionCookieStorage.setItem(name, '{}');
            }
        }
        var ns = {
            localStorage: _extend({}, apis.localStorage, {_ns: name}),
            sessionStorage: _extend({}, apis.sessionStorage, {_ns: name})
        };
        if (cookies_available) {
            if (!window.cookieStorage.getItem(name)) {
                window.cookieStorage.setItem(name, '{}');
            }
            ns.cookieStorage = _extend({}, apis.cookieStorage, {_ns: name});
        }
        apis.namespaceStorages[name] = ns;
        return ns;
    }

    // Test if storage is natively available on browser
    function _testStorage(name) {
        var foo = 'jsapi';
        try {
            if (!window[name]) {
                return false;
            }
            window[name].setItem(foo, foo);
            window[name].removeItem(foo);
            return true;
        } catch (e) {
            return false;
        }
    }

    // Test if a variable is a plain object (from jQuery)
    function _isPlainObject(obj) {
        var proto, Ctor;

        // Detect obvious negatives
        // Use toString instead of jQuery.type to catch host objects
        if (!obj || toString.call(obj) !== "[object Object]") {
            return false;
        }

        proto = getProto(obj);

        // Objects with no prototype (e.g., `Object.create( null )`) are plain
        if (!proto) {
            return true;
        }

        // Objects with prototype are plain iff they were constructed by a global Object function
        Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
        return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
    }

    // Test if a variable is an empty object (from jQuery)
    function _isEmptyObject(obj) {
        var name;

        for (name in obj) {
            return false;
        }
        return true;
    }

    // Merge objects
    function _extend() {
        var i = 1;
        var result = arguments[0];
        for (; i < arguments.length; i++) {
            var attributes = arguments[i];
            for (var key in attributes) {
                if (attributes.hasOwnProperty(key)) {
                    result[key] = attributes[key];
                }
            }
        }
        return result;
    }

    // Check if storages are natively available on browser and check is js-cookie is present
    var storage_available = _testStorage('localStorage');
    var cookies_available = typeof Cookies !== 'undefined';

    // Namespace object
    var storage = {
        _type: '',
        _ns: '',
        _callMethod: function (f, a) {
            a = Array.prototype.slice.call(a);
            var p = [], a0 = a[0];
            if (this._ns) {
                p.push(this._ns);
            }
            if (typeof a0 === 'string' && a0.indexOf('.') !== -1) {
                a.shift();
                [].unshift.apply(a, a0.split('.'));
            }
            [].push.apply(p, a);
            return f.apply(this, p);
        },
        // Define if plugin always use JSON to store values (even to store simple values like string, int...) or not
        alwaysUseJson: false,
        // Get items. If no parameters and storage have a namespace, return all namespace
        get: function () {
            if (!storage_available && !cookies_available){
                return null;
            }
            return this._callMethod(_get, arguments);
        },
        // Set items
        set: function () {
            var l = arguments.length, a = arguments, a0 = a[0];
            if (l < 1 || !_isPlainObject(a0) && l < 2) {
                throw new Error('Minimum 2 arguments must be given or first parameter must be an object');
            }
            if (!storage_available && !cookies_available){
                return null;
            }
            // If first argument is an object and storage is a namespace storage, set values individually
            if (_isPlainObject(a0) && this._ns) {
                for (var i in a0) {
                    if (a0.hasOwnProperty(i)) {
                        this._callMethod(_set, [i, a0[i]]);
                    }
                }
                return a0;
            } else {
                var r = this._callMethod(_set, a);
                if (this._ns) {
                    return r[a0.split('.')[0]];
                } else {
                    return r;
                }
            }
        },
        // Delete items
        remove: function () {
            if (arguments.length < 1) {
                throw new Error('Minimum 1 argument must be given');
            }
            if (!storage_available && !cookies_available){
                return null;
            }
            return this._callMethod(_remove, arguments);
        },
        // Delete all items
        removeAll: function (reinit_ns) {
            if (!storage_available && !cookies_available){
                return null;
            }
            if (this._ns) {
                this._callMethod(_set, [{}]);
                return true;
            } else {
                return this._callMethod(_removeAll, [reinit_ns]);
            }
        },
        // Items empty
        isEmpty: function () {
            if (!storage_available && !cookies_available){
                return null;
            }
            return this._callMethod(_isEmpty, arguments);
        },
        // Items exists
        isSet: function () {
            if (arguments.length < 1) {
                throw new Error('Minimum 1 argument must be given');
            }
            if (!storage_available && !cookies_available){
                return null;
            }
            return this._callMethod(_isSet, arguments);
        },
        // Get keys of items
        keys: function () {
            if (!storage_available && !cookies_available){
                return null;
            }
            return this._callMethod(_keys, arguments);
        }
    };

    // Use js-cookie for compatibility with old browsers and give access to cookieStorage
    if (cookies_available) {
        // sessionStorage is valid for one window/tab. To simulate that with cookie, we set a name for the window and use it for the name of the cookie
        if (!window.name) {
            window.name = Math.floor(Math.random() * 100000000);
        }
        var cookie_storage = {
            _cookie: true,
            _prefix: '',
            _expires: null,
            _path: null,
            _domain: null,
            _secure: false,
            setItem: function (n, v) {
                Cookies.set(this._prefix + n, v, {expires: this._expires, path: this._path, domain: this._domain, secure: this._secure});
            },
            getItem: function (n) {
                return Cookies.get(this._prefix + n);
            },
            removeItem: function (n) {
                return Cookies.remove(this._prefix + n, {path: this._path});
            },
            clear: function () {
                var cookies = Cookies.get();
                for (var key in cookies) {
                    if (cookies.hasOwnProperty(key) && key != '') {
                        if (!this._prefix && key.indexOf(cookie_local_prefix) === -1 && key.indexOf(cookie_session_prefix) === -1 || this._prefix && key.indexOf(this._prefix) === 0) {
                            Cookies.remove(key);
                        }
                    }
                }
            },
            setExpires: function (e) {
                this._expires = e;
                return this;
            },
            setPath: function (p) {
                this._path = p;
                return this;
            },
            setDomain: function (d) {
                this._domain = d;
                return this;
            },
            setSecure: function (s) {
                this._secure = s;
                return this;
            },
            setConf: function (c) {
                if (c.path) {
                    this._path = c.path;
                }
                if (c.domain) {
                    this._domain = c.domain;
                }
                if (c.secure) {
                    this._secure = c.secure;
                }
                if (c.expires) {
                    this._expires = c.expires;
                }
                return this;
            },
            setDefaultConf: function () {
                this._path = this._domain = this._expires = null;
                this._secure = false;
            }
        };
        if (!storage_available) {
            window.localCookieStorage = _extend({}, cookie_storage, {
                _prefix: cookie_local_prefix,
                _expires: 365 * 10,
                _secure: true
            });
            window.sessionCookieStorage = _extend({}, cookie_storage, {
                _prefix: cookie_session_prefix + window.name + '_',
                _secure: true
            });
        }
        window.cookieStorage = _extend({}, cookie_storage);
        // cookieStorage API
        apis.cookieStorage = _extend({}, storage, {
            _type: 'cookieStorage',
            setExpires: function (e) {
                window.cookieStorage.setExpires(e);
                return this;
            },
            setPath: function (p) {
                window.cookieStorage.setPath(p);
                return this;
            },
            setDomain: function (d) {
                window.cookieStorage.setDomain(d);
                return this;
            },
            setSecure: function (s) {
                window.cookieStorage.setSecure(s);
                return this;
            },
            setConf: function (c) {
                window.cookieStorage.setConf(c);
                return this;
            },
            setDefaultConf: function () {
                window.cookieStorage.setDefaultConf();
                return this;
            }
        });
    }

    // Get a new API on a namespace
    apis.initNamespaceStorage = function (ns) {
        return _createNamespace(ns);
    };
    if (storage_available) {
        // localStorage API
        apis.localStorage = _extend({}, storage, {_type: 'localStorage'});
        // sessionStorage API
        apis.sessionStorage = _extend({}, storage, {_type: 'sessionStorage'});
    } else {
        // localStorage API
        apis.localStorage = _extend({}, storage, {_type: 'localCookieStorage'});
        // sessionStorage API
        apis.sessionStorage = _extend({}, storage, {_type: 'sessionCookieStorage'});
    }
    // List of all namespace storage
    apis.namespaceStorages = {};
    // Remove all items in all storages
    apis.removeAllStorages = function (reinit_ns) {
        apis.localStorage.removeAll(reinit_ns);
        apis.sessionStorage.removeAll(reinit_ns);
        if (apis.cookieStorage) {
            apis.cookieStorage.removeAll(reinit_ns);
        }
        if (!reinit_ns) {
            apis.namespaceStorages = {};
        }
    };
    // About alwaysUseJson
    // By default, all values are string on html storages and the plugin don't use json to store simple values (strings, int, float...)
    // So by default, if you do storage.setItem('test',2), value in storage will be "2", not 2
    // If you set this property to true, all values set with the plugin will be stored as json to have typed values in any cases
    apis.alwaysUseJsonInStorage = function (value) {
        storage.alwaysUseJson = value;
        apis.localStorage.alwaysUseJson = value;
        apis.sessionStorage.alwaysUseJson = value;
        if (apis.cookieStorage) {
            apis.cookieStorage.alwaysUseJson = value;
        }
    };

    return apis;
}));
});

var js_cookie = createCommonjsModule(function (module, exports) {
(function (factory) {
	var registeredInModuleLoader;
	{
		module.exports = factory();
		registeredInModuleLoader = true;
	}
	if (!registeredInModuleLoader) {
		var OldCookies = window.Cookies;
		var api = window.Cookies = factory();
		api.noConflict = function () {
			window.Cookies = OldCookies;
			return api;
		};
	}
}(function () {
	function extend () {
		var i = 0;
		var result = {};
		for (; i < arguments.length; i++) {
			var attributes = arguments[ i ];
			for (var key in attributes) {
				result[key] = attributes[key];
			}
		}
		return result;
	}

	function decode (s) {
		return s.replace(/(%[0-9A-Z]{2})+/g, decodeURIComponent);
	}

	function init (converter) {
		function api() {}

		function set (key, value, attributes) {
			if (typeof document === 'undefined') {
				return;
			}

			attributes = extend({
				path: '/'
			}, api.defaults, attributes);

			if (typeof attributes.expires === 'number') {
				attributes.expires = new Date(new Date() * 1 + attributes.expires * 864e+5);
			}

			// We're using "expires" because "max-age" is not supported by IE
			attributes.expires = attributes.expires ? attributes.expires.toUTCString() : '';

			try {
				var result = JSON.stringify(value);
				if (/^[\{\[]/.test(result)) {
					value = result;
				}
			} catch (e) {}

			value = converter.write ?
				converter.write(value, key) :
				encodeURIComponent(String(value))
					.replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent);

			key = encodeURIComponent(String(key))
				.replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent)
				.replace(/[\(\)]/g, escape);

			var stringifiedAttributes = '';
			for (var attributeName in attributes) {
				if (!attributes[attributeName]) {
					continue;
				}
				stringifiedAttributes += '; ' + attributeName;
				if (attributes[attributeName] === true) {
					continue;
				}

				// Considers RFC 6265 section 5.2:
				// ...
				// 3.  If the remaining unparsed-attributes contains a %x3B (";")
				//     character:
				// Consume the characters of the unparsed-attributes up to,
				// not including, the first %x3B (";") character.
				// ...
				stringifiedAttributes += '=' + attributes[attributeName].split(';')[0];
			}

			return (document.cookie = key + '=' + value + stringifiedAttributes);
		}

		function get (key, json) {
			if (typeof document === 'undefined') {
				return;
			}

			var jar = {};
			// To prevent the for loop in the first place assign an empty array
			// in case there are no cookies at all.
			var cookies = document.cookie ? document.cookie.split('; ') : [];
			var i = 0;

			for (; i < cookies.length; i++) {
				var parts = cookies[i].split('=');
				var cookie = parts.slice(1).join('=');

				if (!json && cookie.charAt(0) === '"') {
					cookie = cookie.slice(1, -1);
				}

				try {
					var name = decode(parts[0]);
					cookie = (converter.read || converter)(cookie, name) ||
						decode(cookie);

					if (json) {
						try {
							cookie = JSON.parse(cookie);
						} catch (e) {}
					}

					jar[name] = cookie;

					if (key === name) {
						break;
					}
				} catch (e) {}
			}

			return key ? jar[key] : jar;
		}

		api.set = set;
		api.get = function (key) {
			return get(key, false /* read as raw */);
		};
		api.getJSON = function (key) {
			return get(key, true /* read as json */);
		};
		api.remove = function (key, attributes) {
			set(key, '', extend(attributes, {
				expires: -1
			}));
		};

		api.defaults = {};

		api.withConverter = init;

		return api;
	}

	return init(function () {});
}));
});

js_storage.alwaysUseJsonInStorage();

const localStorage = js_storage.localStorage;
const sessionStorage = js_storage.sessionStorage;
const cookieStorage = js_cookie;

var Storages = /*#__PURE__*/Object.freeze({
    __proto__: null,
    localStorage: localStorage,
    sessionStorage: sessionStorage,
    cookieStorage: cookieStorage,
    'default': js_storage
});

const modals = writable({});

function isSimpleDeriver(deriver) {
    return deriver.length < 2;
}
function generator(storage) {
    /**
     * Creates a `Readable` store that allows reading by subscription.
     * @param key storage key
     * @param value initial value
     * @param {StartStopNotifier}start start and stop notifications for subscriptions
     */
    function readable(key, value, start) {
        return {
            subscribe: writable$1(key, value, start).subscribe
        };
    }
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param key storage key
     * @param {*=}value default value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable$1(key, value, start = noop) {
        function wrap_start(ogSet) {
            return start(function wrap_set(new_value) {
                if (storage) {
                    storage.setItem(key, JSON.stringify(new_value));
                }
                return ogSet(new_value);
            });
        }
        if (storage) {
            if (storage.getItem(key)) {
                value = JSON.parse(storage.getItem(key));
            }
            storage.setItem(key, JSON.stringify(value));
        }
        const ogStore = writable(value, start ? wrap_start : undefined);
        function set(new_value) {
            if (storage) {
                storage.setItem(key, JSON.stringify(new_value));
            }
            ogStore.set(new_value);
        }
        function update(fn) {
            set(fn(get_store_value(ogStore)));
        }
        function subscribe(run, invalidate = noop) {
            return ogStore.subscribe(run, invalidate);
        }
        return { set, update, subscribe };
    }
    /**
     * Derived value store by synchronizing one or more readable stores and
     * applying an aggregation function over its input values.
     * @param key storage key
     * @param {Stores} stores input stores
     * @param {function(Stores=, function(*)=):*}fn function callback that aggregates the values
     * @param {*=}initial_value when used asynchronously
     */
    function derived(key, stores, fn, initial_value) {
        const single = !Array.isArray(stores);
        const stores_array = single
            ? [stores]
            : stores;
        if (storage && storage.getItem(key)) {
            initial_value = JSON.parse(storage.getItem(key));
        }
        return readable(key, initial_value, (set) => {
            let inited = false;
            const values = [];
            let pending = 0;
            let cleanup = noop;
            const sync = () => {
                if (pending) {
                    return;
                }
                cleanup();
                const input = single ? values[0] : values;
                if (isSimpleDeriver(fn)) {
                    set(fn(input));
                }
                else {
                    const result = fn(input, set);
                    cleanup = is_function(result) ? result : noop;
                }
            };
            const unsubscribers = stores_array.map((store, i) => store.subscribe((value) => {
                values[i] = value;
                pending &= ~(1 << i);
                if (inited) {
                    sync();
                }
            }, () => {
                pending |= (1 << i);
            }));
            inited = true;
            sync();
            return function stop() {
                run_all(unsubscribers);
                cleanup();
            };
        });
    }
    return {
        readable,
        writable: writable$1,
        derived,
        get: get_store_value
    };
}

const storage = typeof window !== 'undefined' ? window.localStorage : undefined;
const { readable, writable: writable$1, derived, get: get$1 } = generator(storage);

const organization = writable$1('organization', null);
const organizations = writable$1('organizations', null);

/* src/components/Portal.svelte generated by Svelte v3.24.0 */

const { document: document_1 } = globals;
const file$D = "src/components/Portal.svelte";

function add_css$4() {
	var style = element("style");
	style.id = "svelte-1xulprs-style";
	style.textContent = ".portal-clone.svelte-1xulprs{display:none}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUG9ydGFsLnN2ZWx0ZSIsInNvdXJjZXMiOlsiUG9ydGFsLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0PlxuICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuXG4gIGV4cG9ydCBsZXQgaWQgPSB1bmRlZmluZWRcbiAgZXhwb3J0IGxldCBvZmYgPSBmYWxzZVxuXG4gIGxldCByZWY7XG4gIGxldCBwb3J0YWw7XG5cbiAgb25Nb3VudCgoKSA9PiB7XG4gICAgaWYgKG9mZikgcmV0dXJuXG4gICAgY29uc3QgcHJldlBvcnRhbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGBwb3J0YWxfJHtpZH1gKVxuICAgIGlmIChpZCAmJiBwcmV2UG9ydGFsKSBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHByZXZQb3J0YWwpO1xuICAgIHBvcnRhbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgcG9ydGFsLmNsYXNzTmFtZSA9IFwicG9ydGFsXCI7XG4gICAgcG9ydGFsLmlkID0gYHBvcnRhbF8ke2lkfWA7XG4gICAgcG9ydGFsLmFwcGVuZENoaWxkKHJlZik7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChwb3J0YWwpO1xuICAgIHJldHVybiAoKSA9PiBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHBvcnRhbClcbiAgfSk7XG5cbjwvc2NyaXB0PlxuXG57I2lmIG9mZn1cbiAgPHNsb3QgLz5cbns6ZWxzZX1cbiAgPGRpdiBjbGFzcz1cInBvcnRhbC1jbG9uZVwiPlxuICAgICAgPGRpdiBiaW5kOnRoaXM9e3JlZn0+XG4gICAgICAgICAgPHNsb3QgLz5cbiAgICAgIDwvZGl2PlxuICA8L2Rpdj5cbnsvaWZ9XG5cbjxzdHlsZT5cbi5wb3J0YWwtY2xvbmUge1xuICBkaXNwbGF5OiBub25lO1xufTwvc3R5bGU+XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBa0NBLGFBQWEsZUFBQyxDQUFDLEFBQ2IsT0FBTyxDQUFFLElBQUksQUFDZixDQUFDIn0= */";
	append_dev(document_1.head, style);
}

// (26:0) {:else}
function create_else_block(ctx) {
	let div1;
	let div0;
	let current;
	const default_slot_template = /*$$slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", {});
			var div0_nodes = children(div0);
			if (default_slot) default_slot.l(div0_nodes);
			div0_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(div0, file$D, 27, 6, 602);
			attr_dev(div1, "class", "portal-clone svelte-1xulprs");
			add_location(div1, file$D, 26, 2, 569);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			/*div0_binding*/ ctx[5](div0);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			if (default_slot) default_slot.d(detaching);
			/*div0_binding*/ ctx[5](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(26:0) {:else}",
		ctx
	});

	return block;
}

// (24:0) {#if off}
function create_if_block$1(ctx) {
	let current;
	const default_slot_template = /*$$slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		l: function claim(nodes) {
			if (default_slot) default_slot.l(nodes);
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(24:0) {#if off}",
		ctx
	});

	return block;
}

function create_fragment$D(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$1, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*off*/ ctx[0]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$D.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$D($$self, $$props, $$invalidate) {
	let { id = undefined } = $$props;
	let { off = false } = $$props;
	let ref;
	let portal;

	onMount(() => {
		if (off) return;
		const prevPortal = document.getElementById(`portal_${id}`);
		if (id && prevPortal) document.body.removeChild(prevPortal);
		portal = document.createElement("div");
		portal.className = "portal";
		portal.id = `portal_${id}`;
		portal.appendChild(ref);
		document.body.appendChild(portal);
		return () => document.body.removeChild(portal);
	});

	const writable_props = ["id", "off"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Portal> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Portal", $$slots, ['default']);

	function div0_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			ref = $$value;
			$$invalidate(1, ref);
		});
	}

	$$self.$set = $$props => {
		if ("id" in $$props) $$invalidate(2, id = $$props.id);
		if ("off" in $$props) $$invalidate(0, off = $$props.off);
		if ("$$scope" in $$props) $$invalidate(3, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({ onMount, id, off, ref, portal });

	$$self.$inject_state = $$props => {
		if ("id" in $$props) $$invalidate(2, id = $$props.id);
		if ("off" in $$props) $$invalidate(0, off = $$props.off);
		if ("ref" in $$props) $$invalidate(1, ref = $$props.ref);
		if ("portal" in $$props) portal = $$props.portal;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [off, ref, id, $$scope, $$slots, div0_binding];
}

class Portal extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document_1.getElementById("svelte-1xulprs-style")) add_css$4();
		init(this, options, instance$D, create_fragment$D, safe_not_equal, { id: 2, off: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Portal",
			options,
			id: create_fragment$D.name
		});
	}

	get id() {
		throw new Error("<Portal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<Portal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get off() {
		throw new Error("<Portal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set off(value) {
		throw new Error("<Portal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/Modal.svelte generated by Svelte v3.24.0 */
const file$E = "src/components/Modal.svelte";

function add_css$5() {
	var style = element("style");
	style.id = "svelte-48jsm1-style";
	style.textContent = ".modal.svelte-48jsm1.svelte-48jsm1{z-index:8;position:fixed;top:0;left:0;width:100%;height:100%;display:-webkit-box;display:-ms-flexbox;display:flex;overflow-x:hidden;overflow-y:auto;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-ms-touch-action:manipulation;touch-action:manipulation;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;background-color:rgba(var(--color-black), .75);outline:150px solid rgba(var(--color-black), .75);-webkit-transition-timing-function:ease-out;transition-timing-function:ease-out;opacity:0;pointer-events:none}.modal.active.svelte-48jsm1.svelte-48jsm1,.modal-header.active.svelte-48jsm1.svelte-48jsm1{opacity:1;pointer-events:auto}.modal-inner.svelte-48jsm1.svelte-48jsm1{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-webkit-box-align:stretch;-ms-flex-align:stretch;align-items:stretch;-webkit-box-pack:stretch;-ms-flex-pack:stretch;justify-content:stretch;overflow:hidden;-webkit-transform:translateZ(0);transform:translateZ(0);background-color:rgba(var(--theme-color-primary))}.small.svelte-48jsm1 .modal-inner.svelte-48jsm1{width:200px;border-radius:var(--border-radius-big);max-width:var(--full-container)}.medium.svelte-48jsm1 .modal-inner.svelte-48jsm1{width:calc(100vw - var(--screen-padding) * 2);border-radius:var(--border-radius-big);max-width:var(--full-container)}.big.svelte-48jsm1 .modal-inner.svelte-48jsm1{width:calc(100% - var(--screen-padding) * 2);height:calc(100% - var(--screen-padding) * 2);border-radius:var(--border-radius-big);max-width:var(--full-container)}.full.svelte-48jsm1.svelte-48jsm1{-webkit-box-align:stretch;-ms-flex-align:stretch;align-items:stretch;-webkit-box-pack:stretch;-ms-flex-pack:stretch;justify-content:stretch}.full.svelte-48jsm1 .modal-inner.svelte-48jsm1{-webkit-box-flex:0;-ms-flex:none;flex:none;width:100%;min-height:100%;border-radius:0}.modal-header.svelte-48jsm1.svelte-48jsm1{-webkit-transform:translateZ(0);transform:translateZ(0);z-index:9;position:fixed;top:0;left:0;width:100%;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between;color:rgb(var(--color-white));background-color:rgb(var(--color-info));opacity:0;pointer-events:none;-webkit-transform-origin:50% 50vh;transform-origin:50% 50vh}.modal-header-relative.svelte-48jsm1.svelte-48jsm1{-webkit-transform:translateZ(0);transform:translateZ(0);z-index:9;position:relative;width:100%;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between;color:rgb(var(--color-white));background-color:rgb(var(--color-info))}.modal-header.svelte-48jsm1 .close.svelte-48jsm1,.modal-header-relative.svelte-48jsm1 .close.svelte-48jsm1{font-size:24px;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;width:50px;height:60px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTW9kYWwuc3ZlbHRlIiwic291cmNlcyI6WyJNb2RhbC5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBjcmVhdGVFdmVudERpc3BhdGNoZXIsIHRpY2sgfSBmcm9tICdzdmVsdGUnXG4gICAgaW1wb3J0IHsgZmx5IH0gZnJvbSBcInN2ZWx0ZS90cmFuc2l0aW9uXCI7XG4gICAgaW1wb3J0IHsgU3dpcGUgfSBmcm9tICdAc2VydmljZXMnXG4gICAgaW1wb3J0IHsgc2FmZUdldCwgY2xhc3NuYW1lcywgZGVsYXksIGJvZHlTY3JvbGwsIHN0b3BQcm9wYWdhdGlvbkluUmFuZ2VzIH0gZnJvbSBcIkB1dGlsc1wiO1xuICAgIGltcG9ydCB7IG1vZGFscyB9IGZyb20gXCJAc3RvcmVcIjtcbiAgICBpbXBvcnQgUG9ydGFsIGZyb20gXCIuL1BvcnRhbC5zdmVsdGVcIjtcbiAgICBpbXBvcnQgQnIgZnJvbSBcIi4vQnIuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IEljb24gZnJvbSBcIi4vSWNvbi5zdmVsdGVcIjtcblxuICAgIGNvbnN0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKClcbiAgICBcbiAgICBjb25zdCBEVVJBVElPTiA9IDI1MFxuICAgIGNvbnN0IFRIUkVTSE9MRCA9IDUwXG4gICAgY29uc3QgU1dJUEVfU1BFRUQgPSAuNVxuICAgIGNvbnN0IFRIUkVTSE9MRF9SQU5HRVMgPSB7IHg6IFswLCAxMDBdLCB5OiBbMSwgOTldIH1cbiAgICBjb25zdCBTVEFSVF9QT1NJVElPTiA9IHtcbiAgICAgICAgeDogNTAsXG4gICAgICAgIHk6IDBcbiAgICB9XG5cbiAgICBleHBvcnQgbGV0IGlkXG4gICAgZXhwb3J0IGxldCByZWYgPSBudWxsXG4gICAgZXhwb3J0IGxldCBzaXplID0gJ2Z1bGwnICAgIC8vIHNtYWxsL21lZGl1bS9iaWcvZnVsbFxuICAgIGV4cG9ydCBsZXQgc3dpcGUgPSBbXSAgICAgICAvLyB1cCBkb3duIGxlZnQgcmlnaHQgYWxsXG4gICAgZXhwb3J0IGxldCB0aXRsZSA9ICfQl9Cw0LrRgNC40YLQuCdcbiAgICBleHBvcnQgbGV0IG9wZW4gPSBudWxsXG4gICAgZXhwb3J0IGxldCBzdGFydFBvc2l0aW9uID0gU1RBUlRfUE9TSVRJT05cbiAgICBleHBvcnQgbGV0IGJsb2NrQm9keSA9IHRydWVcbiAgICBleHBvcnQgbGV0IHdpdGhIZWFkZXIgPSB0cnVlXG5cbiAgICBsZXQgcmVmSGVhZGVyXG4gICAgbGV0IGlzQm9keUJsb2NrZWQgPSBmYWxzZVxuICAgIGxldCBpc0FsbG93ZWQgPSB7XG4gICAgICAgIHVwOiB0cnVlLFxuICAgICAgICBkb3duOiBmYWxzZSxcbiAgICAgICAgbGVmdDogdHJ1ZSxcbiAgICAgICAgcmlnaHQ6IHRydWUsXG4gICAgfVxuXG4gICAgJDogaXNTd2lwZSA9IHtcbiAgICAgICAgdXA6IHNhZmVHZXQoKCkgPT4gc3dpcGUuaW5jbHVkZXMoJ3VwJykgfHwgc3dpcGUuaW5jbHVkZXMoJ2FsbCcpKSxcbiAgICAgICAgZG93bjogc2FmZUdldCgoKSA9PiBzd2lwZS5pbmNsdWRlcygnZG93bicpIHx8IHN3aXBlLmluY2x1ZGVzKCdhbGwnKSksXG4gICAgICAgIGxlZnQ6IHNhZmVHZXQoKCkgPT4gc3dpcGUuaW5jbHVkZXMoJ2xlZnQnKSB8fCBzd2lwZS5pbmNsdWRlcygnYWxsJykpLFxuICAgICAgICByaWdodDogc2FmZUdldCgoKSA9PiBzd2lwZS5pbmNsdWRlcygncmlnaHQnKSB8fCBzd2lwZS5pbmNsdWRlcygnYWxsJykpLFxuICAgIH1cbiAgICAkOiBzY3JvbGxZID0gcmVmICYmIHJlZi5zY3JvbGxUb3BcbiAgICAkOiBhY3RpdmUgPSBzYWZlR2V0KCgpID0+IG9wZW4gIT09IG51bGwgPyBvcGVuIDogJG1vZGFsc1tgbW9kYWwtJHtpZH1gXS5vcGVuLCBudWxsKVxuICAgICQ6IGNsYXNzUHJvcCA9IGNsYXNzbmFtZXMoJ21vZGFsJywgc2l6ZSwgeyBhY3RpdmUgfSlcbiAgICAkOiBvbkFjdGl2ZUNoYW5nZShhY3RpdmUpXG4gICAgJDogYmxvY2tTY3JvbGwocmVmKVxuXG4gICAgZnVuY3Rpb24gYmxvY2tTY3JvbGwobW9kYWwpIHtcbiAgICAgICAgaWYgKGJsb2NrQm9keSAmJiBhY3RpdmUgJiYgIWlzQm9keUJsb2NrZWQpIHtcbiAgICAgICAgICAgIGJvZHlTY3JvbGwuZGlzYWJsZVNjcm9sbChtb2RhbCwgeyBleHRyYUxvY2s6IHNpemUgPT09ICdmdWxsJyB9KTtcbiAgICAgICAgICAgIGlzQm9keUJsb2NrZWQgPSB0cnVlXG4gICAgICAgICAgICBtb2RhbCAmJiAobW9kYWwuc2Nyb2xsVG9wID0gMClcbiAgICAgICAgICAgIGlzQWxsb3dlZCA9IHtcbiAgICAgICAgICAgICAgICB1cDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBkb3duOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBsZWZ0OiB0cnVlLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiB0cnVlLFxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGJsb2NrQm9keSAmJiAhYWN0aXZlICYmIGlzQm9keUJsb2NrZWQpIHtcbiAgICAgICAgICAgIGJvZHlTY3JvbGwuZW5hYmxlU2Nyb2xsKG1vZGFsLCB7IGV4dHJhTG9jazogc2l6ZSA9PT0gJ2Z1bGwnIH0pO1xuICAgICAgICAgICAgaXNCb2R5QmxvY2tlZCA9IGZhbHNlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBvbkFjdGl2ZUNoYW5nZShhY3RpdmUpIHtcbiAgICAgICAgaWYgKGFjdGl2ZSkge1xuICAgICAgICAgICAgc2V0RHVyYXRpb24ocmVmLCBEVVJBVElPTilcbiAgICAgICAgICAgIHNldER1cmF0aW9uKHJlZkhlYWRlciwgRFVSQVRJT04pXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHNldER1cmF0aW9uKHJlZiwgMCksIERVUkFUSU9OKVxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBzZXREdXJhdGlvbihyZWZIZWFkZXIsIDApLCBEVVJBVElPTilcbiAgICAgICAgICAgIGRyYXdUcmFuc2Zvcm0ocmVmLCAwLCAwKVxuICAgICAgICAgICAgZHJhd1RyYW5zZm9ybShyZWZIZWFkZXIsIDAsIDApXG4gICAgICAgICAgICBkcmF3T3BhY2l0eShyZWYsIDAsIDApXG4gICAgICAgICAgICBkcmF3T3BhY2l0eShyZWZIZWFkZXIsIDAsIDApXG4gICAgICAgICAgICBibG9ja1Njcm9sbChyZWYpXG4gICAgICAgICAgICBhd2FpdCB0aWNrKClcbiAgICAgICAgICAgIGRpc3BhdGNoKCdvcGVuJylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJsb2NrU2Nyb2xsKHJlZilcbiAgICAgICAgICAgIGF3YWl0IHRpY2soKVxuICAgICAgICAgICAgZGlzcGF0Y2goJ2Nsb3NlJylcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldEFjdGl2ZShpc0FjdGl2ZSkge1xuICAgICAgICBpZiAob3BlbiAhPT0gbnVsbCkgb3BlbiA9IGlzQWN0aXZlXG4gICAgICAgIG1vZGFscy51cGRhdGUocyA9PiAoeyAuLi5zLCBbYG1vZGFsLSR7aWR9YF06IHsgb3BlbjogaXNBY3RpdmUgfSB9KSlcbiAgICB9XG5cbiAgICBsZXQgeFN3aXBlID0gMFxuICAgIGxldCB5U3dpcGUgPSAwXG5cbiAgICBmdW5jdGlvbiBhZGRTd2lwZShlbCkge1xuICAgICAgICBzdG9wUHJvcGFnYXRpb25JblJhbmdlcyhlbCwgVEhSRVNIT0xEX1JBTkdFUywgKHsgeCwgeSB9KSA9PiB7XG4gICAgICAgICAgICBpc0FsbG93ZWQgPSB7XG4gICAgICAgICAgICAgICAgdXA6IHkgPD0gVEhSRVNIT0xEX1JBTkdFUy55WzBdLFxuICAgICAgICAgICAgICAgIGRvd246IHkgPj0gVEhSRVNIT0xEX1JBTkdFUy55WzFdLFxuICAgICAgICAgICAgICAgIGxlZnQ6IHggPD0gVEhSRVNIT0xEX1JBTkdFUy54WzBdIHx8IHggPj0gVEhSRVNIT0xEX1JBTkdFUy54WzFdLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiB4IDw9IFRIUkVTSE9MRF9SQU5HRVMueFswXSB8fCB4ID49IFRIUkVTSE9MRF9SQU5HRVMueFsxXSxcbiAgICAgICAgICAgIH0gXG4gICAgICAgIH0pXG5cbiAgICAgICAgbmV3IFN3aXBlKGVsKVxuICAgICAgICAgICAgICAgIC5ydW4oKVxuICAgICAgICAgICAgICAgIC5vblVwKGlzU3dpcGUudXAgPyBoYW5kbGVWZXJ0aWNhbFN3aXBlIDogbnVsbClcbiAgICAgICAgICAgICAgICAub25Eb3duKGlzU3dpcGUuZG93biA/IGhhbmRsZVZlcnRpY2FsU3dpcGUgOiBudWxsKVxuICAgICAgICAgICAgICAgIC5vbkxlZnQoaXNTd2lwZS5sZWZ0ID8gaGFuZGxlSG9yaXpvbnRhbFN3aXBlIDogbnVsbClcbiAgICAgICAgICAgICAgICAub25SaWdodChpc1N3aXBlLnJpZ2h0ID8gaGFuZGxlSG9yaXpvbnRhbFN3aXBlIDogbnVsbClcbiAgICAgICAgICAgICAgICAub25Ub3VjaEVuZChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNoaWZ0ID0gNTBcblxuICAgICAgICAgICAgICAgICAgICBpZiAoeFN3aXBlID4gVEhSRVNIT0xEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXREdXJhdGlvbihlbCwgRFVSQVRJT04pXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXREdXJhdGlvbihyZWZIZWFkZXIsIERVUkFUSU9OKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBzZXREdXJhdGlvbihlbCwgMCksIERVUkFUSU9OKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBzZXREdXJhdGlvbihyZWZIZWFkZXIsIDApLCBEVVJBVElPTilcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEFjdGl2ZShmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdPcGFjaXR5KGVsLCB4U3dpcGUgKyBzaGlmdCwgeVN3aXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgZHJhd09wYWNpdHkocmVmSGVhZGVyLCB4U3dpcGUgKyBzaGlmdCwgeVN3aXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgZHJhd1RyYW5zZm9ybShlbCwgeFN3aXBlICsgc2hpZnQsIHlTd2lwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdUcmFuc2Zvcm0ocmVmSGVhZGVyLCB4U3dpcGUgKyBzaGlmdCwgeVN3aXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgZGVsYXkoRFVSQVRJT04pXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoeFN3aXBlIDwgLVRIUkVTSE9MRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0RHVyYXRpb24oZWwsIERVUkFUSU9OKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0RHVyYXRpb24ocmVmSGVhZGVyLCBEVVJBVElPTilcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gc2V0RHVyYXRpb24oZWwsIDApLCBEVVJBVElPTilcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gc2V0RHVyYXRpb24ocmVmSGVhZGVyLCAwKSwgRFVSQVRJT04pXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRBY3RpdmUoZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICBkcmF3T3BhY2l0eShlbCwgeFN3aXBlIC0gc2hpZnQsIHlTd2lwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdPcGFjaXR5KHJlZkhlYWRlciwgeFN3aXBlIC0gc2hpZnQsIHlTd2lwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdUcmFuc2Zvcm0oZWwsIHhTd2lwZSAtIHNoaWZ0LCB5U3dpcGUpXG4gICAgICAgICAgICAgICAgICAgICAgICBkcmF3VHJhbnNmb3JtKHJlZkhlYWRlciwgeFN3aXBlIC0gc2hpZnQsIHlTd2lwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGRlbGF5KERVUkFUSU9OKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAoeVN3aXBlID4gVEhSRVNIT0xEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXREdXJhdGlvbihlbCwgRFVSQVRJT04pXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXREdXJhdGlvbihyZWZIZWFkZXIsIERVUkFUSU9OKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBzZXREdXJhdGlvbihlbCwgMCksIERVUkFUSU9OKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBzZXREdXJhdGlvbihyZWZIZWFkZXIsIDApLCBEVVJBVElPTilcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEFjdGl2ZShmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdPcGFjaXR5KGVsLCB4U3dpcGUsIHlTd2lwZSArIHNoaWZ0KVxuICAgICAgICAgICAgICAgICAgICAgICAgZHJhd09wYWNpdHkocmVmSGVhZGVyLCB4U3dpcGUsIHlTd2lwZSArIHNoaWZ0KVxuICAgICAgICAgICAgICAgICAgICAgICAgZHJhd1RyYW5zZm9ybShlbCwgeFN3aXBlLCB5U3dpcGUgKyBzaGlmdClcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdUcmFuc2Zvcm0ocmVmSGVhZGVyLCB4U3dpcGUsIHlTd2lwZSArIHNoaWZ0KVxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgZGVsYXkoRFVSQVRJT04pXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoeVN3aXBlIDwgLVRIUkVTSE9MRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0RHVyYXRpb24oZWwsIERVUkFUSU9OKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0RHVyYXRpb24ocmVmSGVhZGVyLCBEVVJBVElPTilcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gc2V0RHVyYXRpb24oZWwsIDApLCBEVVJBVElPTilcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gc2V0RHVyYXRpb24ocmVmSGVhZGVyLCAwKSwgRFVSQVRJT04pXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRBY3RpdmUoZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICBkcmF3T3BhY2l0eShlbCwgeFN3aXBlLCB5U3dpcGUgLSBzaGlmdClcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdPcGFjaXR5KHJlZkhlYWRlciwgeFN3aXBlLCB5U3dpcGUgLSBzaGlmdClcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdUcmFuc2Zvcm0oZWwsIHhTd2lwZSwgeVN3aXBlIC0gc2hpZnQpXG4gICAgICAgICAgICAgICAgICAgICAgICBkcmF3VHJhbnNmb3JtKHJlZkhlYWRlciwgeFN3aXBlLCB5U3dpcGUgLSBzaGlmdClcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGRlbGF5KERVUkFUSU9OKVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHhTd2lwZSA8PSBUSFJFU0hPTEQgJiYgeFN3aXBlID49IC1USFJFU0hPTEQgJiYgeVN3aXBlIDw9IFRIUkVTSE9MRCAmJiB5U3dpcGUgPj0gLVRIUkVTSE9MRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0RHVyYXRpb24oZWwsIERVUkFUSU9OKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0RHVyYXRpb24ocmVmSGVhZGVyLCBEVVJBVElPTilcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gc2V0RHVyYXRpb24oZWwsIDApLCBEVVJBVElPTilcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gc2V0RHVyYXRpb24ocmVmSGVhZGVyLCAwKSwgRFVSQVRJT04pXG4gICAgICAgICAgICAgICAgICAgICAgICBkcmF3VHJhbnNmb3JtKGVsLCAwLCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgZHJhd1RyYW5zZm9ybShyZWZIZWFkZXIsIDAsIDApXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRTdGFydFBvc2l0aW9uKClcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHhTd2lwZSA9IDBcbiAgICAgICAgICAgICAgICAgICAgeVN3aXBlID0gMFxuICAgICAgICAgICAgICAgICAgICBlbCAmJiAoZWwuc3R5bGUub3BhY2l0eSA9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJlZkhlYWRlciAmJiAocmVmSGVhZGVyLnN0eWxlLm9wYWNpdHkgPSBudWxsKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlVmVydGljYWxTd2lwZSh5RG93biwgeVVwLCBldnQsIGVsKSB7XG4gICAgICAgIGNvbnN0IGRpciA9IHlVcCAtIHlEb3duXG4gICAgICAgIGlmICghaXNBbGxvd2VkLnVwICYmIGRpciA+IDAgfHwgIWlzQWxsb3dlZC5kb3duICYmIGRpciA8IDApIHJldHVyblxuICAgICAgICB5U3dpcGUgPSBkaXIgKiBTV0lQRV9TUEVFRFxuICAgICAgICBkcmF3VHJhbnNmb3JtKGVsLCB4U3dpcGUsIHlTd2lwZSlcbiAgICAgICAgZHJhd1RyYW5zZm9ybShyZWZIZWFkZXIsIHhTd2lwZSwgeVN3aXBlKVxuICAgICAgICBkcmF3T3BhY2l0eShlbCwgeFN3aXBlLCB5U3dpcGUpXG4gICAgICAgIGRyYXdPcGFjaXR5KHJlZkhlYWRlciwgeFN3aXBlLCB5U3dpcGUpXG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZUhvcml6b250YWxTd2lwZSh4RG93biwgeFVwLCBldnQsIGVsKSB7XG4gICAgICAgIGNvbnN0IGRpciA9IHhVcCAtIHhEb3duXG4gICAgICAgIGlmICghaXNBbGxvd2VkLmxlZnQgJiYgZGlyID4gMCB8fCAhaXNBbGxvd2VkLnJpZ2h0ICYmIGRpciA8IDApIHJldHVyblxuICAgICAgICB4U3dpcGUgPSBkaXIgKiBTV0lQRV9TUEVFRFxuICAgICAgICBkcmF3VHJhbnNmb3JtKGVsLCB4U3dpcGUsIHlTd2lwZSlcbiAgICAgICAgZHJhd1RyYW5zZm9ybShyZWZIZWFkZXIsIHhTd2lwZSwgeVN3aXBlKVxuICAgICAgICBkcmF3T3BhY2l0eShlbCwgeFN3aXBlLCB5U3dpcGUpXG4gICAgICAgIGRyYXdPcGFjaXR5KHJlZkhlYWRlciwgeFN3aXBlLCB5U3dpcGUpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0U3RhcnRQb3NpdGlvbigpIHtcbiAgICAgICAgZHJhd1RyYW5zZm9ybShyZWYsIHN0YXJ0UG9zaXRpb24ueCwgc3RhcnRQb3NpdGlvbi55KVxuICAgICAgICBkcmF3VHJhbnNmb3JtKHJlZkhlYWRlciwgc3RhcnRQb3NpdGlvbi54LCBzdGFydFBvc2l0aW9uLnkpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZHJhd1RyYW5zZm9ybShlbCwgeCwgeSkge1xuICAgICAgICBjb25zdCBkZWx0YSA9IE1hdGguYWJzKHgpID4gTWF0aC5hYnMoeSkgPyB4IDogeVxuICAgICAgICBsZXQgc2NhbGUgPSAxIC0gTWF0aC5hYnMoZGVsdGEgLyB3aW5kb3cuaW5uZXJIZWlnaHQpXG4gICAgICAgIGVsICYmIChlbC5zdHlsZS50cmFuc2Zvcm0gPSBgbWF0cml4KCR7c2NhbGV9LCAwLCAwLCAke3NjYWxlfSwgJHt4fSwgJHt5fSlgKVxuICAgIH1cbiAgICAgZnVuY3Rpb24gc2V0RHVyYXRpb24oZWwsIG1zKSB7XG4gICAgICAgIGVsICYmIChlbC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBgJHttc31tc2ApXG4gICAgfVxuICAgIGZ1bmN0aW9uIGRyYXdPcGFjaXR5KGVsLCB4LCB5KSB7XG4gICAgICAgIGNvbnN0IGRlbHRhID0gTWF0aC5hYnMoeCkgPiBNYXRoLmFicyh5KSA/IHggOiB5XG4gICAgICAgIGVsICYmIChlbC5zdHlsZS5vcGFjaXR5ID0gMSAtIE1hdGgubWluKE1hdGguYWJzKGRlbHRhIC8gKFRIUkVTSE9MRCAqIDEuNSkpLCAxKSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcHBlYXIobm9kZSwgcGFyYW1zKSB7XG4gICAgICAgIGlmICghYWN0aXZlKSByZXR1cm5cblx0XHRjb25zdCBleGlzdGluZ1RyYW5zZm9ybSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSkudHJhbnNmb3JtLnJlcGxhY2UoJ25vbmUnLCAnJyk7XG4gICAgICAgIGNvbnN0IGdldFNjYWxlID0gdCA9PiAuOSArIC4xICogdFxuICAgICAgICBjb25zdCBnZXRYID0gdCA9PiBzdGFydFBvc2l0aW9uLnggLSBzdGFydFBvc2l0aW9uLnggKiB0XG5cdFx0cmV0dXJuIHtcblx0XHRcdGR1cmF0aW9uOiBEVVJBVElPTixcblx0XHRcdGNzczogKHQpID0+IGBvcGFjaXR5OiAke3R9OyB0cmFuc2Zvcm06IG1hdHJpeCgke2dldFNjYWxlKHQpfSwgMCwgMCwgJHtnZXRTY2FsZSh0KX0sICR7Z2V0WCh0KX0sIDApYFxuXHRcdH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25DbG9zZU1vZGFsKCkge1xuICAgICAgICBzZXREdXJhdGlvbihyZWYsIERVUkFUSU9OKVxuICAgICAgICBzZXREdXJhdGlvbihyZWZIZWFkZXIsIERVUkFUSU9OKVxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHNldER1cmF0aW9uKHJlZiwgMCksIERVUkFUSU9OKVxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHNldER1cmF0aW9uKHJlZkhlYWRlciwgMCksIERVUkFUSU9OKVxuICAgICAgICBzZXRTdGFydFBvc2l0aW9uKClcbiAgICAgICAgZHJhd09wYWNpdHkocmVmLCBzdGFydFBvc2l0aW9uLnggKiAyLCBzdGFydFBvc2l0aW9uLnkpXG4gICAgICAgIGRyYXdPcGFjaXR5KHJlZkhlYWRlciwgc3RhcnRQb3NpdGlvbi54ICogMiwgc3RhcnRQb3NpdGlvbi55KVxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHNldEFjdGl2ZShmYWxzZSksIERVUkFUSU9OKVxuICAgIH1cbjwvc2NyaXB0PlxuXG57I2lmIGFjdGl2ZX1cbiAgICA8UG9ydGFsIHtpZH0+XG4gICAgICAgIDxkaXZcbiAgICAgICAgICAgIGlkPXtgbW9kYWwtJHtpZH1gfVxuICAgICAgICAgICAgYmluZDp0aGlzPXtyZWZ9XG4gICAgICAgICAgICBhcmlhLWhpZGRlbj1cInRydWVcIiBcbiAgICAgICAgICAgIGNsYXNzPXtjbGFzc1Byb3B9XG4gICAgICAgICAgICB1c2U6YWRkU3dpcGVcbiAgICAgICAgICAgIGluOmFwcGVhclxuICAgICAgICAgICAgb246Y2xpY2s9e3NldEFjdGl2ZS5iaW5kKG51bGwsIGZhbHNlKX1cbiAgICAgICAgPlxuICAgICAgICAgICAgeyNpZiB3aXRoSGVhZGVyICYmIHNpemUgPT09ICdmdWxsJ31cbiAgICAgICAgICAgICAgICA8UG9ydGFsPlxuICAgICAgICAgICAgICAgICAgICA8c2xvdCBuYW1lPVwiaGVhZGVyXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPXtjbGFzc25hbWVzKCdtb2RhbC1oZWFkZXInLCB7IGFjdGl2ZSB9KX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbjphcHBlYXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaW5kOnRoaXM9e3JlZkhlYWRlcn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbjpjbGljaz17b25DbG9zZU1vZGFsfVxuICAgICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxoMiBzdHlsZT1cInBhZGRpbmc6IDE1cHhcIj57IHRpdGxlIH08L2gyPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiY2xvc2VcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxJY29uIHR5cGU9XCJjbG9zZVwiIHNpemU9XCJiaWdcIiBpcz1cImxpZ2h0XCIvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICA8L3Nsb3Q+XG4gICAgICAgICAgICAgICAgPC9Qb3J0YWw+ICAgXG4gICAgICAgICAgICAgICAgPEJyIHNpemU9XCI2MFwiLz5cbiAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgY2xhc3M9XCJtb2RhbC1pbm5lclwiXG4gICAgICAgICAgICAgICAgdGFiaW5kZXg9XCItMVwiXG4gICAgICAgICAgICAgICAgcm9sZT1cImRpYWxvZ1wiXG4gICAgICAgICAgICAgICAgYXJpYS1tb2RhbD1cInRydWVcIlxuICAgICAgICAgICAgICAgIGFyaWEtbGFiZWxsZWRieT1cItC80L7QtNCw0LvRjNC90LUg0LLRltC60L3QvlwiXG4gICAgICAgICAgICAgICAgb246Y2xpY2s9e2UgPT4gZS5zdG9wUHJvcGFnYXRpb24oKX1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICB7I2lmIHdpdGhIZWFkZXIgJiYgc2l6ZSAhPT0gJ2Z1bGwnfVxuICAgICAgICAgICAgICAgICAgICA8c2xvdCBuYW1lPVwiaGVhZGVyXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz17Y2xhc3NuYW1lcygnbW9kYWwtaGVhZGVyLXJlbGF0aXZlIGFjdGl2ZScpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbjphcHBlYXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb246Y2xpY2s9e29uQ2xvc2VNb2RhbH1cbiAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aDIgc3R5bGU9XCJwYWRkaW5nOiAxNXB4XCI+eyB0aXRsZSB9PC9oMj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImNsb3NlXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8SWNvbiB0eXBlPVwiY2xvc2VcIiBzaXplPVwiYmlnXCIgaXM9XCJsaWdodFwiLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgPC9zbG90PlxuICAgICAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICAgICAgPHNsb3QgcHJvcHM9e3NhZmVHZXQoKCkgPT4gJG1vZGFsc1tgbW9kYWwtJHtpZH1gXSwge30sIHRydWUpfS8+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9Qb3J0YWw+XG57L2lmfVxuXG48c3R5bGU+XG4ubW9kYWwge1xuICAgIHotaW5kZXg6IDg7XG4gICAgcG9zaXRpb246IGZpeGVkO1xuICAgIHRvcDogMDtcbiAgICBsZWZ0OiAwO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogMTAwJTtcbiAgICBkaXNwbGF5OiAtd2Via2l0LWJveDtcbiAgICBkaXNwbGF5OiAtbXMtZmxleGJveDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIG92ZXJmbG93LXg6IGhpZGRlbjtcbiAgICBvdmVyZmxvdy15OiBhdXRvO1xuICAgIC13ZWJraXQtYm94LWFsaWduOiBjZW50ZXI7XG4gICAgICAgIC1tcy1mbGV4LWFsaWduOiBjZW50ZXI7XG4gICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIC13ZWJraXQtYm94LXBhY2s6IGNlbnRlcjtcbiAgICAgICAgLW1zLWZsZXgtcGFjazogY2VudGVyO1xuICAgICAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgLXdlYmtpdC1ib3gtb3JpZW50OiB2ZXJ0aWNhbDtcbiAgICAtd2Via2l0LWJveC1kaXJlY3Rpb246IG5vcm1hbDtcbiAgICAgICAgLW1zLWZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIC1tcy10b3VjaC1hY3Rpb246IG1hbmlwdWxhdGlvbjtcbiAgICAgICAgdG91Y2gtYWN0aW9uOiBtYW5pcHVsYXRpb247XG4gICAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcbiAgICAgICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xuICAgICAgICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgICAgICB1c2VyLXNlbGVjdDogbm9uZTtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKHZhcigtLWNvbG9yLWJsYWNrKSwgLjc1KTtcbiAgICBvdXRsaW5lOiAxNTBweCBzb2xpZCByZ2JhKHZhcigtLWNvbG9yLWJsYWNrKSwgLjc1KTtcbiAgICAtd2Via2l0LXRyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uOiBlYXNlLW91dDtcbiAgICAgICAgICAgIHRyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uOiBlYXNlLW91dDtcbiAgICBvcGFjaXR5OiAwO1xuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xufVxuXG4ubW9kYWwuYWN0aXZlLCAubW9kYWwtaGVhZGVyLmFjdGl2ZSB7XG4gICAgb3BhY2l0eTogMTtcbiAgICBwb2ludGVyLWV2ZW50czogYXV0bztcbn1cblxuLm1vZGFsLWlubmVyIHtcbiAgICBkaXNwbGF5OiAtd2Via2l0LWJveDtcbiAgICBkaXNwbGF5OiAtbXMtZmxleGJveDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIC13ZWJraXQtYm94LW9yaWVudDogdmVydGljYWw7XG4gICAgLXdlYmtpdC1ib3gtZGlyZWN0aW9uOiBub3JtYWw7XG4gICAgICAgIC1tcy1mbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAtd2Via2l0LWJveC1hbGlnbjogc3RyZXRjaDtcbiAgICAgICAgLW1zLWZsZXgtYWxpZ246IHN0cmV0Y2g7XG4gICAgICAgICAgICBhbGlnbi1pdGVtczogc3RyZXRjaDtcbiAgICAtd2Via2l0LWJveC1wYWNrOiBzdHJldGNoO1xuICAgICAgICAtbXMtZmxleC1wYWNrOiBzdHJldGNoO1xuICAgICAgICAgICAganVzdGlmeS1jb250ZW50OiBzdHJldGNoO1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVooMCk7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVooMCk7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSh2YXIoLS10aGVtZS1jb2xvci1wcmltYXJ5KSk7XG59XG4uc21hbGwgLm1vZGFsLWlubmVyIHtcbiAgICB3aWR0aDogMjAwcHg7XG4gICAgYm9yZGVyLXJhZGl1czogdmFyKC0tYm9yZGVyLXJhZGl1cy1iaWcpO1xuICAgIG1heC13aWR0aDogdmFyKC0tZnVsbC1jb250YWluZXIpO1xufVxuXG4ubWVkaXVtIC5tb2RhbC1pbm5lciB7XG4gICAgd2lkdGg6IGNhbGMoMTAwdncgLSB2YXIoLS1zY3JlZW4tcGFkZGluZykgKiAyKTtcbiAgICBib3JkZXItcmFkaXVzOiB2YXIoLS1ib3JkZXItcmFkaXVzLWJpZyk7XG4gICAgbWF4LXdpZHRoOiB2YXIoLS1mdWxsLWNvbnRhaW5lcik7XG59XG4uYmlnIC5tb2RhbC1pbm5lciB7XG4gICAgd2lkdGg6IGNhbGMoMTAwJSAtIHZhcigtLXNjcmVlbi1wYWRkaW5nKSAqIDIpO1xuICAgIGhlaWdodDogY2FsYygxMDAlIC0gdmFyKC0tc2NyZWVuLXBhZGRpbmcpICogMik7XG4gICAgYm9yZGVyLXJhZGl1czogdmFyKC0tYm9yZGVyLXJhZGl1cy1iaWcpO1xuICAgIG1heC13aWR0aDogdmFyKC0tZnVsbC1jb250YWluZXIpO1xufVxuXG4uZnVsbCB7XG4gICAgLXdlYmtpdC1ib3gtYWxpZ246IHN0cmV0Y2g7XG4gICAgICAgIC1tcy1mbGV4LWFsaWduOiBzdHJldGNoO1xuICAgICAgICAgICAgYWxpZ24taXRlbXM6IHN0cmV0Y2g7XG4gICAgLXdlYmtpdC1ib3gtcGFjazogc3RyZXRjaDtcbiAgICAgICAgLW1zLWZsZXgtcGFjazogc3RyZXRjaDtcbiAgICAgICAgICAgIGp1c3RpZnktY29udGVudDogc3RyZXRjaDtcbn1cblxuLmZ1bGwgLm1vZGFsLWlubmVyIHtcbiAgICAtd2Via2l0LWJveC1mbGV4OiAwO1xuICAgICAgICAtbXMtZmxleDogbm9uZTtcbiAgICAgICAgICAgIGZsZXg6IG5vbmU7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgbWluLWhlaWdodDogMTAwJTtcbiAgICBib3JkZXItcmFkaXVzOiAwO1xufVxuXG4ubW9kYWwtaGVhZGVyIHtcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWigwKTtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWigwKTtcbiAgICB6LWluZGV4OiA5O1xuICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICB0b3A6IDA7XG4gICAgbGVmdDogMDtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBkaXNwbGF5OiAtd2Via2l0LWJveDtcbiAgICBkaXNwbGF5OiAtbXMtZmxleGJveDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIC13ZWJraXQtYm94LWFsaWduOiBjZW50ZXI7XG4gICAgICAgIC1tcy1mbGV4LWFsaWduOiBjZW50ZXI7XG4gICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIC13ZWJraXQtYm94LXBhY2s6IGp1c3RpZnk7XG4gICAgICAgIC1tcy1mbGV4LXBhY2s6IGp1c3RpZnk7XG4gICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgY29sb3I6IHJnYih2YXIoLS1jb2xvci13aGl0ZSkpO1xuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYih2YXIoLS1jb2xvci1pbmZvKSk7XG4gICAgb3BhY2l0eTogMDtcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICAtd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46IDUwJSA1MHZoO1xuICAgICAgICAgICAgdHJhbnNmb3JtLW9yaWdpbjogNTAlIDUwdmg7XG59XG5cbi5tb2RhbC1oZWFkZXItcmVsYXRpdmUge1xuICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVaKDApO1xuICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVaKDApO1xuICAgIHotaW5kZXg6IDk7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGRpc3BsYXk6IC13ZWJraXQtYm94O1xuICAgIGRpc3BsYXk6IC1tcy1mbGV4Ym94O1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgLXdlYmtpdC1ib3gtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgLW1zLWZsZXgtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgLXdlYmtpdC1ib3gtcGFjazoganVzdGlmeTtcbiAgICAgICAgLW1zLWZsZXgtcGFjazoganVzdGlmeTtcbiAgICAgICAgICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgICBjb2xvcjogcmdiKHZhcigtLWNvbG9yLXdoaXRlKSk7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiKHZhcigtLWNvbG9yLWluZm8pKTtcbn1cblxuLm1vZGFsLWhlYWRlciAuY2xvc2UsXG4ubW9kYWwtaGVhZGVyLXJlbGF0aXZlIC5jbG9zZSB7XG4gICAgZm9udC1zaXplOiAyNHB4O1xuICAgIGRpc3BsYXk6IC13ZWJraXQtYm94O1xuICAgIGRpc3BsYXk6IC1tcy1mbGV4Ym94O1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgLXdlYmtpdC1ib3gtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgLW1zLWZsZXgtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgLXdlYmtpdC1ib3gtcGFjazogY2VudGVyO1xuICAgICAgICAtbXMtZmxleC1wYWNrOiBjZW50ZXI7XG4gICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICB3aWR0aDogNTBweDtcbiAgICBoZWlnaHQ6IDYwcHg7XG59PC9zdHlsZT4gICBcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUE4U0EsTUFBTSw0QkFBQyxDQUFDLEFBQ0osT0FBTyxDQUFFLENBQUMsQ0FDVixRQUFRLENBQUUsS0FBSyxDQUNmLEdBQUcsQ0FBRSxDQUFDLENBQ04sSUFBSSxDQUFFLENBQUMsQ0FDUCxLQUFLLENBQUUsSUFBSSxDQUNYLE1BQU0sQ0FBRSxJQUFJLENBQ1osT0FBTyxDQUFFLFdBQVcsQ0FDcEIsT0FBTyxDQUFFLFdBQVcsQ0FDcEIsT0FBTyxDQUFFLElBQUksQ0FDYixVQUFVLENBQUUsTUFBTSxDQUNsQixVQUFVLENBQUUsSUFBSSxDQUNoQixpQkFBaUIsQ0FBRSxNQUFNLENBQ3JCLGNBQWMsQ0FBRSxNQUFNLENBQ2xCLFdBQVcsQ0FBRSxNQUFNLENBQzNCLGdCQUFnQixDQUFFLE1BQU0sQ0FDcEIsYUFBYSxDQUFFLE1BQU0sQ0FDakIsZUFBZSxDQUFFLE1BQU0sQ0FDL0Isa0JBQWtCLENBQUUsUUFBUSxDQUM1QixxQkFBcUIsQ0FBRSxNQUFNLENBQ3pC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 */";
	append_dev(document.head, style);
}

const get_default_slot_changes = dirty => ({ props: dirty[0] & /*$modals, id*/ 130 });

const get_default_slot_context = ctx => ({
	props: safeGet(/*func*/ ctx[19], {}, true)
});

const get_header_slot_changes_1 = dirty => ({ props: dirty[0] & /*$modals, id*/ 130 });

const get_header_slot_context_1 = ctx => ({
	props: safeGet(/*func*/ ctx[19], {}, true)
});

const get_header_slot_changes = dirty => ({});
const get_header_slot_context = ctx => ({});

// (243:0) {#if active}
function create_if_block$2(ctx) {
	let portal;
	let current;

	portal = new Portal({
			props: {
				id: /*id*/ ctx[1],
				$$slots: { default: [create_default_slot$y] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(portal.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(portal.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(portal, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const portal_changes = {};
			if (dirty[0] & /*id*/ 2) portal_changes.id = /*id*/ ctx[1];

			if (dirty[0] & /*$$scope, id, classProp, ref, $modals, title, withHeader, size, active, refHeader*/ 2097663) {
				portal_changes.$$scope = { dirty, ctx };
			}

			portal.$set(portal_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(portal.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(portal.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(portal, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$2.name,
		type: "if",
		source: "(243:0) {#if active}",
		ctx
	});

	return block;
}

// (254:12) {#if withHeader && size === 'full'}
function create_if_block_2(ctx) {
	let portal;
	let t;
	let br;
	let current;

	portal = new Portal({
			props: {
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	br = new Br({ props: { size: "60" }, $$inline: true });

	const block = {
		c: function create() {
			create_component(portal.$$.fragment);
			t = space();
			create_component(br.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(portal.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(br.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(portal, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(br, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const portal_changes = {};

			if (dirty[0] & /*$$scope, active, refHeader, title*/ 2097256) {
				portal_changes.$$scope = { dirty, ctx };
			}

			portal.$set(portal_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(portal.$$.fragment, local);
			transition_in(br.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(portal.$$.fragment, local);
			transition_out(br.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(portal, detaching);
			if (detaching) detach_dev(t);
			destroy_component(br, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(254:12) {#if withHeader && size === 'full'}",
		ctx
	});

	return block;
}

// (256:40)                          
function fallback_block_1(ctx) {
	let button;
	let h2;
	let t0;
	let t1;
	let span;
	let icon;
	let button_class_value;
	let button_intro;
	let current;
	let mounted;
	let dispose;

	icon = new Icon({
			props: { type: "close", size: "big", is: "light" },
			$$inline: true
		});

	const block = {
		c: function create() {
			button = element("button");
			h2 = element("h2");
			t0 = text(/*title*/ ctx[3]);
			t1 = space();
			span = element("span");
			create_component(icon.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", { type: true, class: true });
			var button_nodes = children(button);
			h2 = claim_element(button_nodes, "H2", { style: true });
			var h2_nodes = children(h2);
			t0 = claim_text(h2_nodes, /*title*/ ctx[3]);
			h2_nodes.forEach(detach_dev);
			t1 = claim_space(button_nodes);
			span = claim_element(button_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			claim_component(icon.$$.fragment, span_nodes);
			span_nodes.forEach(detach_dev);
			button_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_style(h2, "padding", "15px");
			add_location(h2, file$E, 263, 28, 10489);
			attr_dev(span, "class", "close svelte-48jsm1");
			add_location(span, file$E, 264, 28, 10558);
			attr_dev(button, "type", "button");
			attr_dev(button, "class", button_class_value = "" + (null_to_empty(classnames("modal-header", { active: /*active*/ ctx[6] })) + " svelte-48jsm1"));
			add_location(button, file$E, 256, 24, 10169);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, h2);
			append_dev(h2, t0);
			append_dev(button, t1);
			append_dev(button, span);
			mount_component(icon, span, null);
			/*button_binding*/ ctx[18](button);
			current = true;

			if (!mounted) {
				dispose = listen_dev(button, "click", /*onCloseModal*/ ctx[12], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (!current || dirty[0] & /*title*/ 8) set_data_dev(t0, /*title*/ ctx[3]);

			if (!current || dirty[0] & /*active*/ 64 && button_class_value !== (button_class_value = "" + (null_to_empty(classnames("modal-header", { active: /*active*/ ctx[6] })) + " svelte-48jsm1"))) {
				attr_dev(button, "class", button_class_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);

			if (!button_intro) {
				add_render_callback(() => {
					button_intro = create_in_transition(button, /*appear*/ ctx[11], {});
					button_intro.start();
				});
			}

			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			destroy_component(icon);
			/*button_binding*/ ctx[18](null);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: fallback_block_1.name,
		type: "fallback",
		source: "(256:40)                          ",
		ctx
	});

	return block;
}

// (255:16) <Portal>
function create_default_slot_1(ctx) {
	let current;
	const header_slot_template = /*$$slots*/ ctx[17].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[21], get_header_slot_context);
	const header_slot_or_fallback = header_slot || fallback_block_1(ctx);

	const block = {
		c: function create() {
			if (header_slot_or_fallback) header_slot_or_fallback.c();
		},
		l: function claim(nodes) {
			if (header_slot_or_fallback) header_slot_or_fallback.l(nodes);
		},
		m: function mount(target, anchor) {
			if (header_slot_or_fallback) {
				header_slot_or_fallback.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (header_slot) {
				if (header_slot.p && dirty[0] & /*$$scope*/ 2097152) {
					update_slot(header_slot, header_slot_template, ctx, /*$$scope*/ ctx[21], dirty, get_header_slot_changes, get_header_slot_context);
				}
			} else {
				if (header_slot_or_fallback && header_slot_or_fallback.p && dirty[0] & /*active, refHeader, title*/ 104) {
					header_slot_or_fallback.p(ctx, dirty);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(header_slot_or_fallback, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(header_slot_or_fallback, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (header_slot_or_fallback) header_slot_or_fallback.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1.name,
		type: "slot",
		source: "(255:16) <Portal>",
		ctx
	});

	return block;
}

// (281:16) {#if withHeader && size !== 'full'}
function create_if_block_1(ctx) {
	let current;
	const header_slot_template = /*$$slots*/ ctx[17].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[21], get_header_slot_context_1);
	const header_slot_or_fallback = header_slot || fallback_block(ctx);

	const block = {
		c: function create() {
			if (header_slot_or_fallback) header_slot_or_fallback.c();
		},
		l: function claim(nodes) {
			if (header_slot_or_fallback) header_slot_or_fallback.l(nodes);
		},
		m: function mount(target, anchor) {
			if (header_slot_or_fallback) {
				header_slot_or_fallback.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (header_slot) {
				if (header_slot.p && dirty[0] & /*$$scope, $modals, id*/ 2097282) {
					update_slot(header_slot, header_slot_template, ctx, /*$$scope*/ ctx[21], dirty, get_header_slot_changes_1, get_header_slot_context_1);
				}
			} else {
				if (header_slot_or_fallback && header_slot_or_fallback.p && dirty[0] & /*title*/ 8) {
					header_slot_or_fallback.p(ctx, dirty);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(header_slot_or_fallback, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(header_slot_or_fallback, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (header_slot_or_fallback) header_slot_or_fallback.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(281:16) {#if withHeader && size !== 'full'}",
		ctx
	});

	return block;
}

// (282:40)                          
function fallback_block(ctx) {
	let button;
	let h2;
	let t0;
	let t1;
	let span;
	let icon;
	let button_class_value;
	let button_intro;
	let current;
	let mounted;
	let dispose;

	icon = new Icon({
			props: { type: "close", size: "big", is: "light" },
			$$inline: true
		});

	const block = {
		c: function create() {
			button = element("button");
			h2 = element("h2");
			t0 = text(/*title*/ ctx[3]);
			t1 = space();
			span = element("span");
			create_component(icon.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", { type: true, class: true });
			var button_nodes = children(button);
			h2 = claim_element(button_nodes, "H2", { style: true });
			var h2_nodes = children(h2);
			t0 = claim_text(h2_nodes, /*title*/ ctx[3]);
			h2_nodes.forEach(detach_dev);
			t1 = claim_space(button_nodes);
			span = claim_element(button_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			claim_component(icon.$$.fragment, span_nodes);
			span_nodes.forEach(detach_dev);
			button_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_style(h2, "padding", "15px");
			add_location(h2, file$E, 288, 28, 11500);
			attr_dev(span, "class", "close svelte-48jsm1");
			add_location(span, file$E, 289, 28, 11569);
			attr_dev(button, "type", "button");
			attr_dev(button, "class", button_class_value = "" + (null_to_empty(classnames("modal-header-relative active")) + " svelte-48jsm1"));
			add_location(button, file$E, 282, 24, 11211);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, h2);
			append_dev(h2, t0);
			append_dev(button, t1);
			append_dev(button, span);
			mount_component(icon, span, null);
			current = true;

			if (!mounted) {
				dispose = listen_dev(button, "click", /*onCloseModal*/ ctx[12], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (!current || dirty[0] & /*title*/ 8) set_data_dev(t0, /*title*/ ctx[3]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);

			if (!button_intro) {
				add_render_callback(() => {
					button_intro = create_in_transition(button, /*appear*/ ctx[11], {});
					button_intro.start();
				});
			}

			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			destroy_component(icon);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: fallback_block.name,
		type: "fallback",
		source: "(282:40)                          ",
		ctx
	});

	return block;
}

// (244:4) <Portal {id}>
function create_default_slot$y(ctx) {
	let div1;
	let t0;
	let div0;
	let t1;
	let div1_id_value;
	let div1_class_value;
	let addSwipe_action;
	let div1_intro;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*withHeader*/ ctx[4] && /*size*/ ctx[2] === "full" && create_if_block_2(ctx);
	let if_block1 = /*withHeader*/ ctx[4] && /*size*/ ctx[2] !== "full" && create_if_block_1(ctx);
	const default_slot_template = /*$$slots*/ ctx[17].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[21], get_default_slot_context);

	const block = {
		c: function create() {
			div1 = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			div0 = element("div");
			if (if_block1) if_block1.c();
			t1 = space();
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", {
				id: true,
				"aria-hidden": true,
				class: true
			});

			var div1_nodes = children(div1);
			if (if_block0) if_block0.l(div1_nodes);
			t0 = claim_space(div1_nodes);

			div0 = claim_element(div1_nodes, "DIV", {
				class: true,
				tabindex: true,
				role: true,
				"aria-modal": true,
				"aria-labelledby": true
			});

			var div0_nodes = children(div0);
			if (if_block1) if_block1.l(div0_nodes);
			t1 = claim_space(div0_nodes);
			if (default_slot) default_slot.l(div0_nodes);
			div0_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "modal-inner svelte-48jsm1");
			attr_dev(div0, "tabindex", "-1");
			attr_dev(div0, "role", "dialog");
			attr_dev(div0, "aria-modal", "true");
			attr_dev(div0, "aria-labelledby", "модальне вікно");
			add_location(div0, file$E, 272, 12, 10844);
			attr_dev(div1, "id", div1_id_value = `modal-${/*id*/ ctx[1]}`);
			attr_dev(div1, "aria-hidden", "true");
			attr_dev(div1, "class", div1_class_value = "" + (null_to_empty(/*classProp*/ ctx[8]) + " svelte-48jsm1"));
			add_location(div1, file$E, 244, 8, 9797);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			if (if_block0) if_block0.m(div1, null);
			append_dev(div1, t0);
			append_dev(div1, div0);
			if (if_block1) if_block1.m(div0, null);
			append_dev(div0, t1);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			/*div1_binding*/ ctx[20](div1);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(div0, "click", click_handler, false, false, false),
					action_destroyer(addSwipe_action = /*addSwipe*/ ctx[10].call(null, div1)),
					listen_dev(div1, "click", /*setActive*/ ctx[9].bind(null, false), false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*withHeader*/ ctx[4] && /*size*/ ctx[2] === "full") {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*withHeader, size*/ 20) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_2(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div1, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*withHeader*/ ctx[4] && /*size*/ ctx[2] !== "full") {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*withHeader, size*/ 20) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_1(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div0, t1);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && dirty[0] & /*$$scope, $modals, id*/ 2097282) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[21], dirty, get_default_slot_changes, get_default_slot_context);
				}
			}

			if (!current || dirty[0] & /*id*/ 2 && div1_id_value !== (div1_id_value = `modal-${/*id*/ ctx[1]}`)) {
				attr_dev(div1, "id", div1_id_value);
			}

			if (!current || dirty[0] & /*classProp*/ 256 && div1_class_value !== (div1_class_value = "" + (null_to_empty(/*classProp*/ ctx[8]) + " svelte-48jsm1"))) {
				attr_dev(div1, "class", div1_class_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(default_slot, local);

			if (!div1_intro) {
				add_render_callback(() => {
					div1_intro = create_in_transition(div1, /*appear*/ ctx[11], {});
					div1_intro.start();
				});
			}

			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (default_slot) default_slot.d(detaching);
			/*div1_binding*/ ctx[20](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$y.name,
		type: "slot",
		source: "(244:4) <Portal {id}>",
		ctx
	});

	return block;
}

function create_fragment$E(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*active*/ ctx[6] && create_if_block$2(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*active*/ ctx[6]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*active*/ 64) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$2(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$E.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const DURATION$1 = 250;
const THRESHOLD = 50;
const SWIPE_SPEED = 0.5;

function drawTransform(el, x, y) {
	const delta = Math.abs(x) > Math.abs(y) ? x : y;
	let scale = 1 - Math.abs(delta / window.innerHeight);
	el && (el.style.transform = `matrix(${scale}, 0, 0, ${scale}, ${x}, ${y})`);
}

function setDuration(el, ms) {
	el && (el.style.transitionDuration = `${ms}ms`);
}

function drawOpacity(el, x, y) {
	const delta = Math.abs(x) > Math.abs(y) ? x : y;
	el && (el.style.opacity = 1 - Math.min(Math.abs(delta / (THRESHOLD * 1.5)), 1));
}

const click_handler = e => e.stopPropagation();

function instance$E($$self, $$props, $$invalidate) {
	let $modals;
	validate_store(modals, "modals");
	component_subscribe($$self, modals, $$value => $$invalidate(7, $modals = $$value));
	const dispatch = createEventDispatcher();
	const THRESHOLD_RANGES = { x: [0, 100], y: [1, 99] };
	const START_POSITION = { x: 50, y: 0 };
	let { id } = $$props;
	let { ref = null } = $$props;
	let { size = "full" } = $$props; // small/medium/big/full
	let { swipe = [] } = $$props; // up down left right all
	let { title = "Закрити" } = $$props;
	let { open = null } = $$props;
	let { startPosition = START_POSITION } = $$props;
	let { blockBody = true } = $$props;
	let { withHeader = true } = $$props;
	let refHeader;
	let isBodyBlocked = false;

	let isAllowed = {
		up: true,
		down: false,
		left: true,
		right: true
	};

	function blockScroll(modal) {
		if (blockBody && active && !isBodyBlocked) {
			disableScroll(modal, { extraLock: size === "full" });
			isBodyBlocked = true;
			modal && (modal.scrollTop = 0);

			isAllowed = {
				up: true,
				down: false,
				left: true,
				right: true
			};
		} else if (blockBody && !active && isBodyBlocked) {
			enableScroll(modal, { extraLock: size === "full" });
			isBodyBlocked = false;
		}
	}

	async function onActiveChange(active) {
		if (active) {
			setDuration(ref, DURATION$1);
			setDuration(refHeader, DURATION$1);
			setTimeout(() => setDuration(ref, 0), DURATION$1);
			setTimeout(() => setDuration(refHeader, 0), DURATION$1);
			drawTransform(ref, 0, 0);
			drawTransform(refHeader, 0, 0);
			drawOpacity(ref, 0, 0);
			drawOpacity(refHeader, 0, 0);
			blockScroll(ref);
			await tick();
			dispatch("open");
		} else {
			blockScroll(ref);
			await tick();
			dispatch("close");
		}
	}

	function setActive(isActive) {
		if (open !== null) $$invalidate(13, open = isActive);

		modals.update(s => ({
			...s,
			[`modal-${id}`]: { open: isActive }
		}));
	}

	let xSwipe = 0;
	let ySwipe = 0;

	function addSwipe(el) {
		stopPropagationInRanges(el, THRESHOLD_RANGES, ({ x, y }) => {
			isAllowed = {
				up: y <= THRESHOLD_RANGES.y[0],
				down: y >= THRESHOLD_RANGES.y[1],
				left: x <= THRESHOLD_RANGES.x[0] || x >= THRESHOLD_RANGES.x[1],
				right: x <= THRESHOLD_RANGES.x[0] || x >= THRESHOLD_RANGES.x[1]
			};
		});

		new Swipe(el).run().onUp(isSwipe.up ? handleVerticalSwipe : null).onDown(isSwipe.down ? handleVerticalSwipe : null).onLeft(isSwipe.left ? handleHorizontalSwipe : null).onRight(isSwipe.right ? handleHorizontalSwipe : null).onTouchEnd(async () => {
			const shift = 50;

			if (xSwipe > THRESHOLD) {
				setDuration(el, DURATION$1);
				setDuration(refHeader, DURATION$1);
				setTimeout(() => setDuration(el, 0), DURATION$1);
				setTimeout(() => setDuration(refHeader, 0), DURATION$1);
				setActive(false);
				drawOpacity(el, xSwipe + shift, ySwipe);
				drawOpacity(refHeader, xSwipe + shift, ySwipe);
				drawTransform(el, xSwipe + shift, ySwipe);
				drawTransform(refHeader, xSwipe + shift, ySwipe);
				await delay(DURATION$1);
			} else if (xSwipe < -THRESHOLD) {
				setDuration(el, DURATION$1);
				setDuration(refHeader, DURATION$1);
				setTimeout(() => setDuration(el, 0), DURATION$1);
				setTimeout(() => setDuration(refHeader, 0), DURATION$1);
				setActive(false);
				drawOpacity(el, xSwipe - shift, ySwipe);
				drawOpacity(refHeader, xSwipe - shift, ySwipe);
				drawTransform(el, xSwipe - shift, ySwipe);
				drawTransform(refHeader, xSwipe - shift, ySwipe);
				await delay(DURATION$1);
			}

			if (ySwipe > THRESHOLD) {
				setDuration(el, DURATION$1);
				setDuration(refHeader, DURATION$1);
				setTimeout(() => setDuration(el, 0), DURATION$1);
				setTimeout(() => setDuration(refHeader, 0), DURATION$1);
				setActive(false);
				drawOpacity(el, xSwipe, ySwipe + shift);
				drawOpacity(refHeader, xSwipe, ySwipe + shift);
				drawTransform(el, xSwipe, ySwipe + shift);
				drawTransform(refHeader, xSwipe, ySwipe + shift);
				await delay(DURATION$1);
			} else if (ySwipe < -THRESHOLD) {
				setDuration(el, DURATION$1);
				setDuration(refHeader, DURATION$1);
				setTimeout(() => setDuration(el, 0), DURATION$1);
				setTimeout(() => setDuration(refHeader, 0), DURATION$1);
				setActive(false);
				drawOpacity(el, xSwipe, ySwipe - shift);
				drawOpacity(refHeader, xSwipe, ySwipe - shift);
				drawTransform(el, xSwipe, ySwipe - shift);
				drawTransform(refHeader, xSwipe, ySwipe - shift);
				await delay(DURATION$1);
			}

			if (xSwipe <= THRESHOLD && xSwipe >= -THRESHOLD && ySwipe <= THRESHOLD && ySwipe >= -THRESHOLD) {
				setDuration(el, DURATION$1);
				setDuration(refHeader, DURATION$1);
				setTimeout(() => setDuration(el, 0), DURATION$1);
				setTimeout(() => setDuration(refHeader, 0), DURATION$1);
				drawTransform(el, 0, 0);
				drawTransform(refHeader, 0, 0);
			} else {
				setStartPosition();
			}

			xSwipe = 0;
			ySwipe = 0;
			el && (el.style.opacity = null);
			refHeader && $$invalidate(5, refHeader.style.opacity = null, refHeader);
		});
	}

	function handleVerticalSwipe(yDown, yUp, evt, el) {
		const dir = yUp - yDown;
		if (!isAllowed.up && dir > 0 || !isAllowed.down && dir < 0) return;
		ySwipe = dir * SWIPE_SPEED;
		drawTransform(el, xSwipe, ySwipe);
		drawTransform(refHeader, xSwipe, ySwipe);
		drawOpacity(el, xSwipe, ySwipe);
		drawOpacity(refHeader, xSwipe, ySwipe);
	}

	function handleHorizontalSwipe(xDown, xUp, evt, el) {
		const dir = xUp - xDown;
		if (!isAllowed.left && dir > 0 || !isAllowed.right && dir < 0) return;
		xSwipe = dir * SWIPE_SPEED;
		drawTransform(el, xSwipe, ySwipe);
		drawTransform(refHeader, xSwipe, ySwipe);
		drawOpacity(el, xSwipe, ySwipe);
		drawOpacity(refHeader, xSwipe, ySwipe);
	}

	function setStartPosition() {
		drawTransform(ref, startPosition.x, startPosition.y);
		drawTransform(refHeader, startPosition.x, startPosition.y);
	}

	function appear(node, params) {
		if (!active) return;
		const existingTransform = getComputedStyle(node).transform.replace("none", "");
		const getScale = t => 0.9 + 0.1 * t;
		const getX = t => startPosition.x - startPosition.x * t;

		return {
			duration: DURATION$1,
			css: t => `opacity: ${t}; transform: matrix(${getScale(t)}, 0, 0, ${getScale(t)}, ${getX(t)}, 0)`
		};
	}

	function onCloseModal() {
		setDuration(ref, DURATION$1);
		setDuration(refHeader, DURATION$1);
		setTimeout(() => setDuration(ref, 0), DURATION$1);
		setTimeout(() => setDuration(refHeader, 0), DURATION$1);
		setStartPosition();
		drawOpacity(ref, startPosition.x * 2, startPosition.y);
		drawOpacity(refHeader, startPosition.x * 2, startPosition.y);
		setTimeout(() => setActive(false), DURATION$1);
	}

	const writable_props = [
		"id",
		"ref",
		"size",
		"swipe",
		"title",
		"open",
		"startPosition",
		"blockBody",
		"withHeader"
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Modal> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Modal", $$slots, ['header','default']);

	function button_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			refHeader = $$value;
			$$invalidate(5, refHeader);
		});
	}

	const func = () => $modals[`modal-${id}`];

	function div1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			ref = $$value;
			$$invalidate(0, ref);
		});
	}

	$$self.$set = $$props => {
		if ("id" in $$props) $$invalidate(1, id = $$props.id);
		if ("ref" in $$props) $$invalidate(0, ref = $$props.ref);
		if ("size" in $$props) $$invalidate(2, size = $$props.size);
		if ("swipe" in $$props) $$invalidate(14, swipe = $$props.swipe);
		if ("title" in $$props) $$invalidate(3, title = $$props.title);
		if ("open" in $$props) $$invalidate(13, open = $$props.open);
		if ("startPosition" in $$props) $$invalidate(15, startPosition = $$props.startPosition);
		if ("blockBody" in $$props) $$invalidate(16, blockBody = $$props.blockBody);
		if ("withHeader" in $$props) $$invalidate(4, withHeader = $$props.withHeader);
		if ("$$scope" in $$props) $$invalidate(21, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		tick,
		fly,
		Swipe,
		safeGet,
		classnames,
		delay,
		bodyScroll,
		stopPropagationInRanges,
		modals,
		Portal,
		Br,
		Icon,
		dispatch,
		DURATION: DURATION$1,
		THRESHOLD,
		SWIPE_SPEED,
		THRESHOLD_RANGES,
		START_POSITION,
		id,
		ref,
		size,
		swipe,
		title,
		open,
		startPosition,
		blockBody,
		withHeader,
		refHeader,
		isBodyBlocked,
		isAllowed,
		blockScroll,
		onActiveChange,
		setActive,
		xSwipe,
		ySwipe,
		addSwipe,
		handleVerticalSwipe,
		handleHorizontalSwipe,
		setStartPosition,
		drawTransform,
		setDuration,
		drawOpacity,
		appear,
		onCloseModal,
		isSwipe,
		scrollY,
		active,
		$modals,
		classProp
	});

	$$self.$inject_state = $$props => {
		if ("id" in $$props) $$invalidate(1, id = $$props.id);
		if ("ref" in $$props) $$invalidate(0, ref = $$props.ref);
		if ("size" in $$props) $$invalidate(2, size = $$props.size);
		if ("swipe" in $$props) $$invalidate(14, swipe = $$props.swipe);
		if ("title" in $$props) $$invalidate(3, title = $$props.title);
		if ("open" in $$props) $$invalidate(13, open = $$props.open);
		if ("startPosition" in $$props) $$invalidate(15, startPosition = $$props.startPosition);
		if ("blockBody" in $$props) $$invalidate(16, blockBody = $$props.blockBody);
		if ("withHeader" in $$props) $$invalidate(4, withHeader = $$props.withHeader);
		if ("refHeader" in $$props) $$invalidate(5, refHeader = $$props.refHeader);
		if ("isBodyBlocked" in $$props) isBodyBlocked = $$props.isBodyBlocked;
		if ("isAllowed" in $$props) isAllowed = $$props.isAllowed;
		if ("xSwipe" in $$props) xSwipe = $$props.xSwipe;
		if ("ySwipe" in $$props) ySwipe = $$props.ySwipe;
		if ("isSwipe" in $$props) isSwipe = $$props.isSwipe;
		if ("scrollY" in $$props) scrollY = $$props.scrollY;
		if ("active" in $$props) $$invalidate(6, active = $$props.active);
		if ("classProp" in $$props) $$invalidate(8, classProp = $$props.classProp);
	};

	let isSwipe;
	let scrollY;
	let active;
	let classProp;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*swipe*/ 16384) {
			 isSwipe = {
				up: safeGet(() => swipe.includes("up") || swipe.includes("all")),
				down: safeGet(() => swipe.includes("down") || swipe.includes("all")),
				left: safeGet(() => swipe.includes("left") || swipe.includes("all")),
				right: safeGet(() => swipe.includes("right") || swipe.includes("all"))
			};
		}

		if ($$self.$$.dirty[0] & /*ref*/ 1) {
			 scrollY = ref && ref.scrollTop;
		}

		if ($$self.$$.dirty[0] & /*open, $modals, id*/ 8322) {
			 $$invalidate(6, active = safeGet(() => open !== null ? open : $modals[`modal-${id}`].open, null));
		}

		if ($$self.$$.dirty[0] & /*size, active*/ 68) {
			 $$invalidate(8, classProp = classnames("modal", size, { active }));
		}

		if ($$self.$$.dirty[0] & /*active*/ 64) {
			 onActiveChange(active);
		}

		if ($$self.$$.dirty[0] & /*ref*/ 1) {
			 blockScroll(ref);
		}
	};

	return [
		ref,
		id,
		size,
		title,
		withHeader,
		refHeader,
		active,
		$modals,
		classProp,
		setActive,
		addSwipe,
		appear,
		onCloseModal,
		open,
		swipe,
		startPosition,
		blockBody,
		$$slots,
		button_binding,
		func,
		div1_binding,
		$$scope
	];
}

class Modal extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document.getElementById("svelte-48jsm1-style")) add_css$5();

		init(
			this,
			options,
			instance$E,
			create_fragment$E,
			safe_not_equal,
			{
				id: 1,
				ref: 0,
				size: 2,
				swipe: 14,
				title: 3,
				open: 13,
				startPosition: 15,
				blockBody: 16,
				withHeader: 4
			},
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Modal",
			options,
			id: create_fragment$E.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*id*/ ctx[1] === undefined && !("id" in props)) {
			console.warn("<Modal> was created without expected prop 'id'");
		}
	}

	get id() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ref() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ref(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get swipe() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set swipe(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get title() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get open() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set open(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get startPosition() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set startPosition(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get blockBody() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set blockBody(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get withHeader() {
		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set withHeader(value) {
		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/Square.svelte generated by Svelte v3.24.0 */

const file$F = "src/components/Square.svelte";

function add_css$6() {
	var style = element("style");
	style.id = "svelte-i76mlm-style";
	style.textContent = "section.svelte-i76mlm{position:relative;width:100%;overflow:hidden;-webkit-transform:translateZ(0);transform:translateZ(0)}section.svelte-i76mlm:after{content:\"\";display:block;padding-top:100%}div.svelte-i76mlm{position:absolute;top:0;left:0;right:0;bottom:0;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU3F1YXJlLnN2ZWx0ZSIsInNvdXJjZXMiOlsiU3F1YXJlLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0PlxuICAgIGV4cG9ydCBsZXQgc3R5bGUgPSB1bmRlZmluZWRcbjwvc2NyaXB0PiAgXG5cbjxzZWN0aW9uIHtzdHlsZX0gY2xhc3M9e2BzcXVhcmUgJHskJHByb3BzLmNsYXNzIHx8ICcnfWB9PlxuICAgIDxkaXY+XG4gICAgICAgIDxzbG90Pjwvc2xvdD5cbiAgICA8L2Rpdj5cbjwvc2VjdGlvbj5cblxuPHN0eWxlPlxuc2VjdGlvbiB7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVooMCk7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVooMCk7XG59XG5cbnNlY3Rpb246YWZ0ZXIge1xuICAgIGNvbnRlbnQ6IFwiXCI7XG4gICAgZGlzcGxheTogYmxvY2s7XG4gICAgcGFkZGluZy10b3A6IDEwMCU7XG59XG5cbmRpdiB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHRvcDogMDtcbiAgICBsZWZ0OiAwO1xuICAgIHJpZ2h0OiAwO1xuICAgIGJvdHRvbTogMDtcbiAgICBkaXNwbGF5OiAtd2Via2l0LWJveDtcbiAgICBkaXNwbGF5OiAtbXMtZmxleGJveDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIC13ZWJraXQtYm94LW9yaWVudDogdmVydGljYWw7XG4gICAgLXdlYmtpdC1ib3gtZGlyZWN0aW9uOiBub3JtYWw7XG4gICAgICAgIC1tcy1mbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbn08L3N0eWxlPlxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQVdBLE9BQU8sY0FBQyxDQUFDLEFBQ0wsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsS0FBSyxDQUFFLElBQUksQ0FDWCxRQUFRLENBQUUsTUFBTSxDQUNoQixpQkFBaUIsQ0FBRSxXQUFXLENBQUMsQ0FBQyxDQUN4QixTQUFTLENBQUUsV0FBVyxDQUFDLENBQUMsQUFDcEMsQ0FBQyxBQUVELHFCQUFPLE1BQU0sQUFBQyxDQUFDLEFBQ1gsT0FBTyxDQUFFLEVBQUUsQ0FDWCxPQUFPLENBQUUsS0FBSyxDQUNkLFdBQVcsQ0FBRSxJQUFJLEFBQ3JCLENBQUMsQUFFRCxHQUFHLGNBQUMsQ0FBQyxBQUNELFFBQVEsQ0FBRSxRQUFRLENBQ2xCLEdBQUcsQ0FBRSxDQUFDLENBQ04sSUFBSSxDQUFFLENBQUMsQ0FDUCxLQUFLLENBQUUsQ0FBQyxDQUNSLE1BQU0sQ0FBRSxDQUFDLENBQ1QsT0FBTyxDQUFFLFdBQVcsQ0FDcEIsT0FBTyxDQUFFLFdBQVcsQ0FDcEIsT0FBTyxDQUFFLElBQUksQ0FDYixrQkFBa0IsQ0FBRSxRQUFRLENBQzVCLHFCQUFxQixDQUFFLE1BQU0sQ0FDekIsa0JBQWtCLENBQUUsTUFBTSxDQUN0QixjQUFjLENBQUUsTUFBTSxBQUNsQyxDQUFDIn0= */";
	append_dev(document.head, style);
}

function create_fragment$F(ctx) {
	let section;
	let div;
	let section_class_value;
	let current;
	const default_slot_template = /*$$slots*/ ctx[3].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

	const block = {
		c: function create() {
			section = element("section");
			div = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { style: true, class: true });
			var section_nodes = children(section);
			div = claim_element(section_nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach_dev);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "svelte-i76mlm");
			add_location(div, file$F, 5, 4, 117);
			attr_dev(section, "style", /*style*/ ctx[0]);
			attr_dev(section, "class", section_class_value = "" + (null_to_empty(`square ${/*$$props*/ ctx[1].class || ""}`) + " svelte-i76mlm"));
			add_location(section, file$F, 4, 0, 55);
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			append_dev(section, div);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 4) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[2], dirty, null, null);
				}
			}

			if (!current || dirty & /*style*/ 1) {
				attr_dev(section, "style", /*style*/ ctx[0]);
			}

			if (!current || dirty & /*$$props*/ 2 && section_class_value !== (section_class_value = "" + (null_to_empty(`square ${/*$$props*/ ctx[1].class || ""}`) + " svelte-i76mlm"))) {
				attr_dev(section, "class", section_class_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$F.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$F($$self, $$props, $$invalidate) {
	let { style = undefined } = $$props;
	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Square", $$slots, ['default']);

	$$self.$set = $$new_props => {
		$$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("style" in $$new_props) $$invalidate(0, style = $$new_props.style);
		if ("$$scope" in $$new_props) $$invalidate(2, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({ style });

	$$self.$inject_state = $$new_props => {
		$$invalidate(1, $$props = assign(assign({}, $$props), $$new_props));
		if ("style" in $$props) $$invalidate(0, style = $$new_props.style);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);
	return [style, $$props, $$scope, $$slots];
}

class Square extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document.getElementById("svelte-i76mlm-style")) add_css$6();
		init(this, options, instance$F, create_fragment$F, safe_not_equal, { style: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Square",
			options,
			id: create_fragment$F.name
		});
	}

	get style() {
		throw new Error("<Square>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<Square>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/Picture.svelte generated by Svelte v3.24.0 */
const file$G = "src/components/Picture.svelte";

function add_css$7() {
	var style = element("style");
	style.id = "svelte-e9w1rq-style";
	style.textContent = ".picture.svelte-e9w1rq.svelte-e9w1rq{position:relative;-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-item-align:stretch;align-self:stretch;display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-webkit-box-align:stretch;-ms-flex-align:stretch;align-items:stretch;-webkit-box-pack:stretch;-ms-flex-pack:stretch;justify-content:stretch;background-color:rgba(var(--theme-bg-color-opposite), .04)}.picture.svelte-e9w1rq .pic.svelte-e9w1rq{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;overflow:hidden;-ms-flex-item-align:stretch;align-self:stretch;-o-object-position:center;object-position:center;-webkit-transition:opacity .5s ease-in;transition:opacity .5s ease-in}.picture.svelte-e9w1rq .pic-2x.svelte-e9w1rq{position:absolute;top:0;left:0;width:100%;height:100%}.picture.cover.svelte-e9w1rq .pic.svelte-e9w1rq{-o-object-fit:cover;object-fit:cover}.picture.contain.svelte-e9w1rq .pic.svelte-e9w1rq{-o-object-fit:contain;object-fit:contain}.picture.isErrorSmall.svelte-e9w1rq .pic-1x.svelte-e9w1rq,.picture.isErrorBig.svelte-e9w1rq .pic-2x.svelte-e9w1rq,.picture.loadingSrcSmall.svelte-e9w1rq .pic-1x.svelte-e9w1rq,.picture.loadingSrcBig.svelte-e9w1rq .pic-2x.svelte-e9w1rq{opacity:0}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUGljdHVyZS5zdmVsdGUiLCJzb3VyY2VzIjpbIlBpY3R1cmUuc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgY3JlYXRlRXZlbnREaXNwYXRjaGVyIH0gZnJvbSAnc3ZlbHRlJ1xuICAgIGltcG9ydCB7IGNsYXNzbmFtZXMgfSBmcm9tICdAdXRpbHMnXG5cbiAgICBjb25zdCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpXG5cbiAgICBleHBvcnQgbGV0IHNyY1xuICAgIGV4cG9ydCBsZXQgYWx0XG4gICAgZXhwb3J0IGxldCBzaXplID0gJ2NvdmVyJ1xuICAgIGV4cG9ydCBsZXQgc3JjQmlnID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCBpZCA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgd2lkdGggPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IGhlaWdodCA9IHVuZGVmaW5lZFxuXG4gICAgbGV0IGxvYWRpbmdTcmNTbWFsbCA9IHRydWVcbiAgICBsZXQgbG9hZGluZ1NyY0JpZyA9IHRydWVcbiAgICBsZXQgaXNFcnJvclNtYWxsID0gZmFsc2VcbiAgICBsZXQgaXNFcnJvckJpZyA9IGZhbHNlXG5cbiAgICAkOiB3cmFwQ2xhc3NQcm9wID0gY2xhc3NuYW1lcygncGljdHVyZScsICQkcHJvcHMuY2xhc3MsIHNpemUsIHsgbG9hZGluZ1NyY1NtYWxsLCBsb2FkaW5nU3JjQmlnLCBpc0Vycm9yU21hbGwsIGlzRXJyb3JCaWcgfSlcblxuICAgIGZ1bmN0aW9uIGltZ1NlcnZpY2Uobm9kZSwgcG9zdEZpeCkge1xuICAgICAgICBpZiAobm9kZS5jb21wbGV0ZSkge1xuICAgICAgICAgICAgb25Mb2FkKG5vZGUsIHBvc3RGaXgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub2RlLm9ubG9hZCA9IG9uTG9hZC5iaW5kKG51bGwsIG5vZGUsIHBvc3RGaXgpXG4gICAgICAgICAgICBub2RlLm9uZXJyb3IgPSBvbkVycm9yLmJpbmQobnVsbCwgbm9kZSwgcG9zdEZpeClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uTG9hZChub2RlLCBwb3N0Rml4KSB7XG4gICAgICAgIGNoYW5nZUxvYWRpbmcocG9zdEZpeCwgZmFsc2UpXG4gICAgICAgIGNoYW5nZUVycm9yKHBvc3RGaXgsIGZhbHNlKVxuICAgICAgICBkaXNwYXRjaChgbG9hZCR7cG9zdEZpeH1gLCBub2RlKVxuXG4gICAgICAgIGlmICghc3JjQmlnIHx8ICFsb2FkaW5nU3JjQmlnKSB7XG4gICAgICAgICAgICBkaXNwYXRjaCgnbG9hZCcsIG5vZGUpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkVycm9yKG5vZGUsIHBvc3RGaXgpIHtcbiAgICAgICAgY2hhbmdlTG9hZGluZyhwb3N0Rml4LCBmYWxzZSlcbiAgICAgICAgY2hhbmdlRXJyb3IocG9zdEZpeCwgdHJ1ZSlcbiAgICAgICAgZGlzcGF0Y2goYGVycm9yJHtwb3N0Rml4fWAsIG5vZGUpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hhbmdlTG9hZGluZyh0eXBlLCBpc0xvYWRpbmcpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdTbWFsbCc6XG4gICAgICAgICAgICAgICAgbG9hZGluZ1NyY1NtYWxsID0gaXNMb2FkaW5nXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIGNhc2UgJ0JpZyc6XG4gICAgICAgICAgICAgICAgbG9hZGluZ1NyY0JpZyA9IGlzTG9hZGluZ1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGFuZ2VFcnJvcih0eXBlLCBpc0Vycm9yKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnU21hbGwnOlxuICAgICAgICAgICAgICAgIGlzRXJyb3JTbWFsbCA9IGlzRXJyb3JcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgY2FzZSAnQmlnJzpcbiAgICAgICAgICAgICAgICBpc0Vycm9yQmlnID0gaXNFcnJvclxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICB9XG5cbjwvc2NyaXB0PlxuXG48ZmlndXJlIGNsYXNzPXt3cmFwQ2xhc3NQcm9wfT5cbiAgICB7I2lmIHNyY31cbiAgICAgICAgPGltZ1xuICAgICAgICAgICAgdXNlOmltZ1NlcnZpY2U9eydTbWFsbCd9XG4gICAgICAgICAgICB7aWR9XG4gICAgICAgICAgICB7YWx0fVxuICAgICAgICAgICAge3NyY31cbiAgICAgICAgICAgIHt3aWR0aH1cbiAgICAgICAgICAgIHtoZWlnaHR9XG4gICAgICAgICAgICBjbGFzcz1cInBpYyBwaWMtMXhcIlxuICAgICAgICAvPlxuICAgIHsvaWZ9XG5cbiAgICB7I2lmIHNyY0JpZyAmJiAhbG9hZGluZ1NyY1NtYWxsfVxuICAgICAgICA8aW1nXG4gICAgICAgICAgICB1c2U6aW1nU2VydmljZT17J0JpZyd9XG4gICAgICAgICAgICB7YWx0fVxuICAgICAgICAgICAge3dpZHRofVxuICAgICAgICAgICAge2hlaWdodH1cbiAgICAgICAgICAgIHNyYz17c3JjQmlnfVxuICAgICAgICAgICAgY2xhc3M9XCJwaWMgcGljLTJ4XCJcbiAgICAgICAgLz5cbiAgICB7L2lmfVxuXG4gICAgPGZpZ2NhcHRpb24+XG4gICAgICAgIDxzbG90Pjwvc2xvdD5cbiAgICA8L2ZpZ2NhcHRpb24+XG48L2ZpZ3VyZT5cblxuPHN0eWxlPlxuLnBpY3R1cmUge1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAtd2Via2l0LWJveC1mbGV4OiAxO1xuICAgICAgICAtbXMtZmxleC1wb3NpdGl2ZTogMTtcbiAgICAgICAgICAgIGZsZXgtZ3JvdzogMTtcbiAgICAtbXMtZmxleC1pdGVtLWFsaWduOiBzdHJldGNoO1xuICAgICAgICBhbGlnbi1zZWxmOiBzdHJldGNoO1xuICAgIGRpc3BsYXk6IC13ZWJraXQtaW5saW5lLWJveDtcbiAgICBkaXNwbGF5OiAtbXMtaW5saW5lLWZsZXhib3g7XG4gICAgZGlzcGxheTogaW5saW5lLWZsZXg7XG4gICAgLXdlYmtpdC1ib3gtb3JpZW50OiB2ZXJ0aWNhbDtcbiAgICAtd2Via2l0LWJveC1kaXJlY3Rpb246IG5vcm1hbDtcbiAgICAgICAgLW1zLWZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIC13ZWJraXQtYm94LWFsaWduOiBzdHJldGNoO1xuICAgICAgICAtbXMtZmxleC1hbGlnbjogc3RyZXRjaDtcbiAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBzdHJldGNoO1xuICAgIC13ZWJraXQtYm94LXBhY2s6IHN0cmV0Y2g7XG4gICAgICAgIC1tcy1mbGV4LXBhY2s6IHN0cmV0Y2g7XG4gICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHN0cmV0Y2g7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSh2YXIoLS10aGVtZS1iZy1jb2xvci1vcHBvc2l0ZSksIC4wNCk7XG59XG5cbi5waWN0dXJlIC5waWMge1xuICAgIC13ZWJraXQtYm94LWZsZXg6IDE7XG4gICAgICAgIC1tcy1mbGV4LXBvc2l0aXZlOiAxO1xuICAgICAgICAgICAgZmxleC1ncm93OiAxO1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgLW1zLWZsZXgtaXRlbS1hbGlnbjogc3RyZXRjaDtcbiAgICAgICAgYWxpZ24tc2VsZjogc3RyZXRjaDtcbiAgICAtby1vYmplY3QtcG9zaXRpb246IGNlbnRlcjtcbiAgICAgICBvYmplY3QtcG9zaXRpb246IGNlbnRlcjtcbiAgICAtd2Via2l0LXRyYW5zaXRpb246IG9wYWNpdHkgLjVzIGVhc2UtaW47XG4gICAgdHJhbnNpdGlvbjogb3BhY2l0eSAuNXMgZWFzZS1pbjtcbn1cblxuLnBpY3R1cmUgLnBpYy0yeCB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHRvcDogMDtcbiAgICBsZWZ0OiAwO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogMTAwJTtcbn1cblxuLnBpY3R1cmUuY292ZXIgLnBpYyB7XG4gICAgLW8tb2JqZWN0LWZpdDogY292ZXI7XG4gICAgICAgb2JqZWN0LWZpdDogY292ZXI7XG59XG5cbi5waWN0dXJlLmNvbnRhaW4gLnBpYyB7XG4gICAgLW8tb2JqZWN0LWZpdDogY29udGFpbjtcbiAgICAgICBvYmplY3QtZml0OiBjb250YWluO1xufVxuXG4ucGljdHVyZS5pc0Vycm9yU21hbGwgLnBpYy0xeCxcbi5waWN0dXJlLmlzRXJyb3JCaWcgLnBpYy0yeCxcbi5waWN0dXJlLmxvYWRpbmdTcmNTbWFsbCAucGljLTF4LFxuLnBpY3R1cmUubG9hZGluZ1NyY0JpZyAucGljLTJ4IHtcbiAgICBvcGFjaXR5OiAwO1xufTwvc3R5bGU+XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBb0dBLFFBQVEsNEJBQUMsQ0FBQyxBQUNOLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLGdCQUFnQixDQUFFLENBQUMsQ0FDZixpQkFBaUIsQ0FBRSxDQUFDLENBQ2hCLFNBQVMsQ0FBRSxDQUFDLENBQ3BCLG1CQUFtQixDQUFFLE9BQU8sQ0FDeEIsVUFBVSxDQUFFLE9BQU8sQ0FDdkIsT0FBTyxDQUFFLGtCQUFrQixDQUMzQixPQUFPLENBQUUsa0JBQWtCLENBQzNCLE9BQU8sQ0FBRSxXQUFXLENBQ3BCLGtCQUFrQixDQUFFLFFBQVEsQ0FDNUIscUJBQXFCLENBQUUsTUFBTSxDQUN6QixrQkFBa0IsQ0FBRSxNQUFNLENBQ3RCLGNBQWMsQ0FBRSxNQUFNLENBQzlCLGlCQUFpQixDQUFFLE9BQU8sQ0FDdEIsY0FBYyxDQUFFLE9BQU8sQ0FDbkIsV0FBVyxDQUFFLE9BQU8sQ0FDNUIsZ0JBQWdCLENBQUUsT0FBTyxDQUNyQixhQUFhLENBQUUsT0FBTyxDQUNsQixlQUFlLENBQUUsT0FBTyxDQUNoQyxnQkFBZ0IsQ0FBRSxLQUFLLElBQUkseUJBQXlCLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxBQUMvRCxDQUFDLEFBRUQsc0JBQVEsQ0FBQyxJQUFJLGNBQUMsQ0FBQyxBQUNYLGdCQUFnQixDQUFFLENBQUMsQ0FDZixpQkFBaUIsQ0FBRSxDQUFDLENBQ2hCLFNBQVMsQ0FBRSxDQUFDLENBQ3BCLFFBQVEsQ0FBRSxNQUFNLENBQ2hCLG1CQUFtQixDQUFFLE9BQU8sQ0FDeEIsVUFBVSxDQUFFLE9BQU8sQ0FDdkIsa0JBQWtCLENBQUUsTUFBTSxDQUN2QixlQUFlLENBQUUsTUFBTSxDQUMxQixrQkFBa0IsQ0FBRSxPQUFPLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FDdkMsVUFBVSxDQUFFLE9BQU8sQ0FBQyxHQUFHLENBQUMsT0FBTyxBQUNuQyxDQUFDLEFBRUQsc0JBQVEsQ0FBQyxPQUFPLGNBQUMsQ0FBQyxBQUNkLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLEdBQUcsQ0FBRSxDQUFDLENBQ04sSUFBSSxDQUFFLENBQUMsQ0FDUCxLQUFLLENBQUUsSUFBSSxDQUNYLE1BQU0sQ0FBRSxJQUFJLEFBQ2hCLENBQUMsQUFFRCxRQUFRLG9CQUFNLENBQUMsSUFBSSxjQUFDLENBQUMsQUFDakIsYUFBYSxDQUFFLEtBQUssQ0FDakIsVUFBVSxDQUFFLEtBQUssQUFDeEIsQ0FBQyxBQUVELFFBQVEsc0JBQVEsQ0FBQyxJQUFJLGNBQUMsQ0FBQyxBQUNuQixhQUFhLENBQUUsT0FBTyxDQUNuQixVQUFVLENBQUUsT0FBTyxBQUMxQixDQUFDLEFBRUQsUUFBUSwyQkFBYSxDQUFDLHFCQUFPLENBQzdCLFFBQVEseUJBQVcsQ0FBQyxxQkFBTyxDQUMzQixRQUFRLDhCQUFnQixDQUFDLHFCQUFPLENBQ2hDLFFBQVEsNEJBQWMsQ0FBQyxPQUFPLGNBQUMsQ0FBQyxBQUM1QixPQUFPLENBQUUsQ0FBQyxBQUNkLENBQUMifQ== */";
	append_dev(document.head, style);
}

// (72:4) {#if src}
function create_if_block_1$1(ctx) {
	let img;
	let img_src_value;
	let imgService_action;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			img = element("img");
			this.h();
		},
		l: function claim(nodes) {
			img = claim_element(nodes, "IMG", {
				id: true,
				alt: true,
				src: true,
				width: true,
				height: true,
				class: true
			});

			this.h();
		},
		h: function hydrate() {
			attr_dev(img, "id", /*id*/ ctx[3]);
			attr_dev(img, "alt", /*alt*/ ctx[1]);
			if (img.src !== (img_src_value = /*src*/ ctx[0])) attr_dev(img, "src", img_src_value);
			attr_dev(img, "width", /*width*/ ctx[4]);
			attr_dev(img, "height", /*height*/ ctx[5]);
			attr_dev(img, "class", "pic pic-1x svelte-e9w1rq");
			add_location(img, file$G, 72, 8, 1841);
		},
		m: function mount(target, anchor) {
			insert_dev(target, img, anchor);

			if (!mounted) {
				dispose = action_destroyer(imgService_action = /*imgService*/ ctx[8].call(null, img, "Small"));
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*id*/ 8) {
				attr_dev(img, "id", /*id*/ ctx[3]);
			}

			if (dirty & /*alt*/ 2) {
				attr_dev(img, "alt", /*alt*/ ctx[1]);
			}

			if (dirty & /*src*/ 1 && img.src !== (img_src_value = /*src*/ ctx[0])) {
				attr_dev(img, "src", img_src_value);
			}

			if (dirty & /*width*/ 16) {
				attr_dev(img, "width", /*width*/ ctx[4]);
			}

			if (dirty & /*height*/ 32) {
				attr_dev(img, "height", /*height*/ ctx[5]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(img);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$1.name,
		type: "if",
		source: "(72:4) {#if src}",
		ctx
	});

	return block;
}

// (84:4) {#if srcBig && !loadingSrcSmall}
function create_if_block$3(ctx) {
	let img;
	let img_src_value;
	let imgService_action;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			img = element("img");
			this.h();
		},
		l: function claim(nodes) {
			img = claim_element(nodes, "IMG", {
				alt: true,
				width: true,
				height: true,
				src: true,
				class: true
			});

			this.h();
		},
		h: function hydrate() {
			attr_dev(img, "alt", /*alt*/ ctx[1]);
			attr_dev(img, "width", /*width*/ ctx[4]);
			attr_dev(img, "height", /*height*/ ctx[5]);
			if (img.src !== (img_src_value = /*srcBig*/ ctx[2])) attr_dev(img, "src", img_src_value);
			attr_dev(img, "class", "pic pic-2x svelte-e9w1rq");
			add_location(img, file$G, 84, 8, 2075);
		},
		m: function mount(target, anchor) {
			insert_dev(target, img, anchor);

			if (!mounted) {
				dispose = action_destroyer(imgService_action = /*imgService*/ ctx[8].call(null, img, "Big"));
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*alt*/ 2) {
				attr_dev(img, "alt", /*alt*/ ctx[1]);
			}

			if (dirty & /*width*/ 16) {
				attr_dev(img, "width", /*width*/ ctx[4]);
			}

			if (dirty & /*height*/ 32) {
				attr_dev(img, "height", /*height*/ ctx[5]);
			}

			if (dirty & /*srcBig*/ 4 && img.src !== (img_src_value = /*srcBig*/ ctx[2])) {
				attr_dev(img, "src", img_src_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(img);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$3.name,
		type: "if",
		source: "(84:4) {#if srcBig && !loadingSrcSmall}",
		ctx
	});

	return block;
}

function create_fragment$G(ctx) {
	let figure;
	let t0;
	let t1;
	let figcaption;
	let figure_class_value;
	let current;
	let if_block0 = /*src*/ ctx[0] && create_if_block_1$1(ctx);
	let if_block1 = /*srcBig*/ ctx[2] && !/*loadingSrcSmall*/ ctx[6] && create_if_block$3(ctx);
	const default_slot_template = /*$$slots*/ ctx[11].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[10], null);

	const block = {
		c: function create() {
			figure = element("figure");
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			figcaption = element("figcaption");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			figure = claim_element(nodes, "FIGURE", { class: true });
			var figure_nodes = children(figure);
			if (if_block0) if_block0.l(figure_nodes);
			t0 = claim_space(figure_nodes);
			if (if_block1) if_block1.l(figure_nodes);
			t1 = claim_space(figure_nodes);
			figcaption = claim_element(figure_nodes, "FIGCAPTION", {});
			var figcaption_nodes = children(figcaption);
			if (default_slot) default_slot.l(figcaption_nodes);
			figcaption_nodes.forEach(detach_dev);
			figure_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(figcaption, file$G, 94, 4, 2256);
			attr_dev(figure, "class", figure_class_value = "" + (null_to_empty(/*wrapClassProp*/ ctx[7]) + " svelte-e9w1rq"));
			add_location(figure, file$G, 70, 0, 1788);
		},
		m: function mount(target, anchor) {
			insert_dev(target, figure, anchor);
			if (if_block0) if_block0.m(figure, null);
			append_dev(figure, t0);
			if (if_block1) if_block1.m(figure, null);
			append_dev(figure, t1);
			append_dev(figure, figcaption);

			if (default_slot) {
				default_slot.m(figcaption, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*src*/ ctx[0]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_1$1(ctx);
					if_block0.c();
					if_block0.m(figure, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*srcBig*/ ctx[2] && !/*loadingSrcSmall*/ ctx[6]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block$3(ctx);
					if_block1.c();
					if_block1.m(figure, t1);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 1024) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[10], dirty, null, null);
				}
			}

			if (!current || dirty & /*wrapClassProp*/ 128 && figure_class_value !== (figure_class_value = "" + (null_to_empty(/*wrapClassProp*/ ctx[7]) + " svelte-e9w1rq"))) {
				attr_dev(figure, "class", figure_class_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(figure);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$G.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$G($$self, $$props, $$invalidate) {
	const dispatch = createEventDispatcher();
	let { src } = $$props;
	let { alt } = $$props;
	let { size = "cover" } = $$props;
	let { srcBig = undefined } = $$props;
	let { id = undefined } = $$props;
	let { width = undefined } = $$props;
	let { height = undefined } = $$props;
	let loadingSrcSmall = true;
	let loadingSrcBig = true;
	let isErrorSmall = false;
	let isErrorBig = false;

	function imgService(node, postFix) {
		if (node.complete) {
			onLoad(node, postFix);
		} else {
			node.onload = onLoad.bind(null, node, postFix);
			node.onerror = onError.bind(null, node, postFix);
		}
	}

	function onLoad(node, postFix) {
		changeLoading(postFix, false);
		changeError(postFix, false);
		dispatch(`load${postFix}`, node);

		if (!srcBig || !loadingSrcBig) {
			dispatch("load", node);
		}
	}

	function onError(node, postFix) {
		changeLoading(postFix, false);
		changeError(postFix, true);
		dispatch(`error${postFix}`, node);
	}

	function changeLoading(type, isLoading) {
		switch (type) {
			case "Small":
				$$invalidate(6, loadingSrcSmall = isLoading);
				break;
			case "Big":
				$$invalidate(12, loadingSrcBig = isLoading);
				break;
		}
	}

	function changeError(type, isError) {
		switch (type) {
			case "Small":
				$$invalidate(13, isErrorSmall = isError);
				break;
			case "Big":
				$$invalidate(14, isErrorBig = isError);
				break;
		}
	}

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Picture", $$slots, ['default']);

	$$self.$set = $$new_props => {
		$$invalidate(20, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("src" in $$new_props) $$invalidate(0, src = $$new_props.src);
		if ("alt" in $$new_props) $$invalidate(1, alt = $$new_props.alt);
		if ("size" in $$new_props) $$invalidate(9, size = $$new_props.size);
		if ("srcBig" in $$new_props) $$invalidate(2, srcBig = $$new_props.srcBig);
		if ("id" in $$new_props) $$invalidate(3, id = $$new_props.id);
		if ("width" in $$new_props) $$invalidate(4, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(5, height = $$new_props.height);
		if ("$$scope" in $$new_props) $$invalidate(10, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		classnames,
		dispatch,
		src,
		alt,
		size,
		srcBig,
		id,
		width,
		height,
		loadingSrcSmall,
		loadingSrcBig,
		isErrorSmall,
		isErrorBig,
		imgService,
		onLoad,
		onError,
		changeLoading,
		changeError,
		wrapClassProp
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(20, $$props = assign(assign({}, $$props), $$new_props));
		if ("src" in $$props) $$invalidate(0, src = $$new_props.src);
		if ("alt" in $$props) $$invalidate(1, alt = $$new_props.alt);
		if ("size" in $$props) $$invalidate(9, size = $$new_props.size);
		if ("srcBig" in $$props) $$invalidate(2, srcBig = $$new_props.srcBig);
		if ("id" in $$props) $$invalidate(3, id = $$new_props.id);
		if ("width" in $$props) $$invalidate(4, width = $$new_props.width);
		if ("height" in $$props) $$invalidate(5, height = $$new_props.height);
		if ("loadingSrcSmall" in $$props) $$invalidate(6, loadingSrcSmall = $$new_props.loadingSrcSmall);
		if ("loadingSrcBig" in $$props) $$invalidate(12, loadingSrcBig = $$new_props.loadingSrcBig);
		if ("isErrorSmall" in $$props) $$invalidate(13, isErrorSmall = $$new_props.isErrorSmall);
		if ("isErrorBig" in $$props) $$invalidate(14, isErrorBig = $$new_props.isErrorBig);
		if ("wrapClassProp" in $$props) $$invalidate(7, wrapClassProp = $$new_props.wrapClassProp);
	};

	let wrapClassProp;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(7, wrapClassProp = classnames("picture", $$props.class, size, {
			loadingSrcSmall,
			loadingSrcBig,
			isErrorSmall,
			isErrorBig
		}));
	};

	$$props = exclude_internal_props($$props);

	return [
		src,
		alt,
		srcBig,
		id,
		width,
		height,
		loadingSrcSmall,
		wrapClassProp,
		imgService,
		size,
		$$scope,
		$$slots
	];
}

class Picture extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document.getElementById("svelte-e9w1rq-style")) add_css$7();

		init(this, options, instance$G, create_fragment$G, safe_not_equal, {
			src: 0,
			alt: 1,
			size: 9,
			srcBig: 2,
			id: 3,
			width: 4,
			height: 5
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Picture",
			options,
			id: create_fragment$G.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*src*/ ctx[0] === undefined && !("src" in props)) {
			console.warn("<Picture> was created without expected prop 'src'");
		}

		if (/*alt*/ ctx[1] === undefined && !("alt" in props)) {
			console.warn("<Picture> was created without expected prop 'alt'");
		}
	}

	get src() {
		throw new Error("<Picture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set src(value) {
		throw new Error("<Picture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get alt() {
		throw new Error("<Picture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set alt(value) {
		throw new Error("<Picture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<Picture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<Picture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get srcBig() {
		throw new Error("<Picture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set srcBig(value) {
		throw new Error("<Picture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get id() {
		throw new Error("<Picture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<Picture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<Picture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<Picture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get height() {
		throw new Error("<Picture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set height(value) {
		throw new Error("<Picture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/Avatar.svelte generated by Svelte v3.24.0 */
const file$H = "src/components/Avatar.svelte";

function add_css$8() {
	var style = element("style");
	style.id = "svelte-z7tvoj-style";
	style.textContent = ".ava.svelte-z7tvoj{position:relative;-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;display:-webkit-box;display:-ms-flexbox;display:flex;border-radius:50%;overflow:hidden;-webkit-transform:translateZ(0);transform:translateZ(0)}.ava.small.svelte-z7tvoj{-webkit-box-flex:0;-ms-flex:none;flex:none;width:30px;height:30px}.ava.medium.svelte-z7tvoj{-webkit-box-flex:0;-ms-flex:none;flex:none;width:60px;height:60px}.ava.big.svelte-z7tvoj{-webkit-box-flex:0;-ms-flex:none;flex:none;width:130px;height:130px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQXZhdGFyLnN2ZWx0ZSIsInNvdXJjZXMiOlsiQXZhdGFyLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0PlxuICAgIGltcG9ydCB7IGNsYXNzbmFtZXMgfSBmcm9tICdAdXRpbHMnXG4gICAgaW1wb3J0IFBpY3R1cmUgZnJvbSAnLi9QaWN0dXJlLnN2ZWx0ZSdcblxuICAgIGV4cG9ydCBsZXQgc3JjXG4gICAgZXhwb3J0IGxldCBhbHRcbiAgICBleHBvcnQgbGV0IHNpemUgPSBudWxsIC8vIHNtYWxsfG1lZGl1bXxiaWdcbiAgICBleHBvcnQgbGV0IHNyY0JpZyA9IHVuZGVmaW5lZFxuXG4gICAgJDogY2xhc3NQcm9wID0gY2xhc3NuYW1lcygnYXZhJywgc2l6ZSwgJCRwcm9wcy5jbGFzcylcbjwvc2NyaXB0PlxuXG48ZGl2IGNsYXNzPXtjbGFzc1Byb3B9PlxuICAgIDxQaWN0dXJlIHtzcmN9IHtzcmNCaWd9IHthbHR9Lz5cbjwvZGl2PlxuXG48c3R5bGU+XG4uYXZhIHtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgLXdlYmtpdC1ib3gtZmxleDogMTtcbiAgICAgICAgLW1zLWZsZXgtcG9zaXRpdmU6IDE7XG4gICAgICAgICAgICBmbGV4LWdyb3c6IDE7XG4gICAgZGlzcGxheTogLXdlYmtpdC1ib3g7XG4gICAgZGlzcGxheTogLW1zLWZsZXhib3g7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBib3JkZXItcmFkaXVzOiA1MCU7XG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWigwKTtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWigwKTtcbn1cblxuLmF2YS5zbWFsbCB7XG4gICAgLXdlYmtpdC1ib3gtZmxleDogMDtcbiAgICAgICAgLW1zLWZsZXg6IG5vbmU7XG4gICAgICAgICAgICBmbGV4OiBub25lO1xuICAgIHdpZHRoOiAzMHB4O1xuICAgIGhlaWdodDogMzBweDtcbn1cbi5hdmEubWVkaXVtIHtcbiAgICAtd2Via2l0LWJveC1mbGV4OiAwO1xuICAgICAgICAtbXMtZmxleDogbm9uZTtcbiAgICAgICAgICAgIGZsZXg6IG5vbmU7XG4gICAgd2lkdGg6IDYwcHg7XG4gICAgaGVpZ2h0OiA2MHB4O1xufVxuLmF2YS5iaWcge1xuICAgIC13ZWJraXQtYm94LWZsZXg6IDA7XG4gICAgICAgIC1tcy1mbGV4OiBub25lO1xuICAgICAgICAgICAgZmxleDogbm9uZTtcbiAgICB3aWR0aDogMTMwcHg7XG4gICAgaGVpZ2h0OiAxMzBweDtcbn08L3N0eWxlPlxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQWlCQSxJQUFJLGNBQUMsQ0FBQyxBQUNGLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLGdCQUFnQixDQUFFLENBQUMsQ0FDZixpQkFBaUIsQ0FBRSxDQUFDLENBQ2hCLFNBQVMsQ0FBRSxDQUFDLENBQ3BCLE9BQU8sQ0FBRSxXQUFXLENBQ3BCLE9BQU8sQ0FBRSxXQUFXLENBQ3BCLE9BQU8sQ0FBRSxJQUFJLENBQ2IsYUFBYSxDQUFFLEdBQUcsQ0FDbEIsUUFBUSxDQUFFLE1BQU0sQ0FDaEIsaUJBQWlCLENBQUUsV0FBVyxDQUFDLENBQUMsQ0FDeEIsU0FBUyxDQUFFLFdBQVcsQ0FBQyxDQUFDLEFBQ3BDLENBQUMsQUFFRCxJQUFJLE1BQU0sY0FBQyxDQUFDLEFBQ1IsZ0JBQWdCLENBQUUsQ0FBQyxDQUNmLFFBQVEsQ0FBRSxJQUFJLENBQ1YsSUFBSSxDQUFFLElBQUksQ0FDbEIsS0FBSyxDQUFFLElBQUksQ0FDWCxNQUFNLENBQUUsSUFBSSxBQUNoQixDQUFDLEFBQ0QsSUFBSSxPQUFPLGNBQUMsQ0FBQyxBQUNULGdCQUFnQixDQUFFLENBQUMsQ0FDZixRQUFRLENBQUUsSUFBSSxDQUNWLElBQUksQ0FBRSxJQUFJLENBQ2xCLEtBQUssQ0FBRSxJQUFJLENBQ1gsTUFBTSxDQUFFLElBQUksQUFDaEIsQ0FBQyxBQUNELElBQUksSUFBSSxjQUFDLENBQUMsQUFDTixnQkFBZ0IsQ0FBRSxDQUFDLENBQ2YsUUFBUSxDQUFFLElBQUksQ0FDVixJQUFJLENBQUUsSUFBSSxDQUNsQixLQUFLLENBQUUsS0FBSyxDQUNaLE1BQU0sQ0FBRSxLQUFLLEFBQ2pCLENBQUMifQ== */";
	append_dev(document.head, style);
}

function create_fragment$H(ctx) {
	let div;
	let picture;
	let div_class_value;
	let current;

	picture = new Picture({
			props: {
				src: /*src*/ ctx[0],
				srcBig: /*srcBig*/ ctx[2],
				alt: /*alt*/ ctx[1]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div = element("div");
			create_component(picture.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			claim_component(picture.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", div_class_value = "" + (null_to_empty(/*classProp*/ ctx[3]) + " svelte-z7tvoj"));
			add_location(div, file$H, 12, 0, 282);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(picture, div, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const picture_changes = {};
			if (dirty & /*src*/ 1) picture_changes.src = /*src*/ ctx[0];
			if (dirty & /*srcBig*/ 4) picture_changes.srcBig = /*srcBig*/ ctx[2];
			if (dirty & /*alt*/ 2) picture_changes.alt = /*alt*/ ctx[1];
			picture.$set(picture_changes);

			if (!current || dirty & /*classProp*/ 8 && div_class_value !== (div_class_value = "" + (null_to_empty(/*classProp*/ ctx[3]) + " svelte-z7tvoj"))) {
				attr_dev(div, "class", div_class_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(picture.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(picture.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(picture);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$H.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$H($$self, $$props, $$invalidate) {
	let { src } = $$props;
	let { alt } = $$props;
	let { size = null } = $$props; // small|medium|big
	let { srcBig = undefined } = $$props;
	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Avatar", $$slots, []);

	$$self.$set = $$new_props => {
		$$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("src" in $$new_props) $$invalidate(0, src = $$new_props.src);
		if ("alt" in $$new_props) $$invalidate(1, alt = $$new_props.alt);
		if ("size" in $$new_props) $$invalidate(4, size = $$new_props.size);
		if ("srcBig" in $$new_props) $$invalidate(2, srcBig = $$new_props.srcBig);
	};

	$$self.$capture_state = () => ({
		classnames,
		Picture,
		src,
		alt,
		size,
		srcBig,
		classProp
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
		if ("src" in $$props) $$invalidate(0, src = $$new_props.src);
		if ("alt" in $$props) $$invalidate(1, alt = $$new_props.alt);
		if ("size" in $$props) $$invalidate(4, size = $$new_props.size);
		if ("srcBig" in $$props) $$invalidate(2, srcBig = $$new_props.srcBig);
		if ("classProp" in $$props) $$invalidate(3, classProp = $$new_props.classProp);
	};

	let classProp;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(3, classProp = classnames("ava", size, $$props.class));
	};

	$$props = exclude_internal_props($$props);
	return [src, alt, srcBig, classProp, size];
}

class Avatar extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document.getElementById("svelte-z7tvoj-style")) add_css$8();
		init(this, options, instance$H, create_fragment$H, safe_not_equal, { src: 0, alt: 1, size: 4, srcBig: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Avatar",
			options,
			id: create_fragment$H.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*src*/ ctx[0] === undefined && !("src" in props)) {
			console.warn("<Avatar> was created without expected prop 'src'");
		}

		if (/*alt*/ ctx[1] === undefined && !("alt" in props)) {
			console.warn("<Avatar> was created without expected prop 'alt'");
		}
	}

	get src() {
		throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set src(value) {
		throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get alt() {
		throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set alt(value) {
		throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get srcBig() {
		throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set srcBig(value) {
		throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/Button.svelte generated by Svelte v3.24.0 */

const { document: document_1$1 } = globals;
const file$I = "src/components/Button.svelte";

function add_css$9() {
	var style = element("style");
	style.id = "svelte-1hd9njw-style";
	style.textContent = ".btn.svelte-1hd9njw:not(.auto){width:100%;padding:5px 15px}.btn{-webkit-box-flex:0;-ms-flex:none;flex:none;cursor:pointer;max-width:100%;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;font-weight:bold;text-align:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;color:rgba(var(--theme-font-color));border-radius:var(--border-radius-medium)}.btn.small{padding:5px;min-width:calc(var(--min-interactive-size) / 1.3);min-height:calc(var(--min-interactive-size) / 1.3)}.btn.medium{padding:5px 10px;min-width:var(--min-interactive-size);min-height:var(--min-interactive-size)}.btn.big{padding:5px 15px;min-width:calc(var(--min-interactive-size) * 1.3);min-height:calc(var(--min-interactive-size) * 1.3)}.btn:focus{background-color:rgba(var(--color-black), 0.1)}.btn:hover{background-color:rgba(var(--color-black), 0.1)}.btn:active{background-color:rgba(var(--color-black), 0.1)}.btn.theme{color:rgba(var(--theme-font-color));background-color:rgba(var(--theme-color-secondary))}.btn.theme:focus{background-color:rgba(var(--theme-color-secondary), .85)}.btn.theme:hover{-webkit-box-shadow:var(--shadow-primary);box-shadow:var(--shadow-primary)}.btn.theme:active{-webkit-box-shadow:var(--shadow-primary);box-shadow:var(--shadow-primary)}.btn.theme-border{color:rgba(var(--theme-font-color));border:2px solid rgba(var(--theme-color-primary-opposite))}.btn.theme-border:focus{background-color:rgba(var(--theme-color-secondary), .85)}.btn.them-border:hover{-webkit-box-shadow:var(--shadow-primary);box-shadow:var(--shadow-primary)}.btn.theme-border:active{-webkit-box-shadow:var(--shadow-primary);box-shadow:var(--shadow-primary)}.btn.white{color:rgba(var(--color-font-dark));background-color:rgba(var(--color-white))}.btn.white:focus{background-color:rgba(var(--color-white), .85)}.btn.white:hover{-webkit-box-shadow:var(--shadow-primary);box-shadow:var(--shadow-primary)}.btn.white:active{-webkit-box-shadow:var(--shadow-primary);box-shadow:var(--shadow-primary)}.btn.dark{color:rgba(var(--color-font-light));background-color:rgba(var(--color-dark))}.btn.dark:focus{background-color:rgba(var(--color-dark), .85)}.btn.dark:hover{-webkit-box-shadow:var(--shadow-primary);box-shadow:var(--shadow-primary)}.btn.dark:active{-webkit-box-shadow:var(--shadow-primary);box-shadow:var(--shadow-primary)}.btn.dark-border{color:rgba(var(--theme-font-color));border:2px solid rgba(var(--theme-font-color))}.btn.dark-border:focus{background-color:rgba(var(--color-dark), .85)}.btn.dark-border:hover{-webkit-box-shadow:var(--shadow-primary);box-shadow:var(--shadow-primary)}.btn.dark-border:active{-webkit-box-shadow:var(--shadow-primary);box-shadow:var(--shadow-primary)}.btn.success{color:rgba(var(--color-font-light));background-color:rgba(var(--color-success))}.btn.success:focus{background-color:rgba(var(--color-success), .85)}.btn.success:hover{-webkit-box-shadow:var(--shadow-primary);box-shadow:var(--shadow-primary)}.btn.success:active{-webkit-box-shadow:var(--shadow-primary);box-shadow:var(--shadow-primary)}.btn.warning{color:rgba(var(--color-font-light));background-color:rgba(var(--color-warning))}.btn.warning:focus{background-color:rgba(var(--color-warning), .85)}.btn.warning:hover{-webkit-box-shadow:var(--shadow-primary);box-shadow:var(--shadow-primary)}.btn.warning:active{-webkit-box-shadow:var(--shadow-primary);box-shadow:var(--shadow-primary)}.btn.info{color:rgba(var(--color-font-light));border:2px solid rgba(var(--color-info));background-color:rgba(var(--color-info))}.btn.info:focus{background-color:rgba(var(--color-info), .85)}.btn.info:hover{-webkit-box-shadow:var(--shadow-primary);box-shadow:var(--shadow-primary)}.btn.info:active{-webkit-box-shadow:var(--shadow-primary);box-shadow:var(--shadow-primary)}.btn.info-border{color:rgba(var(--color-info));border:2px solid rgba(var(--color-info))}.btn.info-border:focus{background-color:rgba(var(--color-dark), .85)}.btn.info-border:hover{-webkit-box-shadow:var(--shadow-primary);box-shadow:var(--shadow-primary)}.btn.info-border:active{-webkit-box-shadow:var(--shadow-primary);box-shadow:var(--shadow-primary)}.btn.danger{color:rgba(var(--color-font-light));background-color:rgba(var(--color-danger))}.btn.danger:focus{background-color:rgba(var(--color-danger), .85)}.btn.danger:hover{-webkit-box-shadow:var(--shadow-primary);box-shadow:var(--shadow-primary)}.btn.danger:active{-webkit-box-shadow:var(--shadow-primary);box-shadow:var(--shadow-primary)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQnV0dG9uLnN2ZWx0ZSIsInNvdXJjZXMiOlsiQnV0dG9uLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0PlxuICAgIGltcG9ydCB7IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJ3N2ZWx0ZSdcbiAgICBpbXBvcnQgeyBjbGFzc25hbWVzIH0gZnJvbSAnQHV0aWxzJ1xuXG4gICAgY29uc3QgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXIoKVxuXG4gICAgZXhwb3J0IGxldCBpcyA9IHVuZGVmaW5lZCAvLyB0aGVtZSwgdGhlbWUtYm9yZGVyLCB3aGl0ZSwgc3VjY2Vzcywgd2FybmluZywgZGFuZ2VyLCBkYXJrLCBkYXJrLWJvcmRlclxuICAgIGV4cG9ydCBsZXQgaWQgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IHJlbCA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgaHJlZiA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgYXV0byA9IGZhbHNlXG4gICAgZXhwb3J0IGxldCB0eXBlID0gJ2J1dHRvbidcbiAgICBleHBvcnQgbGV0IGZvcm0gPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IHNpemUgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IHRpdGxlID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCBzdHlsZSA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgaHRtbEZvciA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgZGlzYWJsZWQgPSBmYWxzZVxuICAgIGV4cG9ydCBsZXQgYXJpYUxhYmVsID0gdW5kZWZpbmVkXG5cbiAgICBsZXQgdGl0bGVQcm9wID0gdGl0bGUgfHwgYXJpYUxhYmVsXG4gICAgbGV0IGFyaWFMYWJlbFByb3AgPSBhcmlhTGFiZWwgfHwgdGl0bGVcblxuICAgICQ6IGNsYXNzUHJvcCA9IGNsYXNzbmFtZXMoJ2J0bicsIGlzLCBzaXplLCAkJHByb3BzLmNsYXNzLCB7IGF1dG8sIGRpc2FibGVkIH0pXG5cbiAgICBmdW5jdGlvbiBvbkxhYmVsQ2xpY2soZSkge1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChodG1sRm9yKS5jbGljaygpXG4gICAgICAgICFkaXNhYmxlZCAmJiBkaXNwYXRjaCgnY2xpY2snLCBlKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uQ2xpY2soZSkge1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAhZGlzYWJsZWQgJiYgZGlzcGF0Y2goJ2NsaWNrJywgZSlcbiAgICB9XG48L3NjcmlwdD5cblxueyNpZiBocmVmfVxuICAgIDxhXG4gICAgICAgICAgICB7aWR9XG4gICAgICAgICAgICB7cmVsfVxuICAgICAgICAgICAge2hyZWZ9XG4gICAgICAgICAgICB7c3R5bGV9XG4gICAgICAgICAgICB0aXRsZT17dGl0bGVQcm9wfVxuICAgICAgICAgICAgY2xhc3M9e2NsYXNzUHJvcH1cbiAgICAgICAgICAgIGFyaWEtbGFiZWw9e2FyaWFMYWJlbFByb3B9XG4gICAgICAgICAgICBvbjpjbGljaz17b25DbGlja31cbiAgICA+XG4gICAgICAgIDxzbG90Pjwvc2xvdD5cbiAgICA8L2E+XG57OmVsc2UgaWYgaHRtbEZvcn1cbiAgICA8bGFiZWxcbiAgICAgICAgICAgIHtpZH1cbiAgICAgICAgICAgIHtzdHlsZX1cbiAgICAgICAgICAgIHtkaXNhYmxlZH1cbiAgICAgICAgICAgIGZvcj17aHRtbEZvcn1cbiAgICAgICAgICAgIHRpdGxlPXt0aXRsZVByb3B9XG4gICAgICAgICAgICBjbGFzcz17Y2xhc3NQcm9wfVxuICAgICAgICAgICAgYXJpYS1sYWJlbD17YXJpYUxhYmVsUHJvcH1cbiAgICAgICAgICAgIG9uOmNsaWNrPXtvbkxhYmVsQ2xpY2t9XG4gICAgPlxuICAgICAgICA8c2xvdD48L3Nsb3Q+XG4gICAgPC9sYWJlbD5cbns6ZWxzZX1cbiAgICA8YnV0dG9uXG4gICAgICAgICAgICB7aWR9XG4gICAgICAgICAgICB7Zm9ybX1cbiAgICAgICAgICAgIHt0eXBlfVxuICAgICAgICAgICAge3N0eWxlfVxuICAgICAgICAgICAge2Rpc2FibGVkfVxuICAgICAgICAgICAgdGl0bGU9e3RpdGxlUHJvcH1cbiAgICAgICAgICAgIGNsYXNzPXtjbGFzc1Byb3B9XG4gICAgICAgICAgICBhcmlhLWxhYmVsPXthcmlhTGFiZWxQcm9wfVxuICAgICAgICAgICAgb246Y2xpY2s9e29uQ2xpY2t9XG4gICAgPlxuICAgICAgICA8c2xvdD48L3Nsb3Q+XG4gICAgPC9idXR0b24+XG57L2lmfVxuXG48c3R5bGU+XG4uYnRuOm5vdCguYXV0bykge1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIHBhZGRpbmc6IDVweCAxNXB4O1xufVxuXG46Z2xvYmFsKC5idG4pIHtcbiAgICAtd2Via2l0LWJveC1mbGV4OiAwO1xuICAgICAgICAtbXMtZmxleDogbm9uZTtcbiAgICAgICAgICAgIGZsZXg6IG5vbmU7XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIG1heC13aWR0aDogMTAwJTtcbiAgICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xuICAgICAgIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgIC1tcy11c2VyLXNlbGVjdDogbm9uZTtcbiAgICAgICAgICAgIHVzZXItc2VsZWN0OiBub25lO1xuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAtd2Via2l0LWJveC1hbGlnbjogY2VudGVyO1xuICAgICAgICAtbXMtZmxleC1hbGlnbjogY2VudGVyO1xuICAgICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBkaXNwbGF5OiAtd2Via2l0LWlubGluZS1ib3g7XG4gICAgZGlzcGxheTogLW1zLWlubGluZS1mbGV4Ym94O1xuICAgIGRpc3BsYXk6IGlubGluZS1mbGV4O1xuICAgIC13ZWJraXQtYm94LXBhY2s6IGNlbnRlcjtcbiAgICAgICAgLW1zLWZsZXgtcGFjazogY2VudGVyO1xuICAgICAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgY29sb3I6IHJnYmEodmFyKC0tdGhlbWUtZm9udC1jb2xvcikpO1xuICAgIGJvcmRlci1yYWRpdXM6IHZhcigtLWJvcmRlci1yYWRpdXMtbWVkaXVtKTtcbn1cblxuOmdsb2JhbCguYnRuLnNtYWxsKSB7XG4gICAgcGFkZGluZzogNXB4O1xuICAgIG1pbi13aWR0aDogY2FsYyh2YXIoLS1taW4taW50ZXJhY3RpdmUtc2l6ZSkgLyAxLjMpO1xuICAgIG1pbi1oZWlnaHQ6IGNhbGModmFyKC0tbWluLWludGVyYWN0aXZlLXNpemUpIC8gMS4zKTtcbn1cblxuOmdsb2JhbCguYnRuLm1lZGl1bSkge1xuICAgIHBhZGRpbmc6IDVweCAxMHB4O1xuICAgIG1pbi13aWR0aDogdmFyKC0tbWluLWludGVyYWN0aXZlLXNpemUpO1xuICAgIG1pbi1oZWlnaHQ6IHZhcigtLW1pbi1pbnRlcmFjdGl2ZS1zaXplKTtcbn1cblxuOmdsb2JhbCguYnRuLmJpZykge1xuICAgIHBhZGRpbmc6IDVweCAxNXB4O1xuICAgIG1pbi13aWR0aDogY2FsYyh2YXIoLS1taW4taW50ZXJhY3RpdmUtc2l6ZSkgKiAxLjMpO1xuICAgIG1pbi1oZWlnaHQ6IGNhbGModmFyKC0tbWluLWludGVyYWN0aXZlLXNpemUpICogMS4zKTtcbn1cblxuOmdsb2JhbCguYnRuOmZvY3VzKSB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSh2YXIoLS1jb2xvci1ibGFjayksIDAuMSk7XG59XG5cbjpnbG9iYWwoLmJ0bjpob3Zlcikge1xuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEodmFyKC0tY29sb3ItYmxhY2spLCAwLjEpO1xufVxuXG46Z2xvYmFsKC5idG46YWN0aXZlKSB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSh2YXIoLS1jb2xvci1ibGFjayksIDAuMSk7XG59XG5cbi8qIHRoZW1lICovXG5cbjpnbG9iYWwoLmJ0bikudGhlbWUge1xuICAgIGNvbG9yOiByZ2JhKHZhcigtLXRoZW1lLWZvbnQtY29sb3IpKTtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKHZhcigtLXRoZW1lLWNvbG9yLXNlY29uZGFyeSkpO1xufVxuXG46Z2xvYmFsKC5idG4pLnRoZW1lOmZvY3VzIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKHZhcigtLXRoZW1lLWNvbG9yLXNlY29uZGFyeSksIC44NSk7XG59XG5cbjpnbG9iYWwoLmJ0bikudGhlbWU6aG92ZXIge1xuICAgIC13ZWJraXQtYm94LXNoYWRvdzogdmFyKC0tc2hhZG93LXByaW1hcnkpO1xuICAgICAgICAgICAgYm94LXNoYWRvdzogdmFyKC0tc2hhZG93LXByaW1hcnkpO1xufVxuXG46Z2xvYmFsKC5idG4pLnRoZW1lOmFjdGl2ZSB7XG4gICAgLXdlYmtpdC1ib3gtc2hhZG93OiB2YXIoLS1zaGFkb3ctcHJpbWFyeSk7XG4gICAgICAgICAgICBib3gtc2hhZG93OiB2YXIoLS1zaGFkb3ctcHJpbWFyeSk7XG59XG5cbi8qIHRoZW1lICovXG5cbjpnbG9iYWwoLmJ0bikudGhlbWUtYm9yZGVyIHtcbiAgICBjb2xvcjogcmdiYSh2YXIoLS10aGVtZS1mb250LWNvbG9yKSk7XG4gICAgYm9yZGVyOiAycHggc29saWQgcmdiYSh2YXIoLS10aGVtZS1jb2xvci1wcmltYXJ5LW9wcG9zaXRlKSk7XG59XG5cbjpnbG9iYWwoLmJ0bikudGhlbWUtYm9yZGVyOmZvY3VzIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKHZhcigtLXRoZW1lLWNvbG9yLXNlY29uZGFyeSksIC44NSk7XG59XG5cbjpnbG9iYWwoLmJ0bikudGhlbS1ib3JkZXI6aG92ZXIge1xuICAgIC13ZWJraXQtYm94LXNoYWRvdzogdmFyKC0tc2hhZG93LXByaW1hcnkpO1xuICAgICAgICAgICAgYm94LXNoYWRvdzogdmFyKC0tc2hhZG93LXByaW1hcnkpO1xufVxuXG46Z2xvYmFsKC5idG4pLnRoZW1lLWJvcmRlcjphY3RpdmUge1xuICAgIC13ZWJraXQtYm94LXNoYWRvdzogdmFyKC0tc2hhZG93LXByaW1hcnkpO1xuICAgICAgICAgICAgYm94LXNoYWRvdzogdmFyKC0tc2hhZG93LXByaW1hcnkpO1xufVxuXG4vKiBXaGl0ZSAqL1xuXG46Z2xvYmFsKC5idG4pLndoaXRlIHtcbiAgICBjb2xvcjogcmdiYSh2YXIoLS1jb2xvci1mb250LWRhcmspKTtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKHZhcigtLWNvbG9yLXdoaXRlKSk7XG59XG5cbjpnbG9iYWwoLmJ0bikud2hpdGU6Zm9jdXMge1xuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEodmFyKC0tY29sb3Itd2hpdGUpLCAuODUpO1xufVxuXG46Z2xvYmFsKC5idG4pLndoaXRlOmhvdmVyIHtcbiAgICAtd2Via2l0LWJveC1zaGFkb3c6IHZhcigtLXNoYWRvdy1wcmltYXJ5KTtcbiAgICAgICAgICAgIGJveC1zaGFkb3c6IHZhcigtLXNoYWRvdy1wcmltYXJ5KTtcbn1cblxuOmdsb2JhbCguYnRuKS53aGl0ZTphY3RpdmUge1xuICAgIC13ZWJraXQtYm94LXNoYWRvdzogdmFyKC0tc2hhZG93LXByaW1hcnkpO1xuICAgICAgICAgICAgYm94LXNoYWRvdzogdmFyKC0tc2hhZG93LXByaW1hcnkpO1xufVxuXG4vKiBEYXJrICovXG5cbjpnbG9iYWwoLmJ0bikuZGFyayB7XG4gICAgY29sb3I6IHJnYmEodmFyKC0tY29sb3ItZm9udC1saWdodCkpO1xuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEodmFyKC0tY29sb3ItZGFyaykpO1xufVxuXG46Z2xvYmFsKC5idG4pLmRhcms6Zm9jdXMge1xuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEodmFyKC0tY29sb3ItZGFyayksIC44NSk7XG59XG5cbjpnbG9iYWwoLmJ0bikuZGFyazpob3ZlciB7XG4gICAgLXdlYmtpdC1ib3gtc2hhZG93OiB2YXIoLS1zaGFkb3ctcHJpbWFyeSk7XG4gICAgICAgICAgICBib3gtc2hhZG93OiB2YXIoLS1zaGFkb3ctcHJpbWFyeSk7XG59XG5cbjpnbG9iYWwoLmJ0bikuZGFyazphY3RpdmUge1xuICAgIC13ZWJraXQtYm94LXNoYWRvdzogdmFyKC0tc2hhZG93LXByaW1hcnkpO1xuICAgICAgICAgICAgYm94LXNoYWRvdzogdmFyKC0tc2hhZG93LXByaW1hcnkpO1xufVxuXG4vKiBEYXJrLWJvcmRlciAqL1xuXG46Z2xvYmFsKC5idG4pLmRhcmstYm9yZGVyIHtcbiAgICBjb2xvcjogcmdiYSh2YXIoLS10aGVtZS1mb250LWNvbG9yKSk7XG4gICAgYm9yZGVyOiAycHggc29saWQgcmdiYSh2YXIoLS10aGVtZS1mb250LWNvbG9yKSk7XG59XG5cbjpnbG9iYWwoLmJ0bikuZGFyay1ib3JkZXI6Zm9jdXMge1xuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEodmFyKC0tY29sb3ItZGFyayksIC44NSk7XG59XG5cbjpnbG9iYWwoLmJ0bikuZGFyay1ib3JkZXI6aG92ZXIge1xuICAgIC13ZWJraXQtYm94LXNoYWRvdzogdmFyKC0tc2hhZG93LXByaW1hcnkpO1xuICAgICAgICAgICAgYm94LXNoYWRvdzogdmFyKC0tc2hhZG93LXByaW1hcnkpO1xufVxuXG46Z2xvYmFsKC5idG4pLmRhcmstYm9yZGVyOmFjdGl2ZSB7XG4gICAgLXdlYmtpdC1ib3gtc2hhZG93OiB2YXIoLS1zaGFkb3ctcHJpbWFyeSk7XG4gICAgICAgICAgICBib3gtc2hhZG93OiB2YXIoLS1zaGFkb3ctcHJpbWFyeSk7XG59XG5cbi8qIFN1Y2Nlc3MgKi9cblxuOmdsb2JhbCguYnRuKS5zdWNjZXNzIHtcbiAgICBjb2xvcjogcmdiYSh2YXIoLS1jb2xvci1mb250LWxpZ2h0KSk7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSh2YXIoLS1jb2xvci1zdWNjZXNzKSk7XG59XG5cbjpnbG9iYWwoLmJ0bikuc3VjY2Vzczpmb2N1cyB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSh2YXIoLS1jb2xvci1zdWNjZXNzKSwgLjg1KTtcbn1cblxuOmdsb2JhbCguYnRuKS5zdWNjZXNzOmhvdmVyIHtcbiAgICAtd2Via2l0LWJveC1zaGFkb3c6IHZhcigtLXNoYWRvdy1wcmltYXJ5KTtcbiAgICAgICAgICAgIGJveC1zaGFkb3c6IHZhcigtLXNoYWRvdy1wcmltYXJ5KTtcbn1cblxuOmdsb2JhbCguYnRuKS5zdWNjZXNzOmFjdGl2ZSB7XG4gICAgLXdlYmtpdC1ib3gtc2hhZG93OiB2YXIoLS1zaGFkb3ctcHJpbWFyeSk7XG4gICAgICAgICAgICBib3gtc2hhZG93OiB2YXIoLS1zaGFkb3ctcHJpbWFyeSk7XG59XG5cbi8qIFdhcm5pbmcgKi9cblxuOmdsb2JhbCguYnRuKS53YXJuaW5nIHtcbiAgICBjb2xvcjogcmdiYSh2YXIoLS1jb2xvci1mb250LWxpZ2h0KSk7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSh2YXIoLS1jb2xvci13YXJuaW5nKSk7XG59XG5cbjpnbG9iYWwoLmJ0bikud2FybmluZzpmb2N1cyB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSh2YXIoLS1jb2xvci13YXJuaW5nKSwgLjg1KTtcbn1cblxuOmdsb2JhbCguYnRuKS53YXJuaW5nOmhvdmVyIHtcbiAgICAtd2Via2l0LWJveC1zaGFkb3c6IHZhcigtLXNoYWRvdy1wcmltYXJ5KTtcbiAgICAgICAgICAgIGJveC1zaGFkb3c6IHZhcigtLXNoYWRvdy1wcmltYXJ5KTtcbn1cblxuOmdsb2JhbCguYnRuKS53YXJuaW5nOmFjdGl2ZSB7XG4gICAgLXdlYmtpdC1ib3gtc2hhZG93OiB2YXIoLS1zaGFkb3ctcHJpbWFyeSk7XG4gICAgICAgICAgICBib3gtc2hhZG93OiB2YXIoLS1zaGFkb3ctcHJpbWFyeSk7XG59XG5cbi8qIEluZm8gKi9cblxuOmdsb2JhbCguYnRuKS5pbmZvIHtcbiAgICBjb2xvcjogcmdiYSh2YXIoLS1jb2xvci1mb250LWxpZ2h0KSk7XG4gICAgYm9yZGVyOiAycHggc29saWQgcmdiYSh2YXIoLS1jb2xvci1pbmZvKSk7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSh2YXIoLS1jb2xvci1pbmZvKSk7XG59XG5cbjpnbG9iYWwoLmJ0bikuaW5mbzpmb2N1cyB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSh2YXIoLS1jb2xvci1pbmZvKSwgLjg1KTtcbn1cblxuOmdsb2JhbCguYnRuKS5pbmZvOmhvdmVyIHtcbiAgICAtd2Via2l0LWJveC1zaGFkb3c6IHZhcigtLXNoYWRvdy1wcmltYXJ5KTtcbiAgICAgICAgICAgIGJveC1zaGFkb3c6IHZhcigtLXNoYWRvdy1wcmltYXJ5KTtcbn1cblxuOmdsb2JhbCguYnRuKS5pbmZvOmFjdGl2ZSB7XG4gICAgLXdlYmtpdC1ib3gtc2hhZG93OiB2YXIoLS1zaGFkb3ctcHJpbWFyeSk7XG4gICAgICAgICAgICBib3gtc2hhZG93OiB2YXIoLS1zaGFkb3ctcHJpbWFyeSk7XG59XG5cbi8qIEluZm8tYm9yZGVyICAqL1xuXG46Z2xvYmFsKC5idG4pLmluZm8tYm9yZGVyIHtcbiAgICBjb2xvcjogcmdiYSh2YXIoLS1jb2xvci1pbmZvKSk7XG4gICAgYm9yZGVyOiAycHggc29saWQgcmdiYSh2YXIoLS1jb2xvci1pbmZvKSk7XG59XG5cbjpnbG9iYWwoLmJ0bikuaW5mby1ib3JkZXI6Zm9jdXMge1xuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEodmFyKC0tY29sb3ItZGFyayksIC44NSk7XG59XG5cbjpnbG9iYWwoLmJ0bikuaW5mby1ib3JkZXI6aG92ZXIge1xuICAgIC13ZWJraXQtYm94LXNoYWRvdzogdmFyKC0tc2hhZG93LXByaW1hcnkpO1xuICAgICAgICAgICAgYm94LXNoYWRvdzogdmFyKC0tc2hhZG93LXByaW1hcnkpO1xufVxuXG46Z2xvYmFsKC5idG4pLmluZm8tYm9yZGVyOmFjdGl2ZSB7XG4gICAgLXdlYmtpdC1ib3gtc2hhZG93OiB2YXIoLS1zaGFkb3ctcHJpbWFyeSk7XG4gICAgICAgICAgICBib3gtc2hhZG93OiB2YXIoLS1zaGFkb3ctcHJpbWFyeSk7XG59XG5cbi8qIERhbmdlciAqL1xuXG46Z2xvYmFsKC5idG4pLmRhbmdlciB7XG4gICAgY29sb3I6IHJnYmEodmFyKC0tY29sb3ItZm9udC1saWdodCkpO1xuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEodmFyKC0tY29sb3ItZGFuZ2VyKSk7XG59XG5cbjpnbG9iYWwoLmJ0bikuZGFuZ2VyOmZvY3VzIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKHZhcigtLWNvbG9yLWRhbmdlciksIC44NSk7XG59XG5cbjpnbG9iYWwoLmJ0bikuZGFuZ2VyOmhvdmVyIHtcbiAgICAtd2Via2l0LWJveC1zaGFkb3c6IHZhcigtLXNoYWRvdy1wcmltYXJ5KTtcbiAgICAgICAgICAgIGJveC1zaGFkb3c6IHZhcigtLXNoYWRvdy1wcmltYXJ5KTtcbn1cblxuOmdsb2JhbCguYnRuKS5kYW5nZXI6YWN0aXZlIHtcbiAgICAtd2Via2l0LWJveC1zaGFkb3c6IHZhcigtLXNoYWRvdy1wcmltYXJ5KTtcbiAgICAgICAgICAgIGJveC1zaGFkb3c6IHZhcigtLXNoYWRvdy1wcmltYXJ5KTtcbn08L3N0eWxlPlxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQStFQSxtQkFBSSxLQUFLLEtBQUssQ0FBQyxBQUFDLENBQUMsQUFDYixLQUFLLENBQUUsSUFBSSxDQUNYLE9BQU8sQ0FBRSxHQUFHLENBQUMsSUFBSSxBQUNyQixDQUFDLEFBRU8sSUFBSSxBQUFFLENBQUMsQUFDWCxnQkFBZ0IsQ0FBRSxDQUFDLENBQ2YsUUFBUSxDQUFFLElBQUksQ0FDVixJQUFJLENBQUUsSUFBSSxDQUNsQixNQUFNLENBQUUsT0FBTyxDQUNmLFNBQVMsQ0FBRSxJQUFJLENBQ2YsbUJBQW1CLENBQUUsSUFBSSxDQUN0QixnQkFBZ0IsQ0FBRSxJQUFJLENBQ3JCLGVBQWUsQ0FBRSxJQUFJLENBQ2pCLFdBQVcsQ0FBRSxJQUFJLENBQ3pCLFdBQVcsQ0FBRSxJQUFJLENBQ2pCLFVBQVUsQ0FBRSxNQUFNLENBQ2xCLGlCQUFpQixDQUFFLE1BQU0s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 */";
	append_dev(document_1$1.head, style);
}

// (63:0) {:else}
function create_else_block$1(ctx) {
	let button;
	let button_class_value;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*$$slots*/ ctx[19].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[18], null);

	const block = {
		c: function create() {
			button = element("button");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", {
				id: true,
				form: true,
				type: true,
				style: true,
				disabled: true,
				title: true,
				class: true,
				"aria-label": true
			});

			var button_nodes = children(button);
			if (default_slot) default_slot.l(button_nodes);
			button_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(button, "id", /*id*/ ctx[0]);
			attr_dev(button, "form", /*form*/ ctx[4]);
			attr_dev(button, "type", /*type*/ ctx[3]);
			attr_dev(button, "style", /*style*/ ctx[5]);
			button.disabled = /*disabled*/ ctx[7];
			attr_dev(button, "title", /*titleProp*/ ctx[9]);
			attr_dev(button, "class", button_class_value = "" + (null_to_empty(/*classProp*/ ctx[8]) + " svelte-1hd9njw"));
			attr_dev(button, "aria-label", /*ariaLabelProp*/ ctx[10]);
			add_location(button, file$I, 63, 4, 1611);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);

			if (default_slot) {
				default_slot.m(button, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen_dev(button, "click", /*onClick*/ ctx[12], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 262144) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[18], dirty, null, null);
				}
			}

			if (!current || dirty & /*id*/ 1) {
				attr_dev(button, "id", /*id*/ ctx[0]);
			}

			if (!current || dirty & /*form*/ 16) {
				attr_dev(button, "form", /*form*/ ctx[4]);
			}

			if (!current || dirty & /*type*/ 8) {
				attr_dev(button, "type", /*type*/ ctx[3]);
			}

			if (!current || dirty & /*style*/ 32) {
				attr_dev(button, "style", /*style*/ ctx[5]);
			}

			if (!current || dirty & /*disabled*/ 128) {
				prop_dev(button, "disabled", /*disabled*/ ctx[7]);
			}

			if (!current || dirty & /*classProp*/ 256 && button_class_value !== (button_class_value = "" + (null_to_empty(/*classProp*/ ctx[8]) + " svelte-1hd9njw"))) {
				attr_dev(button, "class", button_class_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$1.name,
		type: "else",
		source: "(63:0) {:else}",
		ctx
	});

	return block;
}

// (50:18) 
function create_if_block_1$2(ctx) {
	let label;
	let label_class_value;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*$$slots*/ ctx[19].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[18], null);

	const block = {
		c: function create() {
			label = element("label");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			label = claim_element(nodes, "LABEL", {
				id: true,
				style: true,
				disabled: true,
				for: true,
				title: true,
				class: true,
				"aria-label": true
			});

			var label_nodes = children(label);
			if (default_slot) default_slot.l(label_nodes);
			label_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(label, "id", /*id*/ ctx[0]);
			attr_dev(label, "style", /*style*/ ctx[5]);
			attr_dev(label, "disabled", /*disabled*/ ctx[7]);
			attr_dev(label, "for", /*htmlFor*/ ctx[6]);
			attr_dev(label, "title", /*titleProp*/ ctx[9]);
			attr_dev(label, "class", label_class_value = "" + (null_to_empty(/*classProp*/ ctx[8]) + " svelte-1hd9njw"));
			attr_dev(label, "aria-label", /*ariaLabelProp*/ ctx[10]);
			add_location(label, file$I, 50, 4, 1330);
		},
		m: function mount(target, anchor) {
			insert_dev(target, label, anchor);

			if (default_slot) {
				default_slot.m(label, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen_dev(label, "click", /*onLabelClick*/ ctx[11], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 262144) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[18], dirty, null, null);
				}
			}

			if (!current || dirty & /*id*/ 1) {
				attr_dev(label, "id", /*id*/ ctx[0]);
			}

			if (!current || dirty & /*style*/ 32) {
				attr_dev(label, "style", /*style*/ ctx[5]);
			}

			if (!current || dirty & /*disabled*/ 128) {
				attr_dev(label, "disabled", /*disabled*/ ctx[7]);
			}

			if (!current || dirty & /*htmlFor*/ 64) {
				attr_dev(label, "for", /*htmlFor*/ ctx[6]);
			}

			if (!current || dirty & /*classProp*/ 256 && label_class_value !== (label_class_value = "" + (null_to_empty(/*classProp*/ ctx[8]) + " svelte-1hd9njw"))) {
				attr_dev(label, "class", label_class_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(label);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$2.name,
		type: "if",
		source: "(50:18) ",
		ctx
	});

	return block;
}

// (37:0) {#if href}
function create_if_block$4(ctx) {
	let a;
	let a_class_value;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*$$slots*/ ctx[19].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[18], null);

	const block = {
		c: function create() {
			a = element("a");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			a = claim_element(nodes, "A", {
				id: true,
				rel: true,
				href: true,
				style: true,
				title: true,
				class: true,
				"aria-label": true
			});

			var a_nodes = children(a);
			if (default_slot) default_slot.l(a_nodes);
			a_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a, "id", /*id*/ ctx[0]);
			attr_dev(a, "rel", /*rel*/ ctx[1]);
			attr_dev(a, "href", /*href*/ ctx[2]);
			attr_dev(a, "style", /*style*/ ctx[5]);
			attr_dev(a, "title", /*titleProp*/ ctx[9]);
			attr_dev(a, "class", a_class_value = "" + (null_to_empty(/*classProp*/ ctx[8]) + " svelte-1hd9njw"));
			attr_dev(a, "aria-label", /*ariaLabelProp*/ ctx[10]);
			add_location(a, file$I, 37, 4, 1063);
		},
		m: function mount(target, anchor) {
			insert_dev(target, a, anchor);

			if (default_slot) {
				default_slot.m(a, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen_dev(a, "click", /*onClick*/ ctx[12], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 262144) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[18], dirty, null, null);
				}
			}

			if (!current || dirty & /*id*/ 1) {
				attr_dev(a, "id", /*id*/ ctx[0]);
			}

			if (!current || dirty & /*rel*/ 2) {
				attr_dev(a, "rel", /*rel*/ ctx[1]);
			}

			if (!current || dirty & /*href*/ 4) {
				attr_dev(a, "href", /*href*/ ctx[2]);
			}

			if (!current || dirty & /*style*/ 32) {
				attr_dev(a, "style", /*style*/ ctx[5]);
			}

			if (!current || dirty & /*classProp*/ 256 && a_class_value !== (a_class_value = "" + (null_to_empty(/*classProp*/ ctx[8]) + " svelte-1hd9njw"))) {
				attr_dev(a, "class", a_class_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(a);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$4.name,
		type: "if",
		source: "(37:0) {#if href}",
		ctx
	});

	return block;
}

function create_fragment$I(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$4, create_if_block_1$2, create_else_block$1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*href*/ ctx[2]) return 0;
		if (/*htmlFor*/ ctx[6]) return 1;
		return 2;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$I.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$I($$self, $$props, $$invalidate) {
	const dispatch = createEventDispatcher();
	let { is = undefined } = $$props; // theme, theme-border, white, success, warning, danger, dark, dark-border
	let { id = undefined } = $$props;
	let { rel = undefined } = $$props;
	let { href = undefined } = $$props;
	let { auto = false } = $$props;
	let { type = "button" } = $$props;
	let { form = undefined } = $$props;
	let { size = undefined } = $$props;
	let { title = undefined } = $$props;
	let { style = undefined } = $$props;
	let { htmlFor = undefined } = $$props;
	let { disabled = false } = $$props;
	let { ariaLabel = undefined } = $$props;
	let titleProp = title || ariaLabel;
	let ariaLabelProp = ariaLabel || title;

	function onLabelClick(e) {
		document.getElementById(htmlFor).click();
		!disabled && dispatch("click", e);
	}

	function onClick(e) {
		e.stopPropagation();
		!disabled && dispatch("click", e);
	}

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Button", $$slots, ['default']);

	$$self.$set = $$new_props => {
		$$invalidate(21, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("is" in $$new_props) $$invalidate(13, is = $$new_props.is);
		if ("id" in $$new_props) $$invalidate(0, id = $$new_props.id);
		if ("rel" in $$new_props) $$invalidate(1, rel = $$new_props.rel);
		if ("href" in $$new_props) $$invalidate(2, href = $$new_props.href);
		if ("auto" in $$new_props) $$invalidate(14, auto = $$new_props.auto);
		if ("type" in $$new_props) $$invalidate(3, type = $$new_props.type);
		if ("form" in $$new_props) $$invalidate(4, form = $$new_props.form);
		if ("size" in $$new_props) $$invalidate(15, size = $$new_props.size);
		if ("title" in $$new_props) $$invalidate(16, title = $$new_props.title);
		if ("style" in $$new_props) $$invalidate(5, style = $$new_props.style);
		if ("htmlFor" in $$new_props) $$invalidate(6, htmlFor = $$new_props.htmlFor);
		if ("disabled" in $$new_props) $$invalidate(7, disabled = $$new_props.disabled);
		if ("ariaLabel" in $$new_props) $$invalidate(17, ariaLabel = $$new_props.ariaLabel);
		if ("$$scope" in $$new_props) $$invalidate(18, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		classnames,
		dispatch,
		is,
		id,
		rel,
		href,
		auto,
		type,
		form,
		size,
		title,
		style,
		htmlFor,
		disabled,
		ariaLabel,
		titleProp,
		ariaLabelProp,
		onLabelClick,
		onClick,
		classProp
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(21, $$props = assign(assign({}, $$props), $$new_props));
		if ("is" in $$props) $$invalidate(13, is = $$new_props.is);
		if ("id" in $$props) $$invalidate(0, id = $$new_props.id);
		if ("rel" in $$props) $$invalidate(1, rel = $$new_props.rel);
		if ("href" in $$props) $$invalidate(2, href = $$new_props.href);
		if ("auto" in $$props) $$invalidate(14, auto = $$new_props.auto);
		if ("type" in $$props) $$invalidate(3, type = $$new_props.type);
		if ("form" in $$props) $$invalidate(4, form = $$new_props.form);
		if ("size" in $$props) $$invalidate(15, size = $$new_props.size);
		if ("title" in $$props) $$invalidate(16, title = $$new_props.title);
		if ("style" in $$props) $$invalidate(5, style = $$new_props.style);
		if ("htmlFor" in $$props) $$invalidate(6, htmlFor = $$new_props.htmlFor);
		if ("disabled" in $$props) $$invalidate(7, disabled = $$new_props.disabled);
		if ("ariaLabel" in $$props) $$invalidate(17, ariaLabel = $$new_props.ariaLabel);
		if ("titleProp" in $$props) $$invalidate(9, titleProp = $$new_props.titleProp);
		if ("ariaLabelProp" in $$props) $$invalidate(10, ariaLabelProp = $$new_props.ariaLabelProp);
		if ("classProp" in $$props) $$invalidate(8, classProp = $$new_props.classProp);
	};

	let classProp;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(8, classProp = classnames("btn", is, size, $$props.class, { auto, disabled }));
	};

	$$props = exclude_internal_props($$props);

	return [
		id,
		rel,
		href,
		type,
		form,
		style,
		htmlFor,
		disabled,
		classProp,
		titleProp,
		ariaLabelProp,
		onLabelClick,
		onClick,
		is,
		auto,
		size,
		title,
		ariaLabel,
		$$scope,
		$$slots
	];
}

class Button extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document_1$1.getElementById("svelte-1hd9njw-style")) add_css$9();

		init(this, options, instance$I, create_fragment$I, safe_not_equal, {
			is: 13,
			id: 0,
			rel: 1,
			href: 2,
			auto: 14,
			type: 3,
			form: 4,
			size: 15,
			title: 16,
			style: 5,
			htmlFor: 6,
			disabled: 7,
			ariaLabel: 17
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Button",
			options,
			id: create_fragment$I.name
		});
	}

	get is() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set is(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get id() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get rel() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set rel(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get href() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set href(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get auto() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set auto(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get type() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set type(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get form() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set form(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get title() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get htmlFor() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set htmlFor(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ariaLabel() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ariaLabel(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/Divider.svelte generated by Svelte v3.24.0 */
const file$J = "src/components/Divider.svelte";

function add_css$a() {
	var style = element("style");
	style.id = "svelte-12ng15v-style";
	style.textContent = ".divider.svelte-12ng15v{margin:0;border:none;-webkit-box-sizing:content-box;box-sizing:content-box;background-clip:content-box}.info.svelte-12ng15v{background-color:rgb(var(--color-info))}.success.svelte-12ng15v{background-color:rgb(var(--color-success))}.warning.svelte-12ng15v{background-color:rgb(var(--color-warning))}.danger.svelte-12ng15v{background-color:rgb(var(--color-danger))}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRGl2aWRlci5zdmVsdGUiLCJzb3VyY2VzIjpbIkRpdmlkZXIuc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgdG9DU1NTdHJpbmcsIGNsYXNzbmFtZXMgfSBmcm9tICdAdXRpbHMnXG5cbiAgICBleHBvcnQgbGV0IGlzID0gJ2luZm8nXG4gICAgZXhwb3J0IGxldCBzaXplID0gMFxuICAgIGV4cG9ydCBsZXQgd2lkdGggPSAyXG5cbiAgICAkOiBjbGFzc1Byb3AgPSBjbGFzc25hbWVzKCdkaXZpZGVyJywgaXMsICQkcHJvcHMuY2xhc3MpXG4gICAgJDogc3R5bGVQcm9wID0gdG9DU1NTdHJpbmcoeyBwYWRkaW5nOiBgJHtzaXplIC8gMn1weCAwYCwgaGVpZ2h0OiBgJHt3aWR0aH1weGAgfSlcbjwvc2NyaXB0PlxuXG48aHIgY2xhc3M9e2NsYXNzUHJvcH0gc3R5bGU9e3N0eWxlUHJvcH0+XG5cbjxzdHlsZT5cbi5kaXZpZGVyIHtcbiAgICBtYXJnaW46IDA7XG4gICAgYm9yZGVyOiBub25lO1xuICAgIC13ZWJraXQtYm94LXNpemluZzogY29udGVudC1ib3g7XG4gICAgICAgICAgICBib3gtc2l6aW5nOiBjb250ZW50LWJveDtcbiAgICBiYWNrZ3JvdW5kLWNsaXA6IGNvbnRlbnQtYm94O1xufVxuXG4uaW5mbyB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiKHZhcigtLWNvbG9yLWluZm8pKTtcbn1cblxuLnN1Y2Nlc3Mge1xuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYih2YXIoLS1jb2xvci1zdWNjZXNzKSk7XG59XG5cbi53YXJuaW5nIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IodmFyKC0tY29sb3Itd2FybmluZykpO1xufVxuXG4uZGFuZ2VyIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IodmFyKC0tY29sb3ItZGFuZ2VyKSk7XG59PC9zdHlsZT5cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFjQSxRQUFRLGVBQUMsQ0FBQyxBQUNOLE1BQU0sQ0FBRSxDQUFDLENBQ1QsTUFBTSxDQUFFLElBQUksQ0FDWixrQkFBa0IsQ0FBRSxXQUFXLENBQ3ZCLFVBQVUsQ0FBRSxXQUFXLENBQy9CLGVBQWUsQ0FBRSxXQUFXLEFBQ2hDLENBQUMsQUFFRCxLQUFLLGVBQUMsQ0FBQyxBQUNILGdCQUFnQixDQUFFLElBQUksSUFBSSxZQUFZLENBQUMsQ0FBQyxBQUM1QyxDQUFDLEFBRUQsUUFBUSxlQUFDLENBQUMsQUFDTixnQkFBZ0IsQ0FBRSxJQUFJLElBQUksZUFBZSxDQUFDLENBQUMsQUFDL0MsQ0FBQyxBQUVELFFBQVEsZUFBQyxDQUFDLEFBQ04sZ0JBQWdCLENBQUUsSUFBSSxJQUFJLGVBQWUsQ0FBQyxDQUFDLEFBQy9DLENBQUMsQUFFRCxPQUFPLGVBQUMsQ0FBQyxBQUNMLGdCQUFnQixDQUFFLElBQUksSUFBSSxjQUFjLENBQUMsQ0FBQyxBQUM5QyxDQUFDIn0= */";
	append_dev(document.head, style);
}

function create_fragment$J(ctx) {
	let hr;
	let hr_class_value;

	const block = {
		c: function create() {
			hr = element("hr");
			this.h();
		},
		l: function claim(nodes) {
			hr = claim_element(nodes, "HR", { class: true, style: true });
			this.h();
		},
		h: function hydrate() {
			attr_dev(hr, "class", hr_class_value = "" + (null_to_empty(/*classProp*/ ctx[0]) + " svelte-12ng15v"));
			attr_dev(hr, "style", /*styleProp*/ ctx[1]);
			add_location(hr, file$J, 11, 0, 296);
		},
		m: function mount(target, anchor) {
			insert_dev(target, hr, anchor);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*classProp*/ 1 && hr_class_value !== (hr_class_value = "" + (null_to_empty(/*classProp*/ ctx[0]) + " svelte-12ng15v"))) {
				attr_dev(hr, "class", hr_class_value);
			}

			if (dirty & /*styleProp*/ 2) {
				attr_dev(hr, "style", /*styleProp*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(hr);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$J.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$J($$self, $$props, $$invalidate) {
	let { is = "info" } = $$props;
	let { size = 0 } = $$props;
	let { width = 2 } = $$props;
	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Divider", $$slots, []);

	$$self.$set = $$new_props => {
		$$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("is" in $$new_props) $$invalidate(2, is = $$new_props.is);
		if ("size" in $$new_props) $$invalidate(3, size = $$new_props.size);
		if ("width" in $$new_props) $$invalidate(4, width = $$new_props.width);
	};

	$$self.$capture_state = () => ({
		toCSSString,
		classnames,
		is,
		size,
		width,
		classProp,
		styleProp
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
		if ("is" in $$props) $$invalidate(2, is = $$new_props.is);
		if ("size" in $$props) $$invalidate(3, size = $$new_props.size);
		if ("width" in $$props) $$invalidate(4, width = $$new_props.width);
		if ("classProp" in $$props) $$invalidate(0, classProp = $$new_props.classProp);
		if ("styleProp" in $$props) $$invalidate(1, styleProp = $$new_props.styleProp);
	};

	let classProp;
	let styleProp;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(0, classProp = classnames("divider", is, $$props.class));

		if ($$self.$$.dirty & /*size, width*/ 24) {
			 $$invalidate(1, styleProp = toCSSString({
				padding: `${size / 2}px 0`,
				height: `${width}px`
			}));
		}
	};

	$$props = exclude_internal_props($$props);
	return [classProp, styleProp, is, size, width];
}

class Divider extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document.getElementById("svelte-12ng15v-style")) add_css$a();
		init(this, options, instance$J, create_fragment$J, safe_not_equal, { is: 2, size: 3, width: 4 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Divider",
			options,
			id: create_fragment$J.name
		});
	}

	get is() {
		throw new Error("<Divider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set is(value) {
		throw new Error("<Divider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<Divider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<Divider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<Divider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<Divider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/Progress.svelte generated by Svelte v3.24.0 */
const file$K = "src/components/Progress.svelte";

function add_css$b() {
	var style = element("style");
	style.id = "svelte-wvyka1-style";
	style.textContent = ".progress.medium.svelte-wvyka1.svelte-wvyka1{--progress-height:10px;--progress-padding-point:1px}.progress.svelte-wvyka1.svelte-wvyka1{-webkit-box-flex:0;-ms-flex:0;flex:0;width:100%;border-radius:9999px;height:var(--progress-height)}.progress-inner-frame.svelte-wvyka1.svelte-wvyka1{position:relative;display:-webkit-box;display:-ms-flexbox;display:flex;width:100%;height:100%;border-radius:9999px;overflow:hidden;padding:var(--progress-padding-point) 0;background-color:rgba(var(--theme-color-primary-opposite), .1);background-clip:content-box}.progress-core.svelte-wvyka1.svelte-wvyka1{position:absolute;top:0;left:0;height:100%;-webkit-box-flex:0;-ms-flex:none;flex:none;-ms-flex-item-align:stretch;align-self:stretch;-webkit-transition:1s ease-in-out;transition:1s ease-in-out;border-radius:9999px;background-color:rgba(var(--color-info))}.progress[aria-valuenow=\"100\"].svelte-wvyka1 .progress-core.svelte-wvyka1{background-color:rgba(var(--color-success))}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUHJvZ3Jlc3Muc3ZlbHRlIiwic291cmNlcyI6WyJQcm9ncmVzcy5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBjcmVhdGVFdmVudERpc3BhdGNoZXIsIG9uTW91bnQgfSBmcm9tICdzdmVsdGUnXG4gICAgaW1wb3J0IHsgY2xhc3NuYW1lcywgc2FmZUdldCB9IGZyb20gJ0B1dGlscydcblxuICAgIGNvbnN0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKClcblxuICAgIGV4cG9ydCBsZXQgaWQgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IHZhbHVlID0gMCAvLyAwIC0gMTAwXG4gICAgZXhwb3J0IGxldCBzaXplID0gJ21lZGl1bSdcbiAgICBleHBvcnQgbGV0IHRpdGxlID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCBhcmlhTGFiZWwgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IGJvcmRlclJhZGl1cyA9IHVuZGVmaW5lZFxuXG4gICAgJDogdmFsID0gTnVtYmVyLmlzRmluaXRlKCt2YWx1ZSkgPyBNYXRoLm1heCgwLCBNYXRoLm1pbigrdmFsdWUsIDEwMCkpIDogMFxuICAgICQ6IHRpdGxlUHJvcCA9IHRpdGxlIHx8IGBQcm9ncmVzcyAtICR7dmFsfSVgXG4gICAgJDogYXJpYUxhYmVsUHJvcCA9IGFyaWFMYWJlbCB8fCBgUHJvZ3Jlc3MgLSAke3ZhbH0lYFxuICAgICQ6IGNsYXNzUHJvcCA9IGNsYXNzbmFtZXMoJ3Byb2dyZXNzJywgc2l6ZSwgJCRwcm9wcy5jbGFzcylcblxuICAgIGZ1bmN0aW9uIGdldEJvcmRlclJhZGl1cyhib3JkZXJzLCBkZWZhdWx0cyA9ICc5OTk5OXB4Jykge1xuICAgICAgICBjb25zdCBickRlZmF1bHQgPSBuZXcgQXJyYXkoNCkuZmlsbChkZWZhdWx0cylcbiAgICAgICAgY29uc3QgYmRzID0gc2FmZUdldCgoKSA9PiBib3JkZXJzLnNwbGl0KCcgJyksIFtdLCB0cnVlKVxuICAgICAgICBjb25zdCBydWxlID0gJ2JvcmRlci1yYWRpdXMnXG4gICAgICAgIHJldHVybiBgJHtydWxlfToke2JyRGVmYXVsdC5tYXAoKGRlZiwgaSkgPT4gYCR7YmRzW2ldIHx8IGRlZn1gKS5qb2luKCcgJyl9YFxuICAgIH1cbjwvc2NyaXB0PlxuXG5cbjxkaXZcbiAgICAgICAge2lkfVxuICAgICAgICBjbGFzcz17Y2xhc3NQcm9wfVxuICAgICAgICB0aXRsZT17dGl0bGVQcm9wfVxuICAgICAgICBhcmlhLWxhYmVsPXthcmlhTGFiZWxQcm9wfVxuICAgICAgICByb2xlPVwicHJvZ3Jlc3NiYXJcIlxuICAgICAgICBhcmlhLXZhbHVlbWluPVwiMFwiXG4gICAgICAgIGFyaWEtdmFsdWVtYXg9XCIxMDBcIlxuICAgICAgICBhcmlhLXZhbHVlbm93PXt2YWx9XG4gICAgICAgIHN0eWxlPXtnZXRCb3JkZXJSYWRpdXMoYm9yZGVyUmFkaXVzKX1cbj5cbiAgICA8ZGl2IGNsYXNzPVwicHJvZ3Jlc3MtaW5uZXItZnJhbWVcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInByb2dyZXNzLWNvcmVcIiBzdHlsZT17YHdpZHRoOiR7dmFsfSVgfT48L2Rpdj5cbiAgICA8L2Rpdj5cbjwvZGl2PlxuXG48c3R5bGU+XG4ucHJvZ3Jlc3MubWVkaXVtIHtcbiAgICAtLXByb2dyZXNzLWhlaWdodDogMTBweDtcbiAgICAtLXByb2dyZXNzLXBhZGRpbmctcG9pbnQ6IDFweDtcbn1cblxuLnByb2dyZXNzIHtcbiAgICAtd2Via2l0LWJveC1mbGV4OiAwO1xuICAgICAgICAtbXMtZmxleDogMDtcbiAgICAgICAgICAgIGZsZXg6IDA7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgYm9yZGVyLXJhZGl1czogOTk5OXB4O1xuICAgIGhlaWdodDogdmFyKC0tcHJvZ3Jlc3MtaGVpZ2h0KTtcbn1cblxuLnByb2dyZXNzLWlubmVyLWZyYW1lIHtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgZGlzcGxheTogLXdlYmtpdC1ib3g7XG4gICAgZGlzcGxheTogLW1zLWZsZXhib3g7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBoZWlnaHQ6IDEwMCU7XG4gICAgYm9yZGVyLXJhZGl1czogOTk5OXB4O1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgcGFkZGluZzogdmFyKC0tcHJvZ3Jlc3MtcGFkZGluZy1wb2ludCkgMDtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKHZhcigtLXRoZW1lLWNvbG9yLXByaW1hcnktb3Bwb3NpdGUpLCAuMSk7XG4gICAgYmFja2dyb3VuZC1jbGlwOiBjb250ZW50LWJveDtcbn1cblxuLnByb2dyZXNzLWNvcmUge1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB0b3A6IDA7XG4gICAgbGVmdDogMDtcbiAgICBoZWlnaHQ6IDEwMCU7XG4gICAgLXdlYmtpdC1ib3gtZmxleDogMDtcbiAgICAgICAgLW1zLWZsZXg6IG5vbmU7XG4gICAgICAgICAgICBmbGV4OiBub25lO1xuICAgIC1tcy1mbGV4LWl0ZW0tYWxpZ246IHN0cmV0Y2g7XG4gICAgICAgIGFsaWduLXNlbGY6IHN0cmV0Y2g7XG4gICAgLXdlYmtpdC10cmFuc2l0aW9uOiAxcyBlYXNlLWluLW91dDtcbiAgICB0cmFuc2l0aW9uOiAxcyBlYXNlLWluLW91dDtcbiAgICBib3JkZXItcmFkaXVzOiA5OTk5cHg7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSh2YXIoLS1jb2xvci1pbmZvKSk7XG59XG5cbi5wcm9ncmVzc1thcmlhLXZhbHVlbm93PVwiMTAwXCJdIC5wcm9ncmVzcy1jb3JlIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKHZhcigtLWNvbG9yLXN1Y2Nlc3MpKTtcbn08L3N0eWxlPlxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQTRDQSxTQUFTLE9BQU8sNEJBQUMsQ0FBQyxBQUNkLGlCQUFpQixDQUFFLElBQUksQ0FDdkIsd0JBQXdCLENBQUUsR0FBRyxBQUNqQyxDQUFDLEFBRUQsU0FBUyw0QkFBQyxDQUFDLEFBQ1AsZ0JBQWdCLENBQUUsQ0FBQyxDQUNmLFFBQVEsQ0FBRSxDQUFDLENBQ1AsSUFBSSxDQUFFLENBQUMsQ0FDZixLQUFLLENBQUUsSUFBSSxDQUNYLGFBQWEsQ0FBRSxNQUFNLENBQ3JCLE1BQU0sQ0FBRSxJQUFJLGlCQUFpQixDQUFDLEFBQ2xDLENBQUMsQUFFRCxxQkFBcUIsNEJBQUMsQ0FBQyxBQUNuQixRQUFRLENBQUUsUUFBUSxDQUNsQixPQUFPLENBQUUsV0FBVyxDQUNwQixPQUFPLENBQUUsV0FBVyxDQUNwQixPQUFPLENBQUUsSUFBSSxDQUNiLEtBQUssQ0FBRSxJQUFJLENBQ1gsTUFBTSxDQUFFLElBQUksQ0FDWixhQUFhLENBQUUsTUFBTSxDQUNyQixRQUFRLENBQUUsTUFBTSxDQUNoQixPQUFPLENBQUUsSUFBSSx3QkFBd0IsQ0FBQyxDQUFDLENBQUMsQ0FDeEMsZ0JBQWdCLENBQUUsS0FBSyxJQUFJLDhCQUE4QixDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FDL0QsZUFBZSxDQUFFLFdBQVcsQUFDaEMsQ0FBQyxBQUVELGNBQWMsNEJBQUMsQ0FBQyxBQUNaLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLEdBQUcsQ0FBRSxDQUFDLENBQ04sSUFBSSxDQUFFLENBQUMsQ0FDUCxNQUFNLENBQUUsSUFBSSxDQUNaLGdCQUFnQixDQUFFLENBQUMsQ0FDZixRQUFRLENBQUUsSUFBSSxDQUNWLElBQUksQ0FBRSxJQUFJLENBQ2xCLG1CQUFtQixDQUFFLE9BQU8sQ0FDeEIsVUFBVSxDQUFFLE9BQU8sQ0FDdkIsa0JBQWtCLENBQUUsRUFBRSxDQUFDLFdBQVcsQ0FDbEMsVUFBVSxDQUFFLEVBQUUsQ0FBQyxXQUFXLENBQzFCLGFBQWEsQ0FBRSxNQUFNLENBQ3JCLGdCQUFnQixDQUFFLEtBQUssSUFBSSxZQUFZLENBQUMsQ0FBQyxBQUM3QyxDQUFDLEFBRUQsU0FBUyxDQUFDLGFBQWEsQ0FBQyxLQUFLLGVBQUMsQ0FBQyxjQUFjLGNBQUMsQ0FBQyxBQUMzQyxnQkFBZ0IsQ0FBRSxLQUFLLElBQUksZUFBZSxDQUFDLENBQUMsQUFDaEQsQ0FBQyJ9 */";
	append_dev(document.head, style);
}

function create_fragment$K(ctx) {
	let div2;
	let div1;
	let div0;
	let div0_style_value;
	let div2_class_value;
	let div2_style_value;

	const block = {
		c: function create() {
			div2 = element("div");
			div1 = element("div");
			div0 = element("div");
			this.h();
		},
		l: function claim(nodes) {
			div2 = claim_element(nodes, "DIV", {
				id: true,
				class: true,
				title: true,
				"aria-label": true,
				role: true,
				"aria-valuemin": true,
				"aria-valuemax": true,
				"aria-valuenow": true,
				style: true
			});

			var div2_nodes = children(div2);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true, style: true });
			children(div0).forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "progress-core svelte-wvyka1");
			attr_dev(div0, "style", div0_style_value = `width:${/*val*/ ctx[2]}%`);
			add_location(div0, file$K, 39, 8, 1249);
			attr_dev(div1, "class", "progress-inner-frame svelte-wvyka1");
			add_location(div1, file$K, 38, 4, 1206);
			attr_dev(div2, "id", /*id*/ ctx[0]);
			attr_dev(div2, "class", div2_class_value = "" + (null_to_empty(/*classProp*/ ctx[5]) + " svelte-wvyka1"));
			attr_dev(div2, "title", /*titleProp*/ ctx[3]);
			attr_dev(div2, "aria-label", /*ariaLabelProp*/ ctx[4]);
			attr_dev(div2, "role", "progressbar");
			attr_dev(div2, "aria-valuemin", "0");
			attr_dev(div2, "aria-valuemax", "100");
			attr_dev(div2, "aria-valuenow", /*val*/ ctx[2]);
			attr_dev(div2, "style", div2_style_value = /*getBorderRadius*/ ctx[6](/*borderRadius*/ ctx[1]));
			add_location(div2, file$K, 27, 0, 940);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);
			append_dev(div2, div1);
			append_dev(div1, div0);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*val*/ 4 && div0_style_value !== (div0_style_value = `width:${/*val*/ ctx[2]}%`)) {
				attr_dev(div0, "style", div0_style_value);
			}

			if (dirty & /*id*/ 1) {
				attr_dev(div2, "id", /*id*/ ctx[0]);
			}

			if (dirty & /*classProp*/ 32 && div2_class_value !== (div2_class_value = "" + (null_to_empty(/*classProp*/ ctx[5]) + " svelte-wvyka1"))) {
				attr_dev(div2, "class", div2_class_value);
			}

			if (dirty & /*titleProp*/ 8) {
				attr_dev(div2, "title", /*titleProp*/ ctx[3]);
			}

			if (dirty & /*ariaLabelProp*/ 16) {
				attr_dev(div2, "aria-label", /*ariaLabelProp*/ ctx[4]);
			}

			if (dirty & /*val*/ 4) {
				attr_dev(div2, "aria-valuenow", /*val*/ ctx[2]);
			}

			if (dirty & /*borderRadius*/ 2 && div2_style_value !== (div2_style_value = /*getBorderRadius*/ ctx[6](/*borderRadius*/ ctx[1]))) {
				attr_dev(div2, "style", div2_style_value);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div2);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$K.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$K($$self, $$props, $$invalidate) {
	const dispatch = createEventDispatcher();
	let { id = undefined } = $$props;
	let { value = 0 } = $$props; // 0 - 100
	let { size = "medium" } = $$props;
	let { title = undefined } = $$props;
	let { ariaLabel = undefined } = $$props;
	let { borderRadius = undefined } = $$props;

	function getBorderRadius(borders, defaults = "99999px") {
		const brDefault = new Array(4).fill(defaults);
		const bds = safeGet(() => borders.split(" "), [], true);
		const rule = "border-radius";
		return `${rule}:${brDefault.map((def, i) => `${bds[i] || def}`).join(" ")}`;
	}

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Progress", $$slots, []);

	$$self.$set = $$new_props => {
		$$invalidate(12, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("id" in $$new_props) $$invalidate(0, id = $$new_props.id);
		if ("value" in $$new_props) $$invalidate(7, value = $$new_props.value);
		if ("size" in $$new_props) $$invalidate(8, size = $$new_props.size);
		if ("title" in $$new_props) $$invalidate(9, title = $$new_props.title);
		if ("ariaLabel" in $$new_props) $$invalidate(10, ariaLabel = $$new_props.ariaLabel);
		if ("borderRadius" in $$new_props) $$invalidate(1, borderRadius = $$new_props.borderRadius);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		onMount,
		classnames,
		safeGet,
		dispatch,
		id,
		value,
		size,
		title,
		ariaLabel,
		borderRadius,
		getBorderRadius,
		val,
		titleProp,
		ariaLabelProp,
		classProp
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(12, $$props = assign(assign({}, $$props), $$new_props));
		if ("id" in $$props) $$invalidate(0, id = $$new_props.id);
		if ("value" in $$props) $$invalidate(7, value = $$new_props.value);
		if ("size" in $$props) $$invalidate(8, size = $$new_props.size);
		if ("title" in $$props) $$invalidate(9, title = $$new_props.title);
		if ("ariaLabel" in $$props) $$invalidate(10, ariaLabel = $$new_props.ariaLabel);
		if ("borderRadius" in $$props) $$invalidate(1, borderRadius = $$new_props.borderRadius);
		if ("val" in $$props) $$invalidate(2, val = $$new_props.val);
		if ("titleProp" in $$props) $$invalidate(3, titleProp = $$new_props.titleProp);
		if ("ariaLabelProp" in $$props) $$invalidate(4, ariaLabelProp = $$new_props.ariaLabelProp);
		if ("classProp" in $$props) $$invalidate(5, classProp = $$new_props.classProp);
	};

	let val;
	let titleProp;
	let ariaLabelProp;
	let classProp;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*value*/ 128) {
			 $$invalidate(2, val = Number.isFinite(+value)
			? Math.max(0, Math.min(+value, 100))
			: 0);
		}

		if ($$self.$$.dirty & /*title, val*/ 516) {
			 $$invalidate(3, titleProp = title || `Progress - ${val}%`);
		}

		if ($$self.$$.dirty & /*ariaLabel, val*/ 1028) {
			 $$invalidate(4, ariaLabelProp = ariaLabel || `Progress - ${val}%`);
		}

		 $$invalidate(5, classProp = classnames("progress", size, $$props.class));
	};

	$$props = exclude_internal_props($$props);

	return [
		id,
		borderRadius,
		val,
		titleProp,
		ariaLabelProp,
		classProp,
		getBorderRadius,
		value,
		size,
		title,
		ariaLabel
	];
}

class Progress extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document.getElementById("svelte-wvyka1-style")) add_css$b();

		init(this, options, instance$K, create_fragment$K, safe_not_equal, {
			id: 0,
			value: 7,
			size: 8,
			title: 9,
			ariaLabel: 10,
			borderRadius: 1
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Progress",
			options,
			id: create_fragment$K.name
		});
	}

	get id() {
		throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get title() {
		throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ariaLabel() {
		throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ariaLabel(value) {
		throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get borderRadius() {
		throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set borderRadius(value) {
		throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/FancyBox.svelte generated by Svelte v3.24.0 */
const file$L = "src/components/FancyBox.svelte";

function add_css$c() {
	var style = element("style");
	style.id = "svelte-17mfy9g-style";
	style.textContent = ".fancy-box.svelte-17mfy9g.svelte-17mfy9g{position:relative;width:100%;-webkit-box-flex:0;-ms-flex:none;flex:none;display:-webkit-box;display:-ms-flexbox;display:flex;overflow:hidden;-ms-flex-item-align:stretch;align-self:stretch;-webkit-box-align:stretch;-ms-flex-align:stretch;align-items:stretch;-webkit-box-pack:stretch;-ms-flex-pack:stretch;justify-content:stretch}.fancy-box-ghost.svelte-17mfy9g.svelte-17mfy9g{z-index:10;position:fixed;top:0;left:0;width:100%;height:100%;display:-webkit-box;display:-ms-flexbox;display:flex;overflow:hidden;-webkit-box-align:stretch;-ms-flex-align:stretch;align-items:stretch;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-ms-touch-action:manipulation;touch-action:manipulation;background-color:rgba(var(--color-black), .75);outline:150px solid rgba(var(--color-black), .75);-webkit-transition-timing-function:linear;transition-timing-function:linear;opacity:0;padding:0 var(--screen-padding);-webkit-transform:translate3d(0,30px,0);transform:translate3d(0,30px,0);pointer-events:none;will-change:transform, opacity}.fancy-box-ghost.svelte-17mfy9g>.svelte-17mfy9g{max-width:100%;max-height:100%}.fancy-box-ghost.active.svelte-17mfy9g.svelte-17mfy9g{opacity:1;-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0);pointer-events:auto}button.svelte-17mfy9g.svelte-17mfy9g{position:absolute;top:0;right:0;font-size:24px;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;width:60px;height:60px;color:rgb(var(--color-white))}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRmFuY3lCb3guc3ZlbHRlIiwic291cmNlcyI6WyJGYW5jeUJveC5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBjcmVhdGVFdmVudERpc3BhdGNoZXIsIHRpY2sgfSBmcm9tICdzdmVsdGUnXG4gICAgaW1wb3J0IHsgZmx5IH0gZnJvbSAnc3ZlbHRlL3RyYW5zaXRpb24nXG4gICAgaW1wb3J0IHsgU3dpcGUgfSBmcm9tICdAc2VydmljZXMnXG4gICAgaW1wb3J0IHsgY2xhc3NuYW1lcywgZGVsYXksIGJvZHlTY3JvbGwsIHNhZmVHZXQgfSBmcm9tICdAdXRpbHMnXG4gICAgaW1wb3J0IEljb24gZnJvbSAnQGNvbXBvbmVudHMvSWNvbi5zdmVsdGUnO1xuICAgIGltcG9ydCBQb3J0YWwgZnJvbSAnLi9Qb3J0YWwuc3ZlbHRlJztcblxuICAgIGNvbnN0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKClcbiAgICBcbiAgICBjb25zdCBEVVJBVElPTiA9IDI1MFxuICAgIGNvbnN0IFRIUkVTSE9MRCA9IDUwXG4gICAgY29uc3QgU1dJUEVfU1BFRUQgPSAuNVxuICAgIGNvbnN0IFNUQVJUX1BPU0lUSU9OID0ge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAyMFxuICAgIH1cblxuICAgIGV4cG9ydCBsZXQgcmVmID0gbnVsbFxuICAgIGV4cG9ydCBsZXQgYmxvY2tCb2R5ID0gdHJ1ZVxuICAgIGV4cG9ydCBsZXQgc3dpcGUgPSBbJ2FsbCddICAgICAgIC8vIHVwIGRvd24gbGVmdCByaWdodCBhbGxcbiAgICBleHBvcnQgbGV0IGRpc2FibGVkID0gZmFsc2VcbiAgICBleHBvcnQgbGV0IGV4dHJhTG9jayA9IGZhbHNlXG4gICAgZXhwb3J0IGxldCBzdGFydFBvc2l0aW9uID0gU1RBUlRfUE9TSVRJT05cblxuICAgIGxldCBhY3RpdmUgPSBudWxsXG4gICAgbGV0IHNsb3RzID0gJCRwcm9wcy4kJHNsb3RzIHx8IHt9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBvbkNsaWNrKGUpIHtcbiAgICAgICAgaWYgKGRpc2FibGVkKSByZXR1cm5cblxuICAgICAgICBjb25zdCBuZXdBY3RpdmUgPSAhYWN0aXZlXG5cbiAgICAgICAgc2V0QWN0aXZlKG5ld0FjdGl2ZSlcblxuICAgICAgICBpZiAobmV3QWN0aXZlKSB7XG4gICAgICAgICAgICBkcmF3VHJhbnNmb3JtKHJlZiwgMCwgMClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRyYXdUcmFuc2Zvcm0ocmVmLCBzdGFydFBvc2l0aW9uLngsIHN0YXJ0UG9zaXRpb24ueSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHNldEFjdGl2ZShpc0FjdGl2ZSkge1xuICAgICAgICBhY3RpdmUgPSBpc0FjdGl2ZVxuXG4gICAgICAgIGF3YWl0IHRpY2soKVxuXG4gICAgICAgIGlmIChhY3RpdmUpIHtcbiAgICAgICAgICAgIHNldER1cmF0aW9uKHJlZiwgRFVSQVRJT04pXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHNldER1cmF0aW9uKHJlZiwgMCksIERVUkFUSU9OKVxuICAgICAgICAgICAgYmxvY2tCb2R5ICYmIGJvZHlTY3JvbGwuZGlzYWJsZVNjcm9sbChyZWYsIHsgZXh0cmFMb2NrIH0pO1xuICAgICAgICAgICAgZGlzcGF0Y2goJ29wZW4nKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0RHVyYXRpb24ocmVmLCBEVVJBVElPTilcbiAgICAgICAgICAgIGJsb2NrQm9keSAmJiBib2R5U2Nyb2xsLmVuYWJsZVNjcm9sbChyZWYsIHsgZXh0cmFMb2NrIH0pO1xuICAgICAgICAgICAgZGlzcGF0Y2goJ2Nsb3NlJylcbiAgICAgICAgfVxuICAgIH1cblxuICAgICQ6IGlzU3dpcGUgPSB7XG4gICAgICAgIHVwOiBzYWZlR2V0KCgpID0+IHN3aXBlLmluY2x1ZGVzKCd1cCcpIHx8IHN3aXBlLmluY2x1ZGVzKCdhbGwnKSksXG4gICAgICAgIGRvd246IHNhZmVHZXQoKCkgPT4gc3dpcGUuaW5jbHVkZXMoJ2Rvd24nKSB8fCBzd2lwZS5pbmNsdWRlcygnYWxsJykpLFxuICAgICAgICBsZWZ0OiBzYWZlR2V0KCgpID0+IHN3aXBlLmluY2x1ZGVzKCdsZWZ0JykgfHwgc3dpcGUuaW5jbHVkZXMoJ2FsbCcpKSxcbiAgICAgICAgcmlnaHQ6IHNhZmVHZXQoKCkgPT4gc3dpcGUuaW5jbHVkZXMoJ3JpZ2h0JykgfHwgc3dpcGUuaW5jbHVkZXMoJ2FsbCcpKSxcbiAgICB9XG4gICAgJDogY2xhc3NQcm9wID0gY2xhc3NuYW1lcygnZmFuY3ktYm94LWdob3N0JywgeyBhY3RpdmUgfSlcbiAgICAkOiBjbGFzc1Byb3BXcmFwID0gY2xhc3NuYW1lcygnZmFuY3ktYm94JywgJCRwcm9wcy5jbGFzcylcblxuICAgIGxldCB4U3dpcGUgPSAwXG4gICAgbGV0IHlTd2lwZSA9IDBcblxuICAgIGZ1bmN0aW9uIGFkZFN3aXBlKGVsKSB7XG4gICAgICAgIG5ldyBTd2lwZShlbClcbiAgICAgICAgICAgICAgICAucnVuKClcbiAgICAgICAgICAgICAgICAub25VcChpc1N3aXBlLnVwID8gaGFuZGxlVmVydGljYWxTd2lwZSA6IG51bGwpXG4gICAgICAgICAgICAgICAgLm9uRG93bihpc1N3aXBlLmRvd24gPyBoYW5kbGVWZXJ0aWNhbFN3aXBlIDogbnVsbClcbiAgICAgICAgICAgICAgICAub25MZWZ0KGlzU3dpcGUubGVmdCA/IGhhbmRsZUhvcml6b250YWxTd2lwZSA6IG51bGwpXG4gICAgICAgICAgICAgICAgLm9uUmlnaHQoaXNTd2lwZS5yaWdodCA/IGhhbmRsZUhvcml6b250YWxTd2lwZSA6IG51bGwpXG4gICAgICAgICAgICAgICAgLm9uVG91Y2hFbmQoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoeFN3aXBlID4gVEhSRVNIT0xEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXREdXJhdGlvbihyZWYsIERVUkFUSU9OKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBzZXREdXJhdGlvbihyZWYsIDApLCBEVVJBVElPTilcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEFjdGl2ZShmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdUcmFuc2Zvcm0oZWwsIHhTd2lwZSArIDUwLCB5U3dpcGUpXG4gICAgICAgICAgICAgICAgICAgICAgICBkcmF3T3BhY2l0eShlbCwgeFN3aXBlICsgNTAsIHlTd2lwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGRlbGF5KERVUkFUSU9OKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHhTd2lwZSA8IC1USFJFU0hPTEQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldER1cmF0aW9uKHJlZiwgRFVSQVRJT04pXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHNldER1cmF0aW9uKHJlZiwgMCksIERVUkFUSU9OKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0QWN0aXZlKGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgZHJhd1RyYW5zZm9ybShlbCwgeFN3aXBlIC0gNTAsIHlTd2lwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdPcGFjaXR5KGVsLCB4U3dpcGUgLSA1MCwgeVN3aXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgZGVsYXkoRFVSQVRJT04pXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmICh5U3dpcGUgPiBUSFJFU0hPTEQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldER1cmF0aW9uKHJlZiwgRFVSQVRJT04pXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHNldER1cmF0aW9uKHJlZiwgMCksIERVUkFUSU9OKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0QWN0aXZlKGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgZHJhd1RyYW5zZm9ybShlbCwgeFN3aXBlLCB5U3dpcGUgKyA1MClcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdPcGFjaXR5KGVsLCB4U3dpcGUsIHlTd2lwZSArIDUwKVxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgZGVsYXkoRFVSQVRJT04pXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoeVN3aXBlIDwgLVRIUkVTSE9MRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0RHVyYXRpb24ocmVmLCBEVVJBVElPTilcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gc2V0RHVyYXRpb24ocmVmLCAwKSwgRFVSQVRJT04pXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRBY3RpdmUoZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICBkcmF3VHJhbnNmb3JtKGVsLCB4U3dpcGUsIHlTd2lwZSAtIDUwKVxuICAgICAgICAgICAgICAgICAgICAgICAgZHJhd09wYWNpdHkoZWwsIHhTd2lwZSwgeVN3aXBlIC0gNTApXG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBkZWxheShEVVJBVElPTilcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICh4U3dpcGUgPD0gVEhSRVNIT0xEICYmIHhTd2lwZSA+PSAtVEhSRVNIT0xEICYmIHlTd2lwZSA8PSBUSFJFU0hPTEQgJiYgeVN3aXBlID49IC1USFJFU0hPTEQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldER1cmF0aW9uKHJlZiwgRFVSQVRJT04pXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHNldER1cmF0aW9uKHJlZiwgMCksIERVUkFUSU9OKVxuICAgICAgICAgICAgICAgICAgICAgICAgZHJhd1RyYW5zZm9ybShlbCwgMCwgMClcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdUcmFuc2Zvcm0oZWwsIHN0YXJ0UG9zaXRpb24ueCwgc3RhcnRQb3NpdGlvbi55KVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgeFN3aXBlID0gMFxuICAgICAgICAgICAgICAgICAgICB5U3dpcGUgPSAwXG4gICAgICAgICAgICAgICAgICAgIGVsLnN0eWxlLm9wYWNpdHkgPSBudWxsXG4gICAgICAgICAgICAgICAgfSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVWZXJ0aWNhbFN3aXBlKHlEb3duLCB5VXAsIGV2dCwgZWwpIHtcbiAgICAgICAgeVN3aXBlID0gKHlVcCAtIHlEb3duKSAqIFNXSVBFX1NQRUVEXG4gICAgICAgIGRyYXdUcmFuc2Zvcm0oZWwsIHhTd2lwZSwgeVN3aXBlKVxuICAgICAgICBkcmF3T3BhY2l0eShlbCwgeFN3aXBlLCB5U3dpcGUpXG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZUhvcml6b250YWxTd2lwZSh4RG93biwgeFVwLCBldnQsIGVsKSB7XG4gICAgICAgIHhTd2lwZSA9ICh4VXAgLSB4RG93bikgKiBTV0lQRV9TUEVFRFxuICAgICAgICBkcmF3VHJhbnNmb3JtKGVsLCB4U3dpcGUsIHlTd2lwZSlcbiAgICAgICAgZHJhd09wYWNpdHkoZWwsIHhTd2lwZSwgeVN3aXBlKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRyYXdUcmFuc2Zvcm0oZWwsIHgsIHkpIHtcbiAgICAgICAgY29uc3QgZGVsdGEgPSBNYXRoLmFicyh4KSA+IE1hdGguYWJzKHkpID8geCA6IHlcbiAgICAgICAgbGV0IHNjYWxlID0gMSAtIE1hdGguYWJzKGRlbHRhIC8gd2luZG93LmlubmVySGVpZ2h0KVxuICAgICAgICBlbCAmJiAoZWwuc3R5bGUudHJhbnNmb3JtID0gYG1hdHJpeCgke3NjYWxlfSwgMCwgMCwgJHtzY2FsZX0sICR7eH0sICR7eX0pYClcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0RHVyYXRpb24oZWwsIG1zKSB7XG4gICAgICAgIGVsICYmIChlbC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBgJHttc31tc2ApXG4gICAgfVxuICAgIGZ1bmN0aW9uIGRyYXdPcGFjaXR5KGVsLCB4LCB5KSB7XG4gICAgICAgIGNvbnN0IGRlbHRhID0gTWF0aC5hYnMoeCkgPiBNYXRoLmFicyh5KSA/IHggOiB5XG4gICAgICAgIGVsICYmIChlbC5zdHlsZS5vcGFjaXR5ID0gMSAtIE1hdGgubWluKE1hdGguYWJzKGRlbHRhIC8gKFRIUkVTSE9MRCAqIDEuNSkpLCAxKSlcbiAgICB9XG48L3NjcmlwdD5cblxuPHNlY3Rpb24gcm9sZT1cImJ1dHRvblwiIGNsYXNzPXtjbGFzc1Byb3BXcmFwfSBvbjpjbGljaz17b25DbGlja30+XG4gICAgPHNsb3Qge2FjdGl2ZX0+PC9zbG90PlxuPC9zZWN0aW9uPlxuXG57I2lmIGFjdGl2ZSAhPT0gbnVsbH1cbiAgICA8UG9ydGFsPlxuICAgICAgICA8c2VjdGlvblxuICAgICAgICAgICAgYmluZDp0aGlzPXtyZWZ9XG4gICAgICAgICAgICB1c2U6YWRkU3dpcGVcbiAgICAgICAgICAgIGNsYXNzPXtjbGFzc1Byb3B9XG4gICAgICAgID5cbiAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIG9uOmNsaWNrPXtvbkNsaWNrfT5cbiAgICAgICAgICAgICAgICA8SWNvbiB0eXBlPVwiY2xvc2VcIiBzaXplPVwiYmlnXCIgaXM9XCJsaWdodFwiLz5cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgeyNpZiBzbG90cy5ib3h9XG4gICAgICAgICAgICAgICAgPHNsb3QgbmFtZT1cImJveFwiPjwvc2xvdD5cbiAgICAgICAgICAgIHs6ZWxzZX1cbiAgICAgICAgICAgICAgICA8c2xvdD48L3Nsb3Q+XG4gICAgICAgICAgICB7L2lmfVxuICAgICAgICA8L3NlY3Rpb24+XG4gICAgPC9Qb3J0YWw+XG57L2lmfVxuXG48c3R5bGU+XG4uZmFuY3ktYm94IHtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgLXdlYmtpdC1ib3gtZmxleDogMDtcbiAgICAgICAgLW1zLWZsZXg6IG5vbmU7XG4gICAgICAgICAgICBmbGV4OiBub25lO1xuICAgIGRpc3BsYXk6IC13ZWJraXQtYm94O1xuICAgIGRpc3BsYXk6IC1tcy1mbGV4Ym94O1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAtbXMtZmxleC1pdGVtLWFsaWduOiBzdHJldGNoO1xuICAgICAgICBhbGlnbi1zZWxmOiBzdHJldGNoO1xuICAgIC13ZWJraXQtYm94LWFsaWduOiBzdHJldGNoO1xuICAgICAgICAtbXMtZmxleC1hbGlnbjogc3RyZXRjaDtcbiAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBzdHJldGNoO1xuICAgIC13ZWJraXQtYm94LXBhY2s6IHN0cmV0Y2g7XG4gICAgICAgIC1tcy1mbGV4LXBhY2s6IHN0cmV0Y2g7XG4gICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHN0cmV0Y2g7XG59XG5cbi5mYW5jeS1ib3gtZ2hvc3Qge1xuICAgIHotaW5kZXg6IDEwO1xuICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICB0b3A6IDA7XG4gICAgbGVmdDogMDtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBoZWlnaHQ6IDEwMCU7XG4gICAgZGlzcGxheTogLXdlYmtpdC1ib3g7XG4gICAgZGlzcGxheTogLW1zLWZsZXhib3g7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgIC13ZWJraXQtYm94LWFsaWduOiBzdHJldGNoO1xuICAgICAgICAtbXMtZmxleC1hbGlnbjogc3RyZXRjaDtcbiAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBzdHJldGNoO1xuICAgIC13ZWJraXQtYm94LXBhY2s6IGNlbnRlcjtcbiAgICAgICAgLW1zLWZsZXgtcGFjazogY2VudGVyO1xuICAgICAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgLXdlYmtpdC1ib3gtb3JpZW50OiB2ZXJ0aWNhbDtcbiAgICAtd2Via2l0LWJveC1kaXJlY3Rpb246IG5vcm1hbDtcbiAgICAgICAgLW1zLWZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcbiAgICAgICAgLW1zLXVzZXItc2VsZWN0OiBub25lO1xuICAgICAgICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgLW1zLXRvdWNoLWFjdGlvbjogbWFuaXB1bGF0aW9uO1xuICAgICAgICB0b3VjaC1hY3Rpb246IG1hbmlwdWxhdGlvbjtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKHZhcigtLWNvbG9yLWJsYWNrKSwgLjc1KTtcbiAgICBvdXRsaW5lOiAxNTBweCBzb2xpZCByZ2JhKHZhcigtLWNvbG9yLWJsYWNrKSwgLjc1KTtcbiAgICAtd2Via2l0LXRyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uOiBsaW5lYXI7XG4gICAgICAgICAgICB0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjogbGluZWFyO1xuICAgIG9wYWNpdHk6IDA7XG4gICAgcGFkZGluZzogMCB2YXIoLS1zY3JlZW4tcGFkZGluZyk7XG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsMzBweCwwKTtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwzMHB4LDApO1xuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgIHdpbGwtY2hhbmdlOiB0cmFuc2Zvcm0sIG9wYWNpdHk7XG59XG5cbi5mYW5jeS1ib3gtZ2hvc3QgPiAqIHtcbiAgICBtYXgtd2lkdGg6IDEwMCU7XG4gICAgbWF4LWhlaWdodDogMTAwJTtcbn1cblxuLmZhbmN5LWJveC1naG9zdC5hY3RpdmUge1xuICAgIG9wYWNpdHk6IDE7XG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsMCwwKTtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwwLDApO1xuICAgIHBvaW50ZXItZXZlbnRzOiBhdXRvO1xufVxuXG5idXR0b24ge1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB0b3A6IDA7XG4gICAgcmlnaHQ6IDA7XG4gICAgZm9udC1zaXplOiAyNHB4O1xuICAgIGRpc3BsYXk6IC13ZWJraXQtYm94O1xuICAgIGRpc3BsYXk6IC1tcy1mbGV4Ym94O1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgLXdlYmtpdC1ib3gtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgLW1zLWZsZXgtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgLXdlYmtpdC1ib3gtcGFjazogY2VudGVyO1xuICAgICAgICAtbXMtZmxleC1wYWNrOiBjZW50ZXI7XG4gICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICB3aWR0aDogNjBweDtcbiAgICBoZWlnaHQ6IDYwcHg7XG4gICAgY29sb3I6IHJnYih2YXIoLS1jb2xvci13aGl0ZSkpO1xufTwvc3R5bGU+XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBOEtBLFVBQVUsOEJBQUMsQ0FBQyxBQUNSLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLEtBQUssQ0FBRSxJQUFJLENBQ1gsZ0JBQWdCLENBQUUsQ0FBQyxDQUNmLFFBQVEsQ0FBRSxJQUFJLENBQ1YsSUFBSSxDQUFFLElBQUksQ0FDbEIsT0FBTyxDQUFFLFdBQVcsQ0FDcEIsT0FBTyxDQUFFLFdBQVcsQ0FDcEIsT0FBTyxDQUFFLElBQUksQ0FDYixRQUFRLENBQUUsTUFBTSxDQUNoQixtQkFBbUIsQ0FB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 */";
	append_dev(document.head, style);
}

const get_box_slot_changes = dirty => ({ active: dirty & /*active*/ 2 });
const get_box_slot_context = ctx => ({ active: /*active*/ ctx[1] });
const get_default_slot_changes$1 = dirty => ({ active: dirty & /*active*/ 2 });
const get_default_slot_context$1 = ctx => ({ active: /*active*/ ctx[1] });

// (155:0) {#if active !== null}
function create_if_block$5(ctx) {
	let portal;
	let current;

	portal = new Portal({
			props: {
				$$slots: { default: [create_default_slot$z] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(portal.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(portal.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(portal, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const portal_changes = {};

			if (dirty & /*$$scope, classProp, ref, active*/ 16391) {
				portal_changes.$$scope = { dirty, ctx };
			}

			portal.$set(portal_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(portal.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(portal.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(portal, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$5.name,
		type: "if",
		source: "(155:0) {#if active !== null}",
		ctx
	});

	return block;
}

// (167:12) {:else}
function create_else_block$2(ctx) {
	let current;
	const default_slot_template = /*$$slots*/ ctx[12].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[14], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		l: function claim(nodes) {
			if (default_slot) default_slot.l(nodes);
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 16384) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[14], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$2.name,
		type: "else",
		source: "(167:12) {:else}",
		ctx
	});

	return block;
}

// (165:12) {#if slots.box}
function create_if_block_1$3(ctx) {
	let current;
	const box_slot_template = /*$$slots*/ ctx[12].box;
	const box_slot = create_slot(box_slot_template, ctx, /*$$scope*/ ctx[14], get_box_slot_context);

	const block = {
		c: function create() {
			if (box_slot) box_slot.c();
		},
		l: function claim(nodes) {
			if (box_slot) box_slot.l(nodes);
		},
		m: function mount(target, anchor) {
			if (box_slot) {
				box_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (box_slot) {
				if (box_slot.p && dirty & /*$$scope, active*/ 16386) {
					update_slot(box_slot, box_slot_template, ctx, /*$$scope*/ ctx[14], dirty, get_box_slot_changes, get_box_slot_context);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(box_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(box_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (box_slot) box_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$3.name,
		type: "if",
		source: "(165:12) {#if slots.box}",
		ctx
	});

	return block;
}

// (156:4) <Portal>
function create_default_slot$z(ctx) {
	let section;
	let button;
	let icon;
	let t;
	let current_block_type_index;
	let if_block;
	let section_class_value;
	let addSwipe_action;
	let current;
	let mounted;
	let dispose;

	icon = new Icon({
			props: { type: "close", size: "big", is: "light" },
			$$inline: true
		});

	const if_block_creators = [create_if_block_1$3, create_else_block$2];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*slots*/ ctx[4].box) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			section = element("section");
			button = element("button");
			create_component(icon.$$.fragment);
			t = space();
			if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { class: true });
			var section_nodes = children(section);
			button = claim_element(section_nodes, "BUTTON", { type: true, class: true });
			var button_nodes = children(button);
			claim_component(icon.$$.fragment, button_nodes);
			button_nodes.forEach(detach_dev);
			t = claim_space(section_nodes);
			if_block.l(section_nodes);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(button, "type", "button");
			attr_dev(button, "class", "svelte-17mfy9g");
			add_location(button, file$L, 161, 12, 5781);
			attr_dev(section, "class", section_class_value = "" + (null_to_empty(/*classProp*/ ctx[2]) + " svelte-17mfy9g"));
			add_location(section, file$L, 156, 8, 5667);
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			append_dev(section, button);
			mount_component(icon, button, null);
			append_dev(section, t);
			if_blocks[current_block_type_index].m(section, null);
			/*section_binding*/ ctx[13](section);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(button, "click", /*onClick*/ ctx[5], false, false, false),
					action_destroyer(addSwipe_action = /*addSwipe*/ ctx[6].call(null, section))
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if_block.p(ctx, dirty);

			if (!current || dirty & /*classProp*/ 4 && section_class_value !== (section_class_value = "" + (null_to_empty(/*classProp*/ ctx[2]) + " svelte-17mfy9g"))) {
				attr_dev(section, "class", section_class_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			destroy_component(icon);
			if_blocks[current_block_type_index].d();
			/*section_binding*/ ctx[13](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$z.name,
		type: "slot",
		source: "(156:4) <Portal>",
		ctx
	});

	return block;
}

function create_fragment$L(ctx) {
	let section;
	let section_class_value;
	let t;
	let if_block_anchor;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*$$slots*/ ctx[12].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[14], get_default_slot_context$1);
	let if_block = /*active*/ ctx[1] !== null && create_if_block$5(ctx);

	const block = {
		c: function create() {
			section = element("section");
			if (default_slot) default_slot.c();
			t = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { role: true, class: true });
			var section_nodes = children(section);
			if (default_slot) default_slot.l(section_nodes);
			section_nodes.forEach(detach_dev);
			t = claim_space(nodes);
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			attr_dev(section, "role", "button");
			attr_dev(section, "class", section_class_value = "" + (null_to_empty(/*classPropWrap*/ ctx[3]) + " svelte-17mfy9g"));
			add_location(section, file$L, 150, 0, 5520);
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);

			if (default_slot) {
				default_slot.m(section, null);
			}

			insert_dev(target, t, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;

			if (!mounted) {
				dispose = listen_dev(section, "click", /*onClick*/ ctx[5], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope, active*/ 16386) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[14], dirty, get_default_slot_changes$1, get_default_slot_context$1);
				}
			}

			if (!current || dirty & /*classPropWrap*/ 8 && section_class_value !== (section_class_value = "" + (null_to_empty(/*classPropWrap*/ ctx[3]) + " svelte-17mfy9g"))) {
				attr_dev(section, "class", section_class_value);
			}

			if (/*active*/ ctx[1] !== null) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*active*/ 2) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$5(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			if (default_slot) default_slot.d(detaching);
			if (detaching) detach_dev(t);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$L.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const DURATION$2 = 250;
const THRESHOLD$1 = 50;
const SWIPE_SPEED$1 = 0.5;

function drawTransform$1(el, x, y) {
	const delta = Math.abs(x) > Math.abs(y) ? x : y;
	let scale = 1 - Math.abs(delta / window.innerHeight);
	el && (el.style.transform = `matrix(${scale}, 0, 0, ${scale}, ${x}, ${y})`);
}

function setDuration$1(el, ms) {
	el && (el.style.transitionDuration = `${ms}ms`);
}

function drawOpacity$1(el, x, y) {
	const delta = Math.abs(x) > Math.abs(y) ? x : y;
	el && (el.style.opacity = 1 - Math.min(Math.abs(delta / (THRESHOLD$1 * 1.5)), 1));
}

function instance$L($$self, $$props, $$invalidate) {
	const dispatch = createEventDispatcher();
	const START_POSITION = { x: 0, y: 20 };
	let { ref = null } = $$props;
	let { blockBody = true } = $$props;
	let { swipe = ["all"] } = $$props; // up down left right all
	let { disabled = false } = $$props;
	let { extraLock = false } = $$props;
	let { startPosition = START_POSITION } = $$props;
	let active = null;
	let slots = $$props.$$slots || {};

	async function onClick(e) {
		if (disabled) return;
		const newActive = !active;
		setActive(newActive);

		if (newActive) {
			drawTransform$1(ref, 0, 0);
		} else {
			drawTransform$1(ref, startPosition.x, startPosition.y);
		}
	}

	async function setActive(isActive) {
		$$invalidate(1, active = isActive);
		await tick();

		if (active) {
			setDuration$1(ref, DURATION$2);
			setTimeout(() => setDuration$1(ref, 0), DURATION$2);
			blockBody && disableScroll(ref, { extraLock });
			dispatch("open");
		} else {
			setDuration$1(ref, DURATION$2);
			blockBody && enableScroll(ref, { extraLock });
			dispatch("close");
		}
	}

	let xSwipe = 0;
	let ySwipe = 0;

	function addSwipe(el) {
		new Swipe(el).run().onUp(isSwipe.up ? handleVerticalSwipe : null).onDown(isSwipe.down ? handleVerticalSwipe : null).onLeft(isSwipe.left ? handleHorizontalSwipe : null).onRight(isSwipe.right ? handleHorizontalSwipe : null).onTouchEnd(async () => {
			if (xSwipe > THRESHOLD$1) {
				setDuration$1(ref, DURATION$2);
				setTimeout(() => setDuration$1(ref, 0), DURATION$2);
				setActive(false);
				drawTransform$1(el, xSwipe + 50, ySwipe);
				drawOpacity$1(el, xSwipe + 50, ySwipe);
				await delay(DURATION$2);
			} else if (xSwipe < -THRESHOLD$1) {
				setDuration$1(ref, DURATION$2);
				setTimeout(() => setDuration$1(ref, 0), DURATION$2);
				setActive(false);
				drawTransform$1(el, xSwipe - 50, ySwipe);
				drawOpacity$1(el, xSwipe - 50, ySwipe);
				await delay(DURATION$2);
			}

			if (ySwipe > THRESHOLD$1) {
				setDuration$1(ref, DURATION$2);
				setTimeout(() => setDuration$1(ref, 0), DURATION$2);
				setActive(false);
				drawTransform$1(el, xSwipe, ySwipe + 50);
				drawOpacity$1(el, xSwipe, ySwipe + 50);
				await delay(DURATION$2);
			} else if (ySwipe < -THRESHOLD$1) {
				setDuration$1(ref, DURATION$2);
				setTimeout(() => setDuration$1(ref, 0), DURATION$2);
				setActive(false);
				drawTransform$1(el, xSwipe, ySwipe - 50);
				drawOpacity$1(el, xSwipe, ySwipe - 50);
				await delay(DURATION$2);
			}

			if (xSwipe <= THRESHOLD$1 && xSwipe >= -THRESHOLD$1 && ySwipe <= THRESHOLD$1 && ySwipe >= -THRESHOLD$1) {
				setDuration$1(ref, DURATION$2);
				setTimeout(() => setDuration$1(ref, 0), DURATION$2);
				drawTransform$1(el, 0, 0);
			} else {
				drawTransform$1(el, startPosition.x, startPosition.y);
			}

			xSwipe = 0;
			ySwipe = 0;
			el.style.opacity = null;
		});
	}

	function handleVerticalSwipe(yDown, yUp, evt, el) {
		ySwipe = (yUp - yDown) * SWIPE_SPEED$1;
		drawTransform$1(el, xSwipe, ySwipe);
		drawOpacity$1(el, xSwipe, ySwipe);
	}

	function handleHorizontalSwipe(xDown, xUp, evt, el) {
		xSwipe = (xUp - xDown) * SWIPE_SPEED$1;
		drawTransform$1(el, xSwipe, ySwipe);
		drawOpacity$1(el, xSwipe, ySwipe);
	}

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("FancyBox", $$slots, ['default','box']);

	function section_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			ref = $$value;
			$$invalidate(0, ref);
		});
	}

	$$self.$set = $$new_props => {
		$$invalidate(23, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("ref" in $$new_props) $$invalidate(0, ref = $$new_props.ref);
		if ("blockBody" in $$new_props) $$invalidate(7, blockBody = $$new_props.blockBody);
		if ("swipe" in $$new_props) $$invalidate(8, swipe = $$new_props.swipe);
		if ("disabled" in $$new_props) $$invalidate(9, disabled = $$new_props.disabled);
		if ("extraLock" in $$new_props) $$invalidate(10, extraLock = $$new_props.extraLock);
		if ("startPosition" in $$new_props) $$invalidate(11, startPosition = $$new_props.startPosition);
		if ("$$scope" in $$new_props) $$invalidate(14, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		tick,
		fly,
		Swipe,
		classnames,
		delay,
		bodyScroll,
		safeGet,
		Icon,
		Portal,
		dispatch,
		DURATION: DURATION$2,
		THRESHOLD: THRESHOLD$1,
		SWIPE_SPEED: SWIPE_SPEED$1,
		START_POSITION,
		ref,
		blockBody,
		swipe,
		disabled,
		extraLock,
		startPosition,
		active,
		slots,
		onClick,
		setActive,
		xSwipe,
		ySwipe,
		addSwipe,
		handleVerticalSwipe,
		handleHorizontalSwipe,
		drawTransform: drawTransform$1,
		setDuration: setDuration$1,
		drawOpacity: drawOpacity$1,
		isSwipe,
		classProp,
		classPropWrap
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(23, $$props = assign(assign({}, $$props), $$new_props));
		if ("ref" in $$props) $$invalidate(0, ref = $$new_props.ref);
		if ("blockBody" in $$props) $$invalidate(7, blockBody = $$new_props.blockBody);
		if ("swipe" in $$props) $$invalidate(8, swipe = $$new_props.swipe);
		if ("disabled" in $$props) $$invalidate(9, disabled = $$new_props.disabled);
		if ("extraLock" in $$props) $$invalidate(10, extraLock = $$new_props.extraLock);
		if ("startPosition" in $$props) $$invalidate(11, startPosition = $$new_props.startPosition);
		if ("active" in $$props) $$invalidate(1, active = $$new_props.active);
		if ("slots" in $$props) $$invalidate(4, slots = $$new_props.slots);
		if ("xSwipe" in $$props) xSwipe = $$new_props.xSwipe;
		if ("ySwipe" in $$props) ySwipe = $$new_props.ySwipe;
		if ("isSwipe" in $$props) isSwipe = $$new_props.isSwipe;
		if ("classProp" in $$props) $$invalidate(2, classProp = $$new_props.classProp);
		if ("classPropWrap" in $$props) $$invalidate(3, classPropWrap = $$new_props.classPropWrap);
	};

	let isSwipe;
	let classProp;
	let classPropWrap;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*swipe*/ 256) {
			 isSwipe = {
				up: safeGet(() => swipe.includes("up") || swipe.includes("all")),
				down: safeGet(() => swipe.includes("down") || swipe.includes("all")),
				left: safeGet(() => swipe.includes("left") || swipe.includes("all")),
				right: safeGet(() => swipe.includes("right") || swipe.includes("all"))
			};
		}

		if ($$self.$$.dirty & /*active*/ 2) {
			 $$invalidate(2, classProp = classnames("fancy-box-ghost", { active }));
		}

		 $$invalidate(3, classPropWrap = classnames("fancy-box", $$props.class));
	};

	$$props = exclude_internal_props($$props);

	return [
		ref,
		active,
		classProp,
		classPropWrap,
		slots,
		onClick,
		addSwipe,
		blockBody,
		swipe,
		disabled,
		extraLock,
		startPosition,
		$$slots,
		section_binding,
		$$scope
	];
}

class FancyBox extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document.getElementById("svelte-17mfy9g-style")) add_css$c();

		init(this, options, instance$L, create_fragment$L, safe_not_equal, {
			ref: 0,
			blockBody: 7,
			swipe: 8,
			disabled: 9,
			extraLock: 10,
			startPosition: 11
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "FancyBox",
			options,
			id: create_fragment$L.name
		});
	}

	get ref() {
		throw new Error("<FancyBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ref(value) {
		throw new Error("<FancyBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get blockBody() {
		throw new Error("<FancyBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set blockBody(value) {
		throw new Error("<FancyBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get swipe() {
		throw new Error("<FancyBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set swipe(value) {
		throw new Error("<FancyBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<FancyBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<FancyBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get extraLock() {
		throw new Error("<FancyBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set extraLock(value) {
		throw new Error("<FancyBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get startPosition() {
		throw new Error("<FancyBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set startPosition(value) {
		throw new Error("<FancyBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/Carousel.svelte generated by Svelte v3.24.0 */

const { Error: Error_1 } = globals;
const file$M = "src/components/Carousel.svelte";

function add_css$d() {
	var style = element("style");
	style.id = "svelte-b7wi34-style";
	style.textContent = ".carousel.rounded.svelte-b7wi34.svelte-b7wi34>.carousel-inner.svelte-b7wi34.svelte-b7wi34{border-radius:var(--border-radius-big)}.carousel.svelte-b7wi34.svelte-b7wi34.svelte-b7wi34,.carousel-inner.svelte-b7wi34.svelte-b7wi34.svelte-b7wi34,.carousel-inner.svelte-b7wi34.svelte-b7wi34>li.svelte-b7wi34.svelte-b7wi34{position:relative;-webkit-box-flex:0;-ms-flex:none;flex:none;display:-webkit-box;display:-ms-flexbox;display:flex;overflow:hidden;text-align:left;-ms-flex-item-align:stretch;align-self:stretch;-webkit-box-align:stretch;-ms-flex-align:stretch;align-items:stretch;-webkit-box-pack:stretch;-ms-flex-pack:stretch;justify-content:stretch}.carousel.dots.dotsBelow.filled.svelte-b7wi34.svelte-b7wi34.svelte-b7wi34{padding-bottom:40px}.carousel.filled.svelte-b7wi34.svelte-b7wi34>.carousel-inner.svelte-b7wi34.svelte-b7wi34{background-color:transparent}.carousel.dotsBelow.svelte-b7wi34.svelte-b7wi34 .carousel-dots.svelte-b7wi34.svelte-b7wi34{bottom:0}.carousel.dotsBelow.svelte-b7wi34.svelte-b7wi34 .carousel-dots li.svelte-b7wi34.svelte-b7wi34{background-color:rgba(var(--theme-bg-color-opposite))}.carousel.stretch.svelte-b7wi34>.carousel-inner.svelte-b7wi34>.fluid.svelte-b7wi34{-webkit-box-flex:0;-ms-flex:none;flex:none;width:100%}.carousel.auto.svelte-b7wi34>.carousel-inner.svelte-b7wi34>.fluid.svelte-b7wi34{width:auto}.carousel.svelte-b7wi34.svelte-b7wi34.svelte-b7wi34{width:100%}.carousel.svelte-b7wi34.svelte-b7wi34>.carousel-inner.svelte-b7wi34.svelte-b7wi34{width:100%;overflow-y:hidden;overflow-x:scroll;background-color:rgba(var(--theme-bg-color-opposite), .04)}.carousel-dots.svelte-b7wi34.svelte-b7wi34.svelte-b7wi34{position:absolute;left:0;bottom:10px;width:100%;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;justify-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;pointer-events:none}.carousel-dots.svelte-b7wi34.svelte-b7wi34 li.svelte-b7wi34.svelte-b7wi34{position:relative;width:8px;height:8px;margin:5px;border-radius:50%;overflow:hidden;-webkit-box-shadow:var(--shadow-primary);box-shadow:var(--shadow-primary);background-color:rgba(var(--color-light))}.carousel-dots.svelte-b7wi34.svelte-b7wi34 li.svelte-b7wi34.svelte-b7wi34:not(.active){opacity:.5}.carousel-dots.svelte-b7wi34.svelte-b7wi34 li.active.svelte-b7wi34.svelte-b7wi34{-webkit-transform:scale(1.5);transform:scale(1.5)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2Fyb3VzZWwuc3ZlbHRlIiwic291cmNlcyI6WyJDYXJvdXNlbC5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBjcmVhdGVFdmVudERpc3BhdGNoZXIgfSBmcm9tICdzdmVsdGUnXG4gICAgaW1wb3J0IHsgd2FpdFVudGlsLCBjbGFzc25hbWVzIH0gZnJvbSAnQHV0aWxzJ1xuICAgIGltcG9ydCBQaWN0dXJlIGZyb20gJ0Bjb21wb25lbnRzL1BpY3R1cmUuc3ZlbHRlJ1xuICAgIGltcG9ydCBGYW5jeUJveCBmcm9tICdAY29tcG9uZW50cy9GYW5jeUJveC5zdmVsdGUnXG5cbiAgICBjb25zdCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEB0eXBlIHtudW1iZXIgfCB7XG4gICAgICogICAgIHNyYzogc3RyaW5nLFxuICAgICAqICAgICBzcmNCaWc6IHN0cmluZyxcbiAgICAgKiAgICAgYWx0OiBzdHJpbmcsXG4gICAgICogICAgIG9uQ2xpY2s/OiBmdW5jdGlvbixcbiAgICAgKiB9W119XG4gICAgICovXG4gICAgZXhwb3J0IGxldCBpdGVtcyA9IFtdXG4gICAgZXhwb3J0IGxldCBkb3RzID0gdHJ1ZVxuICAgIGV4cG9ydCBsZXQgZG90c0JlbG93ID0gdHJ1ZVxuICAgIGV4cG9ydCBsZXQgcm91bmRlZCA9IHRydWVcbiAgICBleHBvcnQgbGV0IHNpemUgPSAnc3RyZXRjaCdcbiAgICBleHBvcnQgbGV0IGluaXRJbmRleCA9IDBcbiAgICBleHBvcnQgbGV0IGRpc2FibGVGYW5jeSA9IGZhbHNlXG4gICAgZXhwb3J0IGxldCBzdG9wUHJvcGFnYXRpb24gPSB1bmRlZmluZWRcblxuICAgIGxldCBwYXJlbnQgPSBudWxsXG5cbiAgICAkOiBhY3RpdmVEb3QgPSBpbml0SW5kZXhcbiAgICAkOiBjbGFzc1Byb3AgPSBjbGFzc25hbWVzKCdjYXJvdXNlbCcsIHNpemUsICQkcHJvcHMuY2xhc3MsIHsgZG90cywgZG90c0JlbG93LCByb3VuZGVkLCBmaWxsZWQ6IGl0ZW1zICYmIGl0ZW1zLmxlbmd0aCB9KVxuICAgICQ6IHNldFNjcm9sbFBvc2l0aW9uKHBhcmVudCwgaW5pdEluZGV4KVxuXG4gICAgZnVuY3Rpb24gY2Fyb3VzZWwobm9kZSkge1xuICAgICAgICBub2RlLm9udG91Y2hzdGFydCA9IGUgPT4gc3RvcFByb3BhZ2F0aW9uICYmIChlLnN0b3BQcm9wYWdhdGlvbigpKVxuICAgICAgICBub2RlLm9udG91Y2htb3ZlID0gZSA9PiBzdG9wUHJvcGFnYXRpb24gJiYgKGUuc3RvcFByb3BhZ2F0aW9uKCkpXG4gICAgICAgIG5vZGUub250b3VjaGVuZCA9IGUgPT4gc3RvcFByb3BhZ2F0aW9uICYmIChlLnN0b3BQcm9wYWdhdGlvbigpKVxuXG4gICAgICAgIHBhcmVudCA9IG5vZGVcbiAgICAgICAgc2V0U2Nyb2xsUG9zaXRpb24obm9kZSwgYWN0aXZlRG90KVxuICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIG9uU2Nyb2xsKVxuICAgICAgICByZXR1cm4geyBcbiAgICAgICAgICAgIGRlc3Ryb3k6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIG9uU2Nyb2xsKVxuICAgICAgICAgICAgICAgIG5vZGUub250b3VjaHN0YXJ0PSBudWxsXG4gICAgICAgICAgICAgICAgbm9kZS5vbnRvdWNobW92ZT0gbnVsbFxuICAgICAgICAgICAgICAgIG5vZGUub250b3VjaGVuZD0gbnVsbFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25TY3JvbGwoZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZ2V0QWN0aXZlRG90KGUudGFyZ2V0KVxuICAgICAgICB9IGNhdGNoIChlcnIpIHsgY29uc29sZS53YXJuKCdDYXJvdXNlbCBkb2VzIG5vdCB3b3JrLicsIGVycikgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEFjdGl2ZURvdChwYXJlbnQpIHtcbiAgICAgICAgY29uc3QgeyBzY3JvbGxMZWZ0LCBzY3JvbGxXaWR0aCwgb2Zmc2V0V2lkdGggfSA9IHBhcmVudFxuICAgICAgICBjb25zdCBkb3RBbW91bnQgPSBBcnJheS5mcm9tKHBhcmVudC5jaGlsZHJlbikubGVuZ3RoXG4gICAgICAgIGNvbnN0IHNjcm9sbFggPSBzY3JvbGxMZWZ0IC8gKHNjcm9sbFdpZHRoIC0gb2Zmc2V0V2lkdGgpXG4gICAgICAgIGNvbnN0IG5ld0FjdGl2ZURvdCA9IE1hdGgucm91bmQoc2Nyb2xsWCAqIChkb3RBbW91bnQgLSAxKSlcbiAgICAgICAgaWYgKGFjdGl2ZURvdCAhPT0gbmV3QWN0aXZlRG90ICYmICFpc05hTihuZXdBY3RpdmVEb3QpKSBhY3RpdmVEb3QgPSBuZXdBY3RpdmVEb3RcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRTY3JvbGxQb3NpdGlvbihwYXJlbnQsIGFjdGl2ZURvdCkge1xuICAgICAgICBpZiAoIXBhcmVudCkgcmV0dXJuXG4gICAgICAgIGNvbnN0IHsgd2lkdGggfSA9IHBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgICB3YWl0VW50aWwoKCkgPT4ge1xuICAgICAgICAgICAgcGFyZW50LnNjcm9sbExlZnQgPSBNYXRoLnJvdW5kKHdpZHRoICogYWN0aXZlRG90KVxuICAgICAgICAgICAgaWYgKHBhcmVudC5zY3JvbGxMZWZ0ICE9PSBNYXRoLnJvdW5kKHdpZHRoICogYWN0aXZlRG90KSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBzZXQuJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgeyBpbnRlcnZhbDogNTAgfSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkNsaWNrKGl0ZW0sIGluZGV4LCBlKSB7XG4gICAgICAgIGRpc3BhdGNoKCdjbGljaycsIHsgaXRlbSwgaW5kZXgsIGUgfSlcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtLm9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIGl0ZW0ub25DbGljayhpdGVtLCBpbmRleCwgZSlcbiAgICB9XG5cbjwvc2NyaXB0PlxuXG48c2VjdGlvbiBhcmlhLWxhYmVsPVwiY2Fyb3VzZWxcIiBjbGFzcz17Y2xhc3NQcm9wfT5cbiAgICA8dWwgXG4gICAgICAgIHVzZTpjYXJvdXNlbFxuICAgICAgICBjbGFzcz1cImNhcm91c2VsLWlubmVyIHNjcm9sbC14LWNlbnRlclwiXG4gICAgPlxuICAgICAgICB7I2lmIGl0ZW1zICE9PSBudWxsfVxuICAgICAgICAgICAgeyNlYWNoIGl0ZW1zIGFzIGl0ZW0sIGluZGV4fVxuICAgICAgICAgICAgICAgIDxsaSBjbGFzcz1cImZsdWlkXCIgcm9sZT1cImJ1dHRvblwiIG9uOmNsaWNrPXtvbkNsaWNrLmJpbmQobnVsbCwgaXRlbSwgaW5kZXgpfT5cbiAgICAgICAgICAgICAgICAgICAgPHNsb3Qge2l0ZW19IHtpbmRleH0+XG4gICAgICAgICAgICAgICAgICAgICAgICA8RmFuY3lCb3ggZGlzYWJsZWQ9e2Rpc2FibGVGYW5jeX0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPFBpY3R1cmUga2V5PVwicGljdHVyZVwiIHsuLi5pdGVtfSBhbHQ9e2l0ZW0uYWx0IHx8ICfQpNC+0YLQviDRgdC70LDQudC00YMnfS8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNlY3Rpb24gc2xvdD1cImJveFwiIGNsYXNzPVwiZmxleCBmdWxsLXdpZHRoXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxQaWN0dXJlIGtleT1cInBpY3R1cmVcIiB7Li4uaXRlbX0gYWx0PXtpdGVtLmFsdCB8fCAn0KTQvtGC0L4g0YHQu9Cw0LnQtNGDJ30vPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc2VjdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvRmFuY3lCb3g+XG4gICAgICAgICAgICAgICAgICAgIDwvc2xvdD5cbiAgICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgey9lYWNofVxuICAgICAgICB7L2lmfVxuICAgIDwvdWw+XG5cblxuICAgIHsjaWYgZG90cyAmJiBBcnJheS5pc0FycmF5KGl0ZW1zKX1cbiAgICAgICAgPHVsIGNsYXNzPVwiY2Fyb3VzZWwtZG90c1wiPlxuICAgICAgICAgICAgeyNlYWNoIGl0ZW1zIGFzIF9pdGVtLCBpfVxuICAgICAgICAgICAgICAgIDxsaSBjbGFzcz17aSA9PT0gYWN0aXZlRG90ID8gJ2FjdGl2ZScgOiAnJ30+PC9saT5cbiAgICAgICAgICAgIHsvZWFjaH1cbiAgICAgICAgPC91bD5cbiAgICB7L2lmfVxuPC9zZWN0aW9uPlxuXG48c3R5bGU+XG4uY2Fyb3VzZWwucm91bmRlZCA+IC5jYXJvdXNlbC1pbm5lciB7XG4gICBib3JkZXItcmFkaXVzOiB2YXIoLS1ib3JkZXItcmFkaXVzLWJpZyk7XG59XG5cbi5jYXJvdXNlbCwgLmNhcm91c2VsLWlubmVyLCAuY2Fyb3VzZWwtaW5uZXIgPiBsaSB7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIC13ZWJraXQtYm94LWZsZXg6IDA7XG4gICAgICAgIC1tcy1mbGV4OiBub25lO1xuICAgICAgICAgICAgZmxleDogbm9uZTtcbiAgICBkaXNwbGF5OiAtd2Via2l0LWJveDtcbiAgICBkaXNwbGF5OiAtbXMtZmxleGJveDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgdGV4dC1hbGlnbjogbGVmdDtcbiAgICAtbXMtZmxleC1pdGVtLWFsaWduOiBzdHJldGNoO1xuICAgICAgICBhbGlnbi1zZWxmOiBzdHJldGNoO1xuICAgIC13ZWJraXQtYm94LWFsaWduOiBzdHJldGNoO1xuICAgICAgICAtbXMtZmxleC1hbGlnbjogc3RyZXRjaDtcbiAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBzdHJldGNoO1xuICAgIC13ZWJraXQtYm94LXBhY2s6IHN0cmV0Y2g7XG4gICAgICAgIC1tcy1mbGV4LXBhY2s6IHN0cmV0Y2g7XG4gICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHN0cmV0Y2g7XG59XG5cbi5jYXJvdXNlbC5kb3RzLmRvdHNCZWxvdy5maWxsZWQge1xuICAgIHBhZGRpbmctYm90dG9tOiA0MHB4O1xufVxuXG4uY2Fyb3VzZWwuZmlsbGVkID4gLmNhcm91c2VsLWlubmVyIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcbn1cblxuLmNhcm91c2VsLmRvdHNCZWxvdyAuY2Fyb3VzZWwtZG90cyB7XG4gICAgYm90dG9tOiAwO1xufVxuXG4uY2Fyb3VzZWwuZG90c0JlbG93IC5jYXJvdXNlbC1kb3RzIGxpIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKHZhcigtLXRoZW1lLWJnLWNvbG9yLW9wcG9zaXRlKSk7XG59XG5cbi5jYXJvdXNlbC5zdHJldGNoID4gLmNhcm91c2VsLWlubmVyID4gLmZsdWlkIHtcbiAgICAtd2Via2l0LWJveC1mbGV4OiAwO1xuICAgICAgICAtbXMtZmxleDogbm9uZTtcbiAgICAgICAgICAgIGZsZXg6IG5vbmU7XG4gICAgd2lkdGg6IDEwMCU7XG59XG5cbi5jYXJvdXNlbC5hdXRvID4gLmNhcm91c2VsLWlubmVyID4gLmZsdWlkIHtcbiAgICB3aWR0aDogYXV0bztcbn1cblxuLmNhcm91c2VsIHtcbiAgICB3aWR0aDogMTAwJTtcbn1cblxuLyogM2Qgb3V0IGZvciBnb29kIGFjY2Vzc2liaWxpdHkgb2YgZGVza3RvcCBicm93cyBvZiBkZXNrdG9wIGJyb3dzZXJzICovXG4vKi5jYXJvdXNlbC1pbm5lcjo6LXdlYmtpdC1zY3JvbGxiYXIgeyovXG4vKiAgICBkaXNwbGF5OiBub25lOyovXG4vKn0qL1xuXG4uY2Fyb3VzZWwgPiAuY2Fyb3VzZWwtaW5uZXIge1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIG92ZXJmbG93LXk6IGhpZGRlbjtcbiAgICBvdmVyZmxvdy14OiBzY3JvbGw7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSh2YXIoLS10aGVtZS1iZy1jb2xvci1vcHBvc2l0ZSksIC4wNCk7XG59XG5cbi5jYXJvdXNlbC1kb3RzIHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgbGVmdDogMDtcbiAgICBib3R0b206IDEwcHg7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgZGlzcGxheTogLXdlYmtpdC1ib3g7XG4gICAgZGlzcGxheTogLW1zLWZsZXhib3g7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICAtd2Via2l0LWJveC1hbGlnbjogY2VudGVyO1xuICAgICAgICAtbXMtZmxleC1hbGlnbjogY2VudGVyO1xuICAgICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBqdXN0aWZ5LWl0ZW1zOiBjZW50ZXI7XG4gICAgLXdlYmtpdC1ib3gtcGFjazogY2VudGVyO1xuICAgICAgICAtbXMtZmxleC1wYWNrOiBjZW50ZXI7XG4gICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbn1cblxuLmNhcm91c2VsLWRvdHMgbGkge1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICB3aWR0aDogOHB4O1xuICAgIGhlaWdodDogOHB4O1xuICAgIG1hcmdpbjogNXB4O1xuICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgIC13ZWJraXQtYm94LXNoYWRvdzogdmFyKC0tc2hhZG93LXByaW1hcnkpO1xuICAgICAgICAgICAgYm94LXNoYWRvdzogdmFyKC0tc2hhZG93LXByaW1hcnkpO1xuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEodmFyKC0tY29sb3ItbGlnaHQpKTtcbn1cblxuLmNhcm91c2VsLWRvdHMgbGk6bm90KC5hY3RpdmUpIHtcbiAgICBvcGFjaXR5OiAuNTtcbn1cblxuLmNhcm91c2VsLWRvdHMgbGkuYWN0aXZlIHtcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMS41KTtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMS41KTtcbn08L3N0eWxlPlxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQWtIQSxTQUFTLG9DQUFRLENBQUcsZUFBZSw0QkFBQyxDQUFDLEFBQ2xDLGFBQWEsQ0FBRSxJQUFJLG1CQUFtQixDQUFDLEFBQzFDLENBQUMsQUFFRCxtREFBUyxDQUFFLHlEQUFlLENBQUUsMkNBQWUsQ0FBRyxFQUFFLDRCQUFDLENBQUMsQUFDOUMsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsZ0JBQWdCLENBQUUsQ0FBQyxDQUNmLFFBQVEsQ0FBRSxJQUFJLENBQ1YsSUFBSSxDQUFFLElBQUksQ0FDbEIsT0FBTyxDQUFFLFdBQVcsQ0FDcEIsT0FBTyxDQUFFLFdBQVcsQ0FDcEIsT0FBTyxDQUFFLElBQUksQ0FDYixRQUFRLENBQUUsTUFBTSxDQUNoQixVQUFVLENBQUUsSUFBSSxDQUNoQixtQkFBbUIsQ0FBRSxPQUFPLENBQ3hCLFVBQVUsQ0FBRSxPQUFPLENBQ3ZCLGlCQUFpQixDQUFFLE9BQU8sQ0FDdEIsY0FBYyxDQUFFLE9BQU8sQ0FDbkIsV0FBVyxDQUFFLE9BQU8sQ0FDNUIsZ0JBQWdCLENBQUUsT0FBTyxDQUNyQixhQUFhLENBQUUsT0FBTyxDQUNsQixlQUFlLENBQUUsT0FBTyxBQUNwQyxDQUFDLEFBRUQsU0FBUyxLQUFLLFVBQVUsT0FBTywwQ0FBQyxDQUFDLEFBQzdCLGNBQWMsQ0FBRSxJQUFJLEFBQ3hCLENBQUMsQUFFRCxTQUFTLG1DQUFPLENBQUcsZUFBZSw0QkFBQyxDQUFDLEFBQ2hDLGdCQUFnQixDQUFFLFdBQVcsQUFDakMsQ0FBQyxBQUVELFNBQVMsc0NBQVUsQ0FBQyxjQUFjLDRCQUFDLENBQUMsQUFDaEMsTUFBTSxDQUFFLENBQUMsQUFDYixDQUFDLEFBRUQsU0FBUyxzQ0FBVSxDQUFDLGNBQWMsQ0FBQyxFQUFFLDRCQUFDLENBQUMsQUFDbkMsZ0JBQWdCLENBQUUsS0FBSyxJQUFJLHlCQUF5QixDQUFDLENBQUMsQUFDMUQsQ0FBQyxBQUVELFNBQVMsc0JBQVEsQ0FBRyw2QkFBZSxDQUFHLE1BQU0sY0FBQyxDQUFDLEFBQzFDLGdCQUFnQixDQUFFLENBQUMsQ0FDZixRQUFRLENBQUUsSUFBSSxDQUNWLElBQUksQ0FBRSxJQUFJLENBQ2xCLEtBQUssQ0FBRSxJQUFJLEFBQ2YsQ0FBQyxBQUVELFNBQVMsbUJBQUssQ0FBRyw2QkFBZSxDQUFHLE1BQU0sY0FBQyxDQUFDLEFBQ3ZDLEtBQUssQ0FBRSxJQUFJLEFBQ2YsQ0FBQyxBQUVELFNBQVMsMENBQUMsQ0FBQyxBQUNQLEtBQUssQ0FBRSxJQUFJLEFBQ2YsQ0FBQyxBQU9ELHFDQUFTLENBQUcsZUFBZSw0QkFBQyxDQUFDLEFBQ3pCLEtBQUssQ0FBRSxJQUFJLENBQ1gsVUFBVSxDQUFFLE1BQU0sQ0FDbEIsVUFBVSxDQUFFLE1BQU0sQ0FDbEIsZ0JBQWdCLENBQUUsS0FBSyxJQUFJLHlCQUF5QixDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQUFDL0QsQ0FBQyxBQUVELGNBQWMsMENBQUMsQ0FBQyxBQUNaLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLElBQUksQ0FBRSxDQUFDLENBQ1AsTUFBTSxDQUFFLElBQUksQ0FDWixLQUFLLENBQUUsSUFBSSxDQUNYLE9BQU8sQ0FBRSxXQUFXLENBQ3BCLE9BQU8sQ0FBRSxXQUFXLENBQ3BCLE9BQU8sQ0FBRSxJQUFJLENBQ2IsaUJBQWlCLENBQUUsTUFBTSxDQUNyQixjQUFjLENBQUUsTUFBTSxDQUNsQixXQUFXLENBQUUsTUFBTSxDQUMzQixhQUFhLENBQUUsTUFBTSxDQUNyQixnQkFBZ0IsQ0FBRSxNQUFNLENBQ3BCLGFBQWEsQ0FBRSxNQUFNLENBQ2pCLGVBQWUsQ0FBRSxNQUFNLENBQy9CLGNBQWMsQ0FBRSxJQUFJLEFBQ3hCLENBQUMsQUFFRCwwQ0FBYyxDQUFDLEVBQUUsNEJBQUMsQ0FBQyxBQUNmLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLEtBQUssQ0FBRSxHQUFHLENBQ1YsTUFBTSxDQUFFLEdBQUcsQ0FDWCxNQUFNLENBQUUsR0FBRyxDQUNYLGFBQWEsQ0FBRSxHQUFHLENBQ2xCLFFBQVEsQ0FBRSxNQUFNLENBQ2hCLGtCQUFrQixDQUFFLElBQUksZ0JBQWdCLENBQUMsQ0FDakMsVUFBVSxDQUFFLElBQUksZ0JBQWdCLENBQUMsQ0FDekMsZ0JBQWdCLENBQUUsS0FBSyxJQUFJLGFBQWEsQ0FBQyxDQUFDLEFBQzlDLENBQUMsQUFFRCwwQ0FBYyxDQUFDLDhCQUFFLEtBQUssT0FBTyxDQUFDLEFBQUMsQ0FBQyxBQUM1QixPQUFPLENBQUUsRUFBRSxBQUNmLENBQUMsQUFFRCwwQ0FBYyxDQUFDLEVBQUUsT0FBTyw0QkFBQyxDQUFDLEFBQ3RCLGlCQUFpQixDQUFFLE1BQU0sR0FBRyxDQUFDLENBQ3JCLFNBQVMsQ0FBRSxNQUFNLEdBQUcsQ0FBQyxBQUNqQyxDQUFDIn0= */";
	append_dev(document.head, style);
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[20] = list[i];
	child_ctx[22] = i;
	return child_ctx;
}

const get_default_slot_changes$2 = dirty => ({ item: dirty & /*items*/ 1 });

const get_default_slot_context$2 = ctx => ({
	item: /*item*/ ctx[23],
	index: /*index*/ ctx[25]
});

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[23] = list[i];
	child_ctx[25] = i;
	return child_ctx;
}

// (88:8) {#if items !== null}
function create_if_block_1$4(ctx) {
	let each_1_anchor;
	let current;
	let each_value_1 = /*items*/ ctx[0];
	validate_each_argument(each_value_1);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty & /*onClick, items, disableFancy, $$scope*/ 8261) {
				each_value_1 = /*items*/ ctx[0];
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value_1.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$4.name,
		type: "if",
		source: "(88:8) {#if items !== null}",
		ctx
	});

	return block;
}

// (94:28) <section slot="box" class="flex full-width">
function create_box_slot(ctx) {
	let section;
	let picture;
	let current;

	const picture_spread_levels = [
		{ key: "picture" },
		/*item*/ ctx[23],
		{
			alt: /*item*/ ctx[23].alt || "Фото слайду"
		}
	];

	let picture_props = {};

	for (let i = 0; i < picture_spread_levels.length; i += 1) {
		picture_props = assign(picture_props, picture_spread_levels[i]);
	}

	picture = new Picture({ props: picture_props, $$inline: true });

	const block = {
		c: function create() {
			section = element("section");
			create_component(picture.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { slot: true, class: true });
			var section_nodes = children(section);
			claim_component(picture.$$.fragment, section_nodes);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(section, "slot", "box");
			attr_dev(section, "class", "flex full-width");
			add_location(section, file$M, 93, 28, 3160);
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			mount_component(picture, section, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const picture_changes = (dirty & /*items*/ 1)
			? get_spread_update(picture_spread_levels, [
					picture_spread_levels[0],
					get_spread_object(/*item*/ ctx[23]),
					{
						alt: /*item*/ ctx[23].alt || "Фото слайду"
					}
				])
			: {};

			picture.$set(picture_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(picture.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(picture.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			destroy_component(picture);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_box_slot.name,
		type: "slot",
		source: "(94:28) <section slot=\\\"box\\\" class=\\\"flex full-width\\\">",
		ctx
	});

	return block;
}

// (92:24) <FancyBox disabled={disableFancy}>
function create_default_slot$A(ctx) {
	let picture;
	let t;
	let current;

	const picture_spread_levels = [
		{ key: "picture" },
		/*item*/ ctx[23],
		{
			alt: /*item*/ ctx[23].alt || "Фото слайду"
		}
	];

	let picture_props = {};

	for (let i = 0; i < picture_spread_levels.length; i += 1) {
		picture_props = assign(picture_props, picture_spread_levels[i]);
	}

	picture = new Picture({ props: picture_props, $$inline: true });

	const block = {
		c: function create() {
			create_component(picture.$$.fragment);
			t = space();
		},
		l: function claim(nodes) {
			claim_component(picture.$$.fragment, nodes);
			t = claim_space(nodes);
		},
		m: function mount(target, anchor) {
			mount_component(picture, target, anchor);
			insert_dev(target, t, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const picture_changes = (dirty & /*items*/ 1)
			? get_spread_update(picture_spread_levels, [
					picture_spread_levels[0],
					get_spread_object(/*item*/ ctx[23]),
					{
						alt: /*item*/ ctx[23].alt || "Фото слайду"
					}
				])
			: {};

			picture.$set(picture_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(picture.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(picture.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(picture, detaching);
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$A.name,
		type: "slot",
		source: "(92:24) <FancyBox disabled={disableFancy}>",
		ctx
	});

	return block;
}

// (91:41)                          
function fallback_block$1(ctx) {
	let fancybox;
	let current;

	fancybox = new FancyBox({
			props: {
				disabled: /*disableFancy*/ ctx[2],
				$$slots: {
					default: [create_default_slot$A],
					box: [create_box_slot]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(fancybox.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(fancybox.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(fancybox, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const fancybox_changes = {};
			if (dirty & /*disableFancy*/ 4) fancybox_changes.disabled = /*disableFancy*/ ctx[2];

			if (dirty & /*$$scope, items*/ 8193) {
				fancybox_changes.$$scope = { dirty, ctx };
			}

			fancybox.$set(fancybox_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(fancybox.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(fancybox.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(fancybox, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: fallback_block$1.name,
		type: "fallback",
		source: "(91:41)                          ",
		ctx
	});

	return block;
}

// (89:12) {#each items as item, index}
function create_each_block_1(ctx) {
	let li;
	let t;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*$$slots*/ ctx[12].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[13], get_default_slot_context$2);
	const default_slot_or_fallback = default_slot || fallback_block$1(ctx);

	const block = {
		c: function create() {
			li = element("li");
			if (default_slot_or_fallback) default_slot_or_fallback.c();
			t = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true, role: true });
			var li_nodes = children(li);
			if (default_slot_or_fallback) default_slot_or_fallback.l(li_nodes);
			t = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(li, "class", "fluid svelte-b7wi34");
			attr_dev(li, "role", "button");
			add_location(li, file$M, 89, 16, 2860);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);

			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(li, null);
			}

			append_dev(li, t);
			current = true;

			if (!mounted) {
				dispose = listen_dev(
					li,
					"click",
					function () {
						if (is_function(/*onClick*/ ctx[6].bind(null, /*item*/ ctx[23], /*index*/ ctx[25]))) /*onClick*/ ctx[6].bind(null, /*item*/ ctx[23], /*index*/ ctx[25]).apply(this, arguments);
					},
					false,
					false,
					false
				);

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope, items*/ 8193) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[13], dirty, get_default_slot_changes$2, get_default_slot_context$2);
				}
			} else {
				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*disableFancy, items*/ 5) {
					default_slot_or_fallback.p(ctx, dirty);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot_or_fallback, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot_or_fallback, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1.name,
		type: "each",
		source: "(89:12) {#each items as item, index}",
		ctx
	});

	return block;
}

// (105:4) {#if dots && Array.isArray(items)}
function create_if_block$6(ctx) {
	let ul;
	let each_value = /*items*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(ul_nodes);
			}

			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(ul, "class", "carousel-dots svelte-b7wi34");
			add_location(ul, file$M, 105, 8, 3522);
		},
		m: function mount(target, anchor) {
			insert_dev(target, ul, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*activeDot, items*/ 9) {
				each_value = /*items*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(ul, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(ul);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$6.name,
		type: "if",
		source: "(105:4) {#if dots && Array.isArray(items)}",
		ctx
	});

	return block;
}

// (107:12) {#each items as _item, i}
function create_each_block(ctx) {
	let li;
	let li_class_value;

	const block = {
		c: function create() {
			li = element("li");
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true });
			children(li).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(li, "class", li_class_value = "" + (null_to_empty(/*i*/ ctx[22] === /*activeDot*/ ctx[3] ? "active" : "") + " svelte-b7wi34"));
			add_location(li, file$M, 107, 16, 3603);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*activeDot*/ 8 && li_class_value !== (li_class_value = "" + (null_to_empty(/*i*/ ctx[22] === /*activeDot*/ ctx[3] ? "active" : "") + " svelte-b7wi34"))) {
				attr_dev(li, "class", li_class_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(107:12) {#each items as _item, i}",
		ctx
	});

	return block;
}

function create_fragment$M(ctx) {
	let section;
	let ul;
	let carousel_action;
	let t;
	let show_if = /*dots*/ ctx[1] && Array.isArray(/*items*/ ctx[0]);
	let section_class_value;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*items*/ ctx[0] !== null && create_if_block_1$4(ctx);
	let if_block1 = show_if && create_if_block$6(ctx);

	const block = {
		c: function create() {
			section = element("section");
			ul = element("ul");
			if (if_block0) if_block0.c();
			t = space();
			if (if_block1) if_block1.c();
			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { "aria-label": true, class: true });
			var section_nodes = children(section);
			ul = claim_element(section_nodes, "UL", { class: true });
			var ul_nodes = children(ul);
			if (if_block0) if_block0.l(ul_nodes);
			ul_nodes.forEach(detach_dev);
			t = claim_space(section_nodes);
			if (if_block1) if_block1.l(section_nodes);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(ul, "class", "carousel-inner scroll-x-center svelte-b7wi34");
			add_location(ul, file$M, 83, 4, 2695);
			attr_dev(section, "aria-label", "carousel");
			attr_dev(section, "class", section_class_value = "" + (null_to_empty(/*classProp*/ ctx[4]) + " svelte-b7wi34"));
			add_location(section, file$M, 82, 0, 2641);
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			append_dev(section, ul);
			if (if_block0) if_block0.m(ul, null);
			append_dev(section, t);
			if (if_block1) if_block1.m(section, null);
			current = true;

			if (!mounted) {
				dispose = action_destroyer(carousel_action = /*carousel*/ ctx[5].call(null, ul));
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*items*/ ctx[0] !== null) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*items*/ 1) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_1$4(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(ul, null);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (dirty & /*dots, items*/ 3) show_if = /*dots*/ ctx[1] && Array.isArray(/*items*/ ctx[0]);

			if (show_if) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block$6(ctx);
					if_block1.c();
					if_block1.m(section, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (!current || dirty & /*classProp*/ 16 && section_class_value !== (section_class_value = "" + (null_to_empty(/*classProp*/ ctx[4]) + " svelte-b7wi34"))) {
				attr_dev(section, "class", section_class_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$M.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$M($$self, $$props, $$invalidate) {
	const dispatch = createEventDispatcher();
	let { items = [] } = $$props;
	let { dots = true } = $$props;
	let { dotsBelow = true } = $$props;
	let { rounded = true } = $$props;
	let { size = "stretch" } = $$props;
	let { initIndex = 0 } = $$props;
	let { disableFancy = false } = $$props;
	let { stopPropagation = undefined } = $$props;
	let parent = null;

	function carousel(node) {
		node.ontouchstart = e => stopPropagation && e.stopPropagation();
		node.ontouchmove = e => stopPropagation && e.stopPropagation();
		node.ontouchend = e => stopPropagation && e.stopPropagation();
		$$invalidate(14, parent = node);
		setScrollPosition(node, activeDot);
		node.addEventListener("scroll", onScroll);

		return {
			destroy: () => {
				node.removeEventListener("scroll", onScroll);
				node.ontouchstart = null;
				node.ontouchmove = null;
				node.ontouchend = null;
			}
		};
	}

	function onScroll(e) {
		try {
			getActiveDot(e.target);
		} catch(err) {
			console.warn("Carousel does not work.", err);
		}
	}

	function getActiveDot(parent) {
		const { scrollLeft, scrollWidth, offsetWidth } = parent;
		const dotAmount = Array.from(parent.children).length;
		const scrollX = scrollLeft / (scrollWidth - offsetWidth);
		const newActiveDot = Math.round(scrollX * (dotAmount - 1));
		if (activeDot !== newActiveDot && !isNaN(newActiveDot)) $$invalidate(3, activeDot = newActiveDot);
	}

	function setScrollPosition(parent, activeDot) {
		if (!parent) return;
		const { width } = parent.getBoundingClientRect();

		waitUntil(
			() => {
				parent.scrollLeft = Math.round(width * activeDot);

				if (parent.scrollLeft !== Math.round(width * activeDot)) {
					throw new Error("Not set.");
				}
			},
			{ interval: 50 }
		);
	}

	function onClick(item, index, e) {
		dispatch("click", { item, index, e });
		if (typeof item.onClick === "function") item.onClick(item, index, e);
	}

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Carousel", $$slots, ['default']);

	$$self.$set = $$new_props => {
		$$invalidate(19, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("items" in $$new_props) $$invalidate(0, items = $$new_props.items);
		if ("dots" in $$new_props) $$invalidate(1, dots = $$new_props.dots);
		if ("dotsBelow" in $$new_props) $$invalidate(7, dotsBelow = $$new_props.dotsBelow);
		if ("rounded" in $$new_props) $$invalidate(8, rounded = $$new_props.rounded);
		if ("size" in $$new_props) $$invalidate(9, size = $$new_props.size);
		if ("initIndex" in $$new_props) $$invalidate(10, initIndex = $$new_props.initIndex);
		if ("disableFancy" in $$new_props) $$invalidate(2, disableFancy = $$new_props.disableFancy);
		if ("stopPropagation" in $$new_props) $$invalidate(11, stopPropagation = $$new_props.stopPropagation);
		if ("$$scope" in $$new_props) $$invalidate(13, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		waitUntil,
		classnames,
		Picture,
		FancyBox,
		dispatch,
		items,
		dots,
		dotsBelow,
		rounded,
		size,
		initIndex,
		disableFancy,
		stopPropagation,
		parent,
		carousel,
		onScroll,
		getActiveDot,
		setScrollPosition,
		onClick,
		activeDot,
		classProp
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(19, $$props = assign(assign({}, $$props), $$new_props));
		if ("items" in $$props) $$invalidate(0, items = $$new_props.items);
		if ("dots" in $$props) $$invalidate(1, dots = $$new_props.dots);
		if ("dotsBelow" in $$props) $$invalidate(7, dotsBelow = $$new_props.dotsBelow);
		if ("rounded" in $$props) $$invalidate(8, rounded = $$new_props.rounded);
		if ("size" in $$props) $$invalidate(9, size = $$new_props.size);
		if ("initIndex" in $$props) $$invalidate(10, initIndex = $$new_props.initIndex);
		if ("disableFancy" in $$props) $$invalidate(2, disableFancy = $$new_props.disableFancy);
		if ("stopPropagation" in $$props) $$invalidate(11, stopPropagation = $$new_props.stopPropagation);
		if ("parent" in $$props) $$invalidate(14, parent = $$new_props.parent);
		if ("activeDot" in $$props) $$invalidate(3, activeDot = $$new_props.activeDot);
		if ("classProp" in $$props) $$invalidate(4, classProp = $$new_props.classProp);
	};

	let activeDot;
	let classProp;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*initIndex*/ 1024) {
			 $$invalidate(3, activeDot = initIndex);
		}

		 $$invalidate(4, classProp = classnames("carousel", size, $$props.class, {
			dots,
			dotsBelow,
			rounded,
			filled: items && items.length
		}));

		if ($$self.$$.dirty & /*parent, initIndex*/ 17408) {
			 setScrollPosition(parent, initIndex);
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		items,
		dots,
		disableFancy,
		activeDot,
		classProp,
		carousel,
		onClick,
		dotsBelow,
		rounded,
		size,
		initIndex,
		stopPropagation,
		$$slots,
		$$scope
	];
}

class Carousel extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document.getElementById("svelte-b7wi34-style")) add_css$d();

		init(this, options, instance$M, create_fragment$M, safe_not_equal, {
			items: 0,
			dots: 1,
			dotsBelow: 7,
			rounded: 8,
			size: 9,
			initIndex: 10,
			disableFancy: 2,
			stopPropagation: 11
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Carousel",
			options,
			id: create_fragment$M.name
		});
	}

	get items() {
		throw new Error_1("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set items(value) {
		throw new Error_1("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get dots() {
		throw new Error_1("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dots(value) {
		throw new Error_1("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get dotsBelow() {
		throw new Error_1("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dotsBelow(value) {
		throw new Error_1("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get rounded() {
		throw new Error_1("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set rounded(value) {
		throw new Error_1("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error_1("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error_1("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get initIndex() {
		throw new Error_1("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set initIndex(value) {
		throw new Error_1("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disableFancy() {
		throw new Error_1("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disableFancy(value) {
		throw new Error_1("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get stopPropagation() {
		throw new Error_1("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set stopPropagation(value) {
		throw new Error_1("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/EditArea.svelte generated by Svelte v3.24.0 */
const file$N = "src/components/EditArea.svelte";

function add_css$e() {
	var style = element("style");
	style.id = "svelte-1tyi7td-style";
	style.textContent = ".edit-area.svelte-1tyi7td{--color-bg:rgba(var(--theme-color-primary-opposite), .1);--color-lines:rgba(var(--theme-color-primary-opposite));padding:0 var(--screen-padding);background-image:-webkit-gradient(linear, left top, right top, color-stop(50%, var(--color-lines)), color-stop(0%, rgba(var(--color-black), 0))),\n                      -webkit-gradient(linear, left top, right top, color-stop(50%, var(--color-lines)), color-stop(0%, rgba(var(--color-black), 0)));background-image:linear-gradient(to right, var(--color-lines) 50%, rgba(var(--color-black), 0) 0%),\n                      linear-gradient(to right, var(--color-lines) 50%, rgba(var(--color-black), 0) 0%);background-color:var(--color-bg);background-position:calc(50% - 15px) top, calc(50% - 15px) bottom;background-size:20px 1px;background-repeat:repeat-x;overflow:hidden}.edit-area.svelte-1tyi7td:not(.off)>*{pointer-events:none}.edit-area.off.svelte-1tyi7td{background:none}.edit-area.svelte-1tyi7td:not(.off) *:not(.no-filter){-webkit-filter:grayscale(100%);filter:grayscale(100%)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRWRpdEFyZWEuc3ZlbHRlIiwic291cmNlcyI6WyJFZGl0QXJlYS5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBjcmVhdGVFdmVudERpc3BhdGNoZXIgfSBmcm9tICdzdmVsdGUnXG4gICAgaW1wb3J0IHsgY2xhc3NuYW1lcyB9IGZyb20gJ0B1dGlscydcblxuICAgIGNvbnN0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKClcblxuICAgIGltcG9ydCBCciBmcm9tICcuL0JyLnN2ZWx0ZSdcbiAgICBpbXBvcnQgSWNvbiBmcm9tICcuL0ljb24uc3ZlbHRlJ1xuICAgIGltcG9ydCBCdXR0b24gZnJvbSAnLi9CdXR0b24uc3ZlbHRlJ1xuXG4gICAgZXhwb3J0IGxldCBvZmYgPSBmYWxzZVxuXG4gICAgJDogY2xhc3NQcm9wID0gY2xhc3NuYW1lcygnZWRpdC1hcmVhJywgJCRwcm9wcy5jbGFzcywgeyBvZmYgfSlcblxuICAgIGZ1bmN0aW9uIG9uQ2xpY2soZSkge1xuICAgICAgICBpZiAoIW9mZikge1xuICAgICAgICAgICAgZGlzcGF0Y2goJ2NsaWNrJywgZSlcbiAgICAgICAgfVxuICAgIH1cbjwvc2NyaXB0PlxuXG48c2VjdGlvbiByb2xlPVwiYnV0dG9uXCIgY2xhc3M9e2NsYXNzUHJvcH0gb246Y2xpY2s9e29uQ2xpY2t9PlxuICAgIDxzbG90Pjwvc2xvdD5cblxuICAgIHsjaWYgIW9mZn1cbiAgICAgICAgPEJyIHNpemU9XCIzMFwiLz5cbiAgICAgICAgPEJ1dHRvbiBzaXplPVwic21hbGxcIiBpcz1cImluZm9cIiBjbGFzcz1cIm5vLWZpbHRlclwiPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJoMyBmb250LXNlY29uZGFyeSBmb250LXctNTAwIGZsZXggZmxleC1hbGlnbi1jZW50ZXJcIj5cbiAgICAgICAgICAgICAgICDQoNC10LTQsNCz0YPQstCw0YLQuFxuICAgICAgICAgICAgICAgIDxzPjwvcz5cbiAgICAgICAgICAgICAgICA8cz48L3M+XG4gICAgICAgICAgICAgICAgPEljb24gdHlwZT1cImVkaXRcIiBzaXplPVwic21hbGxcIiBpcz1cImxpZ2h0XCIvPlxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgPEJyIHNpemU9XCI0MFwiLz5cbiAgICB7L2lmfVxuPC9zZWN0aW9uPlxuXG48c3R5bGU+XG4uZWRpdC1hcmVhIHtcbiAgICAtLWNvbG9yLWJnOiByZ2JhKHZhcigtLXRoZW1lLWNvbG9yLXByaW1hcnktb3Bwb3NpdGUpLCAuMSk7XG4gICAgLS1jb2xvci1saW5lczogcmdiYSh2YXIoLS10aGVtZS1jb2xvci1wcmltYXJ5LW9wcG9zaXRlKSk7XG5cbiAgICBwYWRkaW5nOiAwIHZhcigtLXNjcmVlbi1wYWRkaW5nKTtcbiAgICBiYWNrZ3JvdW5kLWltYWdlOiAtd2Via2l0LWdyYWRpZW50KGxpbmVhciwgbGVmdCB0b3AsIHJpZ2h0IHRvcCwgY29sb3Itc3RvcCg1MCUsIHZhcigtLWNvbG9yLWxpbmVzKSksIGNvbG9yLXN0b3AoMCUsIHJnYmEodmFyKC0tY29sb3ItYmxhY2spLCAwKSkpLFxuICAgICAgICAgICAgICAgICAgICAgIC13ZWJraXQtZ3JhZGllbnQobGluZWFyLCBsZWZ0IHRvcCwgcmlnaHQgdG9wLCBjb2xvci1zdG9wKDUwJSwgdmFyKC0tY29sb3ItbGluZXMpKSwgY29sb3Itc3RvcCgwJSwgcmdiYSh2YXIoLS1jb2xvci1ibGFjayksIDApKSk7XG4gICAgYmFja2dyb3VuZC1pbWFnZTogbGluZWFyLWdyYWRpZW50KHRvIHJpZ2h0LCB2YXIoLS1jb2xvci1saW5lcykgNTAlLCByZ2JhKHZhcigtLWNvbG9yLWJsYWNrKSwgMCkgMCUpLFxuICAgICAgICAgICAgICAgICAgICAgIGxpbmVhci1ncmFkaWVudCh0byByaWdodCwgdmFyKC0tY29sb3ItbGluZXMpIDUwJSwgcmdiYSh2YXIoLS1jb2xvci1ibGFjayksIDApIDAlKTtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jb2xvci1iZyk7XG4gICAgYmFja2dyb3VuZC1wb3NpdGlvbjogY2FsYyg1MCUgLSAxNXB4KSB0b3AsIGNhbGMoNTAlIC0gMTVweCkgYm90dG9tO1xuICAgIGJhY2tncm91bmQtc2l6ZTogMjBweCAxcHg7XG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IHJlcGVhdC14O1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG59XG5cbi5lZGl0LWFyZWE6bm90KC5vZmYpID4gOmdsb2JhbCgqKSB7XG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG59XG5cbi5lZGl0LWFyZWEub2ZmIHtcbiAgICBiYWNrZ3JvdW5kOiBub25lO1xufVxuXG4uZWRpdC1hcmVhOm5vdCgub2ZmKSA6Z2xvYmFsKCo6bm90KC5uby1maWx0ZXIpKSB7XG4gICAgLXdlYmtpdC1maWx0ZXI6IGdyYXlzY2FsZSgxMDAlKTtcbiAgICAgICAgICAgIGZpbHRlcjogZ3JheXNjYWxlKDEwMCUpO1xufTwvc3R5bGU+XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBdUNBLFVBQVUsZUFBQyxDQUFDLEFBQ1IsVUFBVSxDQUFFLDZDQUE2QyxDQUN6RCxhQUFhLENBQUUseUNBQXlDLENBRXhELE9BQU8sQ0FBRSxDQUFDLENBQUMsSUFBSSxnQkFBZ0IsQ0FBQyxDQUNoQyxnQkFBZ0IsQ0FBRSxpQkFBaUIsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxXQUFXLEdBQUcsQ0FBQyxDQUFDLElBQUksYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUMsS0FBSyxJQUFJLGFBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO3NCQUNoSSxpQkFBaUIsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxXQUFXLEdBQUcsQ0FBQyxDQUFDLElBQUksYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUMsS0FBSyxJQUFJLGFBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUNqSixnQkFBZ0IsQ0FBRSxnQkFBZ0IsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksYUFBYSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxJQUFJLGFBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7c0JBQ2xGLGdCQUFnQixFQUFFLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxhQUFhLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLElBQUksYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FDbkcsZ0JBQWdCLENBQUUsSUFBSSxVQUFVLENBQUMsQ0FDakMsbUJBQW1CLENBQUUsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLENBQ2xFLGVBQWUsQ0FBRSxJQUFJLENBQUMsR0FBRyxDQUN6QixpQkFBaUIsQ0FBRSxRQUFRLENBQzNCLFFBQVEsQ0FBRSxNQUFNLEFBQ3BCLENBQUMsQUFFRCx5QkFBVSxLQUFLLElBQUksQ0FBQyxDQUFXLENBQUMsQUFBRSxDQUFDLEFBQy9CLGNBQWMsQ0FBRSxJQUFJLEFBQ3hCLENBQUMsQUFFRCxVQUFVLElBQUksZUFBQyxDQUFDLEFBQ1osVUFBVSxDQUFFLElBQUksQUFDcEIsQ0FBQyxBQUVELHlCQUFVLEtBQUssSUFBSSxDQUFDLENBQUMsQUFBUSxpQkFBaUIsQUFBRSxDQUFDLEFBQzdDLGNBQWMsQ0FBRSxVQUFVLElBQUksQ0FBQyxDQUN2QixNQUFNLENBQUUsVUFBVSxJQUFJLENBQUMsQUFDbkMsQ0FBQyJ9 */";
	append_dev(document.head, style);
}

// (25:4) {#if !off}
function create_if_block$7(ctx) {
	let br0;
	let t0;
	let button;
	let t1;
	let br1;
	let current;
	br0 = new Br({ props: { size: "30" }, $$inline: true });

	button = new Button({
			props: {
				size: "small",
				is: "info",
				class: "no-filter",
				$$slots: { default: [create_default_slot$B] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	br1 = new Br({ props: { size: "40" }, $$inline: true });

	const block = {
		c: function create() {
			create_component(br0.$$.fragment);
			t0 = space();
			create_component(button.$$.fragment);
			t1 = space();
			create_component(br1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(br0.$$.fragment, nodes);
			t0 = claim_space(nodes);
			claim_component(button.$$.fragment, nodes);
			t1 = claim_space(nodes);
			claim_component(br1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(br0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(button, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(br1, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(br0.$$.fragment, local);
			transition_in(button.$$.fragment, local);
			transition_in(br1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br0.$$.fragment, local);
			transition_out(button.$$.fragment, local);
			transition_out(br1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(br0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(button, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(br1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$7.name,
		type: "if",
		source: "(25:4) {#if !off}",
		ctx
	});

	return block;
}

// (27:8) <Button size="small" is="info" class="no-filter">
function create_default_slot$B(ctx) {
	let span;
	let t0;
	let s0;
	let t1;
	let s1;
	let t2;
	let icon;
	let current;

	icon = new Icon({
			props: { type: "edit", size: "small", is: "light" },
			$$inline: true
		});

	const block = {
		c: function create() {
			span = element("span");
			t0 = text("Редагувати\n                ");
			s0 = element("s");
			t1 = space();
			s1 = element("s");
			t2 = space();
			create_component(icon.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t0 = claim_text(span_nodes, "Редагувати\n                ");
			s0 = claim_element(span_nodes, "S", {});
			children(s0).forEach(detach_dev);
			t1 = claim_space(span_nodes);
			s1 = claim_element(span_nodes, "S", {});
			children(s1).forEach(detach_dev);
			t2 = claim_space(span_nodes);
			claim_component(icon.$$.fragment, span_nodes);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(s0, file$N, 29, 16, 760);
			add_location(s1, file$N, 30, 16, 784);
			attr_dev(span, "class", "h3 font-secondary font-w-500 flex flex-align-center");
			add_location(span, file$N, 27, 12, 650);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t0);
			append_dev(span, s0);
			append_dev(span, t1);
			append_dev(span, s1);
			append_dev(span, t2);
			mount_component(icon, span, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			destroy_component(icon);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$B.name,
		type: "slot",
		source: "(27:8) <Button size=\\\"small\\\" is=\\\"info\\\" class=\\\"no-filter\\\">",
		ctx
	});

	return block;
}

function create_fragment$N(ctx) {
	let section;
	let t;
	let section_class_value;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*$$slots*/ ctx[3].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);
	let if_block = !/*off*/ ctx[0] && create_if_block$7(ctx);

	const block = {
		c: function create() {
			section = element("section");
			if (default_slot) default_slot.c();
			t = space();
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { role: true, class: true });
			var section_nodes = children(section);
			if (default_slot) default_slot.l(section_nodes);
			t = claim_space(section_nodes);
			if (if_block) if_block.l(section_nodes);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(section, "role", "button");
			attr_dev(section, "class", section_class_value = "" + (null_to_empty(/*classProp*/ ctx[1]) + " svelte-1tyi7td"));
			add_location(section, file$N, 21, 0, 461);
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);

			if (default_slot) {
				default_slot.m(section, null);
			}

			append_dev(section, t);
			if (if_block) if_block.m(section, null);
			current = true;

			if (!mounted) {
				dispose = listen_dev(section, "click", /*onClick*/ ctx[2], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 16) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[4], dirty, null, null);
				}
			}

			if (!/*off*/ ctx[0]) {
				if (if_block) {
					if (dirty & /*off*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$7(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(section, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (!current || dirty & /*classProp*/ 2 && section_class_value !== (section_class_value = "" + (null_to_empty(/*classProp*/ ctx[1]) + " svelte-1tyi7td"))) {
				attr_dev(section, "class", section_class_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			if (default_slot) default_slot.d(detaching);
			if (if_block) if_block.d();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$N.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$N($$self, $$props, $$invalidate) {
	const dispatch = createEventDispatcher();
	let { off = false } = $$props;

	function onClick(e) {
		if (!off) {
			dispatch("click", e);
		}
	}

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("EditArea", $$slots, ['default']);

	$$self.$set = $$new_props => {
		$$invalidate(6, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("off" in $$new_props) $$invalidate(0, off = $$new_props.off);
		if ("$$scope" in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		classnames,
		dispatch,
		Br,
		Icon,
		Button,
		off,
		onClick,
		classProp
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(6, $$props = assign(assign({}, $$props), $$new_props));
		if ("off" in $$props) $$invalidate(0, off = $$new_props.off);
		if ("classProp" in $$props) $$invalidate(1, classProp = $$new_props.classProp);
	};

	let classProp;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(1, classProp = classnames("edit-area", $$props.class, { off }));
	};

	$$props = exclude_internal_props($$props);
	return [off, classProp, onClick, $$slots, $$scope];
}

class EditArea extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document.getElementById("svelte-1tyi7td-style")) add_css$e();
		init(this, options, instance$N, create_fragment$N, safe_not_equal, { off: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "EditArea",
			options,
			id: create_fragment$N.name
		});
	}

	get off() {
		throw new Error("<EditArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set off(value) {
		throw new Error("<EditArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/EditCard.svelte generated by Svelte v3.24.0 */
const file$O = "src/components/EditCard.svelte";

// (28:12) <Button size="small" is="dark-border" on:click={onCancel}>
function create_default_slot_2(ctx) {
	let span;
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text("Скасувати");
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t = claim_text(span_nodes, "Скасувати");
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "h3 font-secondary font-w-500 flex flex-align-center");
			add_location(span, file$O, 28, 16, 680);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2.name,
		type: "slot",
		source: "(28:12) <Button size=\\\"small\\\" is=\\\"dark-border\\\" on:click={onCancel}>",
		ctx
	});

	return block;
}

// (38:12) <Button {form} size="small" type="submit" is="info">
function create_default_slot_1$1(ctx) {
	let span;
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text("Зберегти");
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t = claim_text(span_nodes, "Зберегти");
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "h3 font-secondary font-w-500 flex flex-align-center");
			add_location(span, file$O, 38, 16, 1003);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$1.name,
		type: "slot",
		source: "(38:12) <Button {form} size=\\\"small\\\" type=\\\"submit\\\" is=\\\"info\\\">",
		ctx
	});

	return block;
}

// (19:0) <Card class={classProp}>
function create_default_slot$C(ctx) {
	let br0;
	let t0;
	let t1;
	let br1;
	let t2;
	let section;
	let div0;
	let button0;
	let t3;
	let s0;
	let t4;
	let s1;
	let t5;
	let s2;
	let t6;
	let div1;
	let button1;
	let t7;
	let br2;
	let current;
	br0 = new Br({ props: { size: "30" }, $$inline: true });
	const default_slot_template = /*$$slots*/ ctx[3].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);
	br1 = new Br({ props: { size: "40" }, $$inline: true });

	button0 = new Button({
			props: {
				size: "small",
				is: "dark-border",
				$$slots: { default: [create_default_slot_2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button0.$on("click", /*onCancel*/ ctx[2]);

	button1 = new Button({
			props: {
				form: /*form*/ ctx[0],
				size: "small",
				type: "submit",
				is: "info",
				$$slots: { default: [create_default_slot_1$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	br2 = new Br({ props: { size: "40" }, $$inline: true });

	const block = {
		c: function create() {
			create_component(br0.$$.fragment);
			t0 = space();
			if (default_slot) default_slot.c();
			t1 = space();
			create_component(br1.$$.fragment);
			t2 = space();
			section = element("section");
			div0 = element("div");
			create_component(button0.$$.fragment);
			t3 = space();
			s0 = element("s");
			t4 = space();
			s1 = element("s");
			t5 = space();
			s2 = element("s");
			t6 = space();
			div1 = element("div");
			create_component(button1.$$.fragment);
			t7 = space();
			create_component(br2.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			claim_component(br0.$$.fragment, nodes);
			t0 = claim_space(nodes);
			if (default_slot) default_slot.l(nodes);
			t1 = claim_space(nodes);
			claim_component(br1.$$.fragment, nodes);
			t2 = claim_space(nodes);
			section = claim_element(nodes, "SECTION", { class: true });
			var section_nodes = children(section);
			div0 = claim_element(section_nodes, "DIV", { style: true });
			var div0_nodes = children(div0);
			claim_component(button0.$$.fragment, div0_nodes);
			div0_nodes.forEach(detach_dev);
			t3 = claim_space(section_nodes);
			s0 = claim_element(section_nodes, "S", {});
			children(s0).forEach(detach_dev);
			t4 = claim_space(section_nodes);
			s1 = claim_element(section_nodes, "S", {});
			children(s1).forEach(detach_dev);
			t5 = claim_space(section_nodes);
			s2 = claim_element(section_nodes, "S", {});
			children(s2).forEach(detach_dev);
			t6 = claim_space(section_nodes);
			div1 = claim_element(section_nodes, "DIV", { style: true });
			var div1_nodes = children(div1);
			claim_component(button1.$$.fragment, div1_nodes);
			div1_nodes.forEach(detach_dev);
			section_nodes.forEach(detach_dev);
			t7 = claim_space(nodes);
			claim_component(br2.$$.fragment, nodes);
			this.h();
		},
		h: function hydrate() {
			set_style(div0, "flex", "1 1 50%");
			add_location(div0, file$O, 26, 8, 565);
			add_location(s0, file$O, 33, 8, 846);
			add_location(s1, file$O, 34, 8, 862);
			add_location(s2, file$O, 35, 8, 878);
			set_style(div1, "flex", "1 1 50%");
			add_location(div1, file$O, 36, 8, 894);
			attr_dev(section, "class", "flex flex-align-center");
			add_location(section, file$O, 25, 4, 516);
		},
		m: function mount(target, anchor) {
			mount_component(br0, target, anchor);
			insert_dev(target, t0, anchor);

			if (default_slot) {
				default_slot.m(target, anchor);
			}

			insert_dev(target, t1, anchor);
			mount_component(br1, target, anchor);
			insert_dev(target, t2, anchor);
			insert_dev(target, section, anchor);
			append_dev(section, div0);
			mount_component(button0, div0, null);
			append_dev(section, t3);
			append_dev(section, s0);
			append_dev(section, t4);
			append_dev(section, s1);
			append_dev(section, t5);
			append_dev(section, s2);
			append_dev(section, t6);
			append_dev(section, div1);
			mount_component(button1, div1, null);
			insert_dev(target, t7, anchor);
			mount_component(br2, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 16) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[4], dirty, null, null);
				}
			}

			const button0_changes = {};

			if (dirty & /*$$scope*/ 16) {
				button0_changes.$$scope = { dirty, ctx };
			}

			button0.$set(button0_changes);
			const button1_changes = {};
			if (dirty & /*form*/ 1) button1_changes.form = /*form*/ ctx[0];

			if (dirty & /*$$scope*/ 16) {
				button1_changes.$$scope = { dirty, ctx };
			}

			button1.$set(button1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(br0.$$.fragment, local);
			transition_in(default_slot, local);
			transition_in(br1.$$.fragment, local);
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			transition_in(br2.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br0.$$.fragment, local);
			transition_out(default_slot, local);
			transition_out(br1.$$.fragment, local);
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			transition_out(br2.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(br0, detaching);
			if (detaching) detach_dev(t0);
			if (default_slot) default_slot.d(detaching);
			if (detaching) detach_dev(t1);
			destroy_component(br1, detaching);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(section);
			destroy_component(button0);
			destroy_component(button1);
			if (detaching) detach_dev(t7);
			destroy_component(br2, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$C.name,
		type: "slot",
		source: "(19:0) <Card class={classProp}>",
		ctx
	});

	return block;
}

function create_fragment$O(ctx) {
	let card;
	let current;

	card = new Card({
			props: {
				class: /*classProp*/ ctx[1],
				$$slots: { default: [create_default_slot$C] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(card.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(card.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(card, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const card_changes = {};
			if (dirty & /*classProp*/ 2) card_changes.class = /*classProp*/ ctx[1];

			if (dirty & /*$$scope, form*/ 17) {
				card_changes.$$scope = { dirty, ctx };
			}

			card.$set(card_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(card.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(card.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(card, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$O.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$O($$self, $$props, $$invalidate) {
	const dispatch = createEventDispatcher();
	let { form } = $$props;

	function onCancel(e) {
		dispatch("cancel", e);
	}

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("EditCard", $$slots, ['default']);

	$$self.$set = $$new_props => {
		$$invalidate(6, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("form" in $$new_props) $$invalidate(0, form = $$new_props.form);
		if ("$$scope" in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		classnames,
		Br,
		Card,
		Button,
		dispatch,
		form,
		onCancel,
		classProp
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(6, $$props = assign(assign({}, $$props), $$new_props));
		if ("form" in $$props) $$invalidate(0, form = $$new_props.form);
		if ("classProp" in $$props) $$invalidate(1, classProp = $$new_props.classProp);
	};

	let classProp;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(1, classProp = classnames("edit-area-container container", $$props.class));
	};

	$$props = exclude_internal_props($$props);
	return [form, classProp, onCancel, $$slots, $$scope];
}

class EditCard extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$O, create_fragment$O, safe_not_equal, { form: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "EditCard",
			options,
			id: create_fragment$O.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*form*/ ctx[0] === undefined && !("form" in props)) {
			console.warn("<EditCard> was created without expected prop 'form'");
		}
	}

	get form() {
		throw new Error("<EditCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set form(value) {
		throw new Error("<EditCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/LazyToggle.svelte generated by Svelte v3.24.0 */
const file$P = "src/components/LazyToggle.svelte";

function add_css$f() {
	var style = element("style");
	style.id = "svelte-15bu51u-style";
	style.textContent = ".lazy-toggle.hidden.svelte-15bu51u{display:none}.lazy-toggle.invisible.svelte-15bu51u{visibility:hidden}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTGF6eVRvZ2dsZS5zdmVsdGUiLCJzb3VyY2VzIjpbIkxhenlUb2dnbGUuc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgY2xhc3NuYW1lcyB9IGZyb20gJ0B1dGlscydcblxuICAgIGV4cG9ydCBsZXQgYWN0aXZlID0gZmFsc2VcbiAgICBleHBvcnQgbGV0IHZpc2libGUgPSB0cnVlXG4gICAgZXhwb3J0IGxldCBtb3VudGVkID0gZmFsc2VcblxuICAgIGxldCBpc01vdW50ZWQgPSBtb3VudGVkXG5cbiAgICAkOiBjbGFzc1Byb3AgPSBjbGFzc25hbWVzKCdsYXp5LXRvZ2dsZSBmbGV4LTEnLCAkJHByb3BzLmNsYXNzLCB7IGhpZGRlbjogIWFjdGl2ZSwgaW52aXNpYmxlOiAhdmlzaWJsZSB9KVxuICAgICQ6IGlmIChhY3RpdmUgJiYgIWlzTW91bnRlZCkgaXNNb3VudGVkID0gdHJ1ZVxuPC9zY3JpcHQ+XG5cbjxzZWN0aW9uIGNsYXNzPXtjbGFzc1Byb3B9PlxuICAgIHsjaWYgaXNNb3VudGVkfVxuICAgICAgICA8c2xvdD48L3Nsb3Q+XG4gICAgey9pZn1cbjwvc2VjdGlvbj5cblxuPHN0eWxlPlxuLmxhenktdG9nZ2xlLmhpZGRlbiB7XG4gICAgZGlzcGxheTogbm9uZTtcbn1cblxuLmxhenktdG9nZ2xlLmludmlzaWJsZSB7XG4gICAgdmlzaWJpbGl0eTogaGlkZGVuO1xufTwvc3R5bGU+Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQW9CQSxZQUFZLE9BQU8sZUFBQyxDQUFDLEFBQ2pCLE9BQU8sQ0FBRSxJQUFJLEFBQ2pCLENBQUMsQUFFRCxZQUFZLFVBQVUsZUFBQyxDQUFDLEFBQ3BCLFVBQVUsQ0FBRSxNQUFNLEFBQ3RCLENBQUMifQ== */";
	append_dev(document.head, style);
}

// (15:4) {#if isMounted}
function create_if_block$8(ctx) {
	let current;
	const default_slot_template = /*$$slots*/ ctx[6].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		l: function claim(nodes) {
			if (default_slot) default_slot.l(nodes);
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 32) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[5], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$8.name,
		type: "if",
		source: "(15:4) {#if isMounted}",
		ctx
	});

	return block;
}

function create_fragment$P(ctx) {
	let section;
	let section_class_value;
	let current;
	let if_block = /*isMounted*/ ctx[0] && create_if_block$8(ctx);

	const block = {
		c: function create() {
			section = element("section");
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { class: true });
			var section_nodes = children(section);
			if (if_block) if_block.l(section_nodes);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(section, "class", section_class_value = "" + (null_to_empty(/*classProp*/ ctx[1]) + " svelte-15bu51u"));
			add_location(section, file$P, 13, 0, 341);
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			if (if_block) if_block.m(section, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*isMounted*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*isMounted*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$8(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(section, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (!current || dirty & /*classProp*/ 2 && section_class_value !== (section_class_value = "" + (null_to_empty(/*classProp*/ ctx[1]) + " svelte-15bu51u"))) {
				attr_dev(section, "class", section_class_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			if (if_block) if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$P.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$P($$self, $$props, $$invalidate) {
	let { active = false } = $$props;
	let { visible = true } = $$props;
	let { mounted = false } = $$props;
	let isMounted = mounted;
	let { $$slots = {}, $$scope } = $$props;
	validate_slots("LazyToggle", $$slots, ['default']);

	$$self.$set = $$new_props => {
		$$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("active" in $$new_props) $$invalidate(2, active = $$new_props.active);
		if ("visible" in $$new_props) $$invalidate(3, visible = $$new_props.visible);
		if ("mounted" in $$new_props) $$invalidate(4, mounted = $$new_props.mounted);
		if ("$$scope" in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		classnames,
		active,
		visible,
		mounted,
		isMounted,
		classProp
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(7, $$props = assign(assign({}, $$props), $$new_props));
		if ("active" in $$props) $$invalidate(2, active = $$new_props.active);
		if ("visible" in $$props) $$invalidate(3, visible = $$new_props.visible);
		if ("mounted" in $$props) $$invalidate(4, mounted = $$new_props.mounted);
		if ("isMounted" in $$props) $$invalidate(0, isMounted = $$new_props.isMounted);
		if ("classProp" in $$props) $$invalidate(1, classProp = $$new_props.classProp);
	};

	let classProp;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(1, classProp = classnames("lazy-toggle flex-1", $$props.class, { hidden: !active, invisible: !visible }));

		if ($$self.$$.dirty & /*active, isMounted*/ 5) {
			 if (active && !isMounted) $$invalidate(0, isMounted = true);
		}
	};

	$$props = exclude_internal_props($$props);
	return [isMounted, classProp, active, visible, mounted, $$scope, $$slots];
}

class LazyToggle extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document.getElementById("svelte-15bu51u-style")) add_css$f();
		init(this, options, instance$P, create_fragment$P, safe_not_equal, { active: 2, visible: 3, mounted: 4 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "LazyToggle",
			options,
			id: create_fragment$P.name
		});
	}

	get active() {
		throw new Error("<LazyToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set active(value) {
		throw new Error("<LazyToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get visible() {
		throw new Error("<LazyToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set visible(value) {
		throw new Error("<LazyToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get mounted() {
		throw new Error("<LazyToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set mounted(value) {
		throw new Error("<LazyToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/loader/Text.svelte generated by Svelte v3.24.0 */

const file$Q = "src/components/loader/Text.svelte";

function create_fragment$Q(ctx) {
	let rect;

	const block = {
		c: function create() {
			rect = svg_element("rect");
			this.h();
		},
		l: function claim(nodes) {
			rect = claim_element(
				nodes,
				"rect",
				{
					x: true,
					y: true,
					rx: true,
					ry: true,
					width: true,
					height: true
				},
				1
			);

			children(rect).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(rect, "x", "0");
			attr_dev(rect, "y", "10%");
			attr_dev(rect, "rx", "3");
			attr_dev(rect, "ry", "3");
			attr_dev(rect, "width", "100%");
			attr_dev(rect, "height", "80%");
			add_location(rect, file$Q, 0, 0, 0);
		},
		m: function mount(target, anchor) {
			insert_dev(target, rect, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(rect);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$Q.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$Q($$self, $$props) {
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Text> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Text", $$slots, []);
	return [];
}

class Text extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$Q, create_fragment$Q, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Text",
			options,
			id: create_fragment$Q.name
		});
	}
}

/* src/components/loader/Circle.svelte generated by Svelte v3.24.0 */

const file$R = "src/components/loader/Circle.svelte";

function create_fragment$R(ctx) {
	let circle;

	const block = {
		c: function create() {
			circle = svg_element("circle");
			this.h();
		},
		l: function claim(nodes) {
			circle = claim_element(nodes, "circle", { cx: true, cy: true, r: true }, 1);
			children(circle).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(circle, "cx", "50%");
			attr_dev(circle, "cy", "50%");
			attr_dev(circle, "r", "50%");
			add_location(circle, file$R, 0, 0, 0);
		},
		m: function mount(target, anchor) {
			insert_dev(target, circle, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(circle);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$R.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$R($$self, $$props) {
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Circle> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Circle", $$slots, []);
	return [];
}

class Circle extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$R, create_fragment$R, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Circle",
			options,
			id: create_fragment$R.name
		});
	}
}

/* src/components/loader/Loader.svelte generated by Svelte v3.24.0 */

const { document: document_1$2 } = globals;
const file$S = "src/components/loader/Loader.svelte";

function add_css$g() {
	var style = element("style");
	style.id = "svelte-13ssox4-style";
	style.textContent = ".loader.svelte-13ssox4.svelte-13ssox4{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-flex:1;-ms-flex:1 1 auto;flex:1 1 auto;-ms-flex-item-align:stretch;align-self:stretch;-webkit-transform:translateZ(0);transform:translateZ(0)}.loader.svelte-13ssox4 svg.svelte-13ssox4{-webkit-box-flex:1;-ms-flex:1 1 auto;flex:1 1 auto;-ms-flex-item-align:stretch;align-self:stretch;-webkit-transform:translateZ(0);transform:translateZ(0)}.loader.absolute.svelte-13ssox4.svelte-13ssox4{position:absolute;top:0;left:0;right:0;bottom:0}.loader.border.svelte-13ssox4.svelte-13ssox4{outline-width:1px;outline-style:solid}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTG9hZGVyLnN2ZWx0ZSIsInNvdXJjZXMiOlsiTG9hZGVyLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0PlxuICAgIC8vIEhvdyB0byBtYWtlIGEgY3VzdG9tIGxvYWRlcj9cbiAgICAvLyBTZWUgaGVyZSBmb3IgZ2VuZXJhdGluZzogaHR0cHM6Ly9kYW5pbG93b3ouY29tL2NyZWF0ZS1jb250ZW50LWxvYWRlci9cbiAgICBcbiAgICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSAnc3ZlbHRlJ1xuICAgIGltcG9ydCB7IGNsYXNzbmFtZXMsIHV1aWQgfSBmcm9tICdAdXRpbHMnXG4gICAgaW1wb3J0IFRleHQgZnJvbSAnLi9UZXh0LnN2ZWx0ZSdcbiAgICBpbXBvcnQgQ2lyY2xlIGZyb20gJy4vQ2lyY2xlLnN2ZWx0ZSdcblxuICAgIGV4cG9ydCBsZXQgd2lkdGggPSAnMTAwJScgXG4gICAgZXhwb3J0IGxldCBoZWlnaHQgPSAnMTAwJSdcbiAgICBleHBvcnQgbGV0IGxpZ2h0ID0gJyM5OTk5OTknO1xuICAgIGV4cG9ydCBsZXQgZGFyayA9ICcjNTU1NTU1JztcbiAgICBleHBvcnQgbGV0IG9wYWNpdHkgPSAuMjtcbiAgICBleHBvcnQgbGV0IGJvcmRlciA9IGZhbHNlO1xuICAgIGV4cG9ydCBsZXQgYWJzb2x1dGUgPSBmYWxzZTtcbiAgICBleHBvcnQgbGV0IHR5cGUgPSB1bmRlZmluZWQ7IC8vIGgxLCBoMiwgaDMsIGg0LCBoNSwgaDYsIHAsIHByZSwgYXZhdGFyXG5cbiAgICBjb25zdCB1aWQgPSB1dWlkKClcblxuICAgIGxldCBoVHlwZXMgPSB7XG4gICAgICAgIHA6IDIxLFxuICAgICAgICBoMTogMzUsXG4gICAgICAgIGgyOiAyOSxcbiAgICAgICAgaDM6IDI2LFxuICAgICAgICBoNDogMjEsXG4gICAgICAgIGg1OiAyMSxcbiAgICAgICAgaDY6IDIxLFxuICAgICAgICBwcmU6IDIxLFxuICAgIH1cblxuICAgIG9uTW91bnQoKCkgPT4ge1xuICAgICAgICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuYm9keSk7XG4gICAgICAgIGNvbnN0IGxoID0gTnVtYmVyLnBhcnNlSW50KHN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ2xpbmUtaGVpZ2h0JykpXG4gICAgICAgIGNvbnN0IGJhbGFuY2UgPSAwXG5cbiAgICAgICAgaFR5cGVzID0ge1xuICAgICAgICAgICAgcDogbGggKiAxLjE1ICsgYmFsYW5jZSxcbiAgICAgICAgICAgIGgxOiBsaCAqIDEuODUgKyBiYWxhbmNlLFxuICAgICAgICAgICAgaDI6IGxoICogMS40ICsgYmFsYW5jZSxcbiAgICAgICAgICAgIGgzOiBsaCAqIDEuMyArIGJhbGFuY2UsXG4gICAgICAgICAgICBoNDogbGggKiAxLjE1ICsgYmFsYW5jZSxcbiAgICAgICAgICAgIGg1OiBsaCAqIDEuMTUgKyBiYWxhbmNlLFxuICAgICAgICAgICAgaDY6IGxoICogMS4xNSArIGJhbGFuY2UsXG4gICAgICAgICAgICBwcmU6IGxoICogMS4xNSArIGJhbGFuY2UsXG4gICAgICAgIH1cbiAgICB9KVxuXG4gICAgJDogYXJlYVdpZHRoID0gd2lkdGgucmVwbGFjZSgnJScsICcnKVxuICAgICQ6IGFyZWFIZWlnaHQgPSBoVHlwZXNbdHlwZV0gfHwgaGVpZ2h0XG4gICAgJDogY2xhc3NQcm9wID0gY2xhc3NuYW1lcygnbG9hZGVyJywgeyBib3JkZXIsIGFic29sdXRlIH0pXG48L3NjcmlwdD5cblxuPHNlY3Rpb24gXG4gICAgY2xhc3M9e2NsYXNzUHJvcH1cbiAgICBzdHlsZT17YG9wYWNpdHk6ICR7b3BhY2l0eX07IG91dGxpbmUtY29sb3I6ICR7bGlnaHR9O2B9XG4+XG4gICAgPHN2Z1xuICAgICAgICByb2xlPVwiaW1nXCJcbiAgICAgICAgd2lkdGg9XCIxMDAlXCJcbiAgICAgICAgaGVpZ2h0PXthcmVhSGVpZ2h0fVxuICAgICAgICBhcmlhLWxhYmVsbGVkYnk9XCJsb2FkaW5nLWFyaWFcIlxuICAgICAgICB2aWV3Qm94PXtgMCAwICR7YXJlYVdpZHRofSAxMDBgfVxuICAgICAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvPVwibm9uZVwiXG4gICAgPlxuICAgICAgICA8dGl0bGUgaWQ9XCJsb2FkaW5nLWFyaWFcIj5Mb2FkaW5nLi4uPC90aXRsZT5cbiAgICAgICAgPHJlY3RcbiAgICAgICAgICAgIHg9XCIwXCJcbiAgICAgICAgICAgIHk9XCIwXCJcbiAgICAgICAgICAgIHdpZHRoPVwiMTAwJVwiXG4gICAgICAgICAgICBoZWlnaHQ9XCIxMDAlXCJcbiAgICAgICAgICAgIGNsaXAtcGF0aD17YHVybCgjY2xpcC1wYXRoLSR7dWlkfSlgfVxuICAgICAgICAgICAgc3R5bGU9J2ZpbGw6IHVybChcIiNsb2FkZXItZmlsbFwiKTsnXG4gICAgICAgID48L3JlY3Q+XG4gICAgICAgIDxkZWZzPlxuICAgICAgICAgICAgPGNsaXBQYXRoIGlkPXtgY2xpcC1wYXRoLSR7dWlkfWB9PlxuICAgICAgICAgICAgICAgIDxzbG90PlxuICAgICAgICAgICAgICAgICAgICB7I2lmICdhdmF0YXInLmluY2x1ZGVzKHR5cGUpfVxuICAgICAgICAgICAgICAgICAgICAgICAgPENpcmNsZS8+XG4gICAgICAgICAgICAgICAgICAgIHs6ZWxzZSBpZiAnaDEsaDIsaDMsaDQsaDUsaDYscCxwcmUnLmluY2x1ZGVzKHR5cGUpfVxuICAgICAgICAgICAgICAgICAgICAgICAgPFRleHQvPlxuICAgICAgICAgICAgICAgICAgICB7OmVsc2V9XG4gICAgICAgICAgICAgICAgICAgICAgICA8cmVjdCB4PVwiMFwiIHk9XCIwXCIgcng9XCIzXCIgcnk9XCIzXCIgd2lkdGg9XCIxMDAlXCIgaGVpZ2h0PVwiMTAwJVwiIC8+XG4gICAgICAgICAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICAgICAgPC9zbG90PlxuICAgICAgICAgICAgPC9jbGlwUGF0aD5cbiAgICAgICAgICAgIDxsaW5lYXJHcmFkaWVudCBpZD1cImxvYWRlci1maWxsXCI+XG4gICAgICAgICAgICAgICAgPHN0b3BcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0PVwiMC41OTk5NjRcIlxuICAgICAgICAgICAgICAgICAgICBzdG9wLWNvbG9yPXtsaWdodH1cbiAgICAgICAgICAgICAgICAgICAgc3RvcC1vcGFjaXR5PVwiMVwiXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICA8YW5pbWF0ZVxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVOYW1lPVwib2Zmc2V0XCJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzPVwiLTI7IC0yOyAxXCJcbiAgICAgICAgICAgICAgICAgICAga2V5VGltZXM9XCIwOyAwLjI1OyAxXCJcbiAgICAgICAgICAgICAgICAgICAgZHVyPVwiMnNcIlxuICAgICAgICAgICAgICAgICAgICByZXBlYXRDb3VudD1cImluZGVmaW5pdGVcIlxuICAgICAgICAgICAgICAgICAgICA+PC9hbmltYXRlPlxuICAgICAgICAgICAgICAgIDwvc3RvcD5cbiAgICAgICAgICAgICAgICA8c3RvcFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ9XCIxLjU5OTk2XCJcbiAgICAgICAgICAgICAgICAgICAgc3RvcC1jb2xvcj17ZGFya31cbiAgICAgICAgICAgICAgICAgICAgc3RvcC1vcGFjaXR5PVwiMVwiXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICA8YW5pbWF0ZVxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVOYW1lPVwib2Zmc2V0XCJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzPVwiLTE7IC0xOyAyXCJcbiAgICAgICAgICAgICAgICAgICAga2V5VGltZXM9XCIwOyAwLjI1OyAxXCJcbiAgICAgICAgICAgICAgICAgICAgZHVyPVwiMnNcIlxuICAgICAgICAgICAgICAgICAgICByZXBlYXRDb3VudD1cImluZGVmaW5pdGVcIlxuICAgICAgICAgICAgICAgICAgICA+PC9hbmltYXRlPlxuICAgICAgICAgICAgICAgIDwvc3RvcD5cbiAgICAgICAgICAgICAgICA8c3RvcFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ9XCIyLjU5OTk2XCJcbiAgICAgICAgICAgICAgICAgICAgc3RvcC1jb2xvcj17bGlnaHR9XG4gICAgICAgICAgICAgICAgICAgIHN0b3Atb3BhY2l0eT1cIjFcIlxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgPGFuaW1hdGVcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlTmFtZT1cIm9mZnNldFwiXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcz1cIjA7IDA7IDNcIlxuICAgICAgICAgICAgICAgICAgICBrZXlUaW1lcz1cIjA7IDAuMjU7IDFcIlxuICAgICAgICAgICAgICAgICAgICBkdXI9XCIyc1wiXG4gICAgICAgICAgICAgICAgICAgIHJlcGVhdENvdW50PVwiaW5kZWZpbml0ZVwiXG4gICAgICAgICAgICAgICAgICAgID48L2FuaW1hdGU+XG4gICAgICAgICAgICAgICAgPC9zdG9wPlxuICAgICAgICAgICAgPC9saW5lYXJHcmFkaWVudD5cbiAgICAgICAgPC9kZWZzPlxuICAgIDwvc3ZnPlxuPC9zZWN0aW9uPlxuXG48c3R5bGU+XG4ubG9hZGVyIHtcbiAgICBkaXNwbGF5OiAtd2Via2l0LWJveDtcbiAgICBkaXNwbGF5OiAtbXMtZmxleGJveDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIC13ZWJraXQtYm94LWZsZXg6IDE7XG4gICAgICAgIC1tcy1mbGV4OiAxIDEgYXV0bztcbiAgICAgICAgICAgIGZsZXg6IDEgMSBhdXRvO1xuICAgIC1tcy1mbGV4LWl0ZW0tYWxpZ246IHN0cmV0Y2g7XG4gICAgICAgIGFsaWduLXNlbGY6IHN0cmV0Y2g7XG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVooMCk7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVooMCk7XG59XG5cbi5sb2FkZXIgc3ZnIHtcbiAgICAtd2Via2l0LWJveC1mbGV4OiAxO1xuICAgICAgICAtbXMtZmxleDogMSAxIGF1dG87XG4gICAgICAgICAgICBmbGV4OiAxIDEgYXV0bztcbiAgICAtbXMtZmxleC1pdGVtLWFsaWduOiBzdHJldGNoO1xuICAgICAgICBhbGlnbi1zZWxmOiBzdHJldGNoO1xuICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVaKDApO1xuICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVaKDApO1xufVxuXG4ubG9hZGVyLmFic29sdXRlIHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgdG9wOiAwO1xuICAgIGxlZnQ6IDA7XG4gICAgcmlnaHQ6IDA7XG4gICAgYm90dG9tOiAwO1xufVxuXG4ubG9hZGVyLmJvcmRlciB7XG4gICAgb3V0bGluZS13aWR0aDogMXB4O1xuICAgIG91dGxpbmUtc3R5bGU6IHNvbGlkO1xufTwvc3R5bGU+XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBb0lBLE9BQU8sOEJBQUMsQ0FBQyxBQUNMLE9BQU8sQ0FBRSxXQUFXLENBQ3BCLE9BQU8sQ0FBRSxXQUFXLENBQ3BCLE9BQU8sQ0FBRSxJQUFJLENBQ2IsZ0JBQWdCLENBQUUsQ0FBQyxDQUNmLFFBQVEsQ0FBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FDZCxJQUFJLENBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQ3RCLG1CQUFtQixDQUFFLE9BQU8sQ0FDeEIsVUFBVSxDQUFFLE9BQU8sQ0FDdkIsaUJBQWlCLENBQUUsV0FBVyxDQUFDLENBQUMsQ0FDeEIsU0FBUyxDQUFFLFdBQVcsQ0FBQyxDQUFDLEFBQ3BDLENBQUMsQUFFRCxzQkFBTyxDQUFDLEdBQUcsZUFBQyxDQUFDLEFBQ1QsZ0JBQWdCLENBQUUsQ0FBQyxDQUNmLFFBQVEsQ0FBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FDZCxJQUFJLENBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQ3RCLG1CQUFtQixDQUFFLE9BQU8sQ0FDeEIsVUFBVSxDQUFFLE9BQU8sQ0FDdkIsaUJBQWlCLENBQUUsV0FBVyxDQUFDLENBQUMsQ0FDeEIsU0FBUyxDQUFFLFdBQVcsQ0FBQyxDQUFDLEFBQ3BDLENBQUMsQUFFRCxPQUFPLFNBQVMsOEJBQUMsQ0FBQyxBQUNkLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLEdBQUcsQ0FBRSxDQUFDLENBQ04sSUFBSSxDQUFFLENBQUMsQ0FDUCxLQUFLLENBQUUsQ0FBQyxDQUNSLE1BQU0sQ0FBRSxDQUFDLEFBQ2IsQ0FBQyxBQUVELE9BQU8sT0FBTyw4QkFBQyxDQUFDLEFBQ1osYUFBYSxDQUFFLEdBQUcsQ0FDbEIsYUFBYSxDQUFFLEtBQUssQUFDeEIsQ0FBQyJ9 */";
	append_dev(document_1$2.head, style);
}

// (82:20) {:else}
function create_else_block$3(ctx) {
	let rect;

	const block = {
		c: function create() {
			rect = svg_element("rect");
			this.h();
		},
		l: function claim(nodes) {
			rect = claim_element(
				nodes,
				"rect",
				{
					x: true,
					y: true,
					rx: true,
					ry: true,
					width: true,
					height: true
				},
				1
			);

			children(rect).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(rect, "x", "0");
			attr_dev(rect, "y", "0");
			attr_dev(rect, "rx", "3");
			attr_dev(rect, "ry", "3");
			attr_dev(rect, "width", "100%");
			attr_dev(rect, "height", "100%");
			add_location(rect, file$S, 82, 24, 2313);
		},
		m: function mount(target, anchor) {
			insert_dev(target, rect, anchor);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(rect);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$3.name,
		type: "else",
		source: "(82:20) {:else}",
		ctx
	});

	return block;
}

// (80:71) 
function create_if_block_1$5(ctx) {
	let text_1;
	let current;
	text_1 = new Text({ $$inline: true });

	const block = {
		c: function create() {
			create_component(text_1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(text_1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(text_1, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(text_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(text_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(text_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$5.name,
		type: "if",
		source: "(80:71) ",
		ctx
	});

	return block;
}

// (78:20) {#if 'avatar'.includes(type)}
function create_if_block$9(ctx) {
	let circle;
	let current;
	circle = new Circle({ $$inline: true });

	const block = {
		c: function create() {
			create_component(circle.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(circle.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(circle, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(circle.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(circle.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(circle, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$9.name,
		type: "if",
		source: "(78:20) {#if 'avatar'.includes(type)}",
		ctx
	});

	return block;
}

// (77:22)                      
function fallback_block$2(ctx) {
	let show_if;
	let show_if_1;
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$9, create_if_block_1$5, create_else_block$3];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (dirty & /*type*/ 8) show_if = !!("avatar").includes(/*type*/ ctx[3]);
		if (show_if) return 0;
		if (dirty & /*type*/ 8) show_if_1 = !!("h1,h2,h3,h4,h5,h6,p,pre").includes(/*type*/ ctx[3]);
		if (show_if_1) return 1;
		return 2;
	}

	current_block_type_index = select_block_type(ctx, -1);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index !== previous_block_index) {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: fallback_block$2.name,
		type: "fallback",
		source: "(77:22)                      ",
		ctx
	});

	return block;
}

function create_fragment$S(ctx) {
	let section;
	let svg;
	let title;
	let t;
	let rect;
	let rect_clip_path_value;
	let defs;
	let clipPath;
	let clipPath_id_value;
	let linearGradient;
	let stop0;
	let animate0;
	let stop1;
	let animate1;
	let stop2;
	let animate2;
	let svg_viewBox_value;
	let section_class_value;
	let section_style_value;
	let current;
	const default_slot_template = /*$$slots*/ ctx[13].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], null);
	const default_slot_or_fallback = default_slot || fallback_block$2(ctx);

	const block = {
		c: function create() {
			section = element("section");
			svg = svg_element("svg");
			title = svg_element("title");
			t = text("Loading...");
			rect = svg_element("rect");
			defs = svg_element("defs");
			clipPath = svg_element("clipPath");
			if (default_slot_or_fallback) default_slot_or_fallback.c();
			linearGradient = svg_element("linearGradient");
			stop0 = svg_element("stop");
			animate0 = svg_element("animate");
			stop1 = svg_element("stop");
			animate1 = svg_element("animate");
			stop2 = svg_element("stop");
			animate2 = svg_element("animate");
			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { class: true, style: true });
			var section_nodes = children(section);

			svg = claim_element(
				section_nodes,
				"svg",
				{
					role: true,
					width: true,
					height: true,
					"aria-labelledby": true,
					viewBox: true,
					preserveAspectRatio: true,
					class: true
				},
				1
			);

			var svg_nodes = children(svg);
			title = claim_element(svg_nodes, "title", { id: true }, 1);
			var title_nodes = children(title);
			t = claim_text(title_nodes, "Loading...");
			title_nodes.forEach(detach_dev);

			rect = claim_element(
				svg_nodes,
				"rect",
				{
					x: true,
					y: true,
					width: true,
					height: true,
					"clip-path": true,
					style: true
				},
				1
			);

			children(rect).forEach(detach_dev);
			defs = claim_element(svg_nodes, "defs", {}, 1);
			var defs_nodes = children(defs);
			clipPath = claim_element(defs_nodes, "clipPath", { id: true }, 1);
			var clipPath_nodes = children(clipPath);
			if (default_slot_or_fallback) default_slot_or_fallback.l(clipPath_nodes);
			clipPath_nodes.forEach(detach_dev);
			linearGradient = claim_element(defs_nodes, "linearGradient", { id: true }, 1);
			var linearGradient_nodes = children(linearGradient);

			stop0 = claim_element(
				linearGradient_nodes,
				"stop",
				{
					offset: true,
					"stop-color": true,
					"stop-opacity": true
				},
				1
			);

			var stop0_nodes = children(stop0);

			animate0 = claim_element(
				stop0_nodes,
				"animate",
				{
					attributeName: true,
					values: true,
					keyTimes: true,
					dur: true,
					repeatCount: true
				},
				1
			);

			children(animate0).forEach(detach_dev);
			stop0_nodes.forEach(detach_dev);

			stop1 = claim_element(
				linearGradient_nodes,
				"stop",
				{
					offset: true,
					"stop-color": true,
					"stop-opacity": true
				},
				1
			);

			var stop1_nodes = children(stop1);

			animate1 = claim_element(
				stop1_nodes,
				"animate",
				{
					attributeName: true,
					values: true,
					keyTimes: true,
					dur: true,
					repeatCount: true
				},
				1
			);

			children(animate1).forEach(detach_dev);
			stop1_nodes.forEach(detach_dev);

			stop2 = claim_element(
				linearGradient_nodes,
				"stop",
				{
					offset: true,
					"stop-color": true,
					"stop-opacity": true
				},
				1
			);

			var stop2_nodes = children(stop2);

			animate2 = claim_element(
				stop2_nodes,
				"animate",
				{
					attributeName: true,
					values: true,
					keyTimes: true,
					dur: true,
					repeatCount: true
				},
				1
			);

			children(animate2).forEach(detach_dev);
			stop2_nodes.forEach(detach_dev);
			linearGradient_nodes.forEach(detach_dev);
			defs_nodes.forEach(detach_dev);
			svg_nodes.forEach(detach_dev);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(title, "id", "loading-aria");
			add_location(title, file$S, 65, 8, 1730);
			attr_dev(rect, "x", "0");
			attr_dev(rect, "y", "0");
			attr_dev(rect, "width", "100%");
			attr_dev(rect, "height", "100%");
			attr_dev(rect, "clip-path", rect_clip_path_value = `url(#clip-path-${/*uid*/ ctx[7]})`);
			set_style(rect, "fill", "url(\"#loader-fill\")");
			add_location(rect, file$S, 66, 8, 1782);
			attr_dev(clipPath, "id", clipPath_id_value = `clip-path-${/*uid*/ ctx[7]}`);
			add_location(clipPath, file$S, 75, 12, 2015);
			attr_dev(animate0, "attributeName", "offset");
			attr_dev(animate0, "values", "-2; -2; 1");
			attr_dev(animate0, "keyTimes", "0; 0.25; 1");
			attr_dev(animate0, "dur", "2s");
			attr_dev(animate0, "repeatCount", "indefinite");
			add_location(animate0, file$S, 92, 20, 2669);
			attr_dev(stop0, "offset", "0.599964");
			attr_dev(stop0, "stop-color", /*light*/ ctx[0]);
			attr_dev(stop0, "stop-opacity", "1");
			add_location(stop0, file$S, 87, 16, 2511);
			attr_dev(animate1, "attributeName", "offset");
			attr_dev(animate1, "values", "-1; -1; 2");
			attr_dev(animate1, "keyTimes", "0; 0.25; 1");
			attr_dev(animate1, "dur", "2s");
			attr_dev(animate1, "repeatCount", "indefinite");
			add_location(animate1, file$S, 105, 20, 3104);
			attr_dev(stop1, "offset", "1.59996");
			attr_dev(stop1, "stop-color", /*dark*/ ctx[1]);
			attr_dev(stop1, "stop-opacity", "1");
			add_location(stop1, file$S, 100, 16, 2948);
			attr_dev(animate2, "attributeName", "offset");
			attr_dev(animate2, "values", "0; 0; 3");
			attr_dev(animate2, "keyTimes", "0; 0.25; 1");
			attr_dev(animate2, "dur", "2s");
			attr_dev(animate2, "repeatCount", "indefinite");
			add_location(animate2, file$S, 118, 20, 3540);
			attr_dev(stop2, "offset", "2.59996");
			attr_dev(stop2, "stop-color", /*light*/ ctx[0]);
			attr_dev(stop2, "stop-opacity", "1");
			add_location(stop2, file$S, 113, 16, 3383);
			attr_dev(linearGradient, "id", "loader-fill");
			add_location(linearGradient, file$S, 86, 12, 2461);
			add_location(defs, file$S, 74, 8, 1996);
			attr_dev(svg, "role", "img");
			attr_dev(svg, "width", "100%");
			attr_dev(svg, "height", /*areaHeight*/ ctx[5]);
			attr_dev(svg, "aria-labelledby", "loading-aria");
			attr_dev(svg, "viewBox", svg_viewBox_value = `0 0 ${/*areaWidth*/ ctx[4]} 100`);
			attr_dev(svg, "preserveAspectRatio", "none");
			attr_dev(svg, "class", "svelte-13ssox4");
			add_location(svg, file$S, 57, 4, 1528);
			attr_dev(section, "class", section_class_value = "" + (null_to_empty(/*classProp*/ ctx[6]) + " svelte-13ssox4"));
			attr_dev(section, "style", section_style_value = `opacity: ${/*opacity*/ ctx[2]}; outline-color: ${/*light*/ ctx[0]};`);
			add_location(section, file$S, 53, 0, 1430);
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			append_dev(section, svg);
			append_dev(svg, title);
			append_dev(title, t);
			append_dev(svg, rect);
			append_dev(svg, defs);
			append_dev(defs, clipPath);

			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(clipPath, null);
			}

			append_dev(defs, linearGradient);
			append_dev(linearGradient, stop0);
			append_dev(stop0, animate0);
			append_dev(linearGradient, stop1);
			append_dev(stop1, animate1);
			append_dev(linearGradient, stop2);
			append_dev(stop2, animate2);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 4096) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[12], dirty, null, null);
				}
			} else {
				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*type*/ 8) {
					default_slot_or_fallback.p(ctx, dirty);
				}
			}

			if (!current || dirty & /*light*/ 1) {
				attr_dev(stop0, "stop-color", /*light*/ ctx[0]);
			}

			if (!current || dirty & /*dark*/ 2) {
				attr_dev(stop1, "stop-color", /*dark*/ ctx[1]);
			}

			if (!current || dirty & /*light*/ 1) {
				attr_dev(stop2, "stop-color", /*light*/ ctx[0]);
			}

			if (!current || dirty & /*areaHeight*/ 32) {
				attr_dev(svg, "height", /*areaHeight*/ ctx[5]);
			}

			if (!current || dirty & /*areaWidth*/ 16 && svg_viewBox_value !== (svg_viewBox_value = `0 0 ${/*areaWidth*/ ctx[4]} 100`)) {
				attr_dev(svg, "viewBox", svg_viewBox_value);
			}

			if (!current || dirty & /*classProp*/ 64 && section_class_value !== (section_class_value = "" + (null_to_empty(/*classProp*/ ctx[6]) + " svelte-13ssox4"))) {
				attr_dev(section, "class", section_class_value);
			}

			if (!current || dirty & /*opacity, light*/ 5 && section_style_value !== (section_style_value = `opacity: ${/*opacity*/ ctx[2]}; outline-color: ${/*light*/ ctx[0]};`)) {
				attr_dev(section, "style", section_style_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot_or_fallback, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot_or_fallback, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$S.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$S($$self, $$props, $$invalidate) {
	let { width = "100%" } = $$props;
	let { height = "100%" } = $$props;
	let { light = "#999999" } = $$props;
	let { dark = "#555555" } = $$props;
	let { opacity = 0.2 } = $$props;
	let { border = false } = $$props;
	let { absolute = false } = $$props;
	let { type = undefined } = $$props; // h1, h2, h3, h4, h5, h6, p, pre, avatar
	const uid = uuidv4();

	let hTypes = {
		p: 21,
		h1: 35,
		h2: 29,
		h3: 26,
		h4: 21,
		h5: 21,
		h6: 21,
		pre: 21
	};

	onMount(() => {
		const style = getComputedStyle(document.body);
		const lh = Number.parseInt(style.getPropertyValue("line-height"));
		const balance = 0;

		$$invalidate(14, hTypes = {
			p: lh * 1.15 + balance,
			h1: lh * 1.85 + balance,
			h2: lh * 1.4 + balance,
			h3: lh * 1.3 + balance,
			h4: lh * 1.15 + balance,
			h5: lh * 1.15 + balance,
			h6: lh * 1.15 + balance,
			pre: lh * 1.15 + balance
		});
	});

	const writable_props = ["width", "height", "light", "dark", "opacity", "border", "absolute", "type"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Loader> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Loader", $$slots, ['default']);

	$$self.$set = $$props => {
		if ("width" in $$props) $$invalidate(8, width = $$props.width);
		if ("height" in $$props) $$invalidate(9, height = $$props.height);
		if ("light" in $$props) $$invalidate(0, light = $$props.light);
		if ("dark" in $$props) $$invalidate(1, dark = $$props.dark);
		if ("opacity" in $$props) $$invalidate(2, opacity = $$props.opacity);
		if ("border" in $$props) $$invalidate(10, border = $$props.border);
		if ("absolute" in $$props) $$invalidate(11, absolute = $$props.absolute);
		if ("type" in $$props) $$invalidate(3, type = $$props.type);
		if ("$$scope" in $$props) $$invalidate(12, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		onMount,
		classnames,
		uuid: uuidv4,
		Text,
		Circle,
		width,
		height,
		light,
		dark,
		opacity,
		border,
		absolute,
		type,
		uid,
		hTypes,
		areaWidth,
		areaHeight,
		classProp
	});

	$$self.$inject_state = $$props => {
		if ("width" in $$props) $$invalidate(8, width = $$props.width);
		if ("height" in $$props) $$invalidate(9, height = $$props.height);
		if ("light" in $$props) $$invalidate(0, light = $$props.light);
		if ("dark" in $$props) $$invalidate(1, dark = $$props.dark);
		if ("opacity" in $$props) $$invalidate(2, opacity = $$props.opacity);
		if ("border" in $$props) $$invalidate(10, border = $$props.border);
		if ("absolute" in $$props) $$invalidate(11, absolute = $$props.absolute);
		if ("type" in $$props) $$invalidate(3, type = $$props.type);
		if ("hTypes" in $$props) $$invalidate(14, hTypes = $$props.hTypes);
		if ("areaWidth" in $$props) $$invalidate(4, areaWidth = $$props.areaWidth);
		if ("areaHeight" in $$props) $$invalidate(5, areaHeight = $$props.areaHeight);
		if ("classProp" in $$props) $$invalidate(6, classProp = $$props.classProp);
	};

	let areaWidth;
	let areaHeight;
	let classProp;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*width*/ 256) {
			 $$invalidate(4, areaWidth = width.replace("%", ""));
		}

		if ($$self.$$.dirty & /*hTypes, type, height*/ 16904) {
			 $$invalidate(5, areaHeight = hTypes[type] || height);
		}

		if ($$self.$$.dirty & /*border, absolute*/ 3072) {
			 $$invalidate(6, classProp = classnames("loader", { border, absolute }));
		}
	};

	return [
		light,
		dark,
		opacity,
		type,
		areaWidth,
		areaHeight,
		classProp,
		uid,
		width,
		height,
		border,
		absolute,
		$$scope,
		$$slots
	];
}

class Loader extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document_1$2.getElementById("svelte-13ssox4-style")) add_css$g();

		init(this, options, instance$S, create_fragment$S, safe_not_equal, {
			width: 8,
			height: 9,
			light: 0,
			dark: 1,
			opacity: 2,
			border: 10,
			absolute: 11,
			type: 3
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Loader",
			options,
			id: create_fragment$S.name
		});
	}

	get width() {
		throw new Error("<Loader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<Loader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get height() {
		throw new Error("<Loader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set height(value) {
		throw new Error("<Loader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get light() {
		throw new Error("<Loader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set light(value) {
		throw new Error("<Loader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get dark() {
		throw new Error("<Loader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dark(value) {
		throw new Error("<Loader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get opacity() {
		throw new Error("<Loader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set opacity(value) {
		throw new Error("<Loader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get border() {
		throw new Error("<Loader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set border(value) {
		throw new Error("<Loader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get absolute() {
		throw new Error("<Loader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set absolute(value) {
		throw new Error("<Loader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get type() {
		throw new Error("<Loader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set type(value) {
		throw new Error("<Loader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/FieldErrors.svelte generated by Svelte v3.24.0 */
const file$T = "src/components/FieldErrors.svelte";
const get_after_slot_changes = dirty => ({});
const get_after_slot_context = ctx => ({});

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[5] = list[i];
	return child_ctx;
}

const get_before_slot_changes = dirty => ({});
const get_before_slot_context = ctx => ({});

// (9:0) {#if list && list.length}
function create_if_block$a(ctx) {
	let t0;
	let ul;
	let ul_class_value;
	let t1;
	let current;
	const before_slot_template = /*$$slots*/ ctx[4].before;
	const before_slot = create_slot(before_slot_template, ctx, /*$$scope*/ ctx[3], get_before_slot_context);
	let each_value = /*list*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	const after_slot_template = /*$$slots*/ ctx[4].after;
	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[3], get_after_slot_context);

	const block = {
		c: function create() {
			if (before_slot) before_slot.c();
			t0 = space();
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t1 = space();
			if (after_slot) after_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			if (before_slot) before_slot.l(nodes);
			t0 = claim_space(nodes);
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(ul_nodes);
			}

			ul_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			if (after_slot) after_slot.l(nodes);
			this.h();
		},
		h: function hydrate() {
			attr_dev(ul, "class", ul_class_value = `font-primary font-w-500 h4 text-danger text-left ${/*$$props*/ ctx[1].class || ""}`);
			add_location(ul, file$T, 10, 4, 217);
		},
		m: function mount(target, anchor) {
			if (before_slot) {
				before_slot.m(target, anchor);
			}

			insert_dev(target, t0, anchor);
			insert_dev(target, ul, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}

			insert_dev(target, t1, anchor);

			if (after_slot) {
				after_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (before_slot) {
				if (before_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(before_slot, before_slot_template, ctx, /*$$scope*/ ctx[3], dirty, get_before_slot_changes, get_before_slot_context);
				}
			}

			if (dirty & /*list*/ 1) {
				each_value = /*list*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(ul, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (!current || dirty & /*$$props*/ 2 && ul_class_value !== (ul_class_value = `font-primary font-w-500 h4 text-danger text-left ${/*$$props*/ ctx[1].class || ""}`)) {
				attr_dev(ul, "class", ul_class_value);
			}

			if (after_slot) {
				if (after_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(after_slot, after_slot_template, ctx, /*$$scope*/ ctx[3], dirty, get_after_slot_changes, get_after_slot_context);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(before_slot, local);

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			transition_in(after_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(before_slot, local);
			transition_out(after_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (before_slot) before_slot.d(detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(ul);
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(t1);
			if (after_slot) after_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$a.name,
		type: "if",
		source: "(9:0) {#if list && list.length}",
		ctx
	});

	return block;
}

// (12:8) {#each list as item}
function create_each_block$1(ctx) {
	let li;
	let t0;
	let t1_value = /*item*/ ctx[5] + "";
	let t1;
	let li_intro;

	const block = {
		c: function create() {
			li = element("li");
			t0 = text("* ");
			t1 = text(t1_value);
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", {});
			var li_nodes = children(li);
			t0 = claim_text(li_nodes, "* ");
			t1 = claim_text(li_nodes, t1_value);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(li, file$T, 12, 12, 345);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, t0);
			append_dev(li, t1);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*list*/ 1 && t1_value !== (t1_value = /*item*/ ctx[5] + "")) set_data_dev(t1, t1_value);
		},
		i: function intro(local) {
			if (!li_intro) {
				add_render_callback(() => {
					li_intro = create_in_transition(li, slide, {});
					li_intro.start();
				});
			}
		},
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$1.name,
		type: "each",
		source: "(12:8) {#each list as item}",
		ctx
	});

	return block;
}

function create_fragment$T(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*list*/ ctx[0] && /*list*/ ctx[0].length && create_if_block$a(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*list*/ ctx[0] && /*list*/ ctx[0].length) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*list*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$a(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$T.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$T($$self, $$props, $$invalidate) {
	let { items } = $$props;
	let { $$slots = {}, $$scope } = $$props;
	validate_slots("FieldErrors", $$slots, ['before','after']);

	$$self.$set = $$new_props => {
		$$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("items" in $$new_props) $$invalidate(2, items = $$new_props.items);
		if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({ slide, items, list });

	$$self.$inject_state = $$new_props => {
		$$invalidate(1, $$props = assign(assign({}, $$props), $$new_props));
		if ("items" in $$props) $$invalidate(2, items = $$new_props.items);
		if ("list" in $$props) $$invalidate(0, list = $$new_props.list);
	};

	let list;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*items*/ 4) {
			 $$invalidate(0, list = [].concat(items || []).slice(0, 1).filter(Boolean));
		}
	};

	$$props = exclude_internal_props($$props);
	return [list, $$props, items, $$scope, $$slots];
}

class FieldErrors extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$T, create_fragment$T, safe_not_equal, { items: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "FieldErrors",
			options,
			id: create_fragment$T.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*items*/ ctx[2] === undefined && !("items" in props)) {
			console.warn("<FieldErrors> was created without expected prop 'items'");
		}
	}

	get items() {
		throw new Error("<FieldErrors>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set items(value) {
		throw new Error("<FieldErrors>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/fields/Input.svelte generated by Svelte v3.24.0 */
const file$U = "src/components/fields/Input.svelte";

function add_css$h() {
	var style = element("style");
	style.id = "svelte-1ckwvo6-style";
	style.textContent = ".inp.svelte-1ckwvo6.svelte-1ckwvo6{width:100%;-webkit-box-flex:1;-ms-flex:1 1 auto;flex:1 1 auto;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column}.inp.svelte-1ckwvo6 .inp-inner-wrap.svelte-1ckwvo6{position:relative;display:-webkit-box;display:-ms-flexbox;display:flex;-ms-flex-item-align:stretch;align-self:stretch;-webkit-box-shadow:var(--shadow-field-inset);box-shadow:var(--shadow-field-inset);border-radius:var(--border-radius-small);background-color:rgba(var(--theme-input-bg-color))}.inp.svelte-1ckwvo6 .inp-inner.svelte-1ckwvo6{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;color:inherit;overflow-y:auto;overflow-x:hidden;background-color:transparent;-webkit-overflow-scrolling:touch;min-width:var(--min-interactive-size);min-height:var(--min-interactive-size);border-radius:var(--border-radius-small)}.inp.disabled.svelte-1ckwvo6.svelte-1ckwvo6{opacity:.5;pointer-events:none}.inp.postIcon.svelte-1ckwvo6 .inp-inner.svelte-1ckwvo6{padding-right:var(--min-interactive-size)}.inp.svelte-1ckwvo6 .inp-inner.svelte-1ckwvo6:invalid,.inp.error.svelte-1ckwvo6 .inp-inner.svelte-1ckwvo6{-webkit-box-shadow:0 0 0 1px rgb(var(--color-danger));box-shadow:0 0 0 1px rgb(var(--color-danger));color:rgb(var(--color-danger))}.inp.svelte-1ckwvo6 .inp-inner.svelte-1ckwvo6:focus{-webkit-box-shadow:0 0 0 1px rgb(var(--color-info));box-shadow:0 0 0 1px rgb(var(--color-info));color:rgb(var(--color-info))}.inp .inp-inner:invalid+.inp-post-icon.svelte-1ckwvo6.svelte-1ckwvo6 .ico,.inp.error.svelte-1ckwvo6 .inp-post-icon.svelte-1ckwvo6 .ico{color:rgb(var(--color-danger)) !important}.inp .inp-inner:focus+.inp-post-icon.svelte-1ckwvo6.svelte-1ckwvo6 .ico{color:rgb(var(--color-info)) !important}.inp.svelte-1ckwvo6 .inp-post-icon-inner.svelte-1ckwvo6{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;width:var(--min-interactive-size)}.inp.svelte-1ckwvo6 .inp-post-icon.svelte-1ckwvo6{position:absolute;top:0;right:0;height:100%;width:var(--min-interactive-size);-webkit-box-flex:0;-ms-flex:none;flex:none;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;overflow:hidden}.inp.svelte-1ckwvo6 .inp-inner.svelte-1ckwvo6::-webkit-input-placeholder{color:rgba(var(--theme-color-primary-opposite));opacity:.2}.inp.svelte-1ckwvo6 .inp-inner.svelte-1ckwvo6::-moz-placeholder{color:rgba(var(--theme-color-primary-opposite));opacity:.2}.inp.svelte-1ckwvo6 .inp-inner.svelte-1ckwvo6:-ms-input-placeholder{color:rgba(var(--theme-color-primary-opposite));opacity:.2}.inp.svelte-1ckwvo6 .inp-inner.svelte-1ckwvo6::-ms-input-placeholder{color:rgba(var(--theme-color-primary-opposite));opacity:.2}.inp.svelte-1ckwvo6 .inp-inner.svelte-1ckwvo6::placeholder{color:rgba(var(--theme-color-primary-opposite));opacity:.2}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSW5wdXQuc3ZlbHRlIiwic291cmNlcyI6WyJJbnB1dC5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBjcmVhdGVFdmVudERpc3BhdGNoZXIgfSBmcm9tICdzdmVsdGUnXG4gICAgaW1wb3J0IHsgY2xhc3NuYW1lcywgdG9DU1NTdHJpbmcgfSBmcm9tICdAdXRpbHMnXG4gICAgaW1wb3J0IEJyIGZyb20gJ0Bjb21wb25lbnRzL0JyLnN2ZWx0ZSdcbiAgICBpbXBvcnQgSWNvbiBmcm9tICdAY29tcG9uZW50cy9JY29uLnN2ZWx0ZSdcbiAgICBpbXBvcnQgRmllbGRFcnJvcnMgZnJvbSAnQGNvbXBvbmVudHMvRmllbGRFcnJvcnMuc3ZlbHRlJ1xuXG4gICAgY29uc3QgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXIoKVxuXG4gICAgZXhwb3J0IGxldCBuYW1lXG4gICAgZXhwb3J0IGxldCB2YWx1ZSA9ICcnXG4gICAgZXhwb3J0IGxldCBzdHlsZSA9IHt9XG4gICAgZXhwb3J0IGxldCB0eXBlID0gJ3RleHQnXG4gICAgZXhwb3J0IGxldCBpZCA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgbWluID0gdW5kZWZpbmVkIC8vIFNwZWNpZmllcyBhIG1pbmltdW0gdmFsdWUgZm9yIGFuIDxpbnB1dD4gZWxlbWVudFxuICAgIGV4cG9ydCBsZXQgbWF4ID0gdW5kZWZpbmVkIC8vIFNwZWNpZmllcyB0aGUgbWF4aW11bSB2YWx1ZSBmb3IgYW4gPGlucHV0PiBlbGVtZW50XG4gICAgZXhwb3J0IGxldCBsaXN0ID0gdW5kZWZpbmVkIC8vIFJlZmVycyB0byBhIDxkYXRhbGlzdD4gZWxlbWVudCB0aGF0IGNvbnRhaW5zIHByZS1kZWZpbmVkIG9wdGlvbnMgZm9yIGFuIDxpbnB1dD4gZWxlbWVudFxuICAgIGV4cG9ydCBsZXQgZm9ybSA9IHVuZGVmaW5lZCAvLyBTcGVjaWZpZXMgdGhlIGZvcm0gdGhlIDxpbnB1dD4gZWxlbWVudCBiZWxvbmdzIHRvXG4gICAgZXhwb3J0IGxldCBtYXhsZW5ndGggPSAxMDAwXG4gICAgZXhwb3J0IGxldCBkaXNhYmxlZCA9IGZhbHNlXG4gICAgZXhwb3J0IGxldCByb3dzID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCBhbGlnbiA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgbGFiZWwgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IGVycm9ycyA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgaW52YWxpZCA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgcGF0dGVybiA9IHVuZGVmaW5lZCAvLyBTcGVjaWZpZXMgYSByZWd1bGFyIGV4cHJlc3Npb24gdGhhdCBhbiA8aW5wdXQ+IGVsZW1lbnQncyB2YWx1ZSBpcyBjaGVja2VkIGFnYWluc3QgKHJlZ2V4cClcbiAgICBleHBvcnQgbGV0IHJlYWRvbmx5ID0gdW5kZWZpbmVkIC8vIHVuZGVmaW5lZHxyZWFkb25seVxuICAgIGV4cG9ydCBsZXQgcmVxdWlyZWQgPSB1bmRlZmluZWQgLy8gdW5kZWZpbmVkfHJlcXVpcmVkXG4gICAgZXhwb3J0IGxldCBwb3N0SWNvbiA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgYXJpYUxhYmVsID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCBtaW5sZW5ndGggPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IHBsYWNlaG9sZGVyID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCBhdXRvY29tcGxldGUgPSB1bmRlZmluZWQvLyBvbnxvZmZcblxuICAgIC8qKlxuICAgICAqIGF1dG9jb21wbGV0ZSAtIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvQXR0cmlidXRlcy9hdXRvY29tcGxldGVcbiAgICAgKiBuYW1lcyAtIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3dlYi91cGRhdGVzLzIwMTUvMDYvY2hlY2tvdXQtZmFzdGVyLXdpdGgtYXV0b2ZpbGxcbiAgICAgKi9cbiAgICBjb25zdCBuYW1lVHlwZXMgPSB7XG4gICAgICAgICdzZXgnOiB7IGF1dG9jb21wbGV0ZTogJ3NleCcgfSxcbiAgICAgICAgJ2JkYXknOiB7IGF1dG9jb21wbGV0ZTogJ2JkYXknIH0sXG4gICAgICAgICduYW1lJzogeyBhdXRvY29tcGxldGU6ICduYW1lJyB9LFxuICAgICAgICAncGhvbmUnOiB7IGF1dG9jb21wbGV0ZTogJ3RlbCcgfSxcbiAgICAgICAgJ2ZuYW1lJzogeyBhdXRvY29tcGxldGU6ICduYW1lJyB9LFxuICAgICAgICAnbG5hbWUnOiB7IGF1dG9jb21wbGV0ZTogJ25hbWUnIH0sXG4gICAgICAgICdlbWFpbCc6IHsgYXV0b2NvbXBsZXRlOiAnZW1haWwnIH0sXG4gICAgICAgICdwYXNzd29yZCc6IHsgYXV0b2NvbXBsZXRlOiAnbmV3LXBhc3N3b3JkJyB9LFxuICAgICAgICBcbiAgICAgICAgJ2N2Yyc6IHsgYXV0b2NvbXBsZXRlOiAnY2MtY3NjJyB9LFxuICAgICAgICAnY2MtZXhwJzogeyBhdXRvY29tcGxldGU6ICdjYy1leHAnIH0sXG4gICAgICAgICdjY25hbWUnOiB7IGF1dG9jb21wbGV0ZTogJ2NjLW5hbWUnIH0sXG4gICAgICAgICdjYXJkbnVtYmVyJzogeyBhdXRvY29tcGxldGU6ICdjYy1udW1iZXInIH0sXG5cbiAgICAgICAgJ3NoaXAtc3RhdGUnOiB7IGF1dG9jb21wbGV0ZTogJ3NoaXBwaW5nIHJlZ2lvbicgfSxcbiAgICAgICAgJ3NoaXAtY2l0eSc6IHsgYXV0b2NvbXBsZXRlOiAnc2hpcHBpbmcgbG9jYWxpdHknIH0sXG4gICAgICAgICdzaGlwLXppcCc6IHsgYXV0b2NvbXBsZXRlOiAnc2hpcHBpbmcgcG9zdGFsLWNvZGUnIH0sXG4gICAgICAgICdzaGlwLWNvdW50cnknOiB7IGF1dG9jb21wbGV0ZTogJ3NoaXBwaW5nIGNvdW50cnknIH0sXG4gICAgICAgICdzaGlwLWFkZHJlc3MnOiB7IGF1dG9jb21wbGV0ZTogJ3NoaXBwaW5nIHN0cmVldC1hZGRyZXNzJyB9LFxuICAgIH1cblxuICAgIGNvbnN0IHR5cGVQb3N0SWNvbnMgPSB7XG4gICAgICBkYXRlOiAnY2FsZW5kYXInLFxuICAgICAgc2VhcmNoOiAnc2VhcmNoJyxcbiAgICB9XG5cbiAgICAkOiBpbnB1dFByZWRpY3QgPSBuYW1lVHlwZXNbbmFtZV0gfHwge31cbiAgICAkOiBpY29uVHlwZSA9IHBvc3RJY29uIHx8IHR5cGVQb3N0SWNvbnNbdHlwZV1cblxuICAgICQ6IGVycm9yID0gaW52YWxpZCAhPT0gdW5kZWZpbmVkID8gaW52YWxpZCA6ICEhKGVycm9ycyB8fCBbXSkubGVuZ3RoXG4gICAgJDogaWRQcm9wID0gaWQgfHwgaW5wdXRQcmVkaWN0LmlkIHx8IG5hbWVcbiAgICAkOiB0eXBlUHJvcCA9IHR5cGVcbiAgICAkOiB0aXRsZVByb3AgPSBsYWJlbCB8fCBhcmlhTGFiZWxcbiAgICAkOiBhcmlhTGFiZWxQcm9wID0gYXJpYUxhYmVsIHx8IGxhYmVsIHx8IHBsYWNlaG9sZGVyXG4gICAgJDogc3R5bGVQcm9wID0gdG9DU1NTdHJpbmcoeyAuLi5zdHlsZSwgdGV4dEFsaWduOiBhbGlnbiB9KVxuICAgICQ6IHBhdHRlcm5Qcm9wID0gdHlwZSA9PT0gJ251bWJlcicgJiYgIXBhdHRlcm4gPyAnWzAtOV0qJyA6IHBhdHRlcm5cbiAgICAkOiBjbGFzc1Byb3AgPSBjbGFzc25hbWVzKCdpbnAnLCAkJHByb3BzLmNsYXNzLCB7IGRpc2FibGVkLCByZWFkb25seSwgcmVxdWlyZWQsIGVycm9yLCBwb3N0SWNvbjogaWNvblR5cGUgfSlcbiAgICAkOiBhdXRvY29tcGxldGVQcm9wID0gYXV0b2NvbXBsZXRlIHx8IGlucHV0UHJlZGljdC5hdXRvY29tcGxldGVcblxuICAgIGZ1bmN0aW9uIG9uSW5wdXQoZSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGdldFZhbHVlKGUpXG4gICAgICAgIGRpc3BhdGNoKCdpbnB1dCcsIHsgZSwgdmFsdWUsIG5hbWUgfSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkNoYW5nZShlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZ2V0VmFsdWUoZSlcbiAgICAgICAgZGlzcGF0Y2goJ2NoYW5nZScsIHsgZSwgdmFsdWUsIG5hbWUgfSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRWYWx1ZShlKSB7XG4gICAgICAgIHJldHVybiBlLnRhcmdldC52YWx1ZVxuICAgIH1cbjwvc2NyaXB0PlxuXG48ZGl2IGNsYXNzPXtjbGFzc1Byb3B9PlxuICAgIHsjaWYgdGl0bGVQcm9wfVxuICAgICAgICA8bGFiZWwgZm9yPXtpZFByb3B9IGNsYXNzPVwiaW5wLWxhYmVsIGgyIGZvbnQtc2Vjb25kYXJ5IGZvbnQtdy02MDAgdGV4dC1sZWZ0XCI+XG4gICAgICAgICAgICB7IHRpdGxlUHJvcCB9XG4gICAgICAgICAgICA8QnIgc2l6ZT1cIjEwXCIvPlxuICAgICAgICA8L2xhYmVsPlxuICAgIHsvaWZ9XG5cbiAgICA8ZGl2IGNsYXNzPVwiaW5wLWlubmVyLXdyYXBcIj5cbiAgICAgICAgeyNpZiByb3dzIHx8IHR5cGUgPT09ICd0ZXh0YXJlYSd9XG4gICAgICAgICAgICA8dGV4dGFyZWFcbiAgICAgICAgICAgICAgICAgICAge21pbn1cbiAgICAgICAgICAgICAgICAgICAge21heH1cbiAgICAgICAgICAgICAgICAgICAge3Jvd3N9XG4gICAgICAgICAgICAgICAgICAgIHtuYW1lfVxuICAgICAgICAgICAgICAgICAgICB7Zm9ybX1cbiAgICAgICAgICAgICAgICAgICAge2FsaWdufVxuICAgICAgICAgICAgICAgICAgICB7cmVhZG9ubHl9XG4gICAgICAgICAgICAgICAgICAgIHtkaXNhYmxlZH1cbiAgICAgICAgICAgICAgICAgICAge3JlcXVpcmVkfVxuICAgICAgICAgICAgICAgICAgICB7bWlubGVuZ3RofVxuICAgICAgICAgICAgICAgICAgICB7bWF4bGVuZ3RofVxuICAgICAgICAgICAgICAgICAgICB7cGxhY2Vob2xkZXJ9XG4gICAgICAgICAgICAgICAgICAgIGlkPXtpZFByb3B9XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiaW5wLWlubmVyXCJcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU9e3RpdGxlUHJvcH1cbiAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3N0eWxlUHJvcH1cbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybj17cGF0dGVyblByb3B9XG4gICAgICAgICAgICAgICAgICAgIGFyaWEtbGFiZWw9e2FyaWFMYWJlbFByb3B9XG4gICAgICAgICAgICAgICAgICAgIGF1dG9jb21wbGV0ZT17YXV0b2NvbXBsZXRlUHJvcH1cbiAgICAgICAgICAgICAgICAgICAgey4uLnsgdHlwZTogdHlwZVByb3AgfX1cbiAgICAgICAgICAgICAgICAgICAgYmluZDp2YWx1ZT17dmFsdWV9XG4gICAgICAgICAgICAgICAgICAgIG9uOmlucHV0PXtvbklucHV0fVxuICAgICAgICAgICAgICAgICAgICBvbjpjaGFuZ2U9e29uQ2hhbmdlfVxuICAgICAgICAgICAgICAgICAgICBvbjpibHVyPSd7ZSA9PiAhZGlzYWJsZWQgJiYgZGlzcGF0Y2goXCJibHVyXCIsIGUpfSdcbiAgICAgICAgICAgICAgICAgICAgb246Zm9jdXM9J3tlID0+ICFkaXNhYmxlZCAmJiBkaXNwYXRjaChcImZvY3VzXCIsIGUpfSdcbiAgICAgICAgICAgID48L3RleHRhcmVhPlxuICAgICAgICB7OmVsc2V9XG4gICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICAgICAge21pbn1cbiAgICAgICAgICAgICAgICAgICAge21heH1cbiAgICAgICAgICAgICAgICAgICAge25hbWV9XG4gICAgICAgICAgICAgICAgICAgIHtsaXN0fVxuICAgICAgICAgICAgICAgICAgICB7Zm9ybX1cbiAgICAgICAgICAgICAgICAgICAge2FsaWdufVxuICAgICAgICAgICAgICAgICAgICB7cmVhZG9ubHl9XG4gICAgICAgICAgICAgICAgICAgIHtkaXNhYmxlZH1cbiAgICAgICAgICAgICAgICAgICAge3JlcXVpcmVkfVxuICAgICAgICAgICAgICAgICAgICB7bWlubGVuZ3RofVxuICAgICAgICAgICAgICAgICAgICB7bWF4bGVuZ3RofVxuICAgICAgICAgICAgICAgICAgICB7cGxhY2Vob2xkZXJ9XG4gICAgICAgICAgICAgICAgICAgIGlkPXtpZFByb3B9XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiaW5wLWlubmVyXCJcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU9e3RpdGxlUHJvcH1cbiAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3N0eWxlUHJvcH1cbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybj17cGF0dGVyblByb3B9XG4gICAgICAgICAgICAgICAgICAgIGFyaWEtbGFiZWw9e2FyaWFMYWJlbFByb3B9XG4gICAgICAgICAgICAgICAgICAgIGF1dG9jb21wbGV0ZT17YXV0b2NvbXBsZXRlUHJvcH1cbiAgICAgICAgICAgICAgICAgICAgey4uLnsgdHlwZTogdHlwZVByb3AgfX1cbiAgICAgICAgICAgICAgICAgICAgYmluZDp2YWx1ZT17dmFsdWV9XG4gICAgICAgICAgICAgICAgICAgIG9uOmlucHV0PXtvbklucHV0fVxuICAgICAgICAgICAgICAgICAgICBvbjpjaGFuZ2U9e29uQ2hhbmdlfVxuICAgICAgICAgICAgICAgICAgICBvbjpibHVyPSd7ZSA9PiAhZGlzYWJsZWQgJiYgZGlzcGF0Y2goXCJibHVyXCIsIGUpfSdcbiAgICAgICAgICAgICAgICAgICAgb246Zm9jdXM9J3tlID0+ICFkaXNhYmxlZCAmJiBkaXNwYXRjaChcImZvY3VzXCIsIGUpfSdcbiAgICAgICAgICAgID5cbiAgICAgICAgey9pZn1cblxuICAgICAgICA8bGFiZWwgZm9yPXtpZFByb3B9IGNsYXNzPVwiaW5wLXBvc3QtaWNvblwiPlxuICAgICAgICAgICAgPHNsb3QgbmFtZT1cInBvc3QtaWNvblwiPlxuICAgICAgICAgICAgICAgIHsjaWYgaWNvblR5cGV9XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaW5wLXBvc3QtaWNvbi1pbm5lclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPEljb24gdHlwZT17aWNvblR5cGV9IGlzPVwiaW5mb1wiIHNpemU9XCJtZWRpdW1cIi8+XG4gICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICB7L2lmfVxuICAgICAgICAgICAgPC9zbG90PlxuICAgICAgICA8L2xhYmVsPlxuICAgIDwvZGl2PlxuXG4gICAgPEZpZWxkRXJyb3JzIGl0ZW1zPXtlcnJvcnN9PlxuICAgICAgICA8ZGl2IHNsb3Q9XCJiZWZvcmVcIj5cbiAgICAgICAgICAgIDxCciBzaXplPVwiNVwiLz5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9GaWVsZEVycm9ycz5cbjwvZGl2PlxuXG48c3R5bGU+XG4uaW5wIHtcbiAgICB3aWR0aDogMTAwJTtcbiAgICAtd2Via2l0LWJveC1mbGV4OiAxO1xuICAgICAgICAtbXMtZmxleDogMSAxIGF1dG87XG4gICAgICAgICAgICBmbGV4OiAxIDEgYXV0bztcbiAgICBkaXNwbGF5OiAtd2Via2l0LWJveDtcbiAgICBkaXNwbGF5OiAtbXMtZmxleGJveDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIC13ZWJraXQtYm94LW9yaWVudDogdmVydGljYWw7XG4gICAgLXdlYmtpdC1ib3gtZGlyZWN0aW9uOiBub3JtYWw7XG4gICAgICAgIC1tcy1mbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbn1cblxuLmlucCAuaW5wLWlubmVyLXdyYXAge1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICBkaXNwbGF5OiAtd2Via2l0LWJveDtcbiAgICBkaXNwbGF5OiAtbXMtZmxleGJveDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIC1tcy1mbGV4LWl0ZW0tYWxpZ246IHN0cmV0Y2g7XG4gICAgICAgIGFsaWduLXNlbGY6IHN0cmV0Y2g7XG4gICAgLXdlYmtpdC1ib3gtc2hhZG93OiB2YXIoLS1zaGFkb3ctZmllbGQtaW5zZXQpO1xuICAgICAgICAgICAgYm94LXNoYWRvdzogdmFyKC0tc2hhZG93LWZpZWxkLWluc2V0KTtcbiAgICBib3JkZXItcmFkaXVzOiB2YXIoLS1ib3JkZXItcmFkaXVzLXNtYWxsKTtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKHZhcigtLXRoZW1lLWlucHV0LWJnLWNvbG9yKSk7XG59XG5cbi5pbnAgLmlucC1pbm5lciB7XG4gICAgLXdlYmtpdC1ib3gtZmxleDogMTtcbiAgICAgICAgLW1zLWZsZXgtcG9zaXRpdmU6IDE7XG4gICAgICAgICAgICBmbGV4LWdyb3c6IDE7XG4gICAgY29sb3I6IGluaGVyaXQ7XG4gICAgb3ZlcmZsb3cteTogYXV0bztcbiAgICBvdmVyZmxvdy14OiBoaWRkZW47XG4gICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG4gICAgLXdlYmtpdC1vdmVyZmxvdy1zY3JvbGxpbmc6IHRvdWNoO1xuICAgIG1pbi13aWR0aDogdmFyKC0tbWluLWludGVyYWN0aXZlLXNpemUpO1xuICAgIG1pbi1oZWlnaHQ6IHZhcigtLW1pbi1pbnRlcmFjdGl2ZS1zaXplKTtcbiAgICBib3JkZXItcmFkaXVzOiB2YXIoLS1ib3JkZXItcmFkaXVzLXNtYWxsKTtcbn1cblxuLmlucC5kaXNhYmxlZCB7XG4gICAgb3BhY2l0eTogLjU7XG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG59XG5cbi5pbnAucG9zdEljb24gLmlucC1pbm5lciB7XG4gICAgcGFkZGluZy1yaWdodDogdmFyKC0tbWluLWludGVyYWN0aXZlLXNpemUpO1xufVxuXG4uaW5wIC5pbnAtaW5uZXI6aW52YWxpZCwgLmlucC5lcnJvciAuaW5wLWlubmVyIHtcbiAgICAtd2Via2l0LWJveC1zaGFkb3c6IDAgMCAwIDFweCByZ2IodmFyKC0tY29sb3ItZGFuZ2VyKSk7XG4gICAgICAgICAgICBib3gtc2hhZG93OiAwIDAgMCAxcHggcmdiKHZhcigtLWNvbG9yLWRhbmdlcikpO1xuICAgIGNvbG9yOiByZ2IodmFyKC0tY29sb3ItZGFuZ2VyKSk7XG59XG5cbi5pbnAgLmlucC1pbm5lcjpmb2N1cyB7XG4gICAgLXdlYmtpdC1ib3gtc2hhZG93OiAwIDAgMCAxcHggcmdiKHZhcigtLWNvbG9yLWluZm8pKTtcbiAgICAgICAgICAgIGJveC1zaGFkb3c6IDAgMCAwIDFweCByZ2IodmFyKC0tY29sb3ItaW5mbykpO1xuICAgIGNvbG9yOiByZ2IodmFyKC0tY29sb3ItaW5mbykpO1xufVxuXG5cbi5pbnAgLmlucC1pbm5lcjppbnZhbGlkICsgLmlucC1wb3N0LWljb24gOmdsb2JhbCguaWNvKSxcbi5pbnAuZXJyb3IgLmlucC1wb3N0LWljb24gOmdsb2JhbCguaWNvKSB7XG4gICAgY29sb3I6IHJnYih2YXIoLS1jb2xvci1kYW5nZXIpKSAhaW1wb3J0YW50O1xufVxuXG4uaW5wIC5pbnAtaW5uZXI6Zm9jdXMgKyAuaW5wLXBvc3QtaWNvbiA6Z2xvYmFsKC5pY28pIHtcbiAgICBjb2xvcjogcmdiKHZhcigtLWNvbG9yLWluZm8pKSAhaW1wb3J0YW50O1xufVxuXG4uaW5wIC5pbnAtcG9zdC1pY29uLWlubmVyIHtcbiAgICBkaXNwbGF5OiAtd2Via2l0LWJveDtcbiAgICBkaXNwbGF5OiAtbXMtZmxleGJveDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIC13ZWJraXQtYm94LWFsaWduOiBjZW50ZXI7XG4gICAgICAgIC1tcy1mbGV4LWFsaWduOiBjZW50ZXI7XG4gICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIC13ZWJraXQtYm94LXBhY2s6IGNlbnRlcjtcbiAgICAgICAgLW1zLWZsZXgtcGFjazogY2VudGVyO1xuICAgICAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgd2lkdGg6IHZhcigtLW1pbi1pbnRlcmFjdGl2ZS1zaXplKTtcbn1cblxuLmlucCAuaW5wLXBvc3QtaWNvbiB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHRvcDogMDtcbiAgICByaWdodDogMDtcbiAgICBoZWlnaHQ6IDEwMCU7XG4gICAgd2lkdGg6IHZhcigtLW1pbi1pbnRlcmFjdGl2ZS1zaXplKTtcbiAgICAtd2Via2l0LWJveC1mbGV4OiAwO1xuICAgICAgICAtbXMtZmxleDogbm9uZTtcbiAgICAgICAgICAgIGZsZXg6IG5vbmU7XG4gICAgZGlzcGxheTogLXdlYmtpdC1ib3g7XG4gICAgZGlzcGxheTogLW1zLWZsZXhib3g7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICAtd2Via2l0LWJveC1hbGlnbjogY2VudGVyO1xuICAgICAgICAtbXMtZmxleC1hbGlnbjogY2VudGVyO1xuICAgICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAtd2Via2l0LWJveC1wYWNrOiBjZW50ZXI7XG4gICAgICAgIC1tcy1mbGV4LXBhY2s6IGNlbnRlcjtcbiAgICAgICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG59XG5cbi5pbnAgLmlucC1pbm5lcjo6LXdlYmtpdC1pbnB1dC1wbGFjZWhvbGRlciB7XG4gICAgY29sb3I6IHJnYmEodmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeS1vcHBvc2l0ZSkpO1xuICAgIG9wYWNpdHk6IC4yO1xufVxuXG4uaW5wIC5pbnAtaW5uZXI6Oi1tb3otcGxhY2Vob2xkZXIge1xuICAgIGNvbG9yOiByZ2JhKHZhcigtLXRoZW1lLWNvbG9yLXByaW1hcnktb3Bwb3NpdGUpKTtcbiAgICBvcGFjaXR5OiAuMjtcbn1cblxuLmlucCAuaW5wLWlubmVyOi1tcy1pbnB1dC1wbGFjZWhvbGRlciB7XG4gICAgY29sb3I6IHJnYmEodmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeS1vcHBvc2l0ZSkpO1xuICAgIG9wYWNpdHk6IC4yO1xufVxuXG4uaW5wIC5pbnAtaW5uZXI6Oi1tcy1pbnB1dC1wbGFjZWhvbGRlciB7XG4gICAgY29sb3I6IHJnYmEodmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeS1vcHBvc2l0ZSkpO1xuICAgIG9wYWNpdHk6IC4yO1xufVxuXG4uaW5wIC5pbnAtaW5uZXI6OnBsYWNlaG9sZGVyIHtcbiAgICBjb2xvcjogcmdiYSh2YXIoLS10aGVtZS1jb2xvci1wcmltYXJ5LW9wcG9zaXRlKSk7XG4gICAgb3BhY2l0eTogLjI7XG59PC9zdHlsZT5cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFtTEEsSUFBSSw4QkFBQyxDQUFDLEFBQ0YsS0FBSyxDQUFFLElBQUksQ0FDWCxnQkFBZ0IsQ0FBRSxDQUFDLENBQ2YsUUFBUSxDQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUNkLElBQUksQ0FBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FDdEIsT0FBTyxDQUFFLFdBQVcsQ0FDcEIsT0FBTyxDQUFFLFdBQVcsQ0FDcEIsT0FBTyxDQUFFLElBQUksQ0FDYixrQkFBa0IsQ0FBRSxRQUFRLENBQzVCLHFCQUFxQixDQUFFLE1BQU0sQ0FDekIsa0JBQWtCLENBQUUsTUFBTSxDQUN0QixjQUFjLENBQUUsTUFBTSxBQUNsQyxDQUFDLEFBRUQsbUJBQUksQ0FBQyxlQUFlLGVBQUMsQ0FBQyxBQUNsQixRQUFRLENBQUUsUUFBUSxDQUNsQixPQUFPLENBQUUsV0FBVyxDQUNwQixPQUFPLENBQUUsV0FBVyxDQUNwQixPQUFPLENBQUUsSUFBSSxDQUNiLG1CQUFtQixDQUFFLE9BQU8sQ0FDeEIsVUFBVSxDQUFFLE9BQU8sQ0FDdkIsa0JBQWtCLENBQUUsSUFBSSxvQkFBb0IsQ0FBQyxDQUNyQyxVQUFVLENBQUUsSUFBSSxvQkFBb0IsQ0FBQyxDQUM3QyxhQUFhLENBQUUsSUFBSSxxQkFBcUIsQ0FBQyxDQUN6QyxnQkFBZ0IsQ0FBRSxLQUFLLElBQUksc0JBQXNCLENBQUMsQ0FBQyxBQUN2RCxDQUFDLEFBRUQsbUJBQUksQ0FBQyxVQUFVLGVBQUMsQ0FBQyxBQUNiLGdCQUFnQixDQUFFLENBQUMsQ0FDZixpQkFBaUIsQ0FB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 */";
	append_dev(document.head, style);
}

const get_post_icon_slot_changes = dirty => ({});
const get_post_icon_slot_context = ctx => ({});

// (95:4) {#if titleProp}
function create_if_block_2$1(ctx) {
	let label_1;
	let t0;
	let t1;
	let br;
	let current;
	br = new Br({ props: { size: "10" }, $$inline: true });

	const block = {
		c: function create() {
			label_1 = element("label");
			t0 = text(/*titleProp*/ ctx[19]);
			t1 = space();
			create_component(br.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			label_1 = claim_element(nodes, "LABEL", { for: true, class: true });
			var label_1_nodes = children(label_1);
			t0 = claim_text(label_1_nodes, /*titleProp*/ ctx[19]);
			t1 = claim_space(label_1_nodes);
			claim_component(br.$$.fragment, label_1_nodes);
			label_1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(label_1, "for", /*idProp*/ ctx[17]);
			attr_dev(label_1, "class", "inp-label h2 font-secondary font-w-600 text-left");
			add_location(label_1, file$U, 95, 8, 3678);
		},
		m: function mount(target, anchor) {
			insert_dev(target, label_1, anchor);
			append_dev(label_1, t0);
			append_dev(label_1, t1);
			mount_component(br, label_1, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (!current || dirty[0] & /*titleProp*/ 524288) set_data_dev(t0, /*titleProp*/ ctx[19]);

			if (!current || dirty[0] & /*idProp*/ 131072) {
				attr_dev(label_1, "for", /*idProp*/ ctx[17]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(br.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(label_1);
			destroy_component(br);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$1.name,
		type: "if",
		source: "(95:4) {#if titleProp}",
		ctx
	});

	return block;
}

// (131:8) {:else}
function create_else_block$4(ctx) {
	let input;
	let mounted;
	let dispose;

	let input_levels = [
		{ min: /*min*/ ctx[3] },
		{ max: /*max*/ ctx[4] },
		{ name: /*name*/ ctx[1] },
		{ list: /*list*/ ctx[5] },
		{ form: /*form*/ ctx[6] },
		{ align: /*align*/ ctx[10] },
		{ readOnly: /*readonly*/ ctx[12] },
		{ disabled: /*disabled*/ ctx[8] },
		{ required: /*required*/ ctx[13] },
		{ minlength: /*minlength*/ ctx[14] },
		{ maxlength: /*maxlength*/ ctx[7] },
		{ placeholder: /*placeholder*/ ctx[15] },
		{ id: /*idProp*/ ctx[17] },
		{ class: "inp-inner" },
		{ title: /*titleProp*/ ctx[19] },
		{ style: /*styleProp*/ ctx[21] },
		{ pattern: /*patternProp*/ ctx[22] },
		{ "aria-label": /*ariaLabelProp*/ ctx[20] },
		{
			autocomplete: /*autocompleteProp*/ ctx[24]
		},
		{ type: /*typeProp*/ ctx[18] }
	];

	let input_data = {};

	for (let i = 0; i < input_levels.length; i += 1) {
		input_data = assign(input_data, input_levels[i]);
	}

	const block = {
		c: function create() {
			input = element("input");
			this.h();
		},
		l: function claim(nodes) {
			input = claim_element(nodes, "INPUT", {
				min: true,
				max: true,
				name: true,
				list: true,
				form: true,
				align: true,
				readonly: true,
				disabled: true,
				required: true,
				minlength: true,
				maxlength: true,
				placeholder: true,
				id: true,
				class: true,
				title: true,
				style: true,
				pattern: true,
				"aria-label": true,
				autocomplete: true
			});

			this.h();
		},
		h: function hydrate() {
			set_attributes(input, input_data);
			toggle_class(input, "svelte-1ckwvo6", true);
			add_location(input, file$U, 131, 12, 4932);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			set_input_value(input, /*value*/ ctx[0]);

			if (!mounted) {
				dispose = [
					listen_dev(input, "input", /*input_input_handler*/ ctx[40]),
					listen_dev(input, "input", /*onInput*/ ctx[26], false, false, false),
					listen_dev(input, "change", /*onChange*/ ctx[27], false, false, false),
					listen_dev(input, "blur", /*blur_handler_1*/ ctx[41], false, false, false),
					listen_dev(input, "focus", /*focus_handler_1*/ ctx[42], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			set_attributes(input, input_data = get_spread_update(input_levels, [
				dirty[0] & /*min*/ 8 && { min: /*min*/ ctx[3] },
				dirty[0] & /*max*/ 16 && { max: /*max*/ ctx[4] },
				dirty[0] & /*name*/ 2 && { name: /*name*/ ctx[1] },
				dirty[0] & /*list*/ 32 && { list: /*list*/ ctx[5] },
				dirty[0] & /*form*/ 64 && { form: /*form*/ ctx[6] },
				dirty[0] & /*align*/ 1024 && { align: /*align*/ ctx[10] },
				dirty[0] & /*readonly*/ 4096 && { readOnly: /*readonly*/ ctx[12] },
				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
				dirty[0] & /*required*/ 8192 && { required: /*required*/ ctx[13] },
				dirty[0] & /*minlength*/ 16384 && { minlength: /*minlength*/ ctx[14] },
				dirty[0] & /*maxlength*/ 128 && { maxlength: /*maxlength*/ ctx[7] },
				dirty[0] & /*placeholder*/ 32768 && { placeholder: /*placeholder*/ ctx[15] },
				dirty[0] & /*idProp*/ 131072 && { id: /*idProp*/ ctx[17] },
				{ class: "inp-inner" },
				dirty[0] & /*titleProp*/ 524288 && { title: /*titleProp*/ ctx[19] },
				dirty[0] & /*styleProp*/ 2097152 && { style: /*styleProp*/ ctx[21] },
				dirty[0] & /*patternProp*/ 4194304 && { pattern: /*patternProp*/ ctx[22] },
				dirty[0] & /*ariaLabelProp*/ 1048576 && { "aria-label": /*ariaLabelProp*/ ctx[20] },
				dirty[0] & /*autocompleteProp*/ 16777216 && {
					autocomplete: /*autocompleteProp*/ ctx[24]
				},
				dirty[0] & /*typeProp*/ 262144 && { type: /*typeProp*/ ctx[18] }
			]));

			if (dirty[0] & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
				set_input_value(input, /*value*/ ctx[0]);
			}

			toggle_class(input, "svelte-1ckwvo6", true);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$4.name,
		type: "else",
		source: "(131:8) {:else}",
		ctx
	});

	return block;
}

// (103:8) {#if rows || type === 'textarea'}
function create_if_block_1$6(ctx) {
	let textarea;
	let mounted;
	let dispose;

	let textarea_levels = [
		{ min: /*min*/ ctx[3] },
		{ max: /*max*/ ctx[4] },
		{ rows: /*rows*/ ctx[9] },
		{ name: /*name*/ ctx[1] },
		{ form: /*form*/ ctx[6] },
		{ align: /*align*/ ctx[10] },
		{ readOnly: /*readonly*/ ctx[12] },
		{ disabled: /*disabled*/ ctx[8] },
		{ required: /*required*/ ctx[13] },
		{ minlength: /*minlength*/ ctx[14] },
		{ maxlength: /*maxlength*/ ctx[7] },
		{ placeholder: /*placeholder*/ ctx[15] },
		{ id: /*idProp*/ ctx[17] },
		{ class: "inp-inner" },
		{ title: /*titleProp*/ ctx[19] },
		{ style: /*styleProp*/ ctx[21] },
		{ pattern: /*patternProp*/ ctx[22] },
		{ "aria-label": /*ariaLabelProp*/ ctx[20] },
		{
			autocomplete: /*autocompleteProp*/ ctx[24]
		},
		{ type: /*typeProp*/ ctx[18] }
	];

	let textarea_data = {};

	for (let i = 0; i < textarea_levels.length; i += 1) {
		textarea_data = assign(textarea_data, textarea_levels[i]);
	}

	const block = {
		c: function create() {
			textarea = element("textarea");
			this.h();
		},
		l: function claim(nodes) {
			textarea = claim_element(nodes, "TEXTAREA", {
				min: true,
				max: true,
				rows: true,
				name: true,
				form: true,
				align: true,
				readonly: true,
				disabled: true,
				required: true,
				minlength: true,
				maxlength: true,
				placeholder: true,
				id: true,
				class: true,
				title: true,
				style: true,
				pattern: true,
				"aria-label": true,
				autocomplete: true
			});

			children(textarea).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_attributes(textarea, textarea_data);
			toggle_class(textarea, "svelte-1ckwvo6", true);
			add_location(textarea, file$U, 103, 12, 3925);
		},
		m: function mount(target, anchor) {
			insert_dev(target, textarea, anchor);
			set_input_value(textarea, /*value*/ ctx[0]);

			if (!mounted) {
				dispose = [
					listen_dev(textarea, "input", /*textarea_input_handler*/ ctx[37]),
					listen_dev(textarea, "input", /*onInput*/ ctx[26], false, false, false),
					listen_dev(textarea, "change", /*onChange*/ ctx[27], false, false, false),
					listen_dev(textarea, "blur", /*blur_handler*/ ctx[38], false, false, false),
					listen_dev(textarea, "focus", /*focus_handler*/ ctx[39], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			set_attributes(textarea, textarea_data = get_spread_update(textarea_levels, [
				dirty[0] & /*min*/ 8 && { min: /*min*/ ctx[3] },
				dirty[0] & /*max*/ 16 && { max: /*max*/ ctx[4] },
				dirty[0] & /*rows*/ 512 && { rows: /*rows*/ ctx[9] },
				dirty[0] & /*name*/ 2 && { name: /*name*/ ctx[1] },
				dirty[0] & /*form*/ 64 && { form: /*form*/ ctx[6] },
				dirty[0] & /*align*/ 1024 && { align: /*align*/ ctx[10] },
				dirty[0] & /*readonly*/ 4096 && { readOnly: /*readonly*/ ctx[12] },
				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
				dirty[0] & /*required*/ 8192 && { required: /*required*/ ctx[13] },
				dirty[0] & /*minlength*/ 16384 && { minlength: /*minlength*/ ctx[14] },
				dirty[0] & /*maxlength*/ 128 && { maxlength: /*maxlength*/ ctx[7] },
				dirty[0] & /*placeholder*/ 32768 && { placeholder: /*placeholder*/ ctx[15] },
				dirty[0] & /*idProp*/ 131072 && { id: /*idProp*/ ctx[17] },
				{ class: "inp-inner" },
				dirty[0] & /*titleProp*/ 524288 && { title: /*titleProp*/ ctx[19] },
				dirty[0] & /*styleProp*/ 2097152 && { style: /*styleProp*/ ctx[21] },
				dirty[0] & /*patternProp*/ 4194304 && { pattern: /*patternProp*/ ctx[22] },
				dirty[0] & /*ariaLabelProp*/ 1048576 && { "aria-label": /*ariaLabelProp*/ ctx[20] },
				dirty[0] & /*autocompleteProp*/ 16777216 && {
					autocomplete: /*autocompleteProp*/ ctx[24]
				},
				dirty[0] & /*typeProp*/ 262144 && { type: /*typeProp*/ ctx[18] }
			]));

			if (dirty[0] & /*value*/ 1) {
				set_input_value(textarea, /*value*/ ctx[0]);
			}

			toggle_class(textarea, "svelte-1ckwvo6", true);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(textarea);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$6.name,
		type: "if",
		source: "(103:8) {#if rows || type === 'textarea'}",
		ctx
	});

	return block;
}

// (163:16) {#if iconType}
function create_if_block$b(ctx) {
	let span;
	let icon;
	let current;

	icon = new Icon({
			props: {
				type: /*iconType*/ ctx[16],
				is: "info",
				size: "medium"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			span = element("span");
			create_component(icon.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			claim_component(icon.$$.fragment, span_nodes);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "inp-post-icon-inner svelte-1ckwvo6");
			add_location(span, file$U, 163, 20, 6050);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			mount_component(icon, span, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const icon_changes = {};
			if (dirty[0] & /*iconType*/ 65536) icon_changes.type = /*iconType*/ ctx[16];
			icon.$set(icon_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			destroy_component(icon);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$b.name,
		type: "if",
		source: "(163:16) {#if iconType}",
		ctx
	});

	return block;
}

// (162:35)                  
function fallback_block$3(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*iconType*/ ctx[16] && create_if_block$b(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*iconType*/ ctx[16]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*iconType*/ 65536) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$b(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: fallback_block$3.name,
		type: "fallback",
		source: "(162:35)                  ",
		ctx
	});

	return block;
}

// (173:8) <div slot="before">
function create_before_slot(ctx) {
	let div;
	let br;
	let current;
	br = new Br({ props: { size: "5" }, $$inline: true });

	const block = {
		c: function create() {
			div = element("div");
			create_component(br.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { slot: true });
			var div_nodes = children(div);
			claim_component(br.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "slot", "before");
			add_location(div, file$U, 172, 8, 6297);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(br, div, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(br.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(br);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_before_slot.name,
		type: "slot",
		source: "(173:8) <div slot=\\\"before\\\">",
		ctx
	});

	return block;
}

function create_fragment$U(ctx) {
	let div1;
	let t0;
	let div0;
	let t1;
	let label_1;
	let t2;
	let fielderrors;
	let div1_class_value;
	let current;
	let if_block0 = /*titleProp*/ ctx[19] && create_if_block_2$1(ctx);

	function select_block_type(ctx, dirty) {
		if (/*rows*/ ctx[9] || /*type*/ ctx[2] === "textarea") return create_if_block_1$6;
		return create_else_block$4;
	}

	let current_block_type = select_block_type(ctx);
	let if_block1 = current_block_type(ctx);
	const post_icon_slot_template = /*$$slots*/ ctx[36]["post-icon"];
	const post_icon_slot = create_slot(post_icon_slot_template, ctx, /*$$scope*/ ctx[43], get_post_icon_slot_context);
	const post_icon_slot_or_fallback = post_icon_slot || fallback_block$3(ctx);

	fielderrors = new FieldErrors({
			props: {
				items: /*errors*/ ctx[11],
				$$slots: { before: [create_before_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div1 = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			div0 = element("div");
			if_block1.c();
			t1 = space();
			label_1 = element("label");
			if (post_icon_slot_or_fallback) post_icon_slot_or_fallback.c();
			t2 = space();
			create_component(fielderrors.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			if (if_block0) if_block0.l(div1_nodes);
			t0 = claim_space(div1_nodes);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			if_block1.l(div0_nodes);
			t1 = claim_space(div0_nodes);
			label_1 = claim_element(div0_nodes, "LABEL", { for: true, class: true });
			var label_1_nodes = children(label_1);
			if (post_icon_slot_or_fallback) post_icon_slot_or_fallback.l(label_1_nodes);
			label_1_nodes.forEach(detach_dev);
			div0_nodes.forEach(detach_dev);
			t2 = claim_space(div1_nodes);
			claim_component(fielderrors.$$.fragment, div1_nodes);
			div1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(label_1, "for", /*idProp*/ ctx[17]);
			attr_dev(label_1, "class", "inp-post-icon svelte-1ckwvo6");
			add_location(label_1, file$U, 160, 8, 5920);
			attr_dev(div0, "class", "inp-inner-wrap svelte-1ckwvo6");
			add_location(div0, file$U, 101, 4, 3842);
			attr_dev(div1, "class", div1_class_value = "" + (null_to_empty(/*classProp*/ ctx[23]) + " svelte-1ckwvo6"));
			add_location(div1, file$U, 93, 0, 3626);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			if (if_block0) if_block0.m(div1, null);
			append_dev(div1, t0);
			append_dev(div1, div0);
			if_block1.m(div0, null);
			append_dev(div0, t1);
			append_dev(div0, label_1);

			if (post_icon_slot_or_fallback) {
				post_icon_slot_or_fallback.m(label_1, null);
			}

			append_dev(div1, t2);
			mount_component(fielderrors, div1, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*titleProp*/ ctx[19]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*titleProp*/ 524288) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_2$1(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div1, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block1) {
				if_block1.p(ctx, dirty);
			} else {
				if_block1.d(1);
				if_block1 = current_block_type(ctx);

				if (if_block1) {
					if_block1.c();
					if_block1.m(div0, t1);
				}
			}

			if (post_icon_slot) {
				if (post_icon_slot.p && dirty[1] & /*$$scope*/ 4096) {
					update_slot(post_icon_slot, post_icon_slot_template, ctx, /*$$scope*/ ctx[43], dirty, get_post_icon_slot_changes, get_post_icon_slot_context);
				}
			} else {
				if (post_icon_slot_or_fallback && post_icon_slot_or_fallback.p && dirty[0] & /*iconType*/ 65536) {
					post_icon_slot_or_fallback.p(ctx, dirty);
				}
			}

			if (!current || dirty[0] & /*idProp*/ 131072) {
				attr_dev(label_1, "for", /*idProp*/ ctx[17]);
			}

			const fielderrors_changes = {};
			if (dirty[0] & /*errors*/ 2048) fielderrors_changes.items = /*errors*/ ctx[11];

			if (dirty[1] & /*$$scope*/ 4096) {
				fielderrors_changes.$$scope = { dirty, ctx };
			}

			fielderrors.$set(fielderrors_changes);

			if (!current || dirty[0] & /*classProp*/ 8388608 && div1_class_value !== (div1_class_value = "" + (null_to_empty(/*classProp*/ ctx[23]) + " svelte-1ckwvo6"))) {
				attr_dev(div1, "class", div1_class_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(post_icon_slot_or_fallback, local);
			transition_in(fielderrors.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(post_icon_slot_or_fallback, local);
			transition_out(fielderrors.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			if (if_block0) if_block0.d();
			if_block1.d();
			if (post_icon_slot_or_fallback) post_icon_slot_or_fallback.d(detaching);
			destroy_component(fielderrors);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$U.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function getValue$1(e) {
	return e.target.value;
}

function instance$U($$self, $$props, $$invalidate) {
	const dispatch = createEventDispatcher();
	let { name } = $$props;
	let { value = "" } = $$props;
	let { style = {} } = $$props;
	let { type = "text" } = $$props;
	let { id = undefined } = $$props;
	let { min = undefined } = $$props; // Specifies a minimum value for an <input> element
	let { max = undefined } = $$props; // Specifies the maximum value for an <input> element
	let { list = undefined } = $$props; // Refers to a <datalist> element that contains pre-defined options for an <input> element
	let { form = undefined } = $$props; // Specifies the form the <input> element belongs to
	let { maxlength = 1000 } = $$props;
	let { disabled = false } = $$props;
	let { rows = undefined } = $$props;
	let { align = undefined } = $$props;
	let { label = undefined } = $$props;
	let { errors = undefined } = $$props;
	let { invalid = undefined } = $$props;
	let { pattern = undefined } = $$props; // Specifies a regular expression that an <input> element's value is checked against (regexp)
	let { readonly = undefined } = $$props; // undefined|readonly
	let { required = undefined } = $$props; // undefined|required
	let { postIcon = undefined } = $$props;
	let { ariaLabel = undefined } = $$props;
	let { minlength = undefined } = $$props;
	let { placeholder = undefined } = $$props;
	let { autocomplete = undefined } = $$props; // on|off

	/**
 * autocomplete - https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete
 * names - https://developers.google.com/web/updates/2015/06/checkout-faster-with-autofill
 */
	const nameTypes = {
		"sex": { autocomplete: "sex" },
		"bday": { autocomplete: "bday" },
		"name": { autocomplete: "name" },
		"phone": { autocomplete: "tel" },
		"fname": { autocomplete: "name" },
		"lname": { autocomplete: "name" },
		"email": { autocomplete: "email" },
		"password": { autocomplete: "new-password" },
		"cvc": { autocomplete: "cc-csc" },
		"cc-exp": { autocomplete: "cc-exp" },
		"ccname": { autocomplete: "cc-name" },
		"cardnumber": { autocomplete: "cc-number" },
		"ship-state": { autocomplete: "shipping region" },
		"ship-city": { autocomplete: "shipping locality" },
		"ship-zip": { autocomplete: "shipping postal-code" },
		"ship-country": { autocomplete: "shipping country" },
		"ship-address": { autocomplete: "shipping street-address" }
	};

	const typePostIcons = { date: "calendar", search: "search" };

	function onInput(e) {
		const value = getValue$1(e);
		dispatch("input", { e, value, name });
	}

	function onChange(e) {
		const value = getValue$1(e);
		dispatch("change", { e, value, name });
	}

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Input", $$slots, ['post-icon']);

	function textarea_input_handler() {
		value = this.value;
		$$invalidate(0, value);
	}

	const blur_handler = e => !disabled && dispatch("blur", e);
	const focus_handler = e => !disabled && dispatch("focus", e);

	function input_input_handler() {
		value = this.value;
		$$invalidate(0, value);
	}

	const blur_handler_1 = e => !disabled && dispatch("blur", e);
	const focus_handler_1 = e => !disabled && dispatch("focus", e);

	$$self.$set = $$new_props => {
		$$invalidate(48, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("name" in $$new_props) $$invalidate(1, name = $$new_props.name);
		if ("value" in $$new_props) $$invalidate(0, value = $$new_props.value);
		if ("style" in $$new_props) $$invalidate(28, style = $$new_props.style);
		if ("type" in $$new_props) $$invalidate(2, type = $$new_props.type);
		if ("id" in $$new_props) $$invalidate(29, id = $$new_props.id);
		if ("min" in $$new_props) $$invalidate(3, min = $$new_props.min);
		if ("max" in $$new_props) $$invalidate(4, max = $$new_props.max);
		if ("list" in $$new_props) $$invalidate(5, list = $$new_props.list);
		if ("form" in $$new_props) $$invalidate(6, form = $$new_props.form);
		if ("maxlength" in $$new_props) $$invalidate(7, maxlength = $$new_props.maxlength);
		if ("disabled" in $$new_props) $$invalidate(8, disabled = $$new_props.disabled);
		if ("rows" in $$new_props) $$invalidate(9, rows = $$new_props.rows);
		if ("align" in $$new_props) $$invalidate(10, align = $$new_props.align);
		if ("label" in $$new_props) $$invalidate(30, label = $$new_props.label);
		if ("errors" in $$new_props) $$invalidate(11, errors = $$new_props.errors);
		if ("invalid" in $$new_props) $$invalidate(31, invalid = $$new_props.invalid);
		if ("pattern" in $$new_props) $$invalidate(32, pattern = $$new_props.pattern);
		if ("readonly" in $$new_props) $$invalidate(12, readonly = $$new_props.readonly);
		if ("required" in $$new_props) $$invalidate(13, required = $$new_props.required);
		if ("postIcon" in $$new_props) $$invalidate(33, postIcon = $$new_props.postIcon);
		if ("ariaLabel" in $$new_props) $$invalidate(34, ariaLabel = $$new_props.ariaLabel);
		if ("minlength" in $$new_props) $$invalidate(14, minlength = $$new_props.minlength);
		if ("placeholder" in $$new_props) $$invalidate(15, placeholder = $$new_props.placeholder);
		if ("autocomplete" in $$new_props) $$invalidate(35, autocomplete = $$new_props.autocomplete);
		if ("$$scope" in $$new_props) $$invalidate(43, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		classnames,
		toCSSString,
		Br,
		Icon,
		FieldErrors,
		dispatch,
		name,
		value,
		style,
		type,
		id,
		min,
		max,
		list,
		form,
		maxlength,
		disabled,
		rows,
		align,
		label,
		errors,
		invalid,
		pattern,
		readonly,
		required,
		postIcon,
		ariaLabel,
		minlength,
		placeholder,
		autocomplete,
		nameTypes,
		typePostIcons,
		onInput,
		onChange,
		getValue: getValue$1,
		inputPredict,
		iconType,
		error,
		idProp,
		typeProp,
		titleProp,
		ariaLabelProp,
		styleProp,
		patternProp,
		classProp,
		autocompleteProp
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(48, $$props = assign(assign({}, $$props), $$new_props));
		if ("name" in $$props) $$invalidate(1, name = $$new_props.name);
		if ("value" in $$props) $$invalidate(0, value = $$new_props.value);
		if ("style" in $$props) $$invalidate(28, style = $$new_props.style);
		if ("type" in $$props) $$invalidate(2, type = $$new_props.type);
		if ("id" in $$props) $$invalidate(29, id = $$new_props.id);
		if ("min" in $$props) $$invalidate(3, min = $$new_props.min);
		if ("max" in $$props) $$invalidate(4, max = $$new_props.max);
		if ("list" in $$props) $$invalidate(5, list = $$new_props.list);
		if ("form" in $$props) $$invalidate(6, form = $$new_props.form);
		if ("maxlength" in $$props) $$invalidate(7, maxlength = $$new_props.maxlength);
		if ("disabled" in $$props) $$invalidate(8, disabled = $$new_props.disabled);
		if ("rows" in $$props) $$invalidate(9, rows = $$new_props.rows);
		if ("align" in $$props) $$invalidate(10, align = $$new_props.align);
		if ("label" in $$props) $$invalidate(30, label = $$new_props.label);
		if ("errors" in $$props) $$invalidate(11, errors = $$new_props.errors);
		if ("invalid" in $$props) $$invalidate(31, invalid = $$new_props.invalid);
		if ("pattern" in $$props) $$invalidate(32, pattern = $$new_props.pattern);
		if ("readonly" in $$props) $$invalidate(12, readonly = $$new_props.readonly);
		if ("required" in $$props) $$invalidate(13, required = $$new_props.required);
		if ("postIcon" in $$props) $$invalidate(33, postIcon = $$new_props.postIcon);
		if ("ariaLabel" in $$props) $$invalidate(34, ariaLabel = $$new_props.ariaLabel);
		if ("minlength" in $$props) $$invalidate(14, minlength = $$new_props.minlength);
		if ("placeholder" in $$props) $$invalidate(15, placeholder = $$new_props.placeholder);
		if ("autocomplete" in $$props) $$invalidate(35, autocomplete = $$new_props.autocomplete);
		if ("inputPredict" in $$props) $$invalidate(44, inputPredict = $$new_props.inputPredict);
		if ("iconType" in $$props) $$invalidate(16, iconType = $$new_props.iconType);
		if ("error" in $$props) $$invalidate(45, error = $$new_props.error);
		if ("idProp" in $$props) $$invalidate(17, idProp = $$new_props.idProp);
		if ("typeProp" in $$props) $$invalidate(18, typeProp = $$new_props.typeProp);
		if ("titleProp" in $$props) $$invalidate(19, titleProp = $$new_props.titleProp);
		if ("ariaLabelProp" in $$props) $$invalidate(20, ariaLabelProp = $$new_props.ariaLabelProp);
		if ("styleProp" in $$props) $$invalidate(21, styleProp = $$new_props.styleProp);
		if ("patternProp" in $$props) $$invalidate(22, patternProp = $$new_props.patternProp);
		if ("classProp" in $$props) $$invalidate(23, classProp = $$new_props.classProp);
		if ("autocompleteProp" in $$props) $$invalidate(24, autocompleteProp = $$new_props.autocompleteProp);
	};

	let inputPredict;
	let iconType;
	let error;
	let idProp;
	let typeProp;
	let titleProp;
	let ariaLabelProp;
	let styleProp;
	let patternProp;
	let classProp;
	let autocompleteProp;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*name*/ 2) {
			 $$invalidate(44, inputPredict = nameTypes[name] || {});
		}

		if ($$self.$$.dirty[0] & /*type*/ 4 | $$self.$$.dirty[1] & /*postIcon*/ 4) {
			 $$invalidate(16, iconType = postIcon || typePostIcons[type]);
		}

		if ($$self.$$.dirty[0] & /*errors*/ 2048 | $$self.$$.dirty[1] & /*invalid*/ 1) {
			 $$invalidate(45, error = invalid !== undefined
			? invalid
			: !!(errors || []).length);
		}

		if ($$self.$$.dirty[0] & /*id, name*/ 536870914 | $$self.$$.dirty[1] & /*inputPredict*/ 8192) {
			 $$invalidate(17, idProp = id || inputPredict.id || name);
		}

		if ($$self.$$.dirty[0] & /*type*/ 4) {
			 $$invalidate(18, typeProp = type);
		}

		if ($$self.$$.dirty[0] & /*label*/ 1073741824 | $$self.$$.dirty[1] & /*ariaLabel*/ 8) {
			 $$invalidate(19, titleProp = label || ariaLabel);
		}

		if ($$self.$$.dirty[0] & /*label, placeholder*/ 1073774592 | $$self.$$.dirty[1] & /*ariaLabel*/ 8) {
			 $$invalidate(20, ariaLabelProp = ariaLabel || label || placeholder);
		}

		if ($$self.$$.dirty[0] & /*style, align*/ 268436480) {
			 $$invalidate(21, styleProp = toCSSString({ ...style, textAlign: align }));
		}

		if ($$self.$$.dirty[0] & /*type*/ 4 | $$self.$$.dirty[1] & /*pattern*/ 2) {
			 $$invalidate(22, patternProp = type === "number" && !pattern ? "[0-9]*" : pattern);
		}

		 $$invalidate(23, classProp = classnames("inp", $$props.class, {
			disabled,
			readonly,
			required,
			error,
			postIcon: iconType
		}));

		if ($$self.$$.dirty[1] & /*autocomplete, inputPredict*/ 8208) {
			 $$invalidate(24, autocompleteProp = autocomplete || inputPredict.autocomplete);
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		value,
		name,
		type,
		min,
		max,
		list,
		form,
		maxlength,
		disabled,
		rows,
		align,
		errors,
		readonly,
		required,
		minlength,
		placeholder,
		iconType,
		idProp,
		typeProp,
		titleProp,
		ariaLabelProp,
		styleProp,
		patternProp,
		classProp,
		autocompleteProp,
		dispatch,
		onInput,
		onChange,
		style,
		id,
		label,
		invalid,
		pattern,
		postIcon,
		ariaLabel,
		autocomplete,
		$$slots,
		textarea_input_handler,
		blur_handler,
		focus_handler,
		input_input_handler,
		blur_handler_1,
		focus_handler_1,
		$$scope
	];
}

class Input extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document.getElementById("svelte-1ckwvo6-style")) add_css$h();

		init(
			this,
			options,
			instance$U,
			create_fragment$U,
			safe_not_equal,
			{
				name: 1,
				value: 0,
				style: 28,
				type: 2,
				id: 29,
				min: 3,
				max: 4,
				list: 5,
				form: 6,
				maxlength: 7,
				disabled: 8,
				rows: 9,
				align: 10,
				label: 30,
				errors: 11,
				invalid: 31,
				pattern: 32,
				readonly: 12,
				required: 13,
				postIcon: 33,
				ariaLabel: 34,
				minlength: 14,
				placeholder: 15,
				autocomplete: 35
			},
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Input",
			options,
			id: create_fragment$U.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*name*/ ctx[1] === undefined && !("name" in props)) {
			console.warn("<Input> was created without expected prop 'name'");
		}
	}

	get name() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set name(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get type() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set type(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get id() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get min() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set min(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get max() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set max(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get list() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set list(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get form() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set form(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get maxlength() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set maxlength(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get rows() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set rows(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get align() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set align(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get label() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set label(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get errors() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set errors(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get invalid() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set invalid(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get pattern() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set pattern(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get readonly() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set readonly(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get required() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set required(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get postIcon() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set postIcon(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ariaLabel() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ariaLabel(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get minlength() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set minlength(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get placeholder() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set placeholder(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get autocomplete() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set autocomplete(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/fields/Select.svelte generated by Svelte v3.24.0 */
const file$V = "src/components/fields/Select.svelte";

function add_css$i() {
	var style = element("style");
	style.id = "svelte-6fajxs-style";
	style.textContent = ".select.svelte-6fajxs.svelte-6fajxs{width:100%;-webkit-box-flex:1;-ms-flex:1 1 auto;flex:1 1 auto;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column}.select.disabled.svelte-6fajxs.svelte-6fajxs{opacity:.5;pointer-events:none}.select.null.svelte-6fajxs .inp-inner.svelte-6fajxs{color:rgba(var(--theme-color-primary-opposite), .2) !important}.select.svelte-6fajxs .inp-inner-wrap.svelte-6fajxs{position:relative;display:-webkit-box;display:-ms-flexbox;display:flex;-ms-flex-item-align:stretch;align-self:stretch;-webkit-box-shadow:var(--shadow-field-inset);box-shadow:var(--shadow-field-inset);border-radius:var(--border-radius-small);background-color:rgba(var(--theme-bg-color))}.select.svelte-6fajxs .inp-inner.svelte-6fajxs{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;color:inherit;overflow-y:auto;overflow-x:hidden;background-color:transparent;-webkit-overflow-scrolling:touch;min-width:var(--min-interactive-size);min-height:var(--min-interactive-size);border-radius:var(--border-radius-small)}.select.svelte-6fajxs .inp-post-icon.svelte-6fajxs{position:absolute;top:0;right:0;height:100%;width:var(--min-interactive-size);-webkit-box-flex:0;-ms-flex:none;flex:none;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;overflow:hidden}.select.svelte-6fajxs .inp-post-icon-inner.svelte-6fajxs{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;width:var(--min-interactive-size)}.select.svelte-6fajxs .inp-inner.svelte-6fajxs::-webkit-input-placeholder{color:rgba(var(--theme-color-primary-opposite));opacity:.2}.select.svelte-6fajxs .inp-inner.svelte-6fajxs::-moz-placeholder{color:rgba(var(--theme-color-primary-opposite));opacity:.2}.select.svelte-6fajxs .inp-inner.svelte-6fajxs:-ms-input-placeholder{color:rgba(var(--theme-color-primary-opposite));opacity:.2}.select.svelte-6fajxs .inp-inner.svelte-6fajxs::-ms-input-placeholder{color:rgba(var(--theme-color-primary-opposite));opacity:.2}.select.svelte-6fajxs .inp-inner.svelte-6fajxs::placeholder{color:rgba(var(--theme-color-primary-opposite));opacity:.2}.select.postIcon.svelte-6fajxs .inp-inner.svelte-6fajxs{padding-right:var(--min-interactive-size)}.select.svelte-6fajxs .inp-inner.svelte-6fajxs:invalid,.select.error.svelte-6fajxs .inp-inner.svelte-6fajxs{-webkit-box-shadow:0 0 0 1px rgb(var(--color-danger));box-shadow:0 0 0 1px rgb(var(--color-danger));color:rgb(var(--color-danger))}.select .inp-inner:invalid+.inp-post-icon.svelte-6fajxs.svelte-6fajxs .ico,.select.error.svelte-6fajxs .inp-post-icon.svelte-6fajxs .ico{color:rgb(var(--color-danger)) !important}.select.svelte-6fajxs .inp-inner.svelte-6fajxs:focus{-webkit-box-shadow:0 0 0 1px rgb(var(--color-info));box-shadow:0 0 0 1px rgb(var(--color-info));color:rgb(var(--color-info))}.select .inp-inner:focus+.inp-post-icon.svelte-6fajxs.svelte-6fajxs .ico{color:rgb(var(--color-info)) !important}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2VsZWN0LnN2ZWx0ZSIsInNvdXJjZXMiOlsiU2VsZWN0LnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0PlxuICAgIGltcG9ydCB7IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJ3N2ZWx0ZSdcbiAgICBpbXBvcnQgeyBjbGFzc25hbWVzLCB0b0NTU1N0cmluZyB9IGZyb20gJ0B1dGlscydcbiAgICBpbXBvcnQgQnIgZnJvbSAnQGNvbXBvbmVudHMvQnIuc3ZlbHRlJ1xuICAgIGltcG9ydCBJY29uIGZyb20gJ0Bjb21wb25lbnRzL0ljb24uc3ZlbHRlJ1xuICAgIGltcG9ydCBGaWVsZEVycm9ycyBmcm9tICdAY29tcG9uZW50cy9GaWVsZEVycm9ycy5zdmVsdGUnXG5cbiAgICBjb25zdCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpXG5cbiAgICBleHBvcnQgbGV0IG5hbWVcbiAgICBleHBvcnQgbGV0IHN0eWxlID0ge31cbiAgICBleHBvcnQgbGV0IHR5cGUgPSAnc2VsZWN0J1xuICAgIGV4cG9ydCBsZXQgdmFsdWUgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IGlkID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCBhbGlnbiA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgZGlzYWJsZWQgPSBmYWxzZVxuICAgIGV4cG9ydCBsZXQgbGFiZWwgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IGludmFsaWQgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IGZvcm0gPSB1bmRlZmluZWQgLy8gU3BlY2lmaWVzIHRoZSBmb3JtIHRoZSA8aW5wdXQ+IGVsZW1lbnQgYmVsb25ncyB0b1xuICAgIGV4cG9ydCBsZXQgcmVhZG9ubHkgPSB1bmRlZmluZWQgLy8gdW5kZWZpbmVkfHJlYWRvbmx5XG4gICAgZXhwb3J0IGxldCByZXF1aXJlZCA9IHVuZGVmaW5lZCAvLyB1bmRlZmluZWR8cmVxdWlyZWRcbiAgICBleHBvcnQgbGV0IGFyaWFMYWJlbCA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgcGxhY2Vob2xkZXIgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IGF1dG9jb21wbGV0ZSA9ICdvbidcbiAgICBleHBvcnQgbGV0IHBvc3RJY29uID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCBlcnJvcnMgPSB1bmRlZmluZWRcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEB0eXBlIHt7XG4gICAgICogICAgIHZhbHVlOiBzdHJpbmcsXG4gICAgICogICAgIGxhYmVsOiBzdHJpbmcsXG4gICAgICogfVtdfVxuICAgICAqL1xuICAgIGV4cG9ydCBsZXQgb3B0aW9ucyA9IFtdXG5cbiAgICAkOiBpY29uVHlwZSA9IHBvc3RJY29uIHx8ICdjYXJldC1kb3duJ1xuICAgICQ6IGVycm9yID0gaW52YWxpZCB8fCAhIShlcnJvcnMgfHwgW10pLmxlbmd0aFxuICAgICQ6IGlkUHJvcCA9IGlkIHx8IG5hbWVcbiAgICAkOiB0aXRsZVByb3AgPSBsYWJlbCB8fCBhcmlhTGFiZWxcbiAgICAkOiBhcmlhTGFiZWxQcm9wID0gYXJpYUxhYmVsIHx8IGxhYmVsIHx8IHBsYWNlaG9sZGVyXG4gICAgJDogc3R5bGVQcm9wID0gdG9DU1NTdHJpbmcoeyAuLi5zdHlsZSwgdGV4dEFsaWduOiBhbGlnbiB9KVxuICAgICQ6IGNsYXNzUHJvcCA9IGNsYXNzbmFtZXMoJ3NlbGVjdCcsICQkcHJvcHMuY2xhc3MsIHsgZGlzYWJsZWQsIHJlYWRvbmx5LCByZXF1aXJlZCwgZXJyb3IsIG51bGw6IHZhbHVlID09PSB1bmRlZmluZWQgfSlcblxuICAgIGZ1bmN0aW9uIG9uQ2hhbmdlKGUpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBnZXRWYWx1ZShlKVxuICAgICAgICBkaXNwYXRjaCgnY2hhbmdlJywgeyBlLCB2YWx1ZSwgbmFtZSB9KVxuICAgIH1cbiAgICBcbiAgICBmdW5jdGlvbiBnZXRWYWx1ZShlKSB7XG4gICAgICAgIHJldHVybiBlLnRhcmdldC52YWx1ZVxuICAgIH1cbjwvc2NyaXB0PlxuXG48ZGl2IGNsYXNzPXtjbGFzc1Byb3B9PlxuICAgIHsjaWYgdGl0bGVQcm9wfVxuICAgICAgICA8bGFiZWwgZm9yPXtpZFByb3B9IGNsYXNzPVwiYmxvY2sgaDIgZm9udC13LTUwMCBmdWxsLXdpZHRoIHRleHQtbGVmdFwiPlxuICAgICAgICAgICAgeyB0aXRsZVByb3AgfVxuICAgICAgICA8L2xhYmVsPlxuICAgICAgICA8QnIgc2l6ZT1cIjEwXCIvPlxuICAgIHsvaWZ9XG5cbiAgICA8ZGl2IGNsYXNzPVwiaW5wLWlubmVyLXdyYXBcIj5cbiAgICAgICAgPHNlbGVjdFxuICAgICAgICAgICAgICAgIHtuYW1lfVxuICAgICAgICAgICAgICAgIHt0eXBlfVxuICAgICAgICAgICAgICAgIHtmb3JtfVxuICAgICAgICAgICAgICAgIHthbGlnbn1cbiAgICAgICAgICAgICAgICB7cmVhZG9ubHl9XG4gICAgICAgICAgICAgICAge2Rpc2FibGVkfVxuICAgICAgICAgICAgICAgIHtyZXF1aXJlZH1cbiAgICAgICAgICAgICAgICB7cGxhY2Vob2xkZXJ9XG4gICAgICAgICAgICAgICAge2F1dG9jb21wbGV0ZX1cbiAgICAgICAgICAgICAgICBpZD17aWRQcm9wfVxuICAgICAgICAgICAgICAgIGNsYXNzPVwiaW5wLWlubmVyXCJcbiAgICAgICAgICAgICAgICB0aXRsZT17dGl0bGVQcm9wfVxuICAgICAgICAgICAgICAgIHN0eWxlPXtzdHlsZVByb3B9XG4gICAgICAgICAgICAgICAgYXJpYS1sYWJlbD17YXJpYUxhYmVsUHJvcH1cbiAgICAgICAgICAgICAgICBiaW5kOnZhbHVlXG4gICAgICAgICAgICAgICAgb246Y2hhbmdlPXtvbkNoYW5nZX1cbiAgICAgICAgICAgICAgICBvbjpibHVyPSd7ZSA9PiAhZGlzYWJsZWQgJiYgZGlzcGF0Y2goXCJibHVyXCIsIGUpfSdcbiAgICAgICAgICAgICAgICBvbjpmb2N1cz0ne2UgPT4gIWRpc2FibGVkICYmIGRpc3BhdGNoKFwiZm9jdXNcIiwgZSl9J1xuICAgICAgICA+XG4gICAgICAgICAgICB7I2lmICFyZXF1aXJlZH1cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPXt1bmRlZmluZWR9PntwbGFjZWhvbGRlciB8fCAnJ308L29wdGlvbj5cbiAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICB7I2VhY2ggb3B0aW9ucyBhcyB7IGxhYmVsOiB0ZXh0LCAuLi5vcHRpb24gfX1cbiAgICAgICAgICAgICAgICB7I2lmIG9wdGlvbi52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHRleHQgIT09IHVuZGVmaW5lZH1cbiAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT17b3B0aW9uLnZhbHVlfT5cbiAgICAgICAgICAgICAgICAgICAgICAgIHt0ZXh0fVxuICAgICAgICAgICAgICAgICAgICA8L29wdGlvbj5cbiAgICAgICAgICAgICAgICB7L2lmfVxuICAgICAgICAgICAgey9lYWNofVxuICAgICAgICA8L3NlbGVjdD5cblxuICAgICAgICA8bGFiZWwgZm9yPXtpZFByb3B9IGNsYXNzPVwiaW5wLXBvc3QtaWNvblwiPlxuICAgICAgICAgICAgPHNsb3QgbmFtZT1cInBvc3QtaWNvblwiPlxuICAgICAgICAgICAgICAgIHsjaWYgaWNvblR5cGV9XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaW5wLXBvc3QtaWNvbi1pbm5lclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPEljb24gdHlwZT17aWNvblR5cGV9IGlzPVwiaW5mb1wiIHNpemU9XCJtZWRpdW1cIi8+XG4gICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICB7L2lmfVxuICAgICAgICAgICAgPC9zbG90PlxuICAgICAgICA8L2xhYmVsPlxuICAgIDwvZGl2PlxuXG4gICAgPEZpZWxkRXJyb3JzIGl0ZW1zPXtlcnJvcnN9Lz5cbjwvZGl2PlxuXG48c3R5bGU+XG4uc2VsZWN0IHtcbiAgICB3aWR0aDogMTAwJTtcbiAgICAtd2Via2l0LWJveC1mbGV4OiAxO1xuICAgICAgICAtbXMtZmxleDogMSAxIGF1dG87XG4gICAgICAgICAgICBmbGV4OiAxIDEgYXV0bztcbiAgICBkaXNwbGF5OiAtd2Via2l0LWJveDtcbiAgICBkaXNwbGF5OiAtbXMtZmxleGJveDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIC13ZWJraXQtYm94LW9yaWVudDogdmVydGljYWw7XG4gICAgLXdlYmtpdC1ib3gtZGlyZWN0aW9uOiBub3JtYWw7XG4gICAgICAgIC1tcy1mbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbn1cblxuLnNlbGVjdC5kaXNhYmxlZCB7XG4gICAgb3BhY2l0eTogLjU7XG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG59XG5cbi5zZWxlY3QubnVsbCAuaW5wLWlubmVyIHtcbiAgICBjb2xvcjogcmdiYSh2YXIoLS10aGVtZS1jb2xvci1wcmltYXJ5LW9wcG9zaXRlKSwgLjIpICFpbXBvcnRhbnQ7XG59XG5cbi5zZWxlY3QgLmlucC1pbm5lci13cmFwIHtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgZGlzcGxheTogLXdlYmtpdC1ib3g7XG4gICAgZGlzcGxheTogLW1zLWZsZXhib3g7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICAtbXMtZmxleC1pdGVtLWFsaWduOiBzdHJldGNoO1xuICAgICAgICBhbGlnbi1zZWxmOiBzdHJldGNoO1xuICAgIC13ZWJraXQtYm94LXNoYWRvdzogdmFyKC0tc2hhZG93LWZpZWxkLWluc2V0KTtcbiAgICAgICAgICAgIGJveC1zaGFkb3c6IHZhcigtLXNoYWRvdy1maWVsZC1pbnNldCk7XG4gICAgYm9yZGVyLXJhZGl1czogdmFyKC0tYm9yZGVyLXJhZGl1cy1zbWFsbCk7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSh2YXIoLS10aGVtZS1iZy1jb2xvcikpO1xufVxuXG4uc2VsZWN0IC5pbnAtaW5uZXIge1xuICAgIC13ZWJraXQtYm94LWZsZXg6IDE7XG4gICAgICAgIC1tcy1mbGV4LXBvc2l0aXZlOiAxO1xuICAgICAgICAgICAgZmxleC1ncm93OiAxO1xuICAgIGNvbG9yOiBpbmhlcml0O1xuICAgIG92ZXJmbG93LXk6IGF1dG87XG4gICAgb3ZlcmZsb3cteDogaGlkZGVuO1xuICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuICAgIC13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nOiB0b3VjaDtcbiAgICBtaW4td2lkdGg6IHZhcigtLW1pbi1pbnRlcmFjdGl2ZS1zaXplKTtcbiAgICBtaW4taGVpZ2h0OiB2YXIoLS1taW4taW50ZXJhY3RpdmUtc2l6ZSk7XG4gICAgYm9yZGVyLXJhZGl1czogdmFyKC0tYm9yZGVyLXJhZGl1cy1zbWFsbCk7XG59XG5cbi5zZWxlY3QgLmlucC1wb3N0LWljb24ge1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB0b3A6IDA7XG4gICAgcmlnaHQ6IDA7XG4gICAgaGVpZ2h0OiAxMDAlO1xuICAgIHdpZHRoOiB2YXIoLS1taW4taW50ZXJhY3RpdmUtc2l6ZSk7XG4gICAgLXdlYmtpdC1ib3gtZmxleDogMDtcbiAgICAgICAgLW1zLWZsZXg6IG5vbmU7XG4gICAgICAgICAgICBmbGV4OiBub25lO1xuICAgIGRpc3BsYXk6IC13ZWJraXQtYm94O1xuICAgIGRpc3BsYXk6IC1tcy1mbGV4Ym94O1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgLXdlYmtpdC1ib3gtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgLW1zLWZsZXgtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgLXdlYmtpdC1ib3gtcGFjazogY2VudGVyO1xuICAgICAgICAtbXMtZmxleC1wYWNrOiBjZW50ZXI7XG4gICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xufVxuXG4uc2VsZWN0IC5pbnAtcG9zdC1pY29uLWlubmVyIHtcbiAgICBkaXNwbGF5OiAtd2Via2l0LWJveDtcbiAgICBkaXNwbGF5OiAtbXMtZmxleGJveDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIC13ZWJraXQtYm94LWFsaWduOiBjZW50ZXI7XG4gICAgICAgIC1tcy1mbGV4LWFsaWduOiBjZW50ZXI7XG4gICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIC13ZWJraXQtYm94LXBhY2s6IGNlbnRlcjtcbiAgICAgICAgLW1zLWZsZXgtcGFjazogY2VudGVyO1xuICAgICAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgd2lkdGg6IHZhcigtLW1pbi1pbnRlcmFjdGl2ZS1zaXplKTtcbn1cblxuLnNlbGVjdCAuaW5wLWlubmVyOjotd2Via2l0LWlucHV0LXBsYWNlaG9sZGVyIHtcbiAgICBjb2xvcjogcmdiYSh2YXIoLS10aGVtZS1jb2xvci1wcmltYXJ5LW9wcG9zaXRlKSk7XG4gICAgb3BhY2l0eTogLjI7XG59XG5cbi5zZWxlY3QgLmlucC1pbm5lcjo6LW1vei1wbGFjZWhvbGRlciB7XG4gICAgY29sb3I6IHJnYmEodmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeS1vcHBvc2l0ZSkpO1xuICAgIG9wYWNpdHk6IC4yO1xufVxuXG4uc2VsZWN0IC5pbnAtaW5uZXI6LW1zLWlucHV0LXBsYWNlaG9sZGVyIHtcbiAgICBjb2xvcjogcmdiYSh2YXIoLS10aGVtZS1jb2xvci1wcmltYXJ5LW9wcG9zaXRlKSk7XG4gICAgb3BhY2l0eTogLjI7XG59XG5cbi5zZWxlY3QgLmlucC1pbm5lcjo6LW1zLWlucHV0LXBsYWNlaG9sZGVyIHtcbiAgICBjb2xvcjogcmdiYSh2YXIoLS10aGVtZS1jb2xvci1wcmltYXJ5LW9wcG9zaXRlKSk7XG4gICAgb3BhY2l0eTogLjI7XG59XG5cbi5zZWxlY3QgLmlucC1pbm5lciBvcHRpb25bZGVmYXVsdF0sXG4uc2VsZWN0IC5pbnAtaW5uZXI6OnBsYWNlaG9sZGVyIHtcbiAgICBjb2xvcjogcmdiYSh2YXIoLS10aGVtZS1jb2xvci1wcmltYXJ5LW9wcG9zaXRlKSk7XG4gICAgb3BhY2l0eTogLjI7XG59XG5cbi5zZWxlY3QucG9zdEljb24gLmlucC1pbm5lciB7XG4gICAgcGFkZGluZy1yaWdodDogdmFyKC0tbWluLWludGVyYWN0aXZlLXNpemUpO1xufVxuXG4uc2VsZWN0IC5pbnAtaW5uZXI6aW52YWxpZCxcbi5zZWxlY3QuZXJyb3IgLmlucC1pbm5lciB7XG4gICAgLXdlYmtpdC1ib3gtc2hhZG93OiAwIDAgMCAxcHggcmdiKHZhcigtLWNvbG9yLWRhbmdlcikpO1xuICAgICAgICAgICAgYm94LXNoYWRvdzogMCAwIDAgMXB4IHJnYih2YXIoLS1jb2xvci1kYW5nZXIpKTtcbiAgICBjb2xvcjogcmdiKHZhcigtLWNvbG9yLWRhbmdlcikpO1xufVxuXG4uc2VsZWN0IC5pbnAtaW5uZXI6aW52YWxpZCArIC5pbnAtcG9zdC1pY29uIDpnbG9iYWwoLmljbyksXG4uc2VsZWN0LmVycm9yIC5pbnAtcG9zdC1pY29uIDpnbG9iYWwoLmljbykge1xuICAgIGNvbG9yOiByZ2IodmFyKC0tY29sb3ItZGFuZ2VyKSkgIWltcG9ydGFudDtcbn1cblxuLnNlbGVjdCAuaW5wLWlubmVyOmZvY3VzIHtcbiAgICAtd2Via2l0LWJveC1zaGFkb3c6IDAgMCAwIDFweCByZ2IodmFyKC0tY29sb3ItaW5mbykpO1xuICAgICAgICAgICAgYm94LXNoYWRvdzogMCAwIDAgMXB4IHJnYih2YXIoLS1jb2xvci1pbmZvKSk7XG4gICAgY29sb3I6IHJnYih2YXIoLS1jb2xvci1pbmZvKSk7XG59XG5cbi5zZWxlY3QgLmlucC1pbm5lcjpmb2N1cyArIC5pbnAtcG9zdC1pY29uIDpnbG9iYWwoLmljbykge1xuICAgIGNvbG9yOiByZ2IodmFyKC0tY29sb3ItaW5mbykpICFpbXBvcnRhbnQ7XG59PC9zdHlsZT5cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUE2R0Es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 */";
	append_dev(document.head, style);
}

const get_post_icon_slot_changes$1 = dirty => ({});
const get_post_icon_slot_context$1 = ctx => ({});

function get_each_context$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[33] = list[i].label;
	child_ctx[34] = object_without_properties(list[i], ["label"]);
	return child_ctx;
}

// (55:4) {#if titleProp}
function create_if_block_3(ctx) {
	let label_1;
	let t0;
	let t1;
	let br;
	let current;
	br = new Br({ props: { size: "10" }, $$inline: true });

	const block = {
		c: function create() {
			label_1 = element("label");
			t0 = text(/*titleProp*/ ctx[14]);
			t1 = space();
			create_component(br.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			label_1 = claim_element(nodes, "LABEL", { for: true, class: true });
			var label_1_nodes = children(label_1);
			t0 = claim_text(label_1_nodes, /*titleProp*/ ctx[14]);
			label_1_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			claim_component(br.$$.fragment, nodes);
			this.h();
		},
		h: function hydrate() {
			attr_dev(label_1, "for", /*idProp*/ ctx[13]);
			attr_dev(label_1, "class", "block h2 font-w-500 full-width text-left");
			add_location(label_1, file$V, 55, 8, 1745);
		},
		m: function mount(target, anchor) {
			insert_dev(target, label_1, anchor);
			append_dev(label_1, t0);
			insert_dev(target, t1, anchor);
			mount_component(br, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (!current || dirty[0] & /*titleProp*/ 16384) set_data_dev(t0, /*titleProp*/ ctx[14]);

			if (!current || dirty[0] & /*idProp*/ 8192) {
				attr_dev(label_1, "for", /*idProp*/ ctx[13]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(br.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(label_1);
			if (detaching) detach_dev(t1);
			destroy_component(br, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(55:4) {#if titleProp}",
		ctx
	});

	return block;
}

// (83:12) {#if !required}
function create_if_block_2$2(ctx) {
	let option;
	let t_value = (/*placeholder*/ ctx[8] || "") + "";
	let t;

	const block = {
		c: function create() {
			option = element("option");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			option = claim_element(nodes, "OPTION", { value: true });
			var option_nodes = children(option);
			t = claim_text(option_nodes, t_value);
			option_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			option.__value = undefined;
			option.value = option.__value;
			add_location(option, file$V, 83, 16, 2602);
		},
		m: function mount(target, anchor) {
			insert_dev(target, option, anchor);
			append_dev(option, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*placeholder*/ 256 && t_value !== (t_value = (/*placeholder*/ ctx[8] || "") + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(option);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$2.name,
		type: "if",
		source: "(83:12) {#if !required}",
		ctx
	});

	return block;
}

// (87:16) {#if option.value !== undefined && text !== undefined}
function create_if_block_1$7(ctx) {
	let option;
	let t0_value = /*text*/ ctx[33] + "";
	let t0;
	let t1;
	let option_value_value;

	const block = {
		c: function create() {
			option = element("option");
			t0 = text(t0_value);
			t1 = space();
			this.h();
		},
		l: function claim(nodes) {
			option = claim_element(nodes, "OPTION", { value: true });
			var option_nodes = children(option);
			t0 = claim_text(option_nodes, t0_value);
			t1 = claim_space(option_nodes);
			option_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			option.__value = option_value_value = /*option*/ ctx[34].value;
			option.value = option.__value;
			add_location(option, file$V, 87, 20, 2824);
		},
		m: function mount(target, anchor) {
			insert_dev(target, option, anchor);
			append_dev(option, t0);
			append_dev(option, t1);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*options*/ 2048 && t0_value !== (t0_value = /*text*/ ctx[33] + "")) set_data_dev(t0, t0_value);

			if (dirty[0] & /*options*/ 2048 && option_value_value !== (option_value_value = /*option*/ ctx[34].value)) {
				prop_dev(option, "__value", option_value_value);
				option.value = option.__value;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(option);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$7.name,
		type: "if",
		source: "(87:16) {#if option.value !== undefined && text !== undefined}",
		ctx
	});

	return block;
}

// (86:12) {#each options as { label: text, ...option }}
function create_each_block$2(ctx) {
	let if_block_anchor;
	let if_block = /*option*/ ctx[34].value !== undefined && /*text*/ ctx[33] !== undefined && create_if_block_1$7(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (/*option*/ ctx[34].value !== undefined && /*text*/ ctx[33] !== undefined) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$7(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$2.name,
		type: "each",
		source: "(86:12) {#each options as { label: text, ...option }}",
		ctx
	});

	return block;
}

// (97:16) {#if iconType}
function create_if_block$c(ctx) {
	let span;
	let icon;
	let current;

	icon = new Icon({
			props: {
				type: /*iconType*/ ctx[12],
				is: "info",
				size: "medium"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			span = element("span");
			create_component(icon.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			claim_component(icon.$$.fragment, span_nodes);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "inp-post-icon-inner svelte-6fajxs");
			add_location(span, file$V, 97, 20, 3114);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			mount_component(icon, span, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const icon_changes = {};
			if (dirty[0] & /*iconType*/ 4096) icon_changes.type = /*iconType*/ ctx[12];
			icon.$set(icon_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			destroy_component(icon);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$c.name,
		type: "if",
		source: "(97:16) {#if iconType}",
		ctx
	});

	return block;
}

// (96:35)                  
function fallback_block$4(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*iconType*/ ctx[12] && create_if_block$c(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*iconType*/ ctx[12]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*iconType*/ 4096) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$c(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: fallback_block$4.name,
		type: "fallback",
		source: "(96:35)                  ",
		ctx
	});

	return block;
}

function create_fragment$V(ctx) {
	let div1;
	let t0;
	let div0;
	let select;
	let if_block1_anchor;
	let t1;
	let label_1;
	let t2;
	let fielderrors;
	let div1_class_value;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*titleProp*/ ctx[14] && create_if_block_3(ctx);
	let if_block1 = !/*required*/ ctx[7] && create_if_block_2$2(ctx);
	let each_value = /*options*/ ctx[11];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
	}

	const post_icon_slot_template = /*$$slots*/ ctx[27]["post-icon"];
	const post_icon_slot = create_slot(post_icon_slot_template, ctx, /*$$scope*/ ctx[26], get_post_icon_slot_context$1);
	const post_icon_slot_or_fallback = post_icon_slot || fallback_block$4(ctx);

	fielderrors = new FieldErrors({
			props: { items: /*errors*/ ctx[10] },
			$$inline: true
		});

	const block = {
		c: function create() {
			div1 = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			div0 = element("div");
			select = element("select");
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t1 = space();
			label_1 = element("label");
			if (post_icon_slot_or_fallback) post_icon_slot_or_fallback.c();
			t2 = space();
			create_component(fielderrors.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			if (if_block0) if_block0.l(div1_nodes);
			t0 = claim_space(div1_nodes);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);

			select = claim_element(div0_nodes, "SELECT", {
				name: true,
				type: true,
				form: true,
				align: true,
				readonly: true,
				disabled: true,
				required: true,
				placeholder: true,
				autocomplete: true,
				id: true,
				class: true,
				title: true,
				style: true,
				"aria-label": true
			});

			var select_nodes = children(select);
			if (if_block1) if_block1.l(select_nodes);
			if_block1_anchor = empty();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(select_nodes);
			}

			select_nodes.forEach(detach_dev);
			t1 = claim_space(div0_nodes);
			label_1 = claim_element(div0_nodes, "LABEL", { for: true, class: true });
			var label_1_nodes = children(label_1);
			if (post_icon_slot_or_fallback) post_icon_slot_or_fallback.l(label_1_nodes);
			label_1_nodes.forEach(detach_dev);
			div0_nodes.forEach(detach_dev);
			t2 = claim_space(div1_nodes);
			claim_component(fielderrors.$$.fragment, div1_nodes);
			div1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(select, "name", /*name*/ ctx[1]);
			attr_dev(select, "type", /*type*/ ctx[2]);
			attr_dev(select, "form", /*form*/ ctx[5]);
			attr_dev(select, "align", /*align*/ ctx[3]);
			attr_dev(select, "readonly", /*readonly*/ ctx[6]);
			select.disabled = /*disabled*/ ctx[4];
			select.required = /*required*/ ctx[7];
			attr_dev(select, "placeholder", /*placeholder*/ ctx[8]);
			attr_dev(select, "autocomplete", /*autocomplete*/ ctx[9]);
			attr_dev(select, "id", /*idProp*/ ctx[13]);
			attr_dev(select, "class", "inp-inner svelte-6fajxs");
			attr_dev(select, "title", /*titleProp*/ ctx[14]);
			attr_dev(select, "style", /*styleProp*/ ctx[16]);
			attr_dev(select, "aria-label", /*ariaLabelProp*/ ctx[15]);
			if (/*value*/ ctx[0] === void 0) add_render_callback(() => /*select_change_handler*/ ctx[28].call(select));
			add_location(select, file$V, 62, 8, 1934);
			attr_dev(label_1, "for", /*idProp*/ ctx[13]);
			attr_dev(label_1, "class", "inp-post-icon svelte-6fajxs");
			add_location(label_1, file$V, 94, 8, 2984);
			attr_dev(div0, "class", "inp-inner-wrap svelte-6fajxs");
			add_location(div0, file$V, 61, 4, 1897);
			attr_dev(div1, "class", div1_class_value = "" + (null_to_empty(/*classProp*/ ctx[17]) + " svelte-6fajxs"));
			add_location(div1, file$V, 53, 0, 1693);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			if (if_block0) if_block0.m(div1, null);
			append_dev(div1, t0);
			append_dev(div1, div0);
			append_dev(div0, select);
			if (if_block1) if_block1.m(select, null);
			append_dev(select, if_block1_anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(select, null);
			}

			select_option(select, /*value*/ ctx[0]);
			append_dev(div0, t1);
			append_dev(div0, label_1);

			if (post_icon_slot_or_fallback) {
				post_icon_slot_or_fallback.m(label_1, null);
			}

			append_dev(div1, t2);
			mount_component(fielderrors, div1, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(select, "change", /*select_change_handler*/ ctx[28]),
					listen_dev(select, "change", /*onChange*/ ctx[19], false, false, false),
					listen_dev(select, "blur", /*blur_handler*/ ctx[29], false, false, false),
					listen_dev(select, "focus", /*focus_handler*/ ctx[30], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*titleProp*/ ctx[14]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*titleProp*/ 16384) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_3(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div1, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (!/*required*/ ctx[7]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_2$2(ctx);
					if_block1.c();
					if_block1.m(select, if_block1_anchor);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (dirty[0] & /*options*/ 2048) {
				each_value = /*options*/ ctx[11];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$2(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(select, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (!current || dirty[0] & /*name*/ 2) {
				attr_dev(select, "name", /*name*/ ctx[1]);
			}

			if (!current || dirty[0] & /*type*/ 4) {
				attr_dev(select, "type", /*type*/ ctx[2]);
			}

			if (!current || dirty[0] & /*form*/ 32) {
				attr_dev(select, "form", /*form*/ ctx[5]);
			}

			if (!current || dirty[0] & /*align*/ 8) {
				attr_dev(select, "align", /*align*/ ctx[3]);
			}

			if (!current || dirty[0] & /*readonly*/ 64) {
				attr_dev(select, "readonly", /*readonly*/ ctx[6]);
			}

			if (!current || dirty[0] & /*disabled*/ 16) {
				prop_dev(select, "disabled", /*disabled*/ ctx[4]);
			}

			if (!current || dirty[0] & /*required*/ 128) {
				prop_dev(select, "required", /*required*/ ctx[7]);
			}

			if (!current || dirty[0] & /*placeholder*/ 256) {
				attr_dev(select, "placeholder", /*placeholder*/ ctx[8]);
			}

			if (!current || dirty[0] & /*autocomplete*/ 512) {
				attr_dev(select, "autocomplete", /*autocomplete*/ ctx[9]);
			}

			if (!current || dirty[0] & /*idProp*/ 8192) {
				attr_dev(select, "id", /*idProp*/ ctx[13]);
			}

			if (!current || dirty[0] & /*titleProp*/ 16384) {
				attr_dev(select, "title", /*titleProp*/ ctx[14]);
			}

			if (!current || dirty[0] & /*styleProp*/ 65536) {
				attr_dev(select, "style", /*styleProp*/ ctx[16]);
			}

			if (!current || dirty[0] & /*ariaLabelProp*/ 32768) {
				attr_dev(select, "aria-label", /*ariaLabelProp*/ ctx[15]);
			}

			if (dirty[0] & /*value, options*/ 2049) {
				select_option(select, /*value*/ ctx[0]);
			}

			if (post_icon_slot) {
				if (post_icon_slot.p && dirty[0] & /*$$scope*/ 67108864) {
					update_slot(post_icon_slot, post_icon_slot_template, ctx, /*$$scope*/ ctx[26], dirty, get_post_icon_slot_changes$1, get_post_icon_slot_context$1);
				}
			} else {
				if (post_icon_slot_or_fallback && post_icon_slot_or_fallback.p && dirty[0] & /*iconType*/ 4096) {
					post_icon_slot_or_fallback.p(ctx, dirty);
				}
			}

			if (!current || dirty[0] & /*idProp*/ 8192) {
				attr_dev(label_1, "for", /*idProp*/ ctx[13]);
			}

			const fielderrors_changes = {};
			if (dirty[0] & /*errors*/ 1024) fielderrors_changes.items = /*errors*/ ctx[10];
			fielderrors.$set(fielderrors_changes);

			if (!current || dirty[0] & /*classProp*/ 131072 && div1_class_value !== (div1_class_value = "" + (null_to_empty(/*classProp*/ ctx[17]) + " svelte-6fajxs"))) {
				attr_dev(div1, "class", div1_class_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(post_icon_slot_or_fallback, local);
			transition_in(fielderrors.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(post_icon_slot_or_fallback, local);
			transition_out(fielderrors.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			destroy_each(each_blocks, detaching);
			if (post_icon_slot_or_fallback) post_icon_slot_or_fallback.d(detaching);
			destroy_component(fielderrors);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$V.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function getValue$2(e) {
	return e.target.value;
}

function instance$V($$self, $$props, $$invalidate) {
	const dispatch = createEventDispatcher();
	let { name } = $$props;
	let { style = {} } = $$props;
	let { type = "select" } = $$props;
	let { value = undefined } = $$props;
	let { id = undefined } = $$props;
	let { align = undefined } = $$props;
	let { disabled = false } = $$props;
	let { label = undefined } = $$props;
	let { invalid = undefined } = $$props;
	let { form = undefined } = $$props; // Specifies the form the <input> element belongs to
	let { readonly = undefined } = $$props; // undefined|readonly
	let { required = undefined } = $$props; // undefined|required
	let { ariaLabel = undefined } = $$props;
	let { placeholder = undefined } = $$props;
	let { autocomplete = "on" } = $$props;
	let { postIcon = undefined } = $$props;
	let { errors = undefined } = $$props;
	let { options = [] } = $$props;

	function onChange(e) {
		const value = getValue$2(e);
		dispatch("change", { e, value, name });
	}

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Select", $$slots, ['post-icon']);

	function select_change_handler() {
		value = select_value(this);
		$$invalidate(0, value);
		$$invalidate(11, options);
	}

	const blur_handler = e => !disabled && dispatch("blur", e);
	const focus_handler = e => !disabled && dispatch("focus", e);

	$$self.$set = $$new_props => {
		$$invalidate(32, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("name" in $$new_props) $$invalidate(1, name = $$new_props.name);
		if ("style" in $$new_props) $$invalidate(20, style = $$new_props.style);
		if ("type" in $$new_props) $$invalidate(2, type = $$new_props.type);
		if ("value" in $$new_props) $$invalidate(0, value = $$new_props.value);
		if ("id" in $$new_props) $$invalidate(21, id = $$new_props.id);
		if ("align" in $$new_props) $$invalidate(3, align = $$new_props.align);
		if ("disabled" in $$new_props) $$invalidate(4, disabled = $$new_props.disabled);
		if ("label" in $$new_props) $$invalidate(22, label = $$new_props.label);
		if ("invalid" in $$new_props) $$invalidate(23, invalid = $$new_props.invalid);
		if ("form" in $$new_props) $$invalidate(5, form = $$new_props.form);
		if ("readonly" in $$new_props) $$invalidate(6, readonly = $$new_props.readonly);
		if ("required" in $$new_props) $$invalidate(7, required = $$new_props.required);
		if ("ariaLabel" in $$new_props) $$invalidate(24, ariaLabel = $$new_props.ariaLabel);
		if ("placeholder" in $$new_props) $$invalidate(8, placeholder = $$new_props.placeholder);
		if ("autocomplete" in $$new_props) $$invalidate(9, autocomplete = $$new_props.autocomplete);
		if ("postIcon" in $$new_props) $$invalidate(25, postIcon = $$new_props.postIcon);
		if ("errors" in $$new_props) $$invalidate(10, errors = $$new_props.errors);
		if ("options" in $$new_props) $$invalidate(11, options = $$new_props.options);
		if ("$$scope" in $$new_props) $$invalidate(26, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		classnames,
		toCSSString,
		Br,
		Icon,
		FieldErrors,
		dispatch,
		name,
		style,
		type,
		value,
		id,
		align,
		disabled,
		label,
		invalid,
		form,
		readonly,
		required,
		ariaLabel,
		placeholder,
		autocomplete,
		postIcon,
		errors,
		options,
		onChange,
		getValue: getValue$2,
		iconType,
		error,
		idProp,
		titleProp,
		ariaLabelProp,
		styleProp,
		classProp
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(32, $$props = assign(assign({}, $$props), $$new_props));
		if ("name" in $$props) $$invalidate(1, name = $$new_props.name);
		if ("style" in $$props) $$invalidate(20, style = $$new_props.style);
		if ("type" in $$props) $$invalidate(2, type = $$new_props.type);
		if ("value" in $$props) $$invalidate(0, value = $$new_props.value);
		if ("id" in $$props) $$invalidate(21, id = $$new_props.id);
		if ("align" in $$props) $$invalidate(3, align = $$new_props.align);
		if ("disabled" in $$props) $$invalidate(4, disabled = $$new_props.disabled);
		if ("label" in $$props) $$invalidate(22, label = $$new_props.label);
		if ("invalid" in $$props) $$invalidate(23, invalid = $$new_props.invalid);
		if ("form" in $$props) $$invalidate(5, form = $$new_props.form);
		if ("readonly" in $$props) $$invalidate(6, readonly = $$new_props.readonly);
		if ("required" in $$props) $$invalidate(7, required = $$new_props.required);
		if ("ariaLabel" in $$props) $$invalidate(24, ariaLabel = $$new_props.ariaLabel);
		if ("placeholder" in $$props) $$invalidate(8, placeholder = $$new_props.placeholder);
		if ("autocomplete" in $$props) $$invalidate(9, autocomplete = $$new_props.autocomplete);
		if ("postIcon" in $$props) $$invalidate(25, postIcon = $$new_props.postIcon);
		if ("errors" in $$props) $$invalidate(10, errors = $$new_props.errors);
		if ("options" in $$props) $$invalidate(11, options = $$new_props.options);
		if ("iconType" in $$props) $$invalidate(12, iconType = $$new_props.iconType);
		if ("error" in $$props) $$invalidate(31, error = $$new_props.error);
		if ("idProp" in $$props) $$invalidate(13, idProp = $$new_props.idProp);
		if ("titleProp" in $$props) $$invalidate(14, titleProp = $$new_props.titleProp);
		if ("ariaLabelProp" in $$props) $$invalidate(15, ariaLabelProp = $$new_props.ariaLabelProp);
		if ("styleProp" in $$props) $$invalidate(16, styleProp = $$new_props.styleProp);
		if ("classProp" in $$props) $$invalidate(17, classProp = $$new_props.classProp);
	};

	let iconType;
	let error;
	let idProp;
	let titleProp;
	let ariaLabelProp;
	let styleProp;
	let classProp;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*postIcon*/ 33554432) {
			 $$invalidate(12, iconType = postIcon || "caret-down");
		}

		if ($$self.$$.dirty[0] & /*invalid, errors*/ 8389632) {
			 $$invalidate(31, error = invalid || !!(errors || []).length);
		}

		if ($$self.$$.dirty[0] & /*id, name*/ 2097154) {
			 $$invalidate(13, idProp = id || name);
		}

		if ($$self.$$.dirty[0] & /*label, ariaLabel*/ 20971520) {
			 $$invalidate(14, titleProp = label || ariaLabel);
		}

		if ($$self.$$.dirty[0] & /*ariaLabel, label, placeholder*/ 20971776) {
			 $$invalidate(15, ariaLabelProp = ariaLabel || label || placeholder);
		}

		if ($$self.$$.dirty[0] & /*style, align*/ 1048584) {
			 $$invalidate(16, styleProp = toCSSString({ ...style, textAlign: align }));
		}

		 $$invalidate(17, classProp = classnames("select", $$props.class, {
			disabled,
			readonly,
			required,
			error,
			null: value === undefined
		}));
	};

	$$props = exclude_internal_props($$props);

	return [
		value,
		name,
		type,
		align,
		disabled,
		form,
		readonly,
		required,
		placeholder,
		autocomplete,
		errors,
		options,
		iconType,
		idProp,
		titleProp,
		ariaLabelProp,
		styleProp,
		classProp,
		dispatch,
		onChange,
		style,
		id,
		label,
		invalid,
		ariaLabel,
		postIcon,
		$$scope,
		$$slots,
		select_change_handler,
		blur_handler,
		focus_handler
	];
}

class Select extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document.getElementById("svelte-6fajxs-style")) add_css$i();

		init(
			this,
			options,
			instance$V,
			create_fragment$V,
			safe_not_equal,
			{
				name: 1,
				style: 20,
				type: 2,
				value: 0,
				id: 21,
				align: 3,
				disabled: 4,
				label: 22,
				invalid: 23,
				form: 5,
				readonly: 6,
				required: 7,
				ariaLabel: 24,
				placeholder: 8,
				autocomplete: 9,
				postIcon: 25,
				errors: 10,
				options: 11
			},
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Select",
			options,
			id: create_fragment$V.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*name*/ ctx[1] === undefined && !("name" in props)) {
			console.warn("<Select> was created without expected prop 'name'");
		}
	}

	get name() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set name(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get type() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set type(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get id() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get align() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set align(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get label() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set label(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get invalid() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set invalid(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get form() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set form(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get readonly() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set readonly(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get required() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set required(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ariaLabel() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ariaLabel(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get placeholder() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set placeholder(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get autocomplete() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set autocomplete(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get postIcon() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set postIcon(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get errors() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set errors(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get options() {
		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set options(value) {
		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/fields/ReadField.svelte generated by Svelte v3.24.0 */
const file$W = "src/components/fields/ReadField.svelte";

// (15:4) {#if label}
function create_if_block$d(ctx) {
	let h2;
	let t0;
	let t1;
	let br;
	let current;
	br = new Br({ props: { size: "10" }, $$inline: true });

	const block = {
		c: function create() {
			h2 = element("h2");
			t0 = text(/*label*/ ctx[2]);
			t1 = space();
			create_component(br.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			h2 = claim_element(nodes, "H2", { class: true });
			var h2_nodes = children(h2);
			t0 = claim_text(h2_nodes, /*label*/ ctx[2]);
			h2_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			claim_component(br.$$.fragment, nodes);
			this.h();
		},
		h: function hydrate() {
			attr_dev(h2, "class", "block full-width");
			add_location(h2, file$W, 15, 8, 424);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h2, anchor);
			append_dev(h2, t0);
			insert_dev(target, t1, anchor);
			mount_component(br, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (!current || dirty & /*label*/ 4) set_data_dev(t0, /*label*/ ctx[2]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(br.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h2);
			if (detaching) detach_dev(t1);
			destroy_component(br, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$d.name,
		type: "if",
		source: "(15:4) {#if label}",
		ctx
	});

	return block;
}

function create_fragment$W(ctx) {
	let div;
	let t0;
	let p;
	let t1_value = (/*value*/ ctx[0] || "—") + "";
	let t1;
	let current;
	let if_block = /*label*/ ctx[2] && create_if_block$d(ctx);

	const block = {
		c: function create() {
			div = element("div");
			if (if_block) if_block.c();
			t0 = space();
			p = element("p");
			t1 = text(t1_value);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { id: true, class: true, style: true });
			var div_nodes = children(div);
			if (if_block) if_block.l(div_nodes);
			t0 = claim_space(div_nodes);
			p = claim_element(div_nodes, "P", { class: true });
			var p_nodes = children(p);
			t1 = claim_text(p_nodes, t1_value);
			p_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(p, "class", "block full-width");
			add_location(p, file$W, 18, 4, 504);
			attr_dev(div, "id", /*id*/ ctx[1]);
			attr_dev(div, "class", /*classProp*/ ctx[4]);
			attr_dev(div, "style", /*styleProp*/ ctx[3]);
			add_location(div, file$W, 13, 0, 353);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block) if_block.m(div, null);
			append_dev(div, t0);
			append_dev(div, p);
			append_dev(p, t1);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*label*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*label*/ 4) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$d(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div, t0);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if ((!current || dirty & /*value*/ 1) && t1_value !== (t1_value = (/*value*/ ctx[0] || "—") + "")) set_data_dev(t1, t1_value);

			if (!current || dirty & /*id*/ 2) {
				attr_dev(div, "id", /*id*/ ctx[1]);
			}

			if (!current || dirty & /*classProp*/ 16) {
				attr_dev(div, "class", /*classProp*/ ctx[4]);
			}

			if (!current || dirty & /*styleProp*/ 8) {
				attr_dev(div, "style", /*styleProp*/ ctx[3]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block) if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$W.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$W($$self, $$props, $$invalidate) {
	let { value = "" } = $$props;
	let { style = {} } = $$props;
	let { id = undefined } = $$props;
	let { label = undefined } = $$props;
	let { $$slots = {}, $$scope } = $$props;
	validate_slots("ReadField", $$slots, []);

	$$self.$set = $$new_props => {
		$$invalidate(6, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("value" in $$new_props) $$invalidate(0, value = $$new_props.value);
		if ("style" in $$new_props) $$invalidate(5, style = $$new_props.style);
		if ("id" in $$new_props) $$invalidate(1, id = $$new_props.id);
		if ("label" in $$new_props) $$invalidate(2, label = $$new_props.label);
	};

	$$self.$capture_state = () => ({
		classnames,
		toCSSString,
		Br,
		value,
		style,
		id,
		label,
		styleProp,
		classProp
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(6, $$props = assign(assign({}, $$props), $$new_props));
		if ("value" in $$props) $$invalidate(0, value = $$new_props.value);
		if ("style" in $$props) $$invalidate(5, style = $$new_props.style);
		if ("id" in $$props) $$invalidate(1, id = $$new_props.id);
		if ("label" in $$props) $$invalidate(2, label = $$new_props.label);
		if ("styleProp" in $$props) $$invalidate(3, styleProp = $$new_props.styleProp);
		if ("classProp" in $$props) $$invalidate(4, classProp = $$new_props.classProp);
	};

	let styleProp;
	let classProp;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*style*/ 32) {
			 $$invalidate(3, styleProp = toCSSString({ ...style }));
		}

		 $$invalidate(4, classProp = classnames("block full-width text-left", $$props.class));
	};

	$$props = exclude_internal_props($$props);
	return [value, id, label, styleProp, classProp, style];
}

class ReadField extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$W, create_fragment$W, safe_not_equal, { value: 0, style: 5, id: 1, label: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ReadField",
			options,
			id: create_fragment$W.name
		});
	}

	get value() {
		throw new Error("<ReadField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<ReadField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<ReadField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<ReadField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get id() {
		throw new Error("<ReadField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<ReadField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get label() {
		throw new Error("<ReadField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set label(value) {
		throw new Error("<ReadField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/fields/RadioRect.svelte generated by Svelte v3.24.0 */
const file$X = "src/components/fields/RadioRect.svelte";

const get_default_slot_changes$3 = dirty => ({
	item: dirty & /*options*/ 8,
	checked: dirty & /*value, options*/ 10
});

const get_default_slot_context$3 = ctx => ({
	item: /*radio*/ ctx[21],
	checked: /*value*/ ctx[1] === /*radio*/ ctx[21].value
});

function get_each_context$3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[21] = list[i];
	child_ctx[23] = i;
	return child_ctx;
}

// (35:4) {#if label}
function create_if_block_2$3(ctx) {
	let h2;
	let t0;
	let t1;
	let br;
	let current;
	br = new Br({ props: { size: "10" }, $$inline: true });

	const block = {
		c: function create() {
			h2 = element("h2");
			t0 = text(/*label*/ ctx[2]);
			t1 = space();
			create_component(br.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			h2 = claim_element(nodes, "H2", { class: true });
			var h2_nodes = children(h2);
			t0 = claim_text(h2_nodes, /*label*/ ctx[2]);
			t1 = claim_space(h2_nodes);
			claim_component(br.$$.fragment, h2_nodes);
			h2_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(h2, "class", "text-left");
			add_location(h2, file$X, 35, 8, 1231);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h2, anchor);
			append_dev(h2, t0);
			append_dev(h2, t1);
			mount_component(br, h2, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (!current || dirty & /*label*/ 4) set_data_dev(t0, /*label*/ ctx[2]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(br.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h2);
			destroy_component(br);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$3.name,
		type: "if",
		source: "(35:4) {#if label}",
		ctx
	});

	return block;
}

// (60:28) {#if radio.preIcon}
function create_if_block_1$8(ctx) {
	let icon;
	let t;
	let s;
	let current;

	icon = new Icon({
			props: {
				type: /*radio*/ ctx[21].preIcon,
				size: "medium",
				is: /*value*/ ctx[1] === /*radio*/ ctx[21].value
				? "light"
				: "info"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
			t = space();
			s = element("s");
			this.h();
		},
		l: function claim(nodes) {
			claim_component(icon.$$.fragment, nodes);
			t = claim_space(nodes);
			s = claim_element(nodes, "S", {});
			children(s).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(s, file$X, 61, 32, 2313);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			insert_dev(target, t, anchor);
			insert_dev(target, s, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const icon_changes = {};
			if (dirty & /*options*/ 8) icon_changes.type = /*radio*/ ctx[21].preIcon;

			if (dirty & /*value, options*/ 10) icon_changes.is = /*value*/ ctx[1] === /*radio*/ ctx[21].value
			? "light"
			: "info";

			icon.$set(icon_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
			if (detaching) detach_dev(t);
			if (detaching) detach_dev(s);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$8.name,
		type: "if",
		source: "(60:28) {#if radio.preIcon}",
		ctx
	});

	return block;
}

// (67:28) {#if radio.postIcon}
function create_if_block$e(ctx) {
	let s;
	let t;
	let icon;
	let current;

	icon = new Icon({
			props: {
				type: /*radio*/ ctx[21].postIcon,
				size: "medium",
				is: /*value*/ ctx[1] === /*radio*/ ctx[21].value
				? "light"
				: "info"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			s = element("s");
			t = space();
			create_component(icon.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			s = claim_element(nodes, "S", {});
			children(s).forEach(detach_dev);
			t = claim_space(nodes);
			claim_component(icon.$$.fragment, nodes);
			this.h();
		},
		h: function hydrate() {
			add_location(s, file$X, 67, 32, 2618);
		},
		m: function mount(target, anchor) {
			insert_dev(target, s, anchor);
			insert_dev(target, t, anchor);
			mount_component(icon, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const icon_changes = {};
			if (dirty & /*options*/ 8) icon_changes.type = /*radio*/ ctx[21].postIcon;

			if (dirty & /*value, options*/ 10) icon_changes.is = /*value*/ ctx[1] === /*radio*/ ctx[21].value
			? "light"
			: "info";

			icon.$set(icon_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(s);
			if (detaching) detach_dev(t);
			destroy_component(icon, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$e.name,
		type: "if",
		source: "(67:28) {#if radio.postIcon}",
		ctx
	});

	return block;
}

// (58:71)                          
function fallback_block$5(ctx) {
	let p;
	let t0;
	let span;
	let t1_value = /*radio*/ ctx[21].label + "";
	let t1;
	let t2;
	let current;
	let if_block0 = /*radio*/ ctx[21].preIcon && create_if_block_1$8(ctx);
	let if_block1 = /*radio*/ ctx[21].postIcon && create_if_block$e(ctx);

	const block = {
		c: function create() {
			p = element("p");
			if (if_block0) if_block0.c();
			t0 = space();
			span = element("span");
			t1 = text(t1_value);
			t2 = space();
			if (if_block1) if_block1.c();
			this.h();
		},
		l: function claim(nodes) {
			p = claim_element(nodes, "P", { class: true, style: true });
			var p_nodes = children(p);
			if (if_block0) if_block0.l(p_nodes);
			t0 = claim_space(p_nodes);
			span = claim_element(p_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t1 = claim_text(span_nodes, t1_value);
			span_nodes.forEach(detach_dev);
			t2 = claim_space(p_nodes);
			if (if_block1) if_block1.l(p_nodes);
			p_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "font-w-500 h3 flex flex-align-center flex-justify-center");
			add_location(span, file$X, 63, 28, 2383);
			attr_dev(p, "class", "flex flex-align-center");
			set_style(p, "padding", "10px 20px");
			add_location(p, file$X, 58, 24, 2050);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			if (if_block0) if_block0.m(p, null);
			append_dev(p, t0);
			append_dev(p, span);
			append_dev(span, t1);
			append_dev(p, t2);
			if (if_block1) if_block1.m(p, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*radio*/ ctx[21].preIcon) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*options*/ 8) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_1$8(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(p, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if ((!current || dirty & /*options*/ 8) && t1_value !== (t1_value = /*radio*/ ctx[21].label + "")) set_data_dev(t1, t1_value);

			if (/*radio*/ ctx[21].postIcon) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*options*/ 8) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block$e(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(p, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: fallback_block$5.name,
		type: "fallback",
		source: "(58:71)                          ",
		ctx
	});

	return block;
}

// (45:16) <Button                     auto                     htmlFor={`${idProp}_${i}`}                     is={value === radio.value ? 'info' : 'info-border'}                 >
function create_default_slot$D(ctx) {
	let input;
	let input_id_value;
	let input_value_value;
	let t;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*$$slots*/ ctx[16].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[17], get_default_slot_context$3);
	const default_slot_or_fallback = default_slot || fallback_block$5(ctx);

	const block = {
		c: function create() {
			input = element("input");
			t = space();
			if (default_slot_or_fallback) default_slot_or_fallback.c();
			this.h();
		},
		l: function claim(nodes) {
			input = claim_element(nodes, "INPUT", {
				form: true,
				hidden: true,
				type: true,
				id: true,
				value: true
			});

			t = claim_space(nodes);
			if (default_slot_or_fallback) default_slot_or_fallback.l(nodes);
			this.h();
		},
		h: function hydrate() {
			attr_dev(input, "form", /*form*/ ctx[0]);
			input.hidden = true;
			attr_dev(input, "type", "checkbox");
			attr_dev(input, "id", input_id_value = `${/*idProp*/ ctx[4]}_${/*i*/ ctx[23]}`);
			input.value = input_value_value = /*radio*/ ctx[21].value;
			add_location(input, file$X, 49, 20, 1662);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			insert_dev(target, t, anchor);

			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(target, anchor);
			}

			current = true;

			if (!mounted) {
				dispose = listen_dev(
					input,
					"change",
					function () {
						if (is_function(/*onChange*/ ctx[7].bind(null, /*radio*/ ctx[21].value))) /*onChange*/ ctx[7].bind(null, /*radio*/ ctx[21].value).apply(this, arguments);
					},
					false,
					false,
					false
				);

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (!current || dirty & /*form*/ 1) {
				attr_dev(input, "form", /*form*/ ctx[0]);
			}

			if (!current || dirty & /*idProp*/ 16 && input_id_value !== (input_id_value = `${/*idProp*/ ctx[4]}_${/*i*/ ctx[23]}`)) {
				attr_dev(input, "id", input_id_value);
			}

			if (!current || dirty & /*options*/ 8 && input_value_value !== (input_value_value = /*radio*/ ctx[21].value)) {
				prop_dev(input, "value", input_value_value);
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope, options, value*/ 131082) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[17], dirty, get_default_slot_changes$3, get_default_slot_context$3);
				}
			} else {
				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*options, value*/ 10) {
					default_slot_or_fallback.p(ctx, dirty);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot_or_fallback, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot_or_fallback, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			if (detaching) detach_dev(t);
			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$D.name,
		type: "slot",
		source: "(45:16) <Button                     auto                     htmlFor={`${idProp}_${i}`}                     is={value === radio.value ? 'info' : 'info-border'}                 >",
		ctx
	});

	return block;
}

// (43:8) {#each options as radio, i}
function create_each_block$3(ctx) {
	let li;
	let button;
	let t;
	let current;

	button = new Button({
			props: {
				auto: true,
				htmlFor: `${/*idProp*/ ctx[4]}_${/*i*/ ctx[23]}`,
				is: /*value*/ ctx[1] === /*radio*/ ctx[21].value
				? "info"
				: "info-border",
				$$slots: { default: [create_default_slot$D] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			li = element("li");
			create_component(button.$$.fragment);
			t = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { style: true });
			var li_nodes = children(li);
			claim_component(button.$$.fragment, li_nodes);
			t = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_style(li, "padding", "5px");
			add_location(li, file$X, 43, 12, 1430);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			mount_component(button, li, null);
			append_dev(li, t);
			current = true;
		},
		p: function update(ctx, dirty) {
			const button_changes = {};
			if (dirty & /*idProp*/ 16) button_changes.htmlFor = `${/*idProp*/ ctx[4]}_${/*i*/ ctx[23]}`;

			if (dirty & /*value, options*/ 10) button_changes.is = /*value*/ ctx[1] === /*radio*/ ctx[21].value
			? "info"
			: "info-border";

			if (dirty & /*$$scope, options, value, form, idProp*/ 131099) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			destroy_component(button);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$3.name,
		type: "each",
		source: "(43:8) {#each options as radio, i}",
		ctx
	});

	return block;
}

function create_fragment$X(ctx) {
	let div;
	let t;
	let ul;
	let current;
	let if_block = /*label*/ ctx[2] && create_if_block_2$3(ctx);
	let each_value = /*options*/ ctx[3];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			div = element("div");
			if (if_block) if_block.c();
			t = space();
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { id: true, class: true, style: true });
			var div_nodes = children(div);
			if (if_block) if_block.l(div_nodes);
			t = claim_space(div_nodes);
			ul = claim_element(div_nodes, "UL", { style: true, class: true });
			var ul_nodes = children(ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(ul_nodes);
			}

			ul_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_style(ul, "margin", "-5px");
			attr_dev(ul, "class", "flex flex-wrap");
			add_location(ul, file$X, 41, 4, 1333);
			attr_dev(div, "id", /*idProp*/ ctx[4]);
			attr_dev(div, "class", /*classProp*/ ctx[6]);
			attr_dev(div, "style", /*styleProp*/ ctx[5]);
			add_location(div, file$X, 33, 0, 1153);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block) if_block.m(div, null);
			append_dev(div, t);
			append_dev(div, ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*label*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*label*/ 4) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_2$3(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div, t);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (dirty & /*idProp, value, options, $$scope, form, onChange*/ 131227) {
				each_value = /*options*/ ctx[3];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$3(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$3(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(ul, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}

			if (!current || dirty & /*idProp*/ 16) {
				attr_dev(div, "id", /*idProp*/ ctx[4]);
			}

			if (!current || dirty & /*classProp*/ 64) {
				attr_dev(div, "class", /*classProp*/ ctx[6]);
			}

			if (!current || dirty & /*styleProp*/ 32) {
				attr_dev(div, "style", /*styleProp*/ ctx[5]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block) if_block.d();
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$X.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$X($$self, $$props, $$invalidate) {
	const dispatch = createEventDispatcher();
	let { name } = $$props;
	let { style = {} } = $$props;
	let { id = undefined } = $$props;
	let { form = undefined } = $$props; // Specifies the form the <input> element belongs to
	let { value = undefined } = $$props;
	let { label = undefined } = $$props;
	let { align = undefined } = $$props;
	let { options = undefined } = $$props;
	let { invalid = undefined } = $$props;
	let { disabled = undefined } = $$props;
	let { required = undefined } = $$props; // undefined|required
	let { errors = undefined } = $$props;

	function onChange(val, e) {
		dispatch("change", { e, name, value: val });
	}

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("RadioRect", $$slots, ['default']);

	$$self.$set = $$new_props => {
		$$invalidate(20, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("name" in $$new_props) $$invalidate(8, name = $$new_props.name);
		if ("style" in $$new_props) $$invalidate(9, style = $$new_props.style);
		if ("id" in $$new_props) $$invalidate(10, id = $$new_props.id);
		if ("form" in $$new_props) $$invalidate(0, form = $$new_props.form);
		if ("value" in $$new_props) $$invalidate(1, value = $$new_props.value);
		if ("label" in $$new_props) $$invalidate(2, label = $$new_props.label);
		if ("align" in $$new_props) $$invalidate(11, align = $$new_props.align);
		if ("options" in $$new_props) $$invalidate(3, options = $$new_props.options);
		if ("invalid" in $$new_props) $$invalidate(12, invalid = $$new_props.invalid);
		if ("disabled" in $$new_props) $$invalidate(13, disabled = $$new_props.disabled);
		if ("required" in $$new_props) $$invalidate(14, required = $$new_props.required);
		if ("errors" in $$new_props) $$invalidate(15, errors = $$new_props.errors);
		if ("$$scope" in $$new_props) $$invalidate(17, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		classnames,
		toCSSString,
		Br,
		Icon,
		Button,
		FieldErrors,
		dispatch,
		name,
		style,
		id,
		form,
		value,
		label,
		align,
		options,
		invalid,
		disabled,
		required,
		errors,
		onChange,
		idProp,
		error,
		styleProp,
		classProp
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(20, $$props = assign(assign({}, $$props), $$new_props));
		if ("name" in $$props) $$invalidate(8, name = $$new_props.name);
		if ("style" in $$props) $$invalidate(9, style = $$new_props.style);
		if ("id" in $$props) $$invalidate(10, id = $$new_props.id);
		if ("form" in $$props) $$invalidate(0, form = $$new_props.form);
		if ("value" in $$props) $$invalidate(1, value = $$new_props.value);
		if ("label" in $$props) $$invalidate(2, label = $$new_props.label);
		if ("align" in $$props) $$invalidate(11, align = $$new_props.align);
		if ("options" in $$props) $$invalidate(3, options = $$new_props.options);
		if ("invalid" in $$props) $$invalidate(12, invalid = $$new_props.invalid);
		if ("disabled" in $$props) $$invalidate(13, disabled = $$new_props.disabled);
		if ("required" in $$props) $$invalidate(14, required = $$new_props.required);
		if ("errors" in $$props) $$invalidate(15, errors = $$new_props.errors);
		if ("idProp" in $$props) $$invalidate(4, idProp = $$new_props.idProp);
		if ("error" in $$props) $$invalidate(18, error = $$new_props.error);
		if ("styleProp" in $$props) $$invalidate(5, styleProp = $$new_props.styleProp);
		if ("classProp" in $$props) $$invalidate(6, classProp = $$new_props.classProp);
	};

	let idProp;
	let error;
	let styleProp;
	let classProp;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*id, name*/ 1280) {
			 $$invalidate(4, idProp = id || name);
		}

		if ($$self.$$.dirty & /*invalid, errors*/ 36864) {
			 $$invalidate(18, error = invalid || !!(errors || []).length);
		}

		if ($$self.$$.dirty & /*style, align*/ 2560) {
			 $$invalidate(5, styleProp = toCSSString({ ...style, textAlign: align }));
		}

		 $$invalidate(6, classProp = classnames("radio-rect", $$props.class, { disabled, required, error }));
	};

	$$props = exclude_internal_props($$props);

	return [
		form,
		value,
		label,
		options,
		idProp,
		styleProp,
		classProp,
		onChange,
		name,
		style,
		id,
		align,
		invalid,
		disabled,
		required,
		errors,
		$$slots,
		$$scope
	];
}

class RadioRect extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$X, create_fragment$X, safe_not_equal, {
			name: 8,
			style: 9,
			id: 10,
			form: 0,
			value: 1,
			label: 2,
			align: 11,
			options: 3,
			invalid: 12,
			disabled: 13,
			required: 14,
			errors: 15
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "RadioRect",
			options,
			id: create_fragment$X.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*name*/ ctx[8] === undefined && !("name" in props)) {
			console.warn("<RadioRect> was created without expected prop 'name'");
		}
	}

	get name() {
		throw new Error("<RadioRect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set name(value) {
		throw new Error("<RadioRect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<RadioRect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<RadioRect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get id() {
		throw new Error("<RadioRect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<RadioRect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get form() {
		throw new Error("<RadioRect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set form(value) {
		throw new Error("<RadioRect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<RadioRect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<RadioRect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get label() {
		throw new Error("<RadioRect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set label(value) {
		throw new Error("<RadioRect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get align() {
		throw new Error("<RadioRect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set align(value) {
		throw new Error("<RadioRect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get options() {
		throw new Error("<RadioRect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set options(value) {
		throw new Error("<RadioRect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get invalid() {
		throw new Error("<RadioRect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set invalid(value) {
		throw new Error("<RadioRect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<RadioRect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<RadioRect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get required() {
		throw new Error("<RadioRect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set required(value) {
		throw new Error("<RadioRect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get errors() {
		throw new Error("<RadioRect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set errors(value) {
		throw new Error("<RadioRect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/fields/uploadFiles/UploadBox.svelte generated by Svelte v3.24.0 */
const file$Y = "src/components/fields/uploadFiles/UploadBox.svelte";

function add_css$j() {
	var style = element("style");
	style.id = "svelte-zm8c1o-style";
	style.textContent = ".inp-upload.svelte-zm8c1o.svelte-zm8c1o{width:100%;-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-ms-flex-item-align:stretch;align-self:stretch;justify-self:stretch;overflow:hidden;border-radius:var(--border-radius-medium);color:rgba(var(--theme-color-primary-opposite), .5);background-color:rgba(var(--theme-color-primary-opposite), .07);-webkit-transform:translateZ(0);transform:translateZ(0)}.inp-upload.preview.svelte-zm8c1o .icon.svelte-zm8c1o{opacity:.5}.inp-upload.svelte-zm8c1o .icon.svelte-zm8c1o{opacity:.7}.inp-upload.disabled.svelte-zm8c1o.svelte-zm8c1o{opacity:.5;pointer-events:none}.inp-upload.error.svelte-zm8c1o.svelte-zm8c1o,input:invalid+.inp-upload.svelte-zm8c1o.svelte-zm8c1o{color:rgba(var(--color-danger), .5);background-color:rgba(var(--color-danger), .07)}input:focus+.inp-upload.svelte-zm8c1o.svelte-zm8c1o{color:rgba(var(--color-info), .5);background-color:rgba(var(--color-info), .07)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVXBsb2FkQm94LnN2ZWx0ZSIsInNvdXJjZXMiOlsiVXBsb2FkQm94LnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0PlxuICAgIGltcG9ydCB7IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJ3N2ZWx0ZSdcbiAgICBpbXBvcnQgeyBjbGFzc25hbWVzLCB0b0NTU1N0cmluZyB9IGZyb20gJ0B1dGlscydcbiAgICBpbXBvcnQgQnIgZnJvbSAnQGNvbXBvbmVudHMvQnIuc3ZlbHRlJ1xuICAgIGltcG9ydCBJY29uIGZyb20gJ0Bjb21wb25lbnRzL0ljb24uc3ZlbHRlJ1xuICAgIGltcG9ydCBTcXVhcmUgZnJvbSAnQGNvbXBvbmVudHMvU3F1YXJlLnN2ZWx0ZSdcbiAgICBpbXBvcnQgUGljdHVyZSBmcm9tICdAY29tcG9uZW50cy9QaWN0dXJlLnN2ZWx0ZSdcblxuICAgIGNvbnN0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKClcblxuICAgIGV4cG9ydCBsZXQgaWQgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IHNyYyA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgbmFtZSA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgaWNvbiA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgbGFiZWwgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IHZhbHVlID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCByb3VuZCA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgc3R5bGUgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IGljb25JcyA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgZXJyb3JzID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCBpbnZhbGlkID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCBtdWx0aXBsZSA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgZGlzYWJsZWQgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IGFjY2VwdCA9IFwiaW1hZ2UvcG5nLCBpbWFnZS9qcGVnXCJcblxuICAgIGxldCB2YWxpZFNyY1xuXG4gICAgJDogZXJyb3IgPSBpbnZhbGlkICE9PSB1bmRlZmluZWQgPyBpbnZhbGlkIDogISEoZXJyb3JzIHx8IFtdKS5sZW5ndGhcbiAgICAkOiBpY29uVHlwZSA9IGljb24gfHwgJ3VwbG9hZCdcbiAgICAkOiBpZFByb3AgPSBpZCB8fCBuYW1lXG4gICAgJDogc2V0VmFsaWRTcmMoc3JjKVxuICAgICQ6IGNsYXNzUHJvcCA9IGNsYXNzbmFtZXMoJ2lucC11cGxvYWQnLCB7IGVycm9yLCBkaXNhYmxlZCwgcHJldmlldzogc3JjIH0pXG4gICAgJDogc3R5bGVQcm9wID0gdG9DU1NTdHJpbmcoeyAuLi5zdHlsZSwgYm9yZGVyUmFkaXVzOiByb3VuZCA/ICc1MCUnIDogbnVsbCB9KVxuXG4gICAgZnVuY3Rpb24gc2V0VmFsaWRTcmMoZmlsZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmaWxlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHZhbGlkU3JjID0gZmlsZVxuICAgICAgICAgICAgfSBlbHNlIGlmIChmaWxlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZiA9IEFycmF5LmlzQXJyYXkoZmlsZSkgPyBmaWxlWzBdIDogZmlsZVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgICAgICAgICAgcmVhZGVyLm9ubG9hZCA9IGUgPT4gdmFsaWRTcmMgPSBlLnRhcmdldC5yZXN1bHRcbiAgICAgICAgICAgICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChmKTsgLy8gY29udmVydCB0byBiYXNlNjQgc3RyaW5nXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFmaWxlKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRTcmMgPSB1bmRlZmluZWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdVcGxvYWRCb3gvZ2V0VmFsaWRTcmMgZXJyb3I6ICcsIGVycilcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBmdW5jdGlvbiBvbkNoYW5nZShlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gQXJyYXkuZnJvbShlLnRhcmdldC5maWxlcylcbiAgICAgICAgaWYgKCF2YWx1ZSB8fCAhdmFsdWUubGVuZ3RoKSByZXR1cm5cbiAgICAgICAgZGlzcGF0Y2goJ2NoYW5nZScsIHsgdmFsdWUsIG5hbWUsIGUgfSlcbiAgICB9XG48L3NjcmlwdD5cblxueyNpZiBsYWJlbH1cbiAgICA8aDIgY2xhc3M9XCJ0ZXh0LWxlZnRcIj57bGFiZWx9PC9oMj5cbiAgICA8QnIgc2l6ZT1cIjEwXCIvPlxuey9pZn1cbjxTcXVhcmUgY2xhc3M9eyQkcHJvcHMuY2xhc3N9IHN0eWxlPXtzdHlsZVByb3B9PlxuICAgIDxpbnB1dFxuICAgICAgICB7bmFtZX1cbiAgICAgICAge2FjY2VwdH1cbiAgICAgICAge211bHRpcGxlfVxuICAgICAgICBoaWRkZW4gXG4gICAgICAgIHR5cGU9XCJmaWxlXCIgXG4gICAgICAgIGlkPXtpZFByb3B9XG4gICAgICAgIGJpbmQ6dmFsdWVcbiAgICAgICAgb246Y2hhbmdlPXtvbkNoYW5nZX1cbiAgICA+XG4gICAgPGxhYmVsIGZvcj17aWRQcm9wfSBjbGFzcz17Y2xhc3NQcm9wfT5cbiAgICAgICAgPGRpdiBjbGFzcz1cImZsZXggZnVsbC1hYnNvbHV0ZVwiPlxuICAgICAgICAgICAgPFBpY3R1cmUgc3JjPXt2YWxpZFNyY30gYWx0PVwi0JfQsNCy0LDQvdGC0LDQttC10L3QtSDRhNC+0YLQvlwiLz4gXG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwiaWNvbiBmbGV4IHJlbGF0aXZlXCIgc3R5bGU9XCJmbGV4OiAwIDAgNzVweFwiPlxuICAgICAgICAgICAgPEljb24gdHlwZT17aWNvblR5cGV9IGlzPXtpY29uSXN9Lz5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9sYWJlbD5cbjwvU3F1YXJlPlxuXG48c3R5bGU+XG4uaW5wLXVwbG9hZCB7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgLXdlYmtpdC1ib3gtZmxleDogMTtcbiAgICAgICAgLW1zLWZsZXgtcG9zaXRpdmU6IDE7XG4gICAgICAgICAgICBmbGV4LWdyb3c6IDE7XG4gICAgZGlzcGxheTogLXdlYmtpdC1ib3g7XG4gICAgZGlzcGxheTogLW1zLWZsZXhib3g7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICAtd2Via2l0LWJveC1hbGlnbjogY2VudGVyO1xuICAgICAgICAtbXMtZmxleC1hbGlnbjogY2VudGVyO1xuICAgICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAtd2Via2l0LWJveC1wYWNrOiBjZW50ZXI7XG4gICAgICAgIC1tcy1mbGV4LXBhY2s6IGNlbnRlcjtcbiAgICAgICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIC1tcy1mbGV4LWl0ZW0tYWxpZ246IHN0cmV0Y2g7XG4gICAgICAgIGFsaWduLXNlbGY6IHN0cmV0Y2g7XG4gICAganVzdGlmeS1zZWxmOiBzdHJldGNoO1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgYm9yZGVyLXJhZGl1czogdmFyKC0tYm9yZGVyLXJhZGl1cy1tZWRpdW0pO1xuICAgIGNvbG9yOiByZ2JhKHZhcigtLXRoZW1lLWNvbG9yLXByaW1hcnktb3Bwb3NpdGUpLCAuNSk7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSh2YXIoLS10aGVtZS1jb2xvci1wcmltYXJ5LW9wcG9zaXRlKSwgLjA3KTtcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWigwKTtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWigwKTtcbn1cblxuLmlucC11cGxvYWQucHJldmlldyAuaWNvbiB7XG4gICAgb3BhY2l0eTogLjU7XG59XG5cbi5pbnAtdXBsb2FkIC5pY29uIHtcbiAgICBvcGFjaXR5OiAuNztcbn1cblxuLmlucC11cGxvYWQuZGlzYWJsZWQge1xuICAgIG9wYWNpdHk6IC41O1xuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xufVxuXG4uaW5wLXVwbG9hZC5lcnJvcixcbmlucHV0OmludmFsaWQgKyAuaW5wLXVwbG9hZCB7XG4gICAgY29sb3I6IHJnYmEodmFyKC0tY29sb3ItZGFuZ2VyKSwgLjUpO1xuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEodmFyKC0tY29sb3ItZGFuZ2VyKSwgLjA3KTtcbn1cblxuaW5wdXQ6Zm9jdXMgKyAuaW5wLXVwbG9hZCB7XG4gICAgY29sb3I6IHJnYmEodmFyKC0tY29sb3ItaW5mbyksIC41KTtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKHZhcigtLWNvbG9yLWluZm8pLCAuMDcpO1xufTwvc3R5bGU+XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBb0ZBLFdBQVcsNEJBQUMsQ0FBQyxBQUNULEtBQUssQ0FBRSxJQUFJLENBQ1gsZ0JBQWdCLENBQUUsQ0FBQyxDQUNmLGlCQUFpQixDQUFFLENBQUMsQ0FDaEIsU0FBUyxDQUFFLENBQUMsQ0FDcEIsT0FBTyxDQUFFLFdBQVcsQ0FDcEIsT0FBTyxDQUFFLFdBQVcsQ0FDcEIsT0FBTyxDQUFFLElBQUksQ0FDYixpQkFBaUIsQ0FBRSxNQUFNLENBQ3JCLGNBQWMsQ0FBRSxNQUFNLENBQ2xCLFdBQVcsQ0FBRSxNQUFNLENBQzNCLGdCQUFnQixDQUFFLE1BQU0sQ0FDcEIsYUFBYSxDQUFFLE1BQU0sQ0FDakIsZUFBZSxDQUFFLE1BQU0sQ0FDL0IsbUJBQW1CLENBQUUsT0FBTyxDQUN4QixVQUFVLENBQUUsT0FBTyxDQUN2QixZQUFZLENBQUUsT0FBTyxDQUNyQixRQUFRLENBQUUsTUFBTSxDQUNoQixhQUFhLENBQUUsSUFBSSxzQkFBc0IsQ0FBQyxDQUMxQyxLQUFLLENBQUUsS0FBSyxJQUFJLDhCQUE4QixDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FDcEQsZ0JBQWdCLENBQUUsS0FBSyxJQUFJLDhCQUE4QixDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FDaEUsaUJBQWlCLENBQUUsV0FBVyxDQUFDLENBQUMsQ0FDeEIsU0FBUyxDQUFFLFdBQVcsQ0FBQyxDQUFDLEFBQ3BDLENBQUMsQUFFRCxXQUFXLHNCQUFRLENBQUMsS0FBSyxjQUFDLENBQUMsQUFDdkIsT0FBTyxDQUFFLEVBQUUsQUFDZixDQUFDLEFBRUQseUJBQVcsQ0FBQyxLQUFLLGNBQUMsQ0FBQyxBQUNmLE9BQU8sQ0FBRSxFQUFFLEFBQ2YsQ0FBQyxBQUVELFdBQVcsU0FBUyw0QkFBQyxDQUFDLEFBQ2xCLE9BQU8sQ0FBRSxFQUFFLENBQ1gsY0FBYyxDQUFFLElBQUksQUFDeEIsQ0FBQyxBQUVELFdBQVcsa0NBQU0sQ0FDakIsS0FBSyxRQUFRLENBQUcsV0FBVyw0QkFBQyxDQUFDLEFBQ3pCLEtBQUssQ0FBRSxLQUFLLElBQUksY0FBYyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FDcEMsZ0JBQWdCLENBQUUsS0FBSyxJQUFJLGNBQWMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEFBQ3BELENBQUMsQUFFRCxLQUFLLE1BQU0sQ0FBRyxXQUFXLDRCQUFDLENBQUMsQUFDdkIsS0FBSyxDQUFFLEtBQUssSUFBSSxZQUFZLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUNsQyxnQkFBZ0IsQ0FBRSxLQUFLLElBQUksWUFBWSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQUFDbEQsQ0FBQyJ9 */";
	append_dev(document.head, style);
}

// (59:0) {#if label}
function create_if_block$f(ctx) {
	let h2;
	let t0;
	let t1;
	let br;
	let current;
	br = new Br({ props: { size: "10" }, $$inline: true });

	const block = {
		c: function create() {
			h2 = element("h2");
			t0 = text(/*label*/ ctx[2]);
			t1 = space();
			create_component(br.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			h2 = claim_element(nodes, "H2", { class: true });
			var h2_nodes = children(h2);
			t0 = claim_text(h2_nodes, /*label*/ ctx[2]);
			h2_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			claim_component(br.$$.fragment, nodes);
			this.h();
		},
		h: function hydrate() {
			attr_dev(h2, "class", "text-left");
			add_location(h2, file$Y, 59, 4, 1961);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h2, anchor);
			append_dev(h2, t0);
			insert_dev(target, t1, anchor);
			mount_component(br, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (!current || dirty & /*label*/ 4) set_data_dev(t0, /*label*/ ctx[2]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(br.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h2);
			if (detaching) detach_dev(t1);
			destroy_component(br, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$f.name,
		type: "if",
		source: "(59:0) {#if label}",
		ctx
	});

	return block;
}

// (63:0) <Square class={$$props.class} style={styleProp}>
function create_default_slot$E(ctx) {
	let input;
	let t0;
	let label_1;
	let div0;
	let picture;
	let t1;
	let div1;
	let icon_1;
	let label_1_class_value;
	let current;
	let mounted;
	let dispose;

	picture = new Picture({
			props: {
				src: /*validSrc*/ ctx[6],
				alt: "Завантажене фото"
			},
			$$inline: true
		});

	icon_1 = new Icon({
			props: {
				type: /*iconType*/ ctx[7],
				is: /*iconIs*/ ctx[3]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			input = element("input");
			t0 = space();
			label_1 = element("label");
			div0 = element("div");
			create_component(picture.$$.fragment);
			t1 = space();
			div1 = element("div");
			create_component(icon_1.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			input = claim_element(nodes, "INPUT", {
				name: true,
				accept: true,
				multiple: true,
				hidden: true,
				type: true,
				id: true
			});

			t0 = claim_space(nodes);
			label_1 = claim_element(nodes, "LABEL", { for: true, class: true });
			var label_1_nodes = children(label_1);
			div0 = claim_element(label_1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			claim_component(picture.$$.fragment, div0_nodes);
			div0_nodes.forEach(detach_dev);
			t1 = claim_space(label_1_nodes);
			div1 = claim_element(label_1_nodes, "DIV", { class: true, style: true });
			var div1_nodes = children(div1);
			claim_component(icon_1.$$.fragment, div1_nodes);
			div1_nodes.forEach(detach_dev);
			label_1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(input, "name", /*name*/ ctx[1]);
			attr_dev(input, "accept", /*accept*/ ctx[5]);
			input.multiple = /*multiple*/ ctx[4];
			input.hidden = true;
			attr_dev(input, "type", "file");
			attr_dev(input, "id", /*idProp*/ ctx[8]);
			add_location(input, file$Y, 63, 4, 2075);
			attr_dev(div0, "class", "flex full-absolute");
			add_location(div0, file$Y, 74, 8, 2295);
			attr_dev(div1, "class", "icon flex relative svelte-zm8c1o");
			set_style(div1, "flex", "0 0 75px");
			add_location(div1, file$Y, 77, 8, 2413);
			attr_dev(label_1, "for", /*idProp*/ ctx[8]);
			attr_dev(label_1, "class", label_1_class_value = "" + (null_to_empty(/*classProp*/ ctx[9]) + " svelte-zm8c1o"));
			add_location(label_1, file$Y, 73, 4, 2248);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, label_1, anchor);
			append_dev(label_1, div0);
			mount_component(picture, div0, null);
			append_dev(label_1, t1);
			append_dev(label_1, div1);
			mount_component(icon_1, div1, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(input, "change", /*input_change_handler*/ ctx[21]),
					listen_dev(input, "change", /*onChange*/ ctx[11], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (!current || dirty & /*name*/ 2) {
				attr_dev(input, "name", /*name*/ ctx[1]);
			}

			if (!current || dirty & /*accept*/ 32) {
				attr_dev(input, "accept", /*accept*/ ctx[5]);
			}

			if (!current || dirty & /*multiple*/ 16) {
				prop_dev(input, "multiple", /*multiple*/ ctx[4]);
			}

			if (!current || dirty & /*idProp*/ 256) {
				attr_dev(input, "id", /*idProp*/ ctx[8]);
			}

			const picture_changes = {};
			if (dirty & /*validSrc*/ 64) picture_changes.src = /*validSrc*/ ctx[6];
			picture.$set(picture_changes);
			const icon_1_changes = {};
			if (dirty & /*iconType*/ 128) icon_1_changes.type = /*iconType*/ ctx[7];
			if (dirty & /*iconIs*/ 8) icon_1_changes.is = /*iconIs*/ ctx[3];
			icon_1.$set(icon_1_changes);

			if (!current || dirty & /*idProp*/ 256) {
				attr_dev(label_1, "for", /*idProp*/ ctx[8]);
			}

			if (!current || dirty & /*classProp*/ 512 && label_1_class_value !== (label_1_class_value = "" + (null_to_empty(/*classProp*/ ctx[9]) + " svelte-zm8c1o"))) {
				attr_dev(label_1, "class", label_1_class_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(picture.$$.fragment, local);
			transition_in(icon_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(picture.$$.fragment, local);
			transition_out(icon_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(label_1);
			destroy_component(picture);
			destroy_component(icon_1);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$E.name,
		type: "slot",
		source: "(63:0) <Square class={$$props.class} style={styleProp}>",
		ctx
	});

	return block;
}

function create_fragment$Y(ctx) {
	let t;
	let square;
	let current;
	let if_block = /*label*/ ctx[2] && create_if_block$f(ctx);

	square = new Square({
			props: {
				class: /*$$props*/ ctx[12].class,
				style: /*styleProp*/ ctx[10],
				$$slots: { default: [create_default_slot$E] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			t = space();
			create_component(square.$$.fragment);
		},
		l: function claim(nodes) {
			if (if_block) if_block.l(nodes);
			t = claim_space(nodes);
			claim_component(square.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, t, anchor);
			mount_component(square, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*label*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*label*/ 4) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$f(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(t.parentNode, t);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			const square_changes = {};
			if (dirty & /*$$props*/ 4096) square_changes.class = /*$$props*/ ctx[12].class;
			if (dirty & /*styleProp*/ 1024) square_changes.style = /*styleProp*/ ctx[10];

			if (dirty & /*$$scope, idProp, classProp, iconType, iconIs, validSrc, name, accept, multiple, value*/ 33555451) {
				square_changes.$$scope = { dirty, ctx };
			}

			square.$set(square_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(square.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			transition_out(square.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(t);
			destroy_component(square, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$Y.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$Y($$self, $$props, $$invalidate) {
	const dispatch = createEventDispatcher();
	let { id = undefined } = $$props;
	let { src = undefined } = $$props;
	let { name = undefined } = $$props;
	let { icon = undefined } = $$props;
	let { label = undefined } = $$props;
	let { value = undefined } = $$props;
	let { round = undefined } = $$props;
	let { style = undefined } = $$props;
	let { iconIs = undefined } = $$props;
	let { errors = undefined } = $$props;
	let { invalid = undefined } = $$props;
	let { multiple = undefined } = $$props;
	let { disabled = undefined } = $$props;
	let { accept = "image/png, image/jpeg" } = $$props;
	let validSrc;

	function setValidSrc(file) {
		try {
			if (typeof file === "string") {
				$$invalidate(6, validSrc = file);
			} else if (file) {
				const f = Array.isArray(file) ? file[0] : file;
				const reader = new FileReader();
				reader.onload = e => $$invalidate(6, validSrc = e.target.result);
				reader.readAsDataURL(f); // convert to base64 string
			} else if (!file) {
				$$invalidate(6, validSrc = undefined);
			}
		} catch(err) {
			console.log("UploadBox/getValidSrc error: ", err);
		}
	}

	function onChange(e) {
		const value = Array.from(e.target.files);
		if (!value || !value.length) return;
		dispatch("change", { value, name, e });
	}

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("UploadBox", $$slots, []);

	function input_change_handler() {
		value = this.value;
		$$invalidate(0, value);
	}

	$$self.$set = $$new_props => {
		$$invalidate(12, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("id" in $$new_props) $$invalidate(13, id = $$new_props.id);
		if ("src" in $$new_props) $$invalidate(14, src = $$new_props.src);
		if ("name" in $$new_props) $$invalidate(1, name = $$new_props.name);
		if ("icon" in $$new_props) $$invalidate(15, icon = $$new_props.icon);
		if ("label" in $$new_props) $$invalidate(2, label = $$new_props.label);
		if ("value" in $$new_props) $$invalidate(0, value = $$new_props.value);
		if ("round" in $$new_props) $$invalidate(16, round = $$new_props.round);
		if ("style" in $$new_props) $$invalidate(17, style = $$new_props.style);
		if ("iconIs" in $$new_props) $$invalidate(3, iconIs = $$new_props.iconIs);
		if ("errors" in $$new_props) $$invalidate(18, errors = $$new_props.errors);
		if ("invalid" in $$new_props) $$invalidate(19, invalid = $$new_props.invalid);
		if ("multiple" in $$new_props) $$invalidate(4, multiple = $$new_props.multiple);
		if ("disabled" in $$new_props) $$invalidate(20, disabled = $$new_props.disabled);
		if ("accept" in $$new_props) $$invalidate(5, accept = $$new_props.accept);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		classnames,
		toCSSString,
		Br,
		Icon,
		Square,
		Picture,
		dispatch,
		id,
		src,
		name,
		icon,
		label,
		value,
		round,
		style,
		iconIs,
		errors,
		invalid,
		multiple,
		disabled,
		accept,
		validSrc,
		setValidSrc,
		onChange,
		error,
		iconType,
		idProp,
		classProp,
		styleProp
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(12, $$props = assign(assign({}, $$props), $$new_props));
		if ("id" in $$props) $$invalidate(13, id = $$new_props.id);
		if ("src" in $$props) $$invalidate(14, src = $$new_props.src);
		if ("name" in $$props) $$invalidate(1, name = $$new_props.name);
		if ("icon" in $$props) $$invalidate(15, icon = $$new_props.icon);
		if ("label" in $$props) $$invalidate(2, label = $$new_props.label);
		if ("value" in $$props) $$invalidate(0, value = $$new_props.value);
		if ("round" in $$props) $$invalidate(16, round = $$new_props.round);
		if ("style" in $$props) $$invalidate(17, style = $$new_props.style);
		if ("iconIs" in $$props) $$invalidate(3, iconIs = $$new_props.iconIs);
		if ("errors" in $$props) $$invalidate(18, errors = $$new_props.errors);
		if ("invalid" in $$props) $$invalidate(19, invalid = $$new_props.invalid);
		if ("multiple" in $$props) $$invalidate(4, multiple = $$new_props.multiple);
		if ("disabled" in $$props) $$invalidate(20, disabled = $$new_props.disabled);
		if ("accept" in $$props) $$invalidate(5, accept = $$new_props.accept);
		if ("validSrc" in $$props) $$invalidate(6, validSrc = $$new_props.validSrc);
		if ("error" in $$props) $$invalidate(22, error = $$new_props.error);
		if ("iconType" in $$props) $$invalidate(7, iconType = $$new_props.iconType);
		if ("idProp" in $$props) $$invalidate(8, idProp = $$new_props.idProp);
		if ("classProp" in $$props) $$invalidate(9, classProp = $$new_props.classProp);
		if ("styleProp" in $$props) $$invalidate(10, styleProp = $$new_props.styleProp);
	};

	let error;
	let iconType;
	let idProp;
	let classProp;
	let styleProp;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*invalid, errors*/ 786432) {
			 $$invalidate(22, error = invalid !== undefined
			? invalid
			: !!(errors || []).length);
		}

		if ($$self.$$.dirty & /*icon*/ 32768) {
			 $$invalidate(7, iconType = icon || "upload");
		}

		if ($$self.$$.dirty & /*id, name*/ 8194) {
			 $$invalidate(8, idProp = id || name);
		}

		if ($$self.$$.dirty & /*src*/ 16384) {
			 setValidSrc(src);
		}

		if ($$self.$$.dirty & /*error, disabled, src*/ 5259264) {
			 $$invalidate(9, classProp = classnames("inp-upload", { error, disabled, preview: src }));
		}

		if ($$self.$$.dirty & /*style, round*/ 196608) {
			 $$invalidate(10, styleProp = toCSSString({
				...style,
				borderRadius: round ? "50%" : null
			}));
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		value,
		name,
		label,
		iconIs,
		multiple,
		accept,
		validSrc,
		iconType,
		idProp,
		classProp,
		styleProp,
		onChange,
		$$props,
		id,
		src,
		icon,
		round,
		style,
		errors,
		invalid,
		disabled,
		input_change_handler
	];
}

class UploadBox extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document.getElementById("svelte-zm8c1o-style")) add_css$j();

		init(this, options, instance$Y, create_fragment$Y, safe_not_equal, {
			id: 13,
			src: 14,
			name: 1,
			icon: 15,
			label: 2,
			value: 0,
			round: 16,
			style: 17,
			iconIs: 3,
			errors: 18,
			invalid: 19,
			multiple: 4,
			disabled: 20,
			accept: 5
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "UploadBox",
			options,
			id: create_fragment$Y.name
		});
	}

	get id() {
		throw new Error("<UploadBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<UploadBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get src() {
		throw new Error("<UploadBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set src(value) {
		throw new Error("<UploadBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get name() {
		throw new Error("<UploadBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set name(value) {
		throw new Error("<UploadBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get icon() {
		throw new Error("<UploadBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set icon(value) {
		throw new Error("<UploadBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get label() {
		throw new Error("<UploadBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set label(value) {
		throw new Error("<UploadBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<UploadBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<UploadBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get round() {
		throw new Error("<UploadBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set round(value) {
		throw new Error("<UploadBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<UploadBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<UploadBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get iconIs() {
		throw new Error("<UploadBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set iconIs(value) {
		throw new Error("<UploadBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get errors() {
		throw new Error("<UploadBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set errors(value) {
		throw new Error("<UploadBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get invalid() {
		throw new Error("<UploadBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set invalid(value) {
		throw new Error("<UploadBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get multiple() {
		throw new Error("<UploadBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set multiple(value) {
		throw new Error("<UploadBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<UploadBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<UploadBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get accept() {
		throw new Error("<UploadBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set accept(value) {
		throw new Error("<UploadBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/fields/uploadFiles/UploadBoxGroup.svelte generated by Svelte v3.24.0 */
const file$Z = "src/components/fields/uploadFiles/UploadBoxGroup.svelte";

function add_css$k() {
	var style = element("style");
	style.id = "svelte-1he43cw-style";
	style.textContent = "ul.svelte-1he43cw{width:100%;display:grid;grid-template:auto / .5fr .5fr;grid-gap:var(--screen-padding)}ul.disabled.svelte-1he43cw{opacity:.5;pointer-events:none}button.svelte-1he43cw{position:absolute;top:0;right:0;font-size:24px;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;width:40px;height:40px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVXBsb2FkQm94R3JvdXAuc3ZlbHRlIiwic291cmNlcyI6WyJVcGxvYWRCb3hHcm91cC5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBjcmVhdGVFdmVudERpc3BhdGNoZXIgfSBmcm9tICdzdmVsdGUnXG4gICAgaW1wb3J0IHsgXywgY2xhc3NuYW1lcyB9IGZyb20gJ0B1dGlscydcbiAgICBpbXBvcnQgQnIgZnJvbSAnQGNvbXBvbmVudHMvQnIuc3ZlbHRlJ1xuICAgIGltcG9ydCBJY29uIGZyb20gJ0Bjb21wb25lbnRzL0ljb24uc3ZlbHRlJ1xuICAgIGltcG9ydCBVcGxvYWRCb3ggZnJvbSAnLi9VcGxvYWRCb3guc3ZlbHRlJ1xuXG4gICAgY29uc3QgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXIoKVxuXG4gICAgZXhwb3J0IGxldCBuYW1lXG4gICAgZXhwb3J0IGxldCBpZCA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgbGFiZWwgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IHZhbHVlID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCBhY2NlcHQgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IGVycm9ycyA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgaW52YWxpZCA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgbXVsdGlwbGUgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IGRpc2FibGVkID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCBpbmZvSW5kZXggPSBbMF1cblxuICAgIGNvbnN0IEJPWF9BTU9VTlQgPSA0XG5cbiAgICAkOiB2YWx1ZXMgPSB2YWx1ZSB8fCBbXVxuICAgICQ6IGVycm9yID0gaW52YWxpZCAhPT0gdW5kZWZpbmVkID8gaW52YWxpZCA6ICEhKGVycm9ycyB8fCBbXSkubGVuZ3RoXG4gICAgJDogaWRQcm9wID0gaWQgfHwgbmFtZVxuICAgICQ6IGl0ZW1zTGlzdCA9IGdldENlbGxzKHZhbHVlcylcbiAgICAkOiBjbGFzc1Byb3AgPSBjbGFzc25hbWVzKCdpbnAtdXBsb2FkLWdyb3VwJywgJCRwcm9wcy5jbGFzcywgeyBlcnJvciwgZGlzYWJsZWQgfSlcblxuICAgIGZ1bmN0aW9uIGdldENlbGxzKGxpc3QpIHtcbiAgICAgICAgY29uc3QgZGVmYXVsdExpc3QgPSBuZXcgQXJyYXkoQk9YX0FNT1VOVCAtIDEpLmZpbGwodW5kZWZpbmVkKVxuICAgICAgICBjb25zdCBsaXN0QXJyID0gW10uY29uY2F0KGxpc3QgfHwgW10pXG4gICAgICAgIGNvbnN0IGJpZ2dlckxpc3QgPSBsaXN0QXJyLmxlbmd0aCA+IGRlZmF1bHRMaXN0Lmxlbmd0aCA/IGxpc3RBcnIgOiBkZWZhdWx0TGlzdFxuICAgICAgICBiaWdnZXJMaXN0LnB1c2godW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gYmlnZ2VyTGlzdC5tYXAoKChfLCBpKSA9PiBsaXN0QXJyW2ldIHx8IGRlZmF1bHRMaXN0W2ldKSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkNoYW5nZShpLCB7IGRldGFpbDogeyBlLCB2YWx1ZSB9IH0pIHtcbiAgICAgICAgY29uc3QgdmFsID0gWy4uLnZhbHVlc11cbiAgICAgICAgdmFsLnNwbGljZShpLCAwLCAuLi52YWx1ZSlcbiAgICAgICAgdmFsdWVzID0gdmFsXG4gICAgICAgIGRpc3BhdGNoKCdjaGFuZ2UnLCB7IGUsIG5hbWUsIHZhbHVlOiB2YWx1ZXMgfSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvblJlbW92ZShpLCBlKSB7XG4gICAgICAgIHZhbHVlcyA9IFsuLi52YWx1ZXMuZmlsdGVyKChfLCBpbmQpID0+IGluZCAhPT0gaSldXG4gICAgICAgIGRpc3BhdGNoKCdjaGFuZ2UnLCB7IGUsIG5hbWUsIHZhbHVlOiB2YWx1ZXMgfSlcbiAgICB9XG48L3NjcmlwdD5cblxueyNpZiBsYWJlbH1cbiAgICA8aDIgY2xhc3M9XCJ0ZXh0LWxlZnRcIj57bGFiZWx9PC9oMj5cbiAgICA8QnIgc2l6ZT1cIjEwXCIvPlxuey9pZn1cbjx1bCBpZD17aWRQcm9wfSBjbGFzcz17Y2xhc3NQcm9wfT5cbiAgICB7I2VhY2ggaXRlbXNMaXN0IGFzIGl0ZW0sIGl9XG4gICAgICAgIDxsaSBjbGFzcz1cInJlbGF0aXZlXCI+XG4gICAgICAgICAgICA8VXBsb2FkQm94XG4gICAgICAgICAgICAgICAga2V5PXtpfVxuICAgICAgICAgICAgICAgIHthY2NlcHR9XG4gICAgICAgICAgICAgICAge2ludmFsaWR9XG4gICAgICAgICAgICAgICAge2Rpc2FibGVkfVxuICAgICAgICAgICAgICAgIHttdWx0aXBsZX1cbiAgICAgICAgICAgICAgICBuYW1lPXtgJHtuYW1lIHx8ICcnfVske2l9XWB9XG4gICAgICAgICAgICAgICAgc3JjPXsodmFsdWVzW2ldIHx8IHt9KS5zcmMgfHwgdmFsdWVzW2ldfVxuICAgICAgICAgICAgICAgIGVycm9ycz17Xy5nZXQoZXJyb3JzLCBpKX1cbiAgICAgICAgICAgICAgICBzdHlsZT17eyBtYXhIZWlnaHQ6ICcxNjBweCcgfX1cbiAgICAgICAgICAgICAgICBpY29uSXM9e2luZm9JbmRleC5pbmNsdWRlcyhpKSA/ICdpbmZvJyA6IHVuZGVmaW5lZH1cbiAgICAgICAgICAgICAgICBvbjpjaGFuZ2U9e29uQ2hhbmdlLmJpbmQobnVsbCwgaSl9XG4gICAgICAgICAgICAvPlxuXG4gICAgICAgICAgICB7I2lmIHZhbHVlc1tpXX1cbiAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBvbjpjbGljaz17b25SZW1vdmUuYmluZChudWxsLCBpKX0+XG4gICAgICAgICAgICAgICAgICAgIDxJY29uIHNpemU9XCJiaWdcIiB0eXBlPVwiY2xvc2VcIi8+ICAgIFxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgey9pZn1cbiAgICAgICAgPC9saT5cbiAgICB7L2VhY2h9XG48L3VsPlxuXG48c3R5bGU+XG51bCB7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgZGlzcGxheTogZ3JpZDtcbiAgICBncmlkLXRlbXBsYXRlOiBhdXRvIC8gLjVmciAuNWZyO1xuICAgIGdyaWQtZ2FwOiB2YXIoLS1zY3JlZW4tcGFkZGluZyk7XG59XG5cbnVsLmRpc2FibGVkIHtcbiAgICBvcGFjaXR5OiAuNTtcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbn1cblxuYnV0dG9uIHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgdG9wOiAwO1xuICAgIHJpZ2h0OiAwO1xuICAgIGZvbnQtc2l6ZTogMjRweDtcbiAgICBkaXNwbGF5OiAtd2Via2l0LWJveDtcbiAgICBkaXNwbGF5OiAtbXMtZmxleGJveDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIC13ZWJraXQtYm94LWFsaWduOiBjZW50ZXI7XG4gICAgICAgIC1tcy1mbGV4LWFsaWduOiBjZW50ZXI7XG4gICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIC13ZWJraXQtYm94LXBhY2s6IGNlbnRlcjtcbiAgICAgICAgLW1zLWZsZXgtcGFjazogY2VudGVyO1xuICAgICAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgd2lkdGg6IDQwcHg7XG4gICAgaGVpZ2h0OiA0MHB4O1xufTwvc3R5bGU+XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBZ0ZBLEVBQUUsZUFBQyxDQUFDLEFBQ0EsS0FBSyxDQUFFLElBQUksQ0FDWCxPQUFPLENBQUUsSUFBSSxDQUNiLGFBQWEsQ0FBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQy9CLFFBQVEsQ0FBRSxJQUFJLGdCQUFnQixDQUFDLEFBQ25DLENBQUMsQUFFRCxFQUFFLFNBQVMsZUFBQyxDQUFDLEFBQ1QsT0FBTyxDQUFFLEVBQUUsQ0FDWCxjQUFjLENBQUUsSUFBSSxBQUN4QixDQUFDLEFBRUQsTUFBTSxlQUFDLENBQUMsQUFDSixRQUFRLENBQUUsUUFBUSxDQUNsQixHQUFHLENBQUUsQ0FBQyxDQUNOLEtBQUssQ0FBRSxDQUFDLENBQ1IsU0FBUyxDQUFFLElBQUksQ0FDZixPQUFPLENBQUUsV0FBVyxDQUNwQixPQUFPLENBQUUsV0FBVyxDQUNwQixPQUFPLENBQUUsSUFBSSxDQUNiLGlCQUFpQixDQUFFLE1BQU0sQ0FDckIsY0FBYyxDQUFFLE1BQU0sQ0FDbEIsV0FBVyxDQUFFLE1BQU0sQ0FDM0IsZ0JBQWdCLENBQUUsTUFBTSxDQUNwQixhQUFhLENBQUUsTUFBTSxDQUNqQixlQUFlLENBQUUsTUFBTSxDQUMvQixLQUFLLENBQUUsSUFBSSxDQUNYLE1BQU0sQ0FBRSxJQUFJLEFBQ2hCLENBQUMifQ== */";
	append_dev(document.head, style);
}

function get_each_context$4(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[19] = list[i];
	child_ctx[21] = i;
	return child_ctx;
}

// (50:0) {#if label}
function create_if_block_1$9(ctx) {
	let h2;
	let t0;
	let t1;
	let br;
	let current;
	br = new Br({ props: { size: "10" }, $$inline: true });

	const block = {
		c: function create() {
			h2 = element("h2");
			t0 = text(/*label*/ ctx[1]);
			t1 = space();
			create_component(br.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			h2 = claim_element(nodes, "H2", { class: true });
			var h2_nodes = children(h2);
			t0 = claim_text(h2_nodes, /*label*/ ctx[1]);
			h2_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			claim_component(br.$$.fragment, nodes);
			this.h();
		},
		h: function hydrate() {
			attr_dev(h2, "class", "text-left");
			add_location(h2, file$Z, 50, 4, 1614);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h2, anchor);
			append_dev(h2, t0);
			insert_dev(target, t1, anchor);
			mount_component(br, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (!current || dirty & /*label*/ 2) set_data_dev(t0, /*label*/ ctx[1]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(br.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h2);
			if (detaching) detach_dev(t1);
			destroy_component(br, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$9.name,
		type: "if",
		source: "(50:0) {#if label}",
		ctx
	});

	return block;
}

// (71:12) {#if values[i]}
function create_if_block$g(ctx) {
	let button;
	let icon;
	let current;
	let mounted;
	let dispose;

	icon = new Icon({
			props: { size: "big", type: "close" },
			$$inline: true
		});

	const block = {
		c: function create() {
			button = element("button");
			create_component(icon.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", { type: true, class: true });
			var button_nodes = children(button);
			claim_component(icon.$$.fragment, button_nodes);
			button_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(button, "type", "button");
			attr_dev(button, "class", "svelte-1he43cw");
			add_location(button, file$Z, 71, 16, 2295);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			mount_component(icon, button, null);
			current = true;

			if (!mounted) {
				dispose = listen_dev(button, "click", /*onRemove*/ ctx[13].bind(null, /*i*/ ctx[21]), false, false, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			destroy_component(icon);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$g.name,
		type: "if",
		source: "(71:12) {#if values[i]}",
		ctx
	});

	return block;
}

// (55:4) {#each itemsList as item, i}
function create_each_block$4(ctx) {
	let li;
	let uploadbox;
	let t0;
	let t1;
	let current;

	uploadbox = new UploadBox({
			props: {
				key: /*i*/ ctx[21],
				accept: /*accept*/ ctx[2],
				invalid: /*invalid*/ ctx[4],
				disabled: /*disabled*/ ctx[6],
				multiple: /*multiple*/ ctx[5],
				name: `${/*name*/ ctx[0] || ""}[${/*i*/ ctx[21]}]`,
				src: (/*values*/ ctx[8][/*i*/ ctx[21]] || {}).src || /*values*/ ctx[8][/*i*/ ctx[21]],
				errors: get(/*errors*/ ctx[3], /*i*/ ctx[21]),
				style: { maxHeight: "160px" },
				iconIs: /*infoIndex*/ ctx[7].includes(/*i*/ ctx[21])
				? "info"
				: undefined
			},
			$$inline: true
		});

	uploadbox.$on("change", /*onChange*/ ctx[12].bind(null, /*i*/ ctx[21]));
	let if_block = /*values*/ ctx[8][/*i*/ ctx[21]] && create_if_block$g(ctx);

	const block = {
		c: function create() {
			li = element("li");
			create_component(uploadbox.$$.fragment);
			t0 = space();
			if (if_block) if_block.c();
			t1 = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true });
			var li_nodes = children(li);
			claim_component(uploadbox.$$.fragment, li_nodes);
			t0 = claim_space(li_nodes);
			if (if_block) if_block.l(li_nodes);
			t1 = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(li, "class", "relative");
			add_location(li, file$Z, 55, 8, 1751);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			mount_component(uploadbox, li, null);
			append_dev(li, t0);
			if (if_block) if_block.m(li, null);
			append_dev(li, t1);
			current = true;
		},
		p: function update(ctx, dirty) {
			const uploadbox_changes = {};
			if (dirty & /*accept*/ 4) uploadbox_changes.accept = /*accept*/ ctx[2];
			if (dirty & /*invalid*/ 16) uploadbox_changes.invalid = /*invalid*/ ctx[4];
			if (dirty & /*disabled*/ 64) uploadbox_changes.disabled = /*disabled*/ ctx[6];
			if (dirty & /*multiple*/ 32) uploadbox_changes.multiple = /*multiple*/ ctx[5];
			if (dirty & /*name*/ 1) uploadbox_changes.name = `${/*name*/ ctx[0] || ""}[${/*i*/ ctx[21]}]`;
			if (dirty & /*values*/ 256) uploadbox_changes.src = (/*values*/ ctx[8][/*i*/ ctx[21]] || {}).src || /*values*/ ctx[8][/*i*/ ctx[21]];
			if (dirty & /*errors*/ 8) uploadbox_changes.errors = get(/*errors*/ ctx[3], /*i*/ ctx[21]);

			if (dirty & /*infoIndex*/ 128) uploadbox_changes.iconIs = /*infoIndex*/ ctx[7].includes(/*i*/ ctx[21])
			? "info"
			: undefined;

			uploadbox.$set(uploadbox_changes);

			if (/*values*/ ctx[8][/*i*/ ctx[21]]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*values*/ 256) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$g(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(li, t1);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(uploadbox.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(uploadbox.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			destroy_component(uploadbox);
			if (if_block) if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$4.name,
		type: "each",
		source: "(55:4) {#each itemsList as item, i}",
		ctx
	});

	return block;
}

function create_fragment$Z(ctx) {
	let t;
	let ul;
	let ul_class_value;
	let current;
	let if_block = /*label*/ ctx[1] && create_if_block_1$9(ctx);
	let each_value = /*itemsList*/ ctx[10];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			t = space();
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			if (if_block) if_block.l(nodes);
			t = claim_space(nodes);
			ul = claim_element(nodes, "UL", { id: true, class: true });
			var ul_nodes = children(ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(ul_nodes);
			}

			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(ul, "id", /*idProp*/ ctx[9]);
			attr_dev(ul, "class", ul_class_value = "" + (null_to_empty(/*classProp*/ ctx[11]) + " svelte-1he43cw"));
			add_location(ul, file$Z, 53, 0, 1675);
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, t, anchor);
			insert_dev(target, ul, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*label*/ ctx[1]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*label*/ 2) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_1$9(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(t.parentNode, t);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (dirty & /*onRemove, values, accept, invalid, disabled, multiple, name, _, errors, infoIndex, undefined, onChange, itemsList*/ 13821) {
				each_value = /*itemsList*/ ctx[10];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$4(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$4(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(ul, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}

			if (!current || dirty & /*idProp*/ 512) {
				attr_dev(ul, "id", /*idProp*/ ctx[9]);
			}

			if (!current || dirty & /*classProp*/ 2048 && ul_class_value !== (ul_class_value = "" + (null_to_empty(/*classProp*/ ctx[11]) + " svelte-1he43cw"))) {
				attr_dev(ul, "class", ul_class_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(t);
			if (detaching) detach_dev(ul);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$Z.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const BOX_AMOUNT = 4;

function getCells(list) {
	const defaultList = new Array(BOX_AMOUNT - 1).fill(undefined);
	const listArr = [].concat(list || []);

	const biggerList = listArr.length > defaultList.length
	? listArr
	: defaultList;

	biggerList.push(undefined);
	return biggerList.map((_, i) => listArr[i] || defaultList[i]);
}

function instance$Z($$self, $$props, $$invalidate) {
	const dispatch = createEventDispatcher();
	let { name } = $$props;
	let { id = undefined } = $$props;
	let { label = undefined } = $$props;
	let { value = undefined } = $$props;
	let { accept = undefined } = $$props;
	let { errors = undefined } = $$props;
	let { invalid = undefined } = $$props;
	let { multiple = undefined } = $$props;
	let { disabled = undefined } = $$props;
	let { infoIndex = [0] } = $$props;

	function onChange(i, { detail: { e, value } }) {
		const val = [...values];
		val.splice(i, 0, ...value);
		$$invalidate(8, values = val);
		dispatch("change", { e, name, value: values });
	}

	function onRemove(i, e) {
		$$invalidate(8, values = [...values.filter((_, ind) => ind !== i)]);
		dispatch("change", { e, name, value: values });
	}

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("UploadBoxGroup", $$slots, []);

	$$self.$set = $$new_props => {
		$$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("name" in $$new_props) $$invalidate(0, name = $$new_props.name);
		if ("id" in $$new_props) $$invalidate(14, id = $$new_props.id);
		if ("label" in $$new_props) $$invalidate(1, label = $$new_props.label);
		if ("value" in $$new_props) $$invalidate(15, value = $$new_props.value);
		if ("accept" in $$new_props) $$invalidate(2, accept = $$new_props.accept);
		if ("errors" in $$new_props) $$invalidate(3, errors = $$new_props.errors);
		if ("invalid" in $$new_props) $$invalidate(4, invalid = $$new_props.invalid);
		if ("multiple" in $$new_props) $$invalidate(5, multiple = $$new_props.multiple);
		if ("disabled" in $$new_props) $$invalidate(6, disabled = $$new_props.disabled);
		if ("infoIndex" in $$new_props) $$invalidate(7, infoIndex = $$new_props.infoIndex);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		_,
		classnames,
		Br,
		Icon,
		UploadBox,
		dispatch,
		name,
		id,
		label,
		value,
		accept,
		errors,
		invalid,
		multiple,
		disabled,
		infoIndex,
		BOX_AMOUNT,
		getCells,
		onChange,
		onRemove,
		values,
		error,
		idProp,
		itemsList,
		classProp
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(18, $$props = assign(assign({}, $$props), $$new_props));
		if ("name" in $$props) $$invalidate(0, name = $$new_props.name);
		if ("id" in $$props) $$invalidate(14, id = $$new_props.id);
		if ("label" in $$props) $$invalidate(1, label = $$new_props.label);
		if ("value" in $$props) $$invalidate(15, value = $$new_props.value);
		if ("accept" in $$props) $$invalidate(2, accept = $$new_props.accept);
		if ("errors" in $$props) $$invalidate(3, errors = $$new_props.errors);
		if ("invalid" in $$props) $$invalidate(4, invalid = $$new_props.invalid);
		if ("multiple" in $$props) $$invalidate(5, multiple = $$new_props.multiple);
		if ("disabled" in $$props) $$invalidate(6, disabled = $$new_props.disabled);
		if ("infoIndex" in $$props) $$invalidate(7, infoIndex = $$new_props.infoIndex);
		if ("values" in $$props) $$invalidate(8, values = $$new_props.values);
		if ("error" in $$props) $$invalidate(16, error = $$new_props.error);
		if ("idProp" in $$props) $$invalidate(9, idProp = $$new_props.idProp);
		if ("itemsList" in $$props) $$invalidate(10, itemsList = $$new_props.itemsList);
		if ("classProp" in $$props) $$invalidate(11, classProp = $$new_props.classProp);
	};

	let values;
	let error;
	let idProp;
	let itemsList;
	let classProp;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*value*/ 32768) {
			 $$invalidate(8, values = value || []);
		}

		if ($$self.$$.dirty & /*invalid, errors*/ 24) {
			 $$invalidate(16, error = invalid !== undefined
			? invalid
			: !!(errors || []).length);
		}

		if ($$self.$$.dirty & /*id, name*/ 16385) {
			 $$invalidate(9, idProp = id || name);
		}

		if ($$self.$$.dirty & /*values*/ 256) {
			 $$invalidate(10, itemsList = getCells(values));
		}

		 $$invalidate(11, classProp = classnames("inp-upload-group", $$props.class, { error, disabled }));
	};

	$$props = exclude_internal_props($$props);

	return [
		name,
		label,
		accept,
		errors,
		invalid,
		multiple,
		disabled,
		infoIndex,
		values,
		idProp,
		itemsList,
		classProp,
		onChange,
		onRemove,
		id,
		value
	];
}

class UploadBoxGroup extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document.getElementById("svelte-1he43cw-style")) add_css$k();

		init(this, options, instance$Z, create_fragment$Z, safe_not_equal, {
			name: 0,
			id: 14,
			label: 1,
			value: 15,
			accept: 2,
			errors: 3,
			invalid: 4,
			multiple: 5,
			disabled: 6,
			infoIndex: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "UploadBoxGroup",
			options,
			id: create_fragment$Z.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*name*/ ctx[0] === undefined && !("name" in props)) {
			console.warn("<UploadBoxGroup> was created without expected prop 'name'");
		}
	}

	get name() {
		throw new Error("<UploadBoxGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set name(value) {
		throw new Error("<UploadBoxGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get id() {
		throw new Error("<UploadBoxGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<UploadBoxGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get label() {
		throw new Error("<UploadBoxGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set label(value) {
		throw new Error("<UploadBoxGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<UploadBoxGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<UploadBoxGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get accept() {
		throw new Error("<UploadBoxGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set accept(value) {
		throw new Error("<UploadBoxGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get errors() {
		throw new Error("<UploadBoxGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set errors(value) {
		throw new Error("<UploadBoxGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get invalid() {
		throw new Error("<UploadBoxGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set invalid(value) {
		throw new Error("<UploadBoxGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get multiple() {
		throw new Error("<UploadBoxGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set multiple(value) {
		throw new Error("<UploadBoxGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<UploadBoxGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<UploadBoxGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get infoIndex() {
		throw new Error("<UploadBoxGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set infoIndex(value) {
		throw new Error("<UploadBoxGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/fields/AvatarUpload.svelte generated by Svelte v3.24.0 */
const file$_ = "src/components/fields/AvatarUpload.svelte";

// (32:4) {#if label}
function create_if_block$h(ctx) {
	let h2;
	let t0;
	let t1;
	let br;
	let current;
	br = new Br({ props: { size: "10" }, $$inline: true });

	const block = {
		c: function create() {
			h2 = element("h2");
			t0 = text(/*label*/ ctx[4]);
			t1 = space();
			create_component(br.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			h2 = claim_element(nodes, "H2", { class: true });
			var h2_nodes = children(h2);
			t0 = claim_text(h2_nodes, /*label*/ ctx[4]);
			t1 = claim_space(h2_nodes);
			claim_component(br.$$.fragment, h2_nodes);
			h2_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(h2, "class", "text-left");
			add_location(h2, file$_, 32, 8, 1025);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h2, anchor);
			append_dev(h2, t0);
			append_dev(h2, t1);
			mount_component(br, h2, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (!current || dirty & /*label*/ 16) set_data_dev(t0, /*label*/ ctx[4]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(br.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h2);
			destroy_component(br);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$h.name,
		type: "if",
		source: "(32:4) {#if label}",
		ctx
	});

	return block;
}

function create_fragment$_(ctx) {
	let div1;
	let t0;
	let section;
	let uploadbox;
	let t1;
	let div0;
	let fielderrors;
	let current;
	let if_block = /*label*/ ctx[4] && create_if_block$h(ctx);

	uploadbox = new UploadBox({
			props: {
				name: /*name*/ ctx[0],
				round: /*round*/ ctx[1],
				src: /*value*/ ctx[3],
				style: /*styleProp*/ ctx[6]
			},
			$$inline: true
		});

	uploadbox.$on("change", /*onChange*/ ctx[8]);

	fielderrors = new FieldErrors({
			props: { items: /*errors*/ ctx[5] },
			$$inline: true
		});

	const block = {
		c: function create() {
			div1 = element("div");
			if (if_block) if_block.c();
			t0 = space();
			section = element("section");
			create_component(uploadbox.$$.fragment);
			t1 = space();
			div0 = element("div");
			create_component(fielderrors.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", { id: true, class: true });
			var div1_nodes = children(div1);
			if (if_block) if_block.l(div1_nodes);
			t0 = claim_space(div1_nodes);
			section = claim_element(div1_nodes, "SECTION", { class: true, style: true });
			var section_nodes = children(section);
			claim_component(uploadbox.$$.fragment, section_nodes);
			section_nodes.forEach(detach_dev);
			t1 = claim_space(div1_nodes);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			claim_component(fielderrors.$$.fragment, div0_nodes);
			div0_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(section, "class", "inline-flex flex-justify-center");
			set_style(section, "padding", "10px 0");
			add_location(section, file$_, 38, 4, 1127);
			attr_dev(div0, "class", "text-center");
			add_location(div0, file$_, 48, 4, 1381);
			attr_dev(div1, "id", /*id*/ ctx[2]);
			attr_dev(div1, "class", /*classProp*/ ctx[7]);
			add_location(div1, file$_, 30, 0, 972);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			if (if_block) if_block.m(div1, null);
			append_dev(div1, t0);
			append_dev(div1, section);
			mount_component(uploadbox, section, null);
			append_dev(div1, t1);
			append_dev(div1, div0);
			mount_component(fielderrors, div0, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*label*/ ctx[4]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*label*/ 16) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$h(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div1, t0);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			const uploadbox_changes = {};
			if (dirty & /*name*/ 1) uploadbox_changes.name = /*name*/ ctx[0];
			if (dirty & /*round*/ 2) uploadbox_changes.round = /*round*/ ctx[1];
			if (dirty & /*value*/ 8) uploadbox_changes.src = /*value*/ ctx[3];
			if (dirty & /*styleProp*/ 64) uploadbox_changes.style = /*styleProp*/ ctx[6];
			uploadbox.$set(uploadbox_changes);
			const fielderrors_changes = {};
			if (dirty & /*errors*/ 32) fielderrors_changes.items = /*errors*/ ctx[5];
			fielderrors.$set(fielderrors_changes);

			if (!current || dirty & /*id*/ 4) {
				attr_dev(div1, "id", /*id*/ ctx[2]);
			}

			if (!current || dirty & /*classProp*/ 128) {
				attr_dev(div1, "class", /*classProp*/ ctx[7]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(uploadbox.$$.fragment, local);
			transition_in(fielderrors.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			transition_out(uploadbox.$$.fragment, local);
			transition_out(fielderrors.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			if (if_block) if_block.d();
			destroy_component(uploadbox);
			destroy_component(fielderrors);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$_.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$_($$self, $$props, $$invalidate) {
	const dispatch = createEventDispatcher();
	let { name } = $$props;
	let { style = {} } = $$props;
	let { round = true } = $$props;
	let { id = undefined } = $$props;
	let { value = undefined } = $$props;
	let { label = undefined } = $$props;
	let { align = "center" } = $$props;
	let { invalid = undefined } = $$props;
	let { disabled = undefined } = $$props;
	let { required = undefined } = $$props; // undefined|required
	let { errors = undefined } = $$props;

	function onChange({ detail }) {
		dispatch("change", detail);
	}

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("AvatarUpload", $$slots, []);

	$$self.$set = $$new_props => {
		$$invalidate(16, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("name" in $$new_props) $$invalidate(0, name = $$new_props.name);
		if ("style" in $$new_props) $$invalidate(9, style = $$new_props.style);
		if ("round" in $$new_props) $$invalidate(1, round = $$new_props.round);
		if ("id" in $$new_props) $$invalidate(2, id = $$new_props.id);
		if ("value" in $$new_props) $$invalidate(3, value = $$new_props.value);
		if ("label" in $$new_props) $$invalidate(4, label = $$new_props.label);
		if ("align" in $$new_props) $$invalidate(10, align = $$new_props.align);
		if ("invalid" in $$new_props) $$invalidate(11, invalid = $$new_props.invalid);
		if ("disabled" in $$new_props) $$invalidate(12, disabled = $$new_props.disabled);
		if ("required" in $$new_props) $$invalidate(13, required = $$new_props.required);
		if ("errors" in $$new_props) $$invalidate(5, errors = $$new_props.errors);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		classnames,
		toCSSString,
		UploadBox,
		Br,
		FieldErrors,
		dispatch,
		name,
		style,
		round,
		id,
		value,
		label,
		align,
		invalid,
		disabled,
		required,
		errors,
		onChange,
		error,
		styleProp,
		classProp
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(16, $$props = assign(assign({}, $$props), $$new_props));
		if ("name" in $$props) $$invalidate(0, name = $$new_props.name);
		if ("style" in $$props) $$invalidate(9, style = $$new_props.style);
		if ("round" in $$props) $$invalidate(1, round = $$new_props.round);
		if ("id" in $$props) $$invalidate(2, id = $$new_props.id);
		if ("value" in $$props) $$invalidate(3, value = $$new_props.value);
		if ("label" in $$props) $$invalidate(4, label = $$new_props.label);
		if ("align" in $$props) $$invalidate(10, align = $$new_props.align);
		if ("invalid" in $$props) $$invalidate(11, invalid = $$new_props.invalid);
		if ("disabled" in $$props) $$invalidate(12, disabled = $$new_props.disabled);
		if ("required" in $$props) $$invalidate(13, required = $$new_props.required);
		if ("errors" in $$props) $$invalidate(5, errors = $$new_props.errors);
		if ("error" in $$props) $$invalidate(14, error = $$new_props.error);
		if ("styleProp" in $$props) $$invalidate(6, styleProp = $$new_props.styleProp);
		if ("classProp" in $$props) $$invalidate(7, classProp = $$new_props.classProp);
	};

	let error;
	let styleProp;
	let classProp;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*invalid, errors*/ 2080) {
			 $$invalidate(14, error = invalid || !!(errors || []).length);
		}

		if ($$self.$$.dirty & /*style*/ 512) {
			 $$invalidate(6, styleProp = { width: "145px", ...style });
		}

		 $$invalidate(7, classProp = classnames("avatar-upload", $$props.class, `text-${align}`, { disabled, required, error }));
	};

	$$props = exclude_internal_props($$props);

	return [
		name,
		round,
		id,
		value,
		label,
		errors,
		styleProp,
		classProp,
		onChange,
		style,
		align,
		invalid,
		disabled,
		required
	];
}

class AvatarUpload extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$_, create_fragment$_, safe_not_equal, {
			name: 0,
			style: 9,
			round: 1,
			id: 2,
			value: 3,
			label: 4,
			align: 10,
			invalid: 11,
			disabled: 12,
			required: 13,
			errors: 5
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "AvatarUpload",
			options,
			id: create_fragment$_.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*name*/ ctx[0] === undefined && !("name" in props)) {
			console.warn("<AvatarUpload> was created without expected prop 'name'");
		}
	}

	get name() {
		throw new Error("<AvatarUpload>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set name(value) {
		throw new Error("<AvatarUpload>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<AvatarUpload>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<AvatarUpload>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get round() {
		throw new Error("<AvatarUpload>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set round(value) {
		throw new Error("<AvatarUpload>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get id() {
		throw new Error("<AvatarUpload>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<AvatarUpload>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<AvatarUpload>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<AvatarUpload>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get label() {
		throw new Error("<AvatarUpload>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set label(value) {
		throw new Error("<AvatarUpload>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get align() {
		throw new Error("<AvatarUpload>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set align(value) {
		throw new Error("<AvatarUpload>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get invalid() {
		throw new Error("<AvatarUpload>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set invalid(value) {
		throw new Error("<AvatarUpload>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<AvatarUpload>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<AvatarUpload>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get required() {
		throw new Error("<AvatarUpload>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set required(value) {
		throw new Error("<AvatarUpload>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get errors() {
		throw new Error("<AvatarUpload>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set errors(value) {
		throw new Error("<AvatarUpload>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/fields/checkboxes/Checkbox.svelte generated by Svelte v3.24.0 */
const file$$ = "src/components/fields/checkboxes/Checkbox.svelte";

function add_css$l() {
	var style = element("style");
	style.id = "svelte-3bj243-style";
	style.textContent = ".checkbox.svelte-3bj243.svelte-3bj243{display:block}.checkbox.svelte-3bj243 input.svelte-3bj243{-webkit-appearance:checkbox;-moz-appearance:checkbox;appearance:checkbox}.checkbox.svelte-3bj243 .inp-box-wrap.svelte-3bj243{position:relative;display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex}.checkbox .inp-inner:checked+.inp-label.svelte-3bj243.svelte-3bj243 .checked{display:block}.checkbox.svelte-3bj243 .inp-label.svelte-3bj243{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start}.checkbox.svelte-3bj243 .inp-label.svelte-3bj243 .checked{display:none;position:absolute;top:0;left:0;width:100%;height:100%}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2hlY2tib3guc3ZlbHRlIiwic291cmNlcyI6WyJDaGVja2JveC5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBjcmVhdGVFdmVudERpc3BhdGNoZXIgfSBmcm9tICdzdmVsdGUnXG4gICAgaW1wb3J0IHsgY2xhc3NuYW1lcywgdG9DU1NTdHJpbmcgfSBmcm9tICdAdXRpbHMnXG4gICAgaW1wb3J0IEJyIGZyb20gJ0Bjb21wb25lbnRzL0JyLnN2ZWx0ZSdcbiAgICBpbXBvcnQgSWNvbiBmcm9tICdAY29tcG9uZW50cy9JY29uLnN2ZWx0ZSdcbiAgICBpbXBvcnQgRmllbGRFcnJvcnMgZnJvbSAnQGNvbXBvbmVudHMvRmllbGRFcnJvcnMuc3ZlbHRlJ1xuXG4gICAgY29uc3QgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXIoKVxuXG4gICAgZXhwb3J0IGxldCBuYW1lXG4gICAgZXhwb3J0IGxldCBzdHlsZSA9IHt9XG4gICAgZXhwb3J0IGxldCBjaGVja2VkID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCB2YWx1ZSA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgaWQgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IGFsaWduID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCBkaXNhYmxlZCA9IGZhbHNlXG4gICAgZXhwb3J0IGxldCBsYWJlbCA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgdGV4dCA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgaW52YWxpZCA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgZm9ybSA9IHVuZGVmaW5lZCAvLyBTcGVjaWZpZXMgdGhlIGZvcm0gdGhlIDxpbnB1dD4gZWxlbWVudCBiZWxvbmdzIHRvXG4gICAgZXhwb3J0IGxldCByZXF1aXJlZCA9IHVuZGVmaW5lZCAvLyB1bmRlZmluZWR8cmVxdWlyZWRcbiAgICBleHBvcnQgbGV0IGVycm9ycyA9IHVuZGVmaW5lZFxuXG4gICAgJDogaWRQcm9wID0gaWQgfHwgbmFtZSB8fCB2YWx1ZVxuICAgICQ6IGVycm9yID0gaW52YWxpZCB8fCAhIShlcnJvcnMgfHwgW10pLmxlbmd0aFxuICAgICQ6IHN0eWxlUHJvcCA9IHRvQ1NTU3RyaW5nKHsgLi4uc3R5bGUsIHRleHRBbGlnbjogYWxpZ24gfSlcbiAgICAkOiBjbGFzc1Byb3AgPSBjbGFzc25hbWVzKCdjaGVja2JveCcsICQkcHJvcHMuY2xhc3MsIHsgZGlzYWJsZWQsIHJlcXVpcmVkLCBlcnJvciB9KVxuXG4gICAgZnVuY3Rpb24gb25DaGFuZ2UoZSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGdldFZhbHVlKGUpXG4gICAgICAgIGRpc3BhdGNoKCdjaGFuZ2UnLCB7IGUsIG5hbWUsIHZhbHVlLCBjaGVja2VkOiBlLnRhcmdldC5jaGVja2VkIH0pXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0VmFsdWUoZSkge1xuICAgICAgICByZXR1cm4gZS50YXJnZXQudmFsdWVcbiAgICB9XG48L3NjcmlwdD5cblxuPGRpdiBjbGFzcz17Y2xhc3NQcm9wfT5cbiAgICB7I2lmIGxhYmVsfVxuICAgICAgICA8aDIgY2xhc3M9XCJ0ZXh0LWxlZnRcIj5cbiAgICAgICAgICAgIHsgbGFiZWwgfVxuICAgICAgICAgICAgPEJyIHNpemU9XCIxMFwiLz5cbiAgICAgICAgPC9oMj5cbiAgICB7L2lmfVxuXG4gICAgPGlucHV0XG4gICAgICAgICAgICBoaWRkZW5cbiAgICAgICAgICAgIHR5cGU9XCJjaGVja2JveFwiXG4gICAgICAgICAgICBpZD17aWRQcm9wfVxuICAgICAgICAgICAge25hbWV9XG4gICAgICAgICAgICB7Zm9ybX1cbiAgICAgICAgICAgIHthbGlnbn1cbiAgICAgICAgICAgIHt2YWx1ZX1cbiAgICAgICAgICAgIHtjaGVja2VkfVxuICAgICAgICAgICAge2Rpc2FibGVkfVxuICAgICAgICAgICAge3JlcXVpcmVkfVxuICAgICAgICAgICAgY2xhc3M9XCJpbnAtaW5uZXJcIlxuICAgICAgICAgICAgb246Y2hhbmdlPXtvbkNoYW5nZX1cbiAgICA+XG5cbiAgICA8bGFiZWwgZm9yPXtpZFByb3B9IGNsYXNzPVwiaW5wLWxhYmVsXCI+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwiaW5wLWJveC13cmFwXCI+XG4gICAgICAgICAgICA8SWNvbiB0eXBlPVwiYm94XCIgc2l6ZT1cImJpZ1wiIGlzPVwiaW5mb1wiIGNsYXNzPVwidW5jaGVja2VkXCIvPlxuICAgICAgICAgICAgPEljb24gdHlwZT1cImJveC1jaGVja2VkXCIgc2l6ZT1cImJpZ1wiIGlzPVwiaW5mb1wiIGNsYXNzPVwiY2hlY2tlZFwiLz5cbiAgICAgICAgPC9zcGFuPlxuICAgICAgICB7I2lmIHRleHR9XG4gICAgICAgICAgICA8cz48L3M+XG4gICAgICAgICAgICA8cz48L3M+XG4gICAgICAgICAgICA8aDMgY2xhc3M9XCJmb250LXctNTAwIHRleHQtbGVmdFwiIHN0eWxlPVwicGFkZGluZy10b3A6IDRweFwiPnsgdGV4dCB9PC9oMz5cbiAgICAgICAgey9pZn1cbiAgICA8L2xhYmVsPlxuXG4gICAgPEZpZWxkRXJyb3JzIGl0ZW1zPXtlcnJvcnN9PlxuICAgICAgICA8ZGl2IHNsb3Q9XCJiZWZvcmVcIj5cbiAgICAgICAgICAgIDxCciBzaXplPVwiNVwiLz5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9GaWVsZEVycm9ycz5cbjwvZGl2PlxuXG48c3R5bGU+XG4uY2hlY2tib3gge1xuICAgIGRpc3BsYXk6IGJsb2NrO1xufVxuXG4uY2hlY2tib3ggaW5wdXQge1xuICAgIC13ZWJraXQtYXBwZWFyYW5jZTogY2hlY2tib3g7XG4gICAgICAgLW1vei1hcHBlYXJhbmNlOiBjaGVja2JveDtcbiAgICAgICAgICAgIGFwcGVhcmFuY2U6IGNoZWNrYm94O1xufVxuXG4uY2hlY2tib3ggLmlucC1ib3gtd3JhcCB7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIGRpc3BsYXk6IC13ZWJraXQtaW5saW5lLWJveDtcbiAgICBkaXNwbGF5OiAtbXMtaW5saW5lLWZsZXhib3g7XG4gICAgZGlzcGxheTogaW5saW5lLWZsZXg7XG59XG4uY2hlY2tib3ggLmlucC1pbm5lcjpjaGVja2VkICsgLmlucC1sYWJlbCA6Z2xvYmFsKC5jaGVja2VkKSB7XG4gICAgZGlzcGxheTogYmxvY2s7XG59XG5cbi5jaGVja2JveCAuaW5wLWxhYmVsIHtcbiAgICBkaXNwbGF5OiAtd2Via2l0LWJveDtcbiAgICBkaXNwbGF5OiAtbXMtZmxleGJveDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIC13ZWJraXQtYm94LWFsaWduOiBzdGFydDtcbiAgICAgICAgLW1zLWZsZXgtYWxpZ246IHN0YXJ0O1xuICAgICAgICAgICAgYWxpZ24taXRlbXM6IGZsZXgtc3RhcnQ7XG59XG5cbi5jaGVja2JveCAuaW5wLWxhYmVsIDpnbG9iYWwoLmNoZWNrZWQpIHtcbiAgICBkaXNwbGF5OiBub25lO1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB0b3A6IDA7XG4gICAgbGVmdDogMDtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBoZWlnaHQ6IDEwMCU7XG59PC9zdHlsZT5cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFpRkEsU0FBUyw0QkFBQyxDQUFDLEFBQ1AsT0FBTyxDQUFFLEtBQUssQUFDbEIsQ0FBQyxBQUVELHVCQUFTLENBQUMsS0FBSyxjQUFDLENBQUMsQUFDYixrQkFBa0IsQ0FBRSxRQUFRLENBQ3pCLGVBQWUsQ0FBRSxRQUFRLENBQ3BCLFVBQVUsQ0FBRSxRQUFRLEFBQ2hDLENBQUMsQUFFRCx1QkFBUyxDQUFDLGFBQWEsY0FBQyxDQUFDLEFBQ3JCLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLE9BQU8sQ0FBRSxrQkFBa0IsQ0FDM0IsT0FBTyxDQUFFLGtCQUFrQixDQUMzQixPQUFPLENBQUUsV0FBVyxBQUN4QixDQUFDLEFBQ0QsU0FBUyxDQUFDLFVBQVUsUUFBUSxDQUFHLHNDQUFVLENBQUMsQUFBUSxRQUFRLEFBQUUsQ0FBQyxBQUN6RCxPQUFPLENBQUUsS0FBSyxBQUNsQixDQUFDLEFBRUQsdUJBQVMsQ0FBQyxVQUFVLGNBQUMsQ0FBQyxBQUNsQixPQUFPLENBQUUsV0FBVyxDQUNwQixPQUFPLENBQUUsV0FBVyxDQUNwQixPQUFPLENBQUUsSUFBSSxDQUNiLGlCQUFpQixDQUFFLEtBQUssQ0FDcEIsY0FBYyxDQUFFLEtBQUssQ0FDakIsV0FBVyxDQUFFLFVBQVUsQUFDbkMsQ0FBQyxBQUVELHVCQUFTLENBQUMsd0JBQVUsQ0FBQyxBQUFRLFFBQVEsQUFBRSxDQUFDLEFBQ3BDLE9BQU8sQ0FBRSxJQUFJLENBQ2IsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsR0FBRyxDQUFFLENBQUMsQ0FDTixJQUFJLENBQUUsQ0FBQyxDQUNQLEtBQUssQ0FBRSxJQUFJLENBQ1gsTUFBTSxDQUFFLElBQUksQUFDaEIsQ0FBQyJ9 */";
	append_dev(document.head, style);
}

// (40:4) {#if label}
function create_if_block_1$a(ctx) {
	let h2;
	let t0;
	let t1;
	let br;
	let current;
	br = new Br({ props: { size: "10" }, $$inline: true });

	const block = {
		c: function create() {
			h2 = element("h2");
			t0 = text(/*label*/ ctx[5]);
			t1 = space();
			create_component(br.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			h2 = claim_element(nodes, "H2", { class: true });
			var h2_nodes = children(h2);
			t0 = claim_text(h2_nodes, /*label*/ ctx[5]);
			t1 = claim_space(h2_nodes);
			claim_component(br.$$.fragment, h2_nodes);
			h2_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(h2, "class", "text-left");
			add_location(h2, file$$, 40, 8, 1300);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h2, anchor);
			append_dev(h2, t0);
			append_dev(h2, t1);
			mount_component(br, h2, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (!current || dirty & /*label*/ 32) set_data_dev(t0, /*label*/ ctx[5]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(br.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h2);
			destroy_component(br);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$a.name,
		type: "if",
		source: "(40:4) {#if label}",
		ctx
	});

	return block;
}

// (67:8) {#if text}
function create_if_block$i(ctx) {
	let s0;
	let t0;
	let s1;
	let t1;
	let h3;
	let t2;

	const block = {
		c: function create() {
			s0 = element("s");
			t0 = space();
			s1 = element("s");
			t1 = space();
			h3 = element("h3");
			t2 = text(/*text*/ ctx[6]);
			this.h();
		},
		l: function claim(nodes) {
			s0 = claim_element(nodes, "S", {});
			children(s0).forEach(detach_dev);
			t0 = claim_space(nodes);
			s1 = claim_element(nodes, "S", {});
			children(s1).forEach(detach_dev);
			t1 = claim_space(nodes);
			h3 = claim_element(nodes, "H3", { class: true, style: true });
			var h3_nodes = children(h3);
			t2 = claim_text(h3_nodes, /*text*/ ctx[6]);
			h3_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(s0, file$$, 67, 12, 1968);
			add_location(s1, file$$, 68, 12, 1988);
			attr_dev(h3, "class", "font-w-500 text-left");
			set_style(h3, "padding-top", "4px");
			add_location(h3, file$$, 69, 12, 2008);
		},
		m: function mount(target, anchor) {
			insert_dev(target, s0, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, s1, anchor);
			insert_dev(target, t1, anchor);
			insert_dev(target, h3, anchor);
			append_dev(h3, t2);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*text*/ 64) set_data_dev(t2, /*text*/ ctx[6]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(s0);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(s1);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(h3);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$i.name,
		type: "if",
		source: "(67:8) {#if text}",
		ctx
	});

	return block;
}

// (75:8) <div slot="before">
function create_before_slot$1(ctx) {
	let div;
	let br;
	let current;
	br = new Br({ props: { size: "5" }, $$inline: true });

	const block = {
		c: function create() {
			div = element("div");
			create_component(br.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { slot: true });
			var div_nodes = children(div);
			claim_component(br.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "slot", "before");
			add_location(div, file$$, 74, 8, 2149);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(br, div, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(br.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(br);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_before_slot$1.name,
		type: "slot",
		source: "(75:8) <div slot=\\\"before\\\">",
		ctx
	});

	return block;
}

function create_fragment$$(ctx) {
	let div;
	let t0;
	let input;
	let t1;
	let label_1;
	let span;
	let icon0;
	let t2;
	let icon1;
	let t3;
	let t4;
	let fielderrors;
	let div_class_value;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*label*/ ctx[5] && create_if_block_1$a(ctx);

	icon0 = new Icon({
			props: {
				type: "box",
				size: "big",
				is: "info",
				class: "unchecked"
			},
			$$inline: true
		});

	icon1 = new Icon({
			props: {
				type: "box-checked",
				size: "big",
				is: "info",
				class: "checked"
			},
			$$inline: true
		});

	let if_block1 = /*text*/ ctx[6] && create_if_block$i(ctx);

	fielderrors = new FieldErrors({
			props: {
				items: /*errors*/ ctx[9],
				$$slots: { before: [create_before_slot$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			input = element("input");
			t1 = space();
			label_1 = element("label");
			span = element("span");
			create_component(icon0.$$.fragment);
			t2 = space();
			create_component(icon1.$$.fragment);
			t3 = space();
			if (if_block1) if_block1.c();
			t4 = space();
			create_component(fielderrors.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (if_block0) if_block0.l(div_nodes);
			t0 = claim_space(div_nodes);

			input = claim_element(div_nodes, "INPUT", {
				hidden: true,
				type: true,
				id: true,
				name: true,
				form: true,
				align: true,
				value: true,
				checked: true,
				disabled: true,
				required: true,
				class: true
			});

			t1 = claim_space(div_nodes);
			label_1 = claim_element(div_nodes, "LABEL", { for: true, class: true });
			var label_1_nodes = children(label_1);
			span = claim_element(label_1_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			claim_component(icon0.$$.fragment, span_nodes);
			t2 = claim_space(span_nodes);
			claim_component(icon1.$$.fragment, span_nodes);
			span_nodes.forEach(detach_dev);
			t3 = claim_space(label_1_nodes);
			if (if_block1) if_block1.l(label_1_nodes);
			label_1_nodes.forEach(detach_dev);
			t4 = claim_space(div_nodes);
			claim_component(fielderrors.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			input.hidden = true;
			attr_dev(input, "type", "checkbox");
			attr_dev(input, "id", /*idProp*/ ctx[10]);
			attr_dev(input, "name", /*name*/ ctx[0]);
			attr_dev(input, "form", /*form*/ ctx[7]);
			attr_dev(input, "align", /*align*/ ctx[3]);
			input.value = /*value*/ ctx[2];
			input.checked = /*checked*/ ctx[1];
			input.disabled = /*disabled*/ ctx[4];
			input.required = /*required*/ ctx[8];
			attr_dev(input, "class", "inp-inner svelte-3bj243");
			add_location(input, file$$, 46, 4, 1402);
			attr_dev(span, "class", "inp-box-wrap svelte-3bj243");
			add_location(span, file$$, 62, 8, 1747);
			attr_dev(label_1, "for", /*idProp*/ ctx[10]);
			attr_dev(label_1, "class", "inp-label svelte-3bj243");
			add_location(label_1, file$$, 61, 4, 1700);
			attr_dev(div, "class", div_class_value = "" + (null_to_empty(/*classProp*/ ctx[11]) + " svelte-3bj243"));
			add_location(div, file$$, 38, 0, 1252);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t0);
			append_dev(div, input);
			append_dev(div, t1);
			append_dev(div, label_1);
			append_dev(label_1, span);
			mount_component(icon0, span, null);
			append_dev(span, t2);
			mount_component(icon1, span, null);
			append_dev(label_1, t3);
			if (if_block1) if_block1.m(label_1, null);
			append_dev(div, t4);
			mount_component(fielderrors, div, null);
			current = true;

			if (!mounted) {
				dispose = listen_dev(input, "change", /*onChange*/ ctx[12], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*label*/ ctx[5]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*label*/ 32) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_1$a(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (!current || dirty & /*idProp*/ 1024) {
				attr_dev(input, "id", /*idProp*/ ctx[10]);
			}

			if (!current || dirty & /*name*/ 1) {
				attr_dev(input, "name", /*name*/ ctx[0]);
			}

			if (!current || dirty & /*form*/ 128) {
				attr_dev(input, "form", /*form*/ ctx[7]);
			}

			if (!current || dirty & /*align*/ 8) {
				attr_dev(input, "align", /*align*/ ctx[3]);
			}

			if (!current || dirty & /*value*/ 4) {
				prop_dev(input, "value", /*value*/ ctx[2]);
			}

			if (!current || dirty & /*checked*/ 2) {
				prop_dev(input, "checked", /*checked*/ ctx[1]);
			}

			if (!current || dirty & /*disabled*/ 16) {
				prop_dev(input, "disabled", /*disabled*/ ctx[4]);
			}

			if (!current || dirty & /*required*/ 256) {
				prop_dev(input, "required", /*required*/ ctx[8]);
			}

			if (/*text*/ ctx[6]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block$i(ctx);
					if_block1.c();
					if_block1.m(label_1, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (!current || dirty & /*idProp*/ 1024) {
				attr_dev(label_1, "for", /*idProp*/ ctx[10]);
			}

			const fielderrors_changes = {};
			if (dirty & /*errors*/ 512) fielderrors_changes.items = /*errors*/ ctx[9];

			if (dirty & /*$$scope*/ 1048576) {
				fielderrors_changes.$$scope = { dirty, ctx };
			}

			fielderrors.$set(fielderrors_changes);

			if (!current || dirty & /*classProp*/ 2048 && div_class_value !== (div_class_value = "" + (null_to_empty(/*classProp*/ ctx[11]) + " svelte-3bj243"))) {
				attr_dev(div, "class", div_class_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(icon0.$$.fragment, local);
			transition_in(icon1.$$.fragment, local);
			transition_in(fielderrors.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(icon0.$$.fragment, local);
			transition_out(icon1.$$.fragment, local);
			transition_out(fielderrors.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block0) if_block0.d();
			destroy_component(icon0);
			destroy_component(icon1);
			if (if_block1) if_block1.d();
			destroy_component(fielderrors);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$$.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function getValue$3(e) {
	return e.target.value;
}

function instance$$($$self, $$props, $$invalidate) {
	const dispatch = createEventDispatcher();
	let { name } = $$props;
	let { style = {} } = $$props;
	let { checked = undefined } = $$props;
	let { value = undefined } = $$props;
	let { id = undefined } = $$props;
	let { align = undefined } = $$props;
	let { disabled = false } = $$props;
	let { label = undefined } = $$props;
	let { text = undefined } = $$props;
	let { invalid = undefined } = $$props;
	let { form = undefined } = $$props; // Specifies the form the <input> element belongs to
	let { required = undefined } = $$props; // undefined|required
	let { errors = undefined } = $$props;

	function onChange(e) {
		const value = getValue$3(e);

		dispatch("change", {
			e,
			name,
			value,
			checked: e.target.checked
		});
	}

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Checkbox", $$slots, []);

	$$self.$set = $$new_props => {
		$$invalidate(19, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("name" in $$new_props) $$invalidate(0, name = $$new_props.name);
		if ("style" in $$new_props) $$invalidate(13, style = $$new_props.style);
		if ("checked" in $$new_props) $$invalidate(1, checked = $$new_props.checked);
		if ("value" in $$new_props) $$invalidate(2, value = $$new_props.value);
		if ("id" in $$new_props) $$invalidate(14, id = $$new_props.id);
		if ("align" in $$new_props) $$invalidate(3, align = $$new_props.align);
		if ("disabled" in $$new_props) $$invalidate(4, disabled = $$new_props.disabled);
		if ("label" in $$new_props) $$invalidate(5, label = $$new_props.label);
		if ("text" in $$new_props) $$invalidate(6, text = $$new_props.text);
		if ("invalid" in $$new_props) $$invalidate(15, invalid = $$new_props.invalid);
		if ("form" in $$new_props) $$invalidate(7, form = $$new_props.form);
		if ("required" in $$new_props) $$invalidate(8, required = $$new_props.required);
		if ("errors" in $$new_props) $$invalidate(9, errors = $$new_props.errors);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		classnames,
		toCSSString,
		Br,
		Icon,
		FieldErrors,
		dispatch,
		name,
		style,
		checked,
		value,
		id,
		align,
		disabled,
		label,
		text,
		invalid,
		form,
		required,
		errors,
		onChange,
		getValue: getValue$3,
		idProp,
		error,
		styleProp,
		classProp
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(19, $$props = assign(assign({}, $$props), $$new_props));
		if ("name" in $$props) $$invalidate(0, name = $$new_props.name);
		if ("style" in $$props) $$invalidate(13, style = $$new_props.style);
		if ("checked" in $$props) $$invalidate(1, checked = $$new_props.checked);
		if ("value" in $$props) $$invalidate(2, value = $$new_props.value);
		if ("id" in $$props) $$invalidate(14, id = $$new_props.id);
		if ("align" in $$props) $$invalidate(3, align = $$new_props.align);
		if ("disabled" in $$props) $$invalidate(4, disabled = $$new_props.disabled);
		if ("label" in $$props) $$invalidate(5, label = $$new_props.label);
		if ("text" in $$props) $$invalidate(6, text = $$new_props.text);
		if ("invalid" in $$props) $$invalidate(15, invalid = $$new_props.invalid);
		if ("form" in $$props) $$invalidate(7, form = $$new_props.form);
		if ("required" in $$props) $$invalidate(8, required = $$new_props.required);
		if ("errors" in $$props) $$invalidate(9, errors = $$new_props.errors);
		if ("idProp" in $$props) $$invalidate(10, idProp = $$new_props.idProp);
		if ("error" in $$props) $$invalidate(16, error = $$new_props.error);
		if ("styleProp" in $$props) styleProp = $$new_props.styleProp;
		if ("classProp" in $$props) $$invalidate(11, classProp = $$new_props.classProp);
	};

	let idProp;
	let error;
	let styleProp;
	let classProp;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*id, name, value*/ 16389) {
			 $$invalidate(10, idProp = id || name || value);
		}

		if ($$self.$$.dirty & /*invalid, errors*/ 33280) {
			 $$invalidate(16, error = invalid || !!(errors || []).length);
		}

		if ($$self.$$.dirty & /*style, align*/ 8200) {
			 styleProp = toCSSString({ ...style, textAlign: align });
		}

		 $$invalidate(11, classProp = classnames("checkbox", $$props.class, { disabled, required, error }));
	};

	$$props = exclude_internal_props($$props);

	return [
		name,
		checked,
		value,
		align,
		disabled,
		label,
		text,
		form,
		required,
		errors,
		idProp,
		classProp,
		onChange,
		style,
		id,
		invalid
	];
}

class Checkbox extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document.getElementById("svelte-3bj243-style")) add_css$l();

		init(this, options, instance$$, create_fragment$$, safe_not_equal, {
			name: 0,
			style: 13,
			checked: 1,
			value: 2,
			id: 14,
			align: 3,
			disabled: 4,
			label: 5,
			text: 6,
			invalid: 15,
			form: 7,
			required: 8,
			errors: 9
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Checkbox",
			options,
			id: create_fragment$$.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*name*/ ctx[0] === undefined && !("name" in props)) {
			console.warn("<Checkbox> was created without expected prop 'name'");
		}
	}

	get name() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set name(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get checked() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set checked(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get id() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get align() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set align(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get label() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set label(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get text() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set text(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get invalid() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set invalid(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get form() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set form(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get required() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set required(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get errors() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set errors(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/fields/checkboxes/CheckboxGroup.svelte generated by Svelte v3.24.0 */
const file$10 = "src/components/fields/checkboxes/CheckboxGroup.svelte";

function get_each_context$5(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[15] = list[i];
	child_ctx[17] = i;
	return child_ctx;
}

// (54:4) {#if label}
function create_if_block_1$b(ctx) {
	let h2;
	let t0;
	let t1;
	let br;
	let current;
	br = new Br({ props: { size: "10" }, $$inline: true });

	const block = {
		c: function create() {
			h2 = element("h2");
			t0 = text(/*label*/ ctx[2]);
			t1 = space();
			create_component(br.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			h2 = claim_element(nodes, "H2", { class: true });
			var h2_nodes = children(h2);
			t0 = claim_text(h2_nodes, /*label*/ ctx[2]);
			t1 = claim_space(h2_nodes);
			claim_component(br.$$.fragment, h2_nodes);
			h2_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(h2, "class", "text-left");
			add_location(h2, file$10, 54, 8, 1735);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h2, anchor);
			append_dev(h2, t0);
			append_dev(h2, t1);
			mount_component(br, h2, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (!current || dirty & /*label*/ 4) set_data_dev(t0, /*label*/ ctx[2]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(br.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h2);
			destroy_component(br);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$b.name,
		type: "if",
		source: "(54:4) {#if label}",
		ctx
	});

	return block;
}

// (62:8) {#if i}
function create_if_block$j(ctx) {
	let br;
	let current;
	br = new Br({ props: { size: "15" }, $$inline: true });

	const block = {
		c: function create() {
			create_component(br.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(br.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(br, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(br.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(br, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$j.name,
		type: "if",
		source: "(62:8) {#if i}",
		ctx
	});

	return block;
}

// (61:4) {#each options as checkbox, i}
function create_each_block$5(ctx) {
	let t;
	let checkbox;
	let current;
	let if_block = /*i*/ ctx[17] && create_if_block$j(ctx);

	const checkbox_spread_levels = [
		/*checkbox*/ ctx[15],
		{
			errors: /*errors*/ ctx[4][/*checkbox*/ ctx[15].name]
		},
		{
			checked: /*value*/ ctx[0] && /*getChecked*/ ctx[8](/*checkbox*/ ctx[15].name, /*checkbox*/ ctx[15].value)
		}
	];

	let checkbox_props = {};

	for (let i = 0; i < checkbox_spread_levels.length; i += 1) {
		checkbox_props = assign(checkbox_props, checkbox_spread_levels[i]);
	}

	checkbox = new Checkbox({ props: checkbox_props, $$inline: true });
	checkbox.$on("change", /*onChange*/ ctx[7]);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			t = space();
			create_component(checkbox.$$.fragment);
		},
		l: function claim(nodes) {
			if (if_block) if_block.l(nodes);
			t = claim_space(nodes);
			claim_component(checkbox.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, t, anchor);
			mount_component(checkbox, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const checkbox_changes = (dirty & /*options, errors, value, getChecked*/ 281)
			? get_spread_update(checkbox_spread_levels, [
					dirty & /*options*/ 8 && get_spread_object(/*checkbox*/ ctx[15]),
					dirty & /*errors, options*/ 24 && {
						errors: /*errors*/ ctx[4][/*checkbox*/ ctx[15].name]
					},
					dirty & /*value, getChecked, options*/ 265 && {
						checked: /*value*/ ctx[0] && /*getChecked*/ ctx[8](/*checkbox*/ ctx[15].name, /*checkbox*/ ctx[15].value)
					}
				])
			: {};

			checkbox.$set(checkbox_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(checkbox.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			transition_out(checkbox.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(t);
			destroy_component(checkbox, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$5.name,
		type: "each",
		source: "(61:4) {#each options as checkbox, i}",
		ctx
	});

	return block;
}

function create_fragment$10(ctx) {
	let div;
	let t;
	let current;
	let if_block = /*label*/ ctx[2] && create_if_block_1$b(ctx);
	let each_value = /*options*/ ctx[3];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			div = element("div");
			if (if_block) if_block.c();
			t = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { id: true, class: true, styleProp: true });
			var div_nodes = children(div);
			if (if_block) if_block.l(div_nodes);
			t = claim_space(div_nodes);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div_nodes);
			}

			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "id", /*id*/ ctx[1]);
			attr_dev(div, "class", /*classProp*/ ctx[6]);
			attr_dev(div, "styleprop", /*styleProp*/ ctx[5]);
			add_location(div, file$10, 52, 0, 1660);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block) if_block.m(div, null);
			append_dev(div, t);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*label*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*label*/ 4) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_1$b(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div, t);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (dirty & /*options, errors, value, getChecked, onChange*/ 409) {
				each_value = /*options*/ ctx[3];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$5(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$5(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}

			if (!current || dirty & /*id*/ 2) {
				attr_dev(div, "id", /*id*/ ctx[1]);
			}

			if (!current || dirty & /*classProp*/ 64) {
				attr_dev(div, "class", /*classProp*/ ctx[6]);
			}

			if (!current || dirty & /*styleProp*/ 32) {
				attr_dev(div, "styleprop", /*styleProp*/ ctx[5]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block) if_block.d();
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$10.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$10($$self, $$props, $$invalidate) {
	const dispatch = createEventDispatcher();
	let { name } = $$props;
	let { value = undefined } = $$props;
	let { style = undefined } = $$props;
	let { id = undefined } = $$props;
	let { align = undefined } = $$props;
	let { disabled = false } = $$props;
	let { label = undefined } = $$props;
	let { options = undefined } = $$props;
	let { errors = {} } = $$props;

	const onChange = ({ detail: { e, name: currName, value: currValue, checked } }) => {
		let newValue = cloneDeep(value);

		if (!currName && currValue) {
			if (!Array.isArray(newValue)) {
				newValue = [];
			}

			if (checked && !newValue.includes(currValue)) {
				newValue = [...newValue, currValue];
			} else if (!checked && newValue.includes(currValue)) {
				newValue = value.filter(v => v !== currValue);
			}
		} else if (currName) {
			if (!newValue) {
				newValue = {};
			}

			newValue[currName] = currValue || checked;
		}

		dispatch("change", { e, name, value: newValue });
	};

	function getChecked(currName, currValue) {
		if (Array.isArray(value)) {
			return value.includes(currValue);
		} else {
			return !!value && value[currName];
		}
	}

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("CheckboxGroup", $$slots, []);

	$$self.$set = $$new_props => {
		$$invalidate(14, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("name" in $$new_props) $$invalidate(9, name = $$new_props.name);
		if ("value" in $$new_props) $$invalidate(0, value = $$new_props.value);
		if ("style" in $$new_props) $$invalidate(10, style = $$new_props.style);
		if ("id" in $$new_props) $$invalidate(1, id = $$new_props.id);
		if ("align" in $$new_props) $$invalidate(11, align = $$new_props.align);
		if ("disabled" in $$new_props) $$invalidate(12, disabled = $$new_props.disabled);
		if ("label" in $$new_props) $$invalidate(2, label = $$new_props.label);
		if ("options" in $$new_props) $$invalidate(3, options = $$new_props.options);
		if ("errors" in $$new_props) $$invalidate(4, errors = $$new_props.errors);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		classnames,
		toCSSString,
		_,
		Br,
		Checkbox,
		dispatch,
		name,
		value,
		style,
		id,
		align,
		disabled,
		label,
		options,
		errors,
		onChange,
		getChecked,
		styleProp,
		classProp
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(14, $$props = assign(assign({}, $$props), $$new_props));
		if ("name" in $$props) $$invalidate(9, name = $$new_props.name);
		if ("value" in $$props) $$invalidate(0, value = $$new_props.value);
		if ("style" in $$props) $$invalidate(10, style = $$new_props.style);
		if ("id" in $$props) $$invalidate(1, id = $$new_props.id);
		if ("align" in $$props) $$invalidate(11, align = $$new_props.align);
		if ("disabled" in $$props) $$invalidate(12, disabled = $$new_props.disabled);
		if ("label" in $$props) $$invalidate(2, label = $$new_props.label);
		if ("options" in $$props) $$invalidate(3, options = $$new_props.options);
		if ("errors" in $$props) $$invalidate(4, errors = $$new_props.errors);
		if ("styleProp" in $$props) $$invalidate(5, styleProp = $$new_props.styleProp);
		if ("classProp" in $$props) $$invalidate(6, classProp = $$new_props.classProp);
	};

	let styleProp;
	let classProp;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*style, align*/ 3072) {
			 $$invalidate(5, styleProp = toCSSString({ ...style, textAlign: align }));
		}

		 $$invalidate(6, classProp = classnames("checkbox-group", $$props.class, { disabled, error: !isEmpty(errors) }));
	};

	$$props = exclude_internal_props($$props);

	return [
		value,
		id,
		label,
		options,
		errors,
		styleProp,
		classProp,
		onChange,
		getChecked,
		name,
		style,
		align,
		disabled
	];
}

class CheckboxGroup extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$10, create_fragment$10, safe_not_equal, {
			name: 9,
			value: 0,
			style: 10,
			id: 1,
			align: 11,
			disabled: 12,
			label: 2,
			options: 3,
			errors: 4
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "CheckboxGroup",
			options,
			id: create_fragment$10.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*name*/ ctx[9] === undefined && !("name" in props)) {
			console.warn("<CheckboxGroup> was created without expected prop 'name'");
		}
	}

	get name() {
		throw new Error("<CheckboxGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set name(value) {
		throw new Error("<CheckboxGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<CheckboxGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<CheckboxGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<CheckboxGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<CheckboxGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get id() {
		throw new Error("<CheckboxGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<CheckboxGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get align() {
		throw new Error("<CheckboxGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set align(value) {
		throw new Error("<CheckboxGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<CheckboxGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<CheckboxGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get label() {
		throw new Error("<CheckboxGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set label(value) {
		throw new Error("<CheckboxGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get options() {
		throw new Error("<CheckboxGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set options(value) {
		throw new Error("<CheckboxGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get errors() {
		throw new Error("<CheckboxGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set errors(value) {
		throw new Error("<CheckboxGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/FormBuilder.svelte generated by Svelte v3.24.0 */

const { console: console_1 } = globals;

const file$11 = "src/components/FormBuilder.svelte";

const get_default_slot_changes$4 = dirty => ({
	item: dirty & /*items*/ 2,
	values: dirty & /*values*/ 8,
	errors: dirty & /*errors*/ 4,
	value: dirty & /*values, items*/ 10
});

const get_default_slot_context$4 = ctx => ({
	item: /*item*/ ctx[17],
	values: /*values*/ ctx[3],
	errors: /*errors*/ ctx[2],
	onChange: /*onChange*/ ctx[5],
	value: /*values*/ ctx[3][/*item*/ ctx[17].name]
});

function get_each_context$6(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[17] = list[i];
	child_ctx[19] = i;
	return child_ctx;
}

// (82:8) {#if i}
function create_if_block_10(ctx) {
	let br;
	let current;
	br = new Br({ props: { size: "30" }, $$inline: true });

	const block = {
		c: function create() {
			create_component(br.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(br.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(br, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(br.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(br, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_10.name,
		type: "if",
		source: "(82:8) {#if i}",
		ctx
	});

	return block;
}

// (165:8) {:else}
function create_else_block_2(ctx) {
	let current;
	const default_slot_template = /*$$slots*/ ctx[12].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[13], get_default_slot_context$4);
	const default_slot_or_fallback = default_slot || fallback_block$6(ctx);

	const block = {
		c: function create() {
			if (default_slot_or_fallback) default_slot_or_fallback.c();
		},
		l: function claim(nodes) {
			if (default_slot_or_fallback) default_slot_or_fallback.l(nodes);
		},
		m: function mount(target, anchor) {
			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope, items, values, errors*/ 8206) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[13], dirty, get_default_slot_changes$4, get_default_slot_context$4);
				}
			} else {
				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*items, values*/ 10) {
					default_slot_or_fallback.p(ctx, dirty);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot_or_fallback, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot_or_fallback, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_2.name,
		type: "else",
		source: "(165:8) {:else}",
		ctx
	});

	return block;
}

// (156:53) 
function create_if_block_8(ctx) {
	let radiorect;
	let current;

	const radiorect_spread_levels = [
		/*item*/ ctx[17].meta,
		{ name: /*item*/ ctx[17].name },
		{ label: /*item*/ ctx[17].label },
		{
			value: /*getValue*/ ctx[7](/*values*/ ctx[3], /*item*/ ctx[17].name)
		},
		{
			errors: /*errors*/ ctx[2][/*item*/ ctx[17].name]
		}
	];

	let radiorect_props = {};

	for (let i = 0; i < radiorect_spread_levels.length; i += 1) {
		radiorect_props = assign(radiorect_props, radiorect_spread_levels[i]);
	}

	radiorect = new RadioRect({ props: radiorect_props, $$inline: true });

	radiorect.$on("change", function () {
		if (is_function(/*getOnChange*/ ctx[6](/*item*/ ctx[17]))) /*getOnChange*/ ctx[6](/*item*/ ctx[17]).apply(this, arguments);
	});

	const block = {
		c: function create() {
			create_component(radiorect.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(radiorect.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(radiorect, target, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			const radiorect_changes = (dirty & /*items, getValue, values, errors*/ 142)
			? get_spread_update(radiorect_spread_levels, [
					dirty & /*items*/ 2 && get_spread_object(/*item*/ ctx[17].meta),
					dirty & /*items*/ 2 && { name: /*item*/ ctx[17].name },
					dirty & /*items*/ 2 && { label: /*item*/ ctx[17].label },
					dirty & /*getValue, values, items*/ 138 && {
						value: /*getValue*/ ctx[7](/*values*/ ctx[3], /*item*/ ctx[17].name)
					},
					dirty & /*errors, items*/ 6 && {
						errors: /*errors*/ ctx[2][/*item*/ ctx[17].name]
					}
				])
			: {};

			radiorect.$set(radiorect_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(radiorect.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(radiorect.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(radiorect, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_8.name,
		type: "if",
		source: "(156:53) ",
		ctx
	});

	return block;
}

// (147:49) 
function create_if_block_7(ctx) {
	let avatarupload;
	let current;

	const avatarupload_spread_levels = [
		/*item*/ ctx[17].meta,
		{ name: /*item*/ ctx[17].name },
		{ label: /*item*/ ctx[17].label },
		{
			value: /*getValue*/ ctx[7](/*values*/ ctx[3], /*item*/ ctx[17].name)
		},
		{
			errors: /*errors*/ ctx[2][/*item*/ ctx[17].name]
		}
	];

	let avatarupload_props = {};

	for (let i = 0; i < avatarupload_spread_levels.length; i += 1) {
		avatarupload_props = assign(avatarupload_props, avatarupload_spread_levels[i]);
	}

	avatarupload = new AvatarUpload({
			props: avatarupload_props,
			$$inline: true
		});

	avatarupload.$on("change", function () {
		if (is_function(/*getOnChange*/ ctx[6](/*item*/ ctx[17]))) /*getOnChange*/ ctx[6](/*item*/ ctx[17]).apply(this, arguments);
	});

	const block = {
		c: function create() {
			create_component(avatarupload.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(avatarupload.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(avatarupload, target, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			const avatarupload_changes = (dirty & /*items, getValue, values, errors*/ 142)
			? get_spread_update(avatarupload_spread_levels, [
					dirty & /*items*/ 2 && get_spread_object(/*item*/ ctx[17].meta),
					dirty & /*items*/ 2 && { name: /*item*/ ctx[17].name },
					dirty & /*items*/ 2 && { label: /*item*/ ctx[17].label },
					dirty & /*getValue, values, items*/ 138 && {
						value: /*getValue*/ ctx[7](/*values*/ ctx[3], /*item*/ ctx[17].name)
					},
					dirty & /*errors, items*/ 6 && {
						errors: /*errors*/ ctx[2][/*item*/ ctx[17].name]
					}
				])
			: {};

			avatarupload.$set(avatarupload_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(avatarupload.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(avatarupload.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(avatarupload, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_7.name,
		type: "if",
		source: "(147:49) ",
		ctx
	});

	return block;
}

// (138:48) 
function create_if_block_6(ctx) {
	let uploadboxgroup;
	let current;

	const uploadboxgroup_spread_levels = [
		/*item*/ ctx[17].meta,
		{ name: /*item*/ ctx[17].name },
		{ label: /*item*/ ctx[17].label },
		{
			value: /*getValue*/ ctx[7](/*values*/ ctx[3], /*item*/ ctx[17].name)
		},
		{
			errors: /*errors*/ ctx[2][/*item*/ ctx[17].name]
		}
	];

	let uploadboxgroup_props = {};

	for (let i = 0; i < uploadboxgroup_spread_levels.length; i += 1) {
		uploadboxgroup_props = assign(uploadboxgroup_props, uploadboxgroup_spread_levels[i]);
	}

	uploadboxgroup = new UploadBoxGroup({
			props: uploadboxgroup_props,
			$$inline: true
		});

	uploadboxgroup.$on("change", function () {
		if (is_function(/*getOnChange*/ ctx[6](/*item*/ ctx[17]))) /*getOnChange*/ ctx[6](/*item*/ ctx[17]).apply(this, arguments);
	});

	const block = {
		c: function create() {
			create_component(uploadboxgroup.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(uploadboxgroup.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(uploadboxgroup, target, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			const uploadboxgroup_changes = (dirty & /*items, getValue, values, errors*/ 142)
			? get_spread_update(uploadboxgroup_spread_levels, [
					dirty & /*items*/ 2 && get_spread_object(/*item*/ ctx[17].meta),
					dirty & /*items*/ 2 && { name: /*item*/ ctx[17].name },
					dirty & /*items*/ 2 && { label: /*item*/ ctx[17].label },
					dirty & /*getValue, values, items*/ 138 && {
						value: /*getValue*/ ctx[7](/*values*/ ctx[3], /*item*/ ctx[17].name)
					},
					dirty & /*errors, items*/ 6 && {
						errors: /*errors*/ ctx[2][/*item*/ ctx[17].name]
					}
				])
			: {};

			uploadboxgroup.$set(uploadboxgroup_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(uploadboxgroup.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(uploadboxgroup.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(uploadboxgroup, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_6.name,
		type: "if",
		source: "(138:48) ",
		ctx
	});

	return block;
}

// (129:47) 
function create_if_block_5(ctx) {
	let uploadbox;
	let current;

	const uploadbox_spread_levels = [
		/*item*/ ctx[17].meta,
		{ name: /*item*/ ctx[17].name },
		{ label: /*item*/ ctx[17].label },
		{
			value: /*getValue*/ ctx[7](/*values*/ ctx[3], /*item*/ ctx[17].name)
		},
		{
			errors: /*errors*/ ctx[2][/*item*/ ctx[17].name]
		}
	];

	let uploadbox_props = {};

	for (let i = 0; i < uploadbox_spread_levels.length; i += 1) {
		uploadbox_props = assign(uploadbox_props, uploadbox_spread_levels[i]);
	}

	uploadbox = new UploadBox({ props: uploadbox_props, $$inline: true });

	uploadbox.$on("change", function () {
		if (is_function(/*getOnChange*/ ctx[6](/*item*/ ctx[17]))) /*getOnChange*/ ctx[6](/*item*/ ctx[17]).apply(this, arguments);
	});

	const block = {
		c: function create() {
			create_component(uploadbox.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(uploadbox.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(uploadbox, target, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			const uploadbox_changes = (dirty & /*items, getValue, values, errors*/ 142)
			? get_spread_update(uploadbox_spread_levels, [
					dirty & /*items*/ 2 && get_spread_object(/*item*/ ctx[17].meta),
					dirty & /*items*/ 2 && { name: /*item*/ ctx[17].name },
					dirty & /*items*/ 2 && { label: /*item*/ ctx[17].label },
					dirty & /*getValue, values, items*/ 138 && {
						value: /*getValue*/ ctx[7](/*values*/ ctx[3], /*item*/ ctx[17].name)
					},
					dirty & /*errors, items*/ 6 && {
						errors: /*errors*/ ctx[2][/*item*/ ctx[17].name]
					}
				])
			: {};

			uploadbox.$set(uploadbox_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(uploadbox.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(uploadbox.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(uploadbox, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_5.name,
		type: "if",
		source: "(129:47) ",
		ctx
	});

	return block;
}

// (112:49) 
function create_if_block_3$1(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_4, create_else_block_1];
	const if_blocks = [];

	function select_block_type_2(ctx, dirty) {
		if (/*values*/ ctx[3][/*item*/ ctx[17].name] !== null) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_2(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_2(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$1.name,
		type: "if",
		source: "(112:49) ",
		ctx
	});

	return block;
}

// (103:51) 
function create_if_block_2$4(ctx) {
	let checkboxgroup;
	let current;

	const checkboxgroup_spread_levels = [
		/*item*/ ctx[17].meta,
		{ name: /*item*/ ctx[17].name },
		{ label: /*item*/ ctx[17].label },
		{
			value: /*getValue*/ ctx[7](/*values*/ ctx[3], /*item*/ ctx[17].name)
		},
		{
			errors: /*errors*/ ctx[2][/*item*/ ctx[17].name]
		}
	];

	let checkboxgroup_props = {};

	for (let i = 0; i < checkboxgroup_spread_levels.length; i += 1) {
		checkboxgroup_props = assign(checkboxgroup_props, checkboxgroup_spread_levels[i]);
	}

	checkboxgroup = new CheckboxGroup({
			props: checkboxgroup_props,
			$$inline: true
		});

	checkboxgroup.$on("change", function () {
		if (is_function(/*getOnChange*/ ctx[6](/*item*/ ctx[17]))) /*getOnChange*/ ctx[6](/*item*/ ctx[17]).apply(this, arguments);
	});

	const block = {
		c: function create() {
			create_component(checkboxgroup.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(checkboxgroup.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(checkboxgroup, target, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			const checkboxgroup_changes = (dirty & /*items, getValue, values, errors*/ 142)
			? get_spread_update(checkboxgroup_spread_levels, [
					dirty & /*items*/ 2 && get_spread_object(/*item*/ ctx[17].meta),
					dirty & /*items*/ 2 && { name: /*item*/ ctx[17].name },
					dirty & /*items*/ 2 && { label: /*item*/ ctx[17].label },
					dirty & /*getValue, values, items*/ 138 && {
						value: /*getValue*/ ctx[7](/*values*/ ctx[3], /*item*/ ctx[17].name)
					},
					dirty & /*errors, items*/ 6 && {
						errors: /*errors*/ ctx[2][/*item*/ ctx[17].name]
					}
				])
			: {};

			checkboxgroup.$set(checkboxgroup_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(checkboxgroup.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(checkboxgroup.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(checkboxgroup, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$4.name,
		type: "if",
		source: "(103:51) ",
		ctx
	});

	return block;
}

// (85:8) {#if ['text', 'number', 'textarea', 'email', 'password', 'search', 'tel', 'url', 'date', 'datetime-local', 'time'].includes(item.type)}
function create_if_block$k(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_1$c, create_else_block$5];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*values*/ ctx[3][/*item*/ ctx[17].name] !== null) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_1(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$k.name,
		type: "if",
		source: "(85:8) {#if ['text', 'number', 'textarea', 'email', 'password', 'search', 'tel', 'url', 'date', 'datetime-local', 'time'].includes(item.type)}",
		ctx
	});

	return block;
}

// (173:16) {:else}
function create_else_block_3(ctx) {
	let div;
	let loader0;
	let t;
	let loader1;
	let current;
	loader0 = new Loader({ props: { type: "h2" }, $$inline: true });
	loader1 = new Loader({ props: { type: "p" }, $$inline: true });

	const block = {
		c: function create() {
			div = element("div");
			create_component(loader0.$$.fragment);
			t = space();
			create_component(loader1.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", {});
			var div_nodes = children(div);
			claim_component(loader0.$$.fragment, div_nodes);
			t = claim_space(div_nodes);
			claim_component(loader1.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(div, file$11, 173, 20, 6068);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(loader0, div, null);
			append_dev(div, t);
			mount_component(loader1, div, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(loader0.$$.fragment, local);
			transition_in(loader1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loader0.$$.fragment, local);
			transition_out(loader1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(loader0);
			destroy_component(loader1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_3.name,
		type: "else",
		source: "(173:16) {:else}",
		ctx
	});

	return block;
}

// (167:16) {#if values[item.name] !== null}
function create_if_block_9(ctx) {
	let readfield;
	let current;

	const readfield_spread_levels = [
		/*item*/ ctx[17].meta,
		{ label: /*item*/ ctx[17].label },
		{
			value: /*getValue*/ ctx[7](/*values*/ ctx[3], /*item*/ ctx[17].name)
		}
	];

	let readfield_props = {};

	for (let i = 0; i < readfield_spread_levels.length; i += 1) {
		readfield_props = assign(readfield_props, readfield_spread_levels[i]);
	}

	readfield = new ReadField({ props: readfield_props, $$inline: true });

	const block = {
		c: function create() {
			create_component(readfield.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(readfield.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(readfield, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const readfield_changes = (dirty & /*items, getValue, values*/ 138)
			? get_spread_update(readfield_spread_levels, [
					dirty & /*items*/ 2 && get_spread_object(/*item*/ ctx[17].meta),
					dirty & /*items*/ 2 && { label: /*item*/ ctx[17].label },
					{
						value: /*getValue*/ ctx[7](/*values*/ ctx[3], /*item*/ ctx[17].name)
					}
				])
			: {};

			readfield.$set(readfield_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(readfield.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(readfield.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(readfield, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_9.name,
		type: "if",
		source: "(167:16) {#if values[item.name] !== null}",
		ctx
	});

	return block;
}

// (166:80)                  
function fallback_block$6(ctx) {
	let current_block_type_index;
	let if_block;
	let t;
	let current;
	const if_block_creators = [create_if_block_9, create_else_block_3];
	const if_blocks = [];

	function select_block_type_3(ctx, dirty) {
		if (/*values*/ ctx[3][/*item*/ ctx[17].name] !== null) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_3(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			t = space();
		},
		l: function claim(nodes) {
			if_block.l(nodes);
			t = claim_space(nodes);
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, t, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_3(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(t.parentNode, t);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: fallback_block$6.name,
		type: "fallback",
		source: "(166:80)                  ",
		ctx
	});

	return block;
}

// (123:12) {:else}
function create_else_block_1(ctx) {
	let div;
	let loader0;
	let t0;
	let loader1;
	let t1;
	let current;
	loader0 = new Loader({ props: { type: "h2" }, $$inline: true });
	loader1 = new Loader({ props: { height: "50" }, $$inline: true });

	const block = {
		c: function create() {
			div = element("div");
			create_component(loader0.$$.fragment);
			t0 = space();
			create_component(loader1.$$.fragment);
			t1 = space();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", {});
			var div_nodes = children(div);
			claim_component(loader0.$$.fragment, div_nodes);
			t0 = claim_space(div_nodes);
			claim_component(loader1.$$.fragment, div_nodes);
			t1 = claim_space(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(div, file$11, 123, 16, 4135);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(loader0, div, null);
			append_dev(div, t0);
			mount_component(loader1, div, null);
			append_dev(div, t1);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(loader0.$$.fragment, local);
			transition_in(loader1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loader0.$$.fragment, local);
			transition_out(loader1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(loader0);
			destroy_component(loader1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1.name,
		type: "else",
		source: "(123:12) {:else}",
		ctx
	});

	return block;
}

// (113:12) {#if values[item.name] !== null}
function create_if_block_4(ctx) {
	let select;
	let current;

	const select_spread_levels = [
		/*item*/ ctx[17].meta,
		{ name: /*item*/ ctx[17].name },
		{ type: /*item*/ ctx[17].type },
		{ label: /*item*/ ctx[17].label },
		{
			value: /*getValue*/ ctx[7](/*values*/ ctx[3], /*item*/ ctx[17].name)
		},
		{
			errors: /*errors*/ ctx[2][/*item*/ ctx[17].name]
		}
	];

	let select_props = {};

	for (let i = 0; i < select_spread_levels.length; i += 1) {
		select_props = assign(select_props, select_spread_levels[i]);
	}

	select = new Select({ props: select_props, $$inline: true });

	select.$on("change", function () {
		if (is_function(/*getOnChange*/ ctx[6](/*item*/ ctx[17]))) /*getOnChange*/ ctx[6](/*item*/ ctx[17]).apply(this, arguments);
	});

	const block = {
		c: function create() {
			create_component(select.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(select.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(select, target, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			const select_changes = (dirty & /*items, getValue, values, errors*/ 142)
			? get_spread_update(select_spread_levels, [
					dirty & /*items*/ 2 && get_spread_object(/*item*/ ctx[17].meta),
					dirty & /*items*/ 2 && { name: /*item*/ ctx[17].name },
					dirty & /*items*/ 2 && { type: /*item*/ ctx[17].type },
					dirty & /*items*/ 2 && { label: /*item*/ ctx[17].label },
					dirty & /*getValue, values, items*/ 138 && {
						value: /*getValue*/ ctx[7](/*values*/ ctx[3], /*item*/ ctx[17].name)
					},
					dirty & /*errors, items*/ 6 && {
						errors: /*errors*/ ctx[2][/*item*/ ctx[17].name]
					}
				])
			: {};

			select.$set(select_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(select.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(select.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(select, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4.name,
		type: "if",
		source: "(113:12) {#if values[item.name] !== null}",
		ctx
	});

	return block;
}

// (97:12) {:else}
function create_else_block$5(ctx) {
	let div;
	let loader0;
	let t0;
	let loader1;
	let t1;
	let current;
	loader0 = new Loader({ props: { type: "h2" }, $$inline: true });
	loader1 = new Loader({ props: { height: "50" }, $$inline: true });

	const block = {
		c: function create() {
			div = element("div");
			create_component(loader0.$$.fragment);
			t0 = space();
			create_component(loader1.$$.fragment);
			t1 = space();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", {});
			var div_nodes = children(div);
			claim_component(loader0.$$.fragment, div_nodes);
			t0 = claim_space(div_nodes);
			claim_component(loader1.$$.fragment, div_nodes);
			t1 = claim_space(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(div, file$11, 97, 16, 3172);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(loader0, div, null);
			append_dev(div, t0);
			mount_component(loader1, div, null);
			append_dev(div, t1);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(loader0.$$.fragment, local);
			transition_in(loader1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loader0.$$.fragment, local);
			transition_out(loader1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(loader0);
			destroy_component(loader1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$5.name,
		type: "else",
		source: "(97:12) {:else}",
		ctx
	});

	return block;
}

// (86:12) {#if values[item.name] !== null}
function create_if_block_1$c(ctx) {
	let input;
	let current;

	const input_spread_levels = [
		/*item*/ ctx[17].meta,
		{ name: /*item*/ ctx[17].name },
		{ type: /*item*/ ctx[17].type },
		{ label: /*item*/ ctx[17].label },
		{
			value: /*getValue*/ ctx[7](/*values*/ ctx[3], /*item*/ ctx[17].name)
		},
		{
			errors: /*errors*/ ctx[2][/*item*/ ctx[17].name]
		}
	];

	let input_props = {};

	for (let i = 0; i < input_spread_levels.length; i += 1) {
		input_props = assign(input_props, input_spread_levels[i]);
	}

	input = new Input({ props: input_props, $$inline: true });
	input.$on("input", /*onChange*/ ctx[5]);

	input.$on("change", function () {
		if (is_function(/*getOnChange*/ ctx[6](/*item*/ ctx[17]))) /*getOnChange*/ ctx[6](/*item*/ ctx[17]).apply(this, arguments);
	});

	const block = {
		c: function create() {
			create_component(input.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(input.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(input, target, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			const input_changes = (dirty & /*items, getValue, values, errors*/ 142)
			? get_spread_update(input_spread_levels, [
					dirty & /*items*/ 2 && get_spread_object(/*item*/ ctx[17].meta),
					dirty & /*items*/ 2 && { name: /*item*/ ctx[17].name },
					dirty & /*items*/ 2 && { type: /*item*/ ctx[17].type },
					dirty & /*items*/ 2 && { label: /*item*/ ctx[17].label },
					dirty & /*getValue, values, items*/ 138 && {
						value: /*getValue*/ ctx[7](/*values*/ ctx[3], /*item*/ ctx[17].name)
					},
					dirty & /*errors, items*/ 6 && {
						errors: /*errors*/ ctx[2][/*item*/ ctx[17].name]
					}
				])
			: {};

			input.$set(input_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(input.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(input.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(input, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$c.name,
		type: "if",
		source: "(86:12) {#if values[item.name] !== null}",
		ctx
	});

	return block;
}

// (81:4) {#each items as item, i}
function create_each_block$6(ctx) {
	let t;
	let show_if;
	let show_if_1;
	let show_if_2;
	let show_if_3;
	let show_if_4;
	let show_if_5;
	let show_if_6;
	let current_block_type_index;
	let if_block1;
	let if_block1_anchor;
	let current;
	let if_block0 = /*i*/ ctx[19] && create_if_block_10(ctx);

	const if_block_creators = [
		create_if_block$k,
		create_if_block_2$4,
		create_if_block_3$1,
		create_if_block_5,
		create_if_block_6,
		create_if_block_7,
		create_if_block_8,
		create_else_block_2
	];

	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (dirty & /*items*/ 2) show_if = !![
			"text",
			"number",
			"textarea",
			"email",
			"password",
			"search",
			"tel",
			"url",
			"date",
			"datetime-local",
			"time"
		].includes(/*item*/ ctx[17].type);

		if (show_if) return 0;
		if (dirty & /*items*/ 2) show_if_1 = !!["checkbox"].includes(/*item*/ ctx[17].type);
		if (show_if_1) return 1;
		if (dirty & /*items*/ 2) show_if_2 = !!["select"].includes(/*item*/ ctx[17].type);
		if (show_if_2) return 2;
		if (dirty & /*items*/ 2) show_if_3 = !!["file"].includes(/*item*/ ctx[17].type);
		if (show_if_3) return 3;
		if (dirty & /*items*/ 2) show_if_4 = !!["files"].includes(/*item*/ ctx[17].type);
		if (show_if_4) return 4;
		if (dirty & /*items*/ 2) show_if_5 = !!["avatar"].includes(/*item*/ ctx[17].type);
		if (show_if_5) return 5;
		if (dirty & /*items*/ 2) show_if_6 = !!["radio-rect"].includes(/*item*/ ctx[17].type);
		if (show_if_6) return 6;
		return 7;
	}

	current_block_type_index = select_block_type(ctx, -1);
	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if (if_block0) if_block0.c();
			t = space();
			if_block1.c();
			if_block1_anchor = empty();
		},
		l: function claim(nodes) {
			if (if_block0) if_block0.l(nodes);
			t = claim_space(nodes);
			if_block1.l(nodes);
			if_block1_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert_dev(target, t, anchor);
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block1 = if_blocks[current_block_type_index];

				if (!if_block1) {
					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block1.c();
				}

				transition_in(if_block1, 1);
				if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach_dev(t);
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$6.name,
		type: "each",
		source: "(81:4) {#each items as item, i}",
		ctx
	});

	return block;
}

// (80:0) <Form {id} on:submit={onSubmit} class={classProp}>
function create_default_slot$F(ctx) {
	let each_1_anchor;
	let current;
	let each_value = /*items*/ ctx[1];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty & /*items, getValue, values, errors, onChange, getOnChange, $$scope*/ 8430) {
				each_value = /*items*/ ctx[1];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$6(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$6(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$F.name,
		type: "slot",
		source: "(80:0) <Form {id} on:submit={onSubmit} class={classProp}>",
		ctx
	});

	return block;
}

function create_fragment$11(ctx) {
	let form;
	let current;

	form = new Form({
			props: {
				id: /*id*/ ctx[0],
				class: /*classProp*/ ctx[4],
				$$slots: { default: [create_default_slot$F] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	form.$on("submit", /*onSubmit*/ ctx[8]);

	const block = {
		c: function create() {
			create_component(form.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(form.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(form, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const form_changes = {};
			if (dirty & /*id*/ 1) form_changes.id = /*id*/ ctx[0];
			if (dirty & /*classProp*/ 16) form_changes.class = /*classProp*/ ctx[4];

			if (dirty & /*$$scope, items, values, errors*/ 8206) {
				form_changes.$$scope = { dirty, ctx };
			}

			form.$set(form_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(form.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(form.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(form, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$11.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$11($$self, $$props, $$invalidate) {
	const dispatch = createEventDispatcher();
	let { id = undefined } = $$props;
	let { items = [] } = $$props;
	let { data = {} } = $$props;
	let { errors = {} } = $$props;

	let { submit = async () => {
		
	} } = $$props;

	let { beforeChange = values => values } = $$props;
	let submitting = false;

	function onChange({ detail: { e, name, value } }) {
		$$invalidate(3, values = beforeChange(set(values, name, value)));
		dispatch("change", { e, name, value, values });
	}

	async function onDefaultImageChange({ detail: { e, name, value: rawValue } }) {
		const value = [];

		const imgMapper = img => img instanceof File
		? API.uploadImage(img).catch(() => null)
		: Promise.resolve(img);

		const imgPromises = rawValue.map(imgMapper);
		for await (const image of imgPromises) image && value.push(image);
		$$invalidate(3, values = beforeChange(set(values, name, value)));
		dispatch("change", { e, name, value, values, rawValue });
	}

	function getOnChange(item) {
		switch (true) {
			case ["file", "files", "avatar"].includes(item.type):
				return onDefaultImageChange;
			default:
				return onChange;
		}
	}

	function getValue(values, name) {
		const val = get(values, name);
		return val === undefined ? "" : val;
	}

	async function onSubmit() {
		$$invalidate(14, submitting = true);
		await submit(values).catch(err => console.warn("FormBuilder/submit error: ", err));
		$$invalidate(14, submitting = false);
	}

	const writable_props = ["id", "items", "data", "errors", "submit", "beforeChange"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<FormBuilder> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("FormBuilder", $$slots, ['default']);

	$$self.$set = $$props => {
		if ("id" in $$props) $$invalidate(0, id = $$props.id);
		if ("items" in $$props) $$invalidate(1, items = $$props.items);
		if ("data" in $$props) $$invalidate(9, data = $$props.data);
		if ("errors" in $$props) $$invalidate(2, errors = $$props.errors);
		if ("submit" in $$props) $$invalidate(10, submit = $$props.submit);
		if ("beforeChange" in $$props) $$invalidate(11, beforeChange = $$props.beforeChange);
		if ("$$scope" in $$props) $$invalidate(13, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		API,
		classnames,
		_,
		Br,
		Form,
		Loader,
		Input,
		Select,
		ReadField,
		UploadBox,
		RadioRect,
		AvatarUpload,
		CheckboxGroup,
		UploadBoxGroup,
		dispatch,
		id,
		items,
		data,
		errors,
		submit,
		beforeChange,
		submitting,
		onChange,
		onDefaultImageChange,
		getOnChange,
		getValue,
		onSubmit,
		values,
		classProp
	});

	$$self.$inject_state = $$props => {
		if ("id" in $$props) $$invalidate(0, id = $$props.id);
		if ("items" in $$props) $$invalidate(1, items = $$props.items);
		if ("data" in $$props) $$invalidate(9, data = $$props.data);
		if ("errors" in $$props) $$invalidate(2, errors = $$props.errors);
		if ("submit" in $$props) $$invalidate(10, submit = $$props.submit);
		if ("beforeChange" in $$props) $$invalidate(11, beforeChange = $$props.beforeChange);
		if ("submitting" in $$props) $$invalidate(14, submitting = $$props.submitting);
		if ("values" in $$props) $$invalidate(3, values = $$props.values);
		if ("classProp" in $$props) $$invalidate(4, classProp = $$props.classProp);
	};

	let values;
	let classProp;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*data*/ 512) {
			 $$invalidate(3, values = cloneDeep(data));
		}

		if ($$self.$$.dirty & /*submitting*/ 16384) {
			 $$invalidate(4, classProp = classnames("form-builder", { submitting }));
		}
	};

	return [
		id,
		items,
		errors,
		values,
		classProp,
		onChange,
		getOnChange,
		getValue,
		onSubmit,
		data,
		submit,
		beforeChange,
		$$slots,
		$$scope
	];
}

class FormBuilder extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$11, create_fragment$11, safe_not_equal, {
			id: 0,
			items: 1,
			data: 9,
			errors: 2,
			submit: 10,
			beforeChange: 11
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "FormBuilder",
			options,
			id: create_fragment$11.name
		});
	}

	get id() {
		throw new Error("<FormBuilder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<FormBuilder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get items() {
		throw new Error("<FormBuilder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set items(value) {
		throw new Error("<FormBuilder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get data() {
		throw new Error("<FormBuilder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set data(value) {
		throw new Error("<FormBuilder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get errors() {
		throw new Error("<FormBuilder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set errors(value) {
		throw new Error("<FormBuilder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get submit() {
		throw new Error("<FormBuilder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set submit(value) {
		throw new Error("<FormBuilder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get beforeChange() {
		throw new Error("<FormBuilder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set beforeChange(value) {
		throw new Error("<FormBuilder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/app/Header.svelte generated by Svelte v3.24.0 */

const { document: document_1$3, window: window_1 } = globals;
const file$12 = "src/components/app/Header.svelte";

function add_css$m() {
	var style = element("style");
	style.id = "svelte-1x3mqf2-style";
	style.textContent = "nav.svelte-1x3mqf2.svelte-1x3mqf2{position:fixed;top:0;width:100%;height:var(--header-height);z-index:7;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-transform:translateY(-100%);transform:translateY(-100%);-webkit-transition:.2s ease-in-out;transition:.2s ease-in-out;color:rgba(var(--color-font-light));-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between;-webkit-box-shadow:var(--shadow-secondary);box-shadow:var(--shadow-secondary);background-color:rgba(var(--color-dark-second))}nav.active.svelte-1x3mqf2.svelte-1x3mqf2{-webkit-transform:none;transform:none\n}.selected.svelte-1x3mqf2.svelte-1x3mqf2{position:relative;display:inline-block}.selected.svelte-1x3mqf2.svelte-1x3mqf2::after{position:absolute;content:\"\";width:calc(100% - 1em);height:2px;background-color:rgb(var(--color-danger));display:block;bottom:-1px}.nav-pages.svelte-1x3mqf2 a.svelte-1x3mqf2{padding:0.8em 0.5em}.nav-actions.svelte-1x3mqf2.svelte-1x3mqf2{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;margin:-3px}.nav-actions.svelte-1x3mqf2 li.svelte-1x3mqf2{padding:3px}.nav-actions.svelte-1x3mqf2 a.svelte-1x3mqf2{display:block}.lang-select.svelte-1x3mqf2.svelte-1x3mqf2{padding:5px;background-color:transparent;color:rgba(var(--color-font-light))}.lang-select.svelte-1x3mqf2.svelte-1x3mqf2:hover,.lang-select.svelte-1x3mqf2.svelte-1x3mqf2:focus{-webkit-box-shadow:none;box-shadow:none;background-color:rgba(var(--color-black), 0.1)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSGVhZGVyLnN2ZWx0ZSIsInNvdXJjZXMiOlsiSGVhZGVyLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0PlxuICAgIGltcG9ydCB7IG9uTW91bnQgfSBmcm9tICdzdmVsdGUnXG4gICAgaW1wb3J0IHsgU3RvcmFnZXMgfSBmcm9tICdAc2VydmljZXMnXG4gICAgaW1wb3J0IHsgY2xhc3NuYW1lcywgc2FmZUdldCB9IGZyb20gJ0B1dGlscydcbiAgICBpbXBvcnQgSWNvbiBmcm9tICdAY29tcG9uZW50cy9JY29uLnN2ZWx0ZSdcbiAgICBpbXBvcnQgQnV0dG9uIGZyb20gJ0Bjb21wb25lbnRzL0J1dHRvbi5zdmVsdGUnXG4gICAgaW1wb3J0IEF2YXRhciBmcm9tICdAY29tcG9uZW50cy9BdmF0YXIuc3ZlbHRlJ1xuXG4gICAgZXhwb3J0IGxldCBzZWdtZW50XG5cbiAgICBsZXQgdmFsdWUgPSAndWEnXG5cbiAgICBjb25zdCBnYXAgPSA1MFxuICAgIGxldCBpc0hlYWRlclZpc2libGUgPSB0cnVlXG4gICAgbGV0IG9uU2Nyb2xsID0gbnVsbFxuICAgIGxldCBsYXN0WSA9IDBcbiAgICAkOiBjbGFzc1Byb3AgPSBjbGFzc25hbWVzKCdjb250YWluZXInLCB7IGFjdGl2ZTogaXNIZWFkZXJWaXNpYmxlIH0pXG4gICAgb25Nb3VudCgoKSA9PiB7XG4gICAgICAgIG9uU2Nyb2xsID0gKCkgPT4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFkgPSB3aW5kb3cucGFnZVlPZmZzZXQ7XG4gICAgICAgICAgICBjb25zdCBkaXJlY3Rpb24gPSBjdXJyZW50WSAtIGxhc3RZXG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uIDwgLWdhcCB8fCBjdXJyZW50WSA8IDUwKSB7IC8vIHVwICg1MCAtIG1heCBzY3JvbGxUb3AgZm9yIGRpc3BsYXlpbmcgaGVhZGVyKVxuICAgICAgICAgICAgICAgIGlmICghaXNIZWFkZXJWaXNpYmxlKSBpc0hlYWRlclZpc2libGUgPSB0cnVlXG4gICAgICAgICAgICAgICAgbGFzdFkgPSBjdXJyZW50WSArIGdhcDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID4gZ2FwKSB7IC8vIGRvd25cbiAgICAgICAgICAgICAgICBpZiAoaXNIZWFkZXJWaXNpYmxlKSBpc0hlYWRlclZpc2libGUgPSBmYWxzZVxuICAgICAgICAgICAgICAgIGxhc3RZID0gY3VycmVudFkgLSBnYXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfSlcblxuICAgIGxldCB0aGVtZU5hbWUgPSBzYWZlR2V0KCgpID0+IFN0b3JhZ2VzLmNvb2tpZVN0b3JhZ2UuZ2V0KCd0aGVtZScpIHx8IFN0b3JhZ2VzLmxvY2FsU3RvcmFnZS5nZXQoJ3RoZW1lJykpXG4gICAgZnVuY3Rpb24gY2hhbmdlVGhlbWUodGhlbWUpIHtcbiAgICAgICAgdGhlbWVOYW1lID0gdGhlbWVcbiAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKCd0aGVtZS1kYXJrJylcbiAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKCd0aGVtZS1saWdodCcpXG4gICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZCh0aGVtZSlcblxuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWFpbicpLmNsYXNzTGlzdC5yZW1vdmUoJ3RoZW1lLWRhcmsnKVxuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWFpbicpLmNsYXNzTGlzdC5yZW1vdmUoJ3RoZW1lLWxpZ2h0JylcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21haW4nKS5jbGFzc0xpc3QuYWRkKHRoZW1lKVxuXG4gICAgICAgIFN0b3JhZ2VzLmNvb2tpZVN0b3JhZ2Uuc2V0KCd0aGVtZScsIHRoZW1lKVxuICAgICAgICBTdG9yYWdlcy5sb2NhbFN0b3JhZ2Uuc2V0KCd0aGVtZScsIHRoZW1lKVxuICAgIH1cblxuICAgIG9uTW91bnQoKCkgPT4ge1xuICAgICAgICBjaGFuZ2VUaGVtZSh0aGVtZU5hbWUpXG4gICAgfSlcbjwvc2NyaXB0PlxuXG48c3ZlbHRlOndpbmRvdyBvbjpzY3JvbGw9e29uU2Nyb2xsfS8+XG48bmF2IGNsYXNzPXtjbGFzc1Byb3B9PlxuICAgIDx1bCBjbGFzcz1cIm5hdi1wYWdlcyBmbGV4XCI+XG4gICAgICAgIDxsaT48YSByZWw9cHJlZmV0Y2ggaHJlZj0nLicgY2xhc3M6c2VsZWN0ZWQ9J3tzZWdtZW50ID09PSB1bmRlZmluZWR9Jz5ob21lPC9hPjwvbGk+XG4gICAgICAgIDxsaT48YSByZWw9cHJlZmV0Y2ggaHJlZj0nbGlzdHMvZnVuZHMnIGNsYXNzOnNlbGVjdGVkPSd7c2VnbWVudCA9PT0gXCJsaXN0c1wifSc+bGlzdHM8L2E+PC9saT5cbiAgICAgICAgPGxpPjxhIGhyZWY9J21hcCcgY2xhc3M6c2VsZWN0ZWQ9J3tzZWdtZW50ID09PSBcIm1hcFwifSc+bWFwPC9hPjwvbGk+XG4gICAgPC91bD5cblxuICAgIDx1bCBjbGFzcz1cIm5hdi1hY3Rpb25zXCI+XG4gICAgICAgIDxsaT5cbiAgICAgICAgICAgIDxzZWxlY3Qge3ZhbHVlfSBuYW1lPVwibGFuZ1wiIGlkPVwibGFuZ1wiIGNsYXNzPVwiYnRuIHNtYWxsIGxhbmctc2VsZWN0XCI+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInVhXCI+VWE8L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicnVcIj5SdTwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJlblwiPkVuPC9vcHRpb24+XG4gICAgICAgICAgICA8L3NlbGVjdD5cbiAgICAgICAgPC9saT5cblxuICAgICAgICA8bGk+XG4gICAgICAgICAgICA8QnV0dG9uIG9uOmNsaWNrPXsoKSA9PiBjaGFuZ2VUaGVtZSh0aGVtZU5hbWUgPT09ICd0aGVtZS1saWdodCcgPyAndGhlbWUtZGFyaycgOiAndGhlbWUtbGlnaHQnKX0gYXV0byBzaXplPVwic21hbGxcIj5cbiAgICAgICAgICAgICAgICA8SWNvbiB0eXBlPVwibW9vblwiIHNpemU9XCJtZWRpdW1cIiBjbGFzcz1cInRoZW1lLXN2Zy1maWxsLW9wcG9zaXRlXCIgaXM9XCJsaWdodFwiLz5cbiAgICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICA8L2xpPlxuXG4gICAgICAgIDxsaT5cbiAgICAgICAgICAgIDxhIGNsYXNzPVwiYnRuIHNtYWxsXCIgaHJlZj1cInVzZXJzL21lXCI+XG4gICAgICAgICAgICAgICAgPEF2YXRhciBzaXplPVwic21hbGxcIiBzcmM9XCJodHRwczovL3BsYWNlaW1nLmNvbS8zMC8zMC9wZW9wbGVcIiBhbHQ9XCJhdmF0YXJcIi8+XG4gICAgICAgICAgICA8L2E+XG4gICAgICAgIDwvbGk+XG4gICAgPC91bD5cbjwvbmF2PlxuXG48c3R5bGU+XG5uYXYge1xuICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICB0b3A6IDA7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiB2YXIoLS1oZWFkZXItaGVpZ2h0KTtcbiAgICB6LWluZGV4OiA3O1xuICAgIGRpc3BsYXk6IC13ZWJraXQtYm94O1xuICAgIGRpc3BsYXk6IC1tcy1mbGV4Ym94O1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgLXdlYmtpdC1ib3gtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgLW1zLWZsZXgtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTEwMCUpO1xuICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC0xMDAlKTtcbiAgICAtd2Via2l0LXRyYW5zaXRpb246IC4ycyBlYXNlLWluLW91dDtcbiAgICB0cmFuc2l0aW9uOiAuMnMgZWFzZS1pbi1vdXQ7XG4gICAgY29sb3I6IHJnYmEodmFyKC0tY29sb3ItZm9udC1saWdodCkpO1xuICAgIC13ZWJraXQtYm94LXBhY2s6IGp1c3RpZnk7XG4gICAgICAgIC1tcy1mbGV4LXBhY2s6IGp1c3RpZnk7XG4gICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgLXdlYmtpdC1ib3gtc2hhZG93OiB2YXIoLS1zaGFkb3ctc2Vjb25kYXJ5KTtcbiAgICAgICAgICAgIGJveC1zaGFkb3c6IHZhcigtLXNoYWRvdy1zZWNvbmRhcnkpO1xuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEodmFyKC0tY29sb3ItZGFyay1zZWNvbmQpKTtcbn1cblxubmF2LmFjdGl2ZSB7XG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IG5vbmU7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IG5vbmVcbn1cblxuLnNlbGVjdGVkIHtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xufVxuXG4uc2VsZWN0ZWQ6OmFmdGVyIHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgY29udGVudDogXCJcIjtcbiAgICB3aWR0aDogY2FsYygxMDAlIC0gMWVtKTtcbiAgICBoZWlnaHQ6IDJweDtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IodmFyKC0tY29sb3ItZGFuZ2VyKSk7XG4gICAgZGlzcGxheTogYmxvY2s7XG4gICAgYm90dG9tOiAtMXB4O1xufVxuXG4ubmF2LXBhZ2VzIGEge1xuICAgIHBhZGRpbmc6IDAuOGVtIDAuNWVtO1xufVxuXG4ubmF2LWFjdGlvbnMge1xuICAgIGRpc3BsYXk6IC13ZWJraXQtYm94O1xuICAgIGRpc3BsYXk6IC1tcy1mbGV4Ym94O1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgLXdlYmtpdC1ib3gtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgLW1zLWZsZXgtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgbWFyZ2luOiAtM3B4O1xufVxuXG4ubmF2LWFjdGlvbnMgbGkge1xuICAgIHBhZGRpbmc6IDNweDtcbn1cblxuLm5hdi1hY3Rpb25zIGEge1xuICAgIGRpc3BsYXk6IGJsb2NrO1xufVxuXG4ubGFuZy1zZWxlY3Qge1xuICAgIHBhZGRpbmc6IDVweDtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcbiAgICBjb2xvcjogcmdiYSh2YXIoLS1jb2xvci1mb250LWxpZ2h0KSk7XG59XG5cbi5sYW5nLXNlbGVjdDpob3Zlcixcbi5sYW5nLXNlbGVjdDpmb2N1cyB7XG4gICAgLXdlYmtpdC1ib3gtc2hhZG93OiBub25lO1xuICAgICAgICAgICAgYm94LXNoYWRvdzogbm9uZTtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKHZhcigtLWNvbG9yLWJsYWNrKSwgMC4xKTtcbn08L3N0eWxlPlxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQW1GQSxHQUFHLDhCQUFDLENBQUMsQUFDRCxRQUFRLENBQUUsS0FBSyxDQUNmLEdBQUcsQ0FBRSxDQUFDLENBQ04sS0FBSyxDQUFFLElBQUksQ0FDWCxNQUFNLENBQUUsSUFBSSxlQUFlLENBQUMsQ0FDNUIsT0FBTyxDQUFFLENBQUMsQ0FDVixPQUFPLENBQUUsV0FBVyxDQUNwQixPQUFPLENBQUUsV0FBVyxDQUNwQixPQUFPLENBQUUsSUFBSSxDQUNiLGlCQUFpQixDQUFFLE1BQU0sQ0FDckIsY0FBYyxDQUFFLE1BQU0sQ0FDbEIsV0FBVyxDQUFFLE1BQU0sQ0FDM0IsaUJBQWlCLENBQUUsV0FBVyxLQUFLLENBQUMsQ0FDNUIsU0FBUyxDQUFFLFdBQVcsS0FBSyxDQUFDLENBQ3BDLGtCQUFrQixDQUFFLEdBQUcsQ0FBQyxXQUFXLENBQ25DLFVBQVUsQ0FBRSxHQUFHLENBQUMsV0FBVyxDQUMzQixLQUFLLENBQUUsS0FBSyxJQUFJLGtCQUFrQixDQUFDLENBQUMsQ0FDcEMsZ0JBQWdCLENBQUUsT0FBTyxDQUNyQixhQUFhLENBQUUsT0FBTyxDQUNsQixlQUFlLENBQUUsYUFBYSxDQUN0QyxrQkFBa0IsQ0FBRSxJQUFJLGtCQUFrQixDQUFDLENBQ25DLFVBQVUsQ0FBRSxJQUFJLGtCQUFrQixDQUFDLENBQzNDLGdCQUFnQixDQUFFLEtBQUssSUFBSSxtQkFBbUIsQ0FBQyxDQUFDLEFBQ3BELENBQUMsQUFFRCxHQUFHLE9BQU8sOEJBQUMsQ0FBQyxBQUNSLGlCQUFpQixDQUFFLElBQUksQ0FDZixTQUFTLENBQUUsSUFBSTtBQUMzQixDQUFDLEFBRUQsU0FBUyw4QkFBQyxDQUFDLEFBQ1AsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsT0FBTyxDQUFFLFlBQVksQUFDekIsQ0FBQyxBQUVELHVDQUFTLE9BQU8sQUFBQyxDQUFDLEFBQ2QsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsT0FBTyxDQUFFLEVBQUUsQ0FDWCxLQUFLLENBQUUsS0FBSyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUN2QixNQUFNLENBQUUsR0FBRyxDQUNYLGdCQUFnQixDQUFFLElBQUksSUFBSSxjQUFjLENBQUMsQ0FBQyxDQUMxQyxPQUFPLENBQUUsS0FBSyxDQUNkLE1BQU0sQ0FBRSxJQUFJLEFBQ2hCLENBQUMsQUFFRCx5QkFBVSxDQUFDLENBQUMsZUFBQyxDQUFDLEFBQ1YsT0FBTyxDQUFFLEtBQUssQ0FBQyxLQUFLLEFBQ3hCLENBQUMsQUFFRCxZQUFZLDhCQUFDLENBQUMsQUFDVixPQUFPLENBQUUsV0FBVyxDQUNwQixPQUFPLENBQUUsV0FBVyxDQUNwQixPQUFPLENBQUUsSUFBSSxDQUNiLGlCQUFpQixDQUFFLE1BQU0sQ0FDckIsY0FBYyxDQUFFLE1BQU0sQ0FDbEIsV0FBVyxDQUFFLE1BQU0sQ0FDM0IsTUFBTSxDQUFFLElBQUksQUFDaEIsQ0FBQyxBQUVELDJCQUFZLENBQUMsRUFBRSxlQUFDLENBQUMsQUFDYixPQUFPLENBQUUsR0FBRyxBQUNoQixDQUFDLEFBRUQsMkJBQVksQ0FBQyxDQUFDLGVBQUMsQ0FBQyxBQUNaLE9BQU8sQ0FBRSxLQUFLLEFBQ2xCLENBQUMsQUFFRCxZQUFZLDhCQUFDLENBQUMsQUFDVixPQUFPLENBQUUsR0FBRyxDQUNaLGdCQUFnQixDQUFFLFdBQVcsQ0FDN0IsS0FBSyxDQUFFLEtBQUssSUFBSSxrQkFBa0IsQ0FBQyxDQUFDLEFBQ3hDLENBQUMsQUFFRCwwQ0FBWSxNQUFNLENBQ2xCLDBDQUFZLE1BQU0sQUFBQyxDQUFDLEFBQ2hCLGtCQUFrQixDQUFFLElBQUksQ0FDaEIsVUFBVSxDQUFFLElBQUksQ0FDeEIsZ0JBQWdCLENBQUUsS0FBSyxJQUFJLGFBQWEsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEFBQ25ELENBQUMifQ== */";
	append_dev(document_1$3.head, style);
}

// (70:12) <Button on:click={() => changeTheme(themeName === 'theme-light' ? 'theme-dark' : 'theme-light')} auto size="small">
function create_default_slot$G(ctx) {
	let icon;
	let current;

	icon = new Icon({
			props: {
				type: "moon",
				size: "medium",
				class: "theme-svg-fill-opposite",
				is: "light"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(icon.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$G.name,
		type: "slot",
		source: "(70:12) <Button on:click={() => changeTheme(themeName === 'theme-light' ? 'theme-dark' : 'theme-light')} auto size=\\\"small\\\">",
		ctx
	});

	return block;
}

function create_fragment$12(ctx) {
	let nav;
	let ul0;
	let li0;
	let a0;
	let t0;
	let t1;
	let li1;
	let a1;
	let t2;
	let t3;
	let li2;
	let a2;
	let t4;
	let t5;
	let ul1;
	let li3;
	let select;
	let option0;
	let t6;
	let option1;
	let t7;
	let option2;
	let t8;
	let t9;
	let li4;
	let button;
	let t10;
	let li5;
	let a3;
	let avatar;
	let nav_class_value;
	let current;
	let mounted;
	let dispose;

	button = new Button({
			props: {
				auto: true,
				size: "small",
				$$slots: { default: [create_default_slot$G] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button.$on("click", /*click_handler*/ ctx[6]);

	avatar = new Avatar({
			props: {
				size: "small",
				src: "https://placeimg.com/30/30/people",
				alt: "avatar"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			nav = element("nav");
			ul0 = element("ul");
			li0 = element("li");
			a0 = element("a");
			t0 = text("home");
			t1 = space();
			li1 = element("li");
			a1 = element("a");
			t2 = text("lists");
			t3 = space();
			li2 = element("li");
			a2 = element("a");
			t4 = text("map");
			t5 = space();
			ul1 = element("ul");
			li3 = element("li");
			select = element("select");
			option0 = element("option");
			t6 = text("Ua");
			option1 = element("option");
			t7 = text("Ru");
			option2 = element("option");
			t8 = text("En");
			t9 = space();
			li4 = element("li");
			create_component(button.$$.fragment);
			t10 = space();
			li5 = element("li");
			a3 = element("a");
			create_component(avatar.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			nav = claim_element(nodes, "NAV", { class: true });
			var nav_nodes = children(nav);
			ul0 = claim_element(nav_nodes, "UL", { class: true });
			var ul0_nodes = children(ul0);
			li0 = claim_element(ul0_nodes, "LI", { class: true });
			var li0_nodes = children(li0);
			a0 = claim_element(li0_nodes, "A", { rel: true, href: true, class: true });
			var a0_nodes = children(a0);
			t0 = claim_text(a0_nodes, "home");
			a0_nodes.forEach(detach_dev);
			li0_nodes.forEach(detach_dev);
			t1 = claim_space(ul0_nodes);
			li1 = claim_element(ul0_nodes, "LI", { class: true });
			var li1_nodes = children(li1);
			a1 = claim_element(li1_nodes, "A", { rel: true, href: true, class: true });
			var a1_nodes = children(a1);
			t2 = claim_text(a1_nodes, "lists");
			a1_nodes.forEach(detach_dev);
			li1_nodes.forEach(detach_dev);
			t3 = claim_space(ul0_nodes);
			li2 = claim_element(ul0_nodes, "LI", { class: true });
			var li2_nodes = children(li2);
			a2 = claim_element(li2_nodes, "A", { href: true, class: true });
			var a2_nodes = children(a2);
			t4 = claim_text(a2_nodes, "map");
			a2_nodes.forEach(detach_dev);
			li2_nodes.forEach(detach_dev);
			ul0_nodes.forEach(detach_dev);
			t5 = claim_space(nav_nodes);
			ul1 = claim_element(nav_nodes, "UL", { class: true });
			var ul1_nodes = children(ul1);
			li3 = claim_element(ul1_nodes, "LI", { class: true });
			var li3_nodes = children(li3);

			select = claim_element(li3_nodes, "SELECT", {
				value: true,
				name: true,
				id: true,
				class: true
			});

			var select_nodes = children(select);
			option0 = claim_element(select_nodes, "OPTION", { value: true });
			var option0_nodes = children(option0);
			t6 = claim_text(option0_nodes, "Ua");
			option0_nodes.forEach(detach_dev);
			option1 = claim_element(select_nodes, "OPTION", { value: true });
			var option1_nodes = children(option1);
			t7 = claim_text(option1_nodes, "Ru");
			option1_nodes.forEach(detach_dev);
			option2 = claim_element(select_nodes, "OPTION", { value: true });
			var option2_nodes = children(option2);
			t8 = claim_text(option2_nodes, "En");
			option2_nodes.forEach(detach_dev);
			select_nodes.forEach(detach_dev);
			li3_nodes.forEach(detach_dev);
			t9 = claim_space(ul1_nodes);
			li4 = claim_element(ul1_nodes, "LI", { class: true });
			var li4_nodes = children(li4);
			claim_component(button.$$.fragment, li4_nodes);
			li4_nodes.forEach(detach_dev);
			t10 = claim_space(ul1_nodes);
			li5 = claim_element(ul1_nodes, "LI", { class: true });
			var li5_nodes = children(li5);
			a3 = claim_element(li5_nodes, "A", { class: true, href: true });
			var a3_nodes = children(a3);
			claim_component(avatar.$$.fragment, a3_nodes);
			a3_nodes.forEach(detach_dev);
			li5_nodes.forEach(detach_dev);
			ul1_nodes.forEach(detach_dev);
			nav_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a0, "rel", "prefetch");
			attr_dev(a0, "href", ".");
			attr_dev(a0, "class", "svelte-1x3mqf2");
			toggle_class(a0, "selected", /*segment*/ ctx[0] === undefined);
			add_location(a0, file$12, 54, 12, 1867);
			attr_dev(li0, "class", "svelte-1x3mqf2");
			add_location(li0, file$12, 54, 8, 1863);
			attr_dev(a1, "rel", "prefetch");
			attr_dev(a1, "href", "lists/funds");
			attr_dev(a1, "class", "svelte-1x3mqf2");
			toggle_class(a1, "selected", /*segment*/ ctx[0] === "lists");
			add_location(a1, file$12, 55, 12, 1959);
			attr_dev(li1, "class", "svelte-1x3mqf2");
			add_location(li1, file$12, 55, 8, 1955);
			attr_dev(a2, "href", "map");
			attr_dev(a2, "class", "svelte-1x3mqf2");
			toggle_class(a2, "selected", /*segment*/ ctx[0] === "map");
			add_location(a2, file$12, 56, 12, 2060);
			attr_dev(li2, "class", "svelte-1x3mqf2");
			add_location(li2, file$12, 56, 8, 2056);
			attr_dev(ul0, "class", "nav-pages flex svelte-1x3mqf2");
			add_location(ul0, file$12, 53, 4, 1827);
			option0.__value = "ua";
			option0.value = option0.__value;
			add_location(option0, file$12, 62, 16, 2274);
			option1.__value = "ru";
			option1.value = option1.__value;
			add_location(option1, file$12, 63, 16, 2321);
			option2.__value = "en";
			option2.value = option2.__value;
			add_location(option2, file$12, 64, 16, 2368);
			attr_dev(select, "name", "lang");
			attr_dev(select, "id", "lang");
			attr_dev(select, "class", "btn small lang-select svelte-1x3mqf2");
			add_location(select, file$12, 61, 12, 2189);
			attr_dev(li3, "class", "svelte-1x3mqf2");
			add_location(li3, file$12, 60, 8, 2172);
			attr_dev(li4, "class", "svelte-1x3mqf2");
			add_location(li4, file$12, 68, 8, 2444);
			attr_dev(a3, "class", "btn small svelte-1x3mqf2");
			attr_dev(a3, "href", "users/me");
			add_location(a3, file$12, 75, 12, 2732);
			attr_dev(li5, "class", "svelte-1x3mqf2");
			add_location(li5, file$12, 74, 8, 2715);
			attr_dev(ul1, "class", "nav-actions svelte-1x3mqf2");
			add_location(ul1, file$12, 59, 4, 2139);
			attr_dev(nav, "class", nav_class_value = "" + (null_to_empty(/*classProp*/ ctx[3]) + " svelte-1x3mqf2"));
			add_location(nav, file$12, 52, 0, 1799);
		},
		m: function mount(target, anchor) {
			insert_dev(target, nav, anchor);
			append_dev(nav, ul0);
			append_dev(ul0, li0);
			append_dev(li0, a0);
			append_dev(a0, t0);
			append_dev(ul0, t1);
			append_dev(ul0, li1);
			append_dev(li1, a1);
			append_dev(a1, t2);
			append_dev(ul0, t3);
			append_dev(ul0, li2);
			append_dev(li2, a2);
			append_dev(a2, t4);
			append_dev(nav, t5);
			append_dev(nav, ul1);
			append_dev(ul1, li3);
			append_dev(li3, select);
			append_dev(select, option0);
			append_dev(option0, t6);
			append_dev(select, option1);
			append_dev(option1, t7);
			append_dev(select, option2);
			append_dev(option2, t8);
			select_option(select, /*value*/ ctx[4]);
			append_dev(ul1, t9);
			append_dev(ul1, li4);
			mount_component(button, li4, null);
			append_dev(ul1, t10);
			append_dev(ul1, li5);
			append_dev(li5, a3);
			mount_component(avatar, a3, null);
			current = true;

			if (!mounted) {
				dispose = listen_dev(
					window_1,
					"scroll",
					function () {
						if (is_function(/*onScroll*/ ctx[1])) /*onScroll*/ ctx[1].apply(this, arguments);
					},
					false,
					false,
					false
				);

				mounted = true;
			}
		},
		p: function update(new_ctx, [dirty]) {
			ctx = new_ctx;

			if (dirty & /*segment, undefined*/ 1) {
				toggle_class(a0, "selected", /*segment*/ ctx[0] === undefined);
			}

			if (dirty & /*segment*/ 1) {
				toggle_class(a1, "selected", /*segment*/ ctx[0] === "lists");
			}

			if (dirty & /*segment*/ 1) {
				toggle_class(a2, "selected", /*segment*/ ctx[0] === "map");
			}

			const button_changes = {};

			if (dirty & /*$$scope*/ 512) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);

			if (!current || dirty & /*classProp*/ 8 && nav_class_value !== (nav_class_value = "" + (null_to_empty(/*classProp*/ ctx[3]) + " svelte-1x3mqf2"))) {
				attr_dev(nav, "class", nav_class_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			transition_in(avatar.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button.$$.fragment, local);
			transition_out(avatar.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(nav);
			destroy_component(button);
			destroy_component(avatar);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$12.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const gap = 50;

function instance$12($$self, $$props, $$invalidate) {
	let { segment } = $$props;
	let value = "ua";
	let isHeaderVisible = true;
	let onScroll = null;
	let lastY = 0;

	onMount(() => {
		$$invalidate(1, onScroll = () => requestAnimationFrame(function () {
			const currentY = window.pageYOffset;
			const direction = currentY - lastY;

			if (direction < -gap || currentY < 50) {
				// up (50 - max scrollTop for displaying header)
				if (!isHeaderVisible) $$invalidate(7, isHeaderVisible = true);

				lastY = currentY + gap;
			} else if (direction > gap) {
				// down
				if (isHeaderVisible) $$invalidate(7, isHeaderVisible = false);

				lastY = currentY - gap;
			}
		}));
	});

	let themeName = safeGet(() => cookieStorage.get("theme") || localStorage.get("theme"));

	function changeTheme(theme) {
		$$invalidate(2, themeName = theme);
		document.body.classList.remove("theme-dark");
		document.body.classList.remove("theme-light");
		document.body.classList.add(theme);
		document.getElementById("main").classList.remove("theme-dark");
		document.getElementById("main").classList.remove("theme-light");
		document.getElementById("main").classList.add(theme);
		cookieStorage.set("theme", theme);
		localStorage.set("theme", theme);
	}

	onMount(() => {
		changeTheme(themeName);
	});

	const writable_props = ["segment"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Header> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Header", $$slots, []);

	const click_handler = () => changeTheme(themeName === "theme-light"
	? "theme-dark"
	: "theme-light");

	$$self.$set = $$props => {
		if ("segment" in $$props) $$invalidate(0, segment = $$props.segment);
	};

	$$self.$capture_state = () => ({
		onMount,
		Storages,
		classnames,
		safeGet,
		Icon,
		Button,
		Avatar,
		segment,
		value,
		gap,
		isHeaderVisible,
		onScroll,
		lastY,
		themeName,
		changeTheme,
		classProp
	});

	$$self.$inject_state = $$props => {
		if ("segment" in $$props) $$invalidate(0, segment = $$props.segment);
		if ("value" in $$props) $$invalidate(4, value = $$props.value);
		if ("isHeaderVisible" in $$props) $$invalidate(7, isHeaderVisible = $$props.isHeaderVisible);
		if ("onScroll" in $$props) $$invalidate(1, onScroll = $$props.onScroll);
		if ("lastY" in $$props) lastY = $$props.lastY;
		if ("themeName" in $$props) $$invalidate(2, themeName = $$props.themeName);
		if ("classProp" in $$props) $$invalidate(3, classProp = $$props.classProp);
	};

	let classProp;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*isHeaderVisible*/ 128) {
			 $$invalidate(3, classProp = classnames("container", { active: isHeaderVisible }));
		}
	};

	return [segment, onScroll, themeName, classProp, value, changeTheme, click_handler];
}

class Header extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document_1$3.getElementById("svelte-1x3mqf2-style")) add_css$m();
		init(this, options, instance$12, create_fragment$12, safe_not_equal, { segment: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Header",
			options,
			id: create_fragment$12.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*segment*/ ctx[0] === undefined && !("segment" in props)) {
			console.warn("<Header> was created without expected prop 'segment'");
		}
	}

	get segment() {
		throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set segment(value) {
		throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/app/Footer.svelte generated by Svelte v3.24.0 */
const file$13 = "src/components/app/Footer.svelte";

function add_css$n() {
	var style = element("style");
	style.id = "svelte-e0hzot-style";
	style.textContent = "footer.svelte-e0hzot{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between;padding:var(--screen-padding);-webkit-box-shadow:inset var(--shadow-primary);box-shadow:inset var(--shadow-primary);background-color:rgba(var(--theme-bg-color))}ul.svelte-e0hzot{display:-webkit-box;display:-ms-flexbox;display:flex;margin:-3px}li.svelte-e0hzot{padding:3px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRm9vdGVyLnN2ZWx0ZSIsInNvdXJjZXMiOlsiRm9vdGVyLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0PlxuICAgIGltcG9ydCBCdXR0b24gZnJvbSAnQGNvbXBvbmVudHMvQnV0dG9uLnN2ZWx0ZSdcbjwvc2NyaXB0PlxuXG48Zm9vdGVyPlxuICAgIDxwPsKpIHtuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCl9PC9wPlxuICAgIDx1bD5cbiAgICAgICAgPGxpPlxuICAgICAgICAgICAgPEJ1dHRvbiBzaXplPVwic21hbGxcIiBpcz1cInN1Y2Nlc3NcIj5BY3Rpb248L0J1dHRvbj5cbiAgICAgICAgPC9saT5cbiAgICA8L3VsPlxuPC9mb290ZXI+XG5cbjxzdHlsZT5cbmZvb3RlciB7XG4gICAgZGlzcGxheTogLXdlYmtpdC1ib3g7XG4gICAgZGlzcGxheTogLW1zLWZsZXhib3g7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICAtd2Via2l0LWJveC1hbGlnbjogY2VudGVyO1xuICAgICAgICAtbXMtZmxleC1hbGlnbjogY2VudGVyO1xuICAgICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAtd2Via2l0LWJveC1wYWNrOiBqdXN0aWZ5O1xuICAgICAgICAtbXMtZmxleC1wYWNrOiBqdXN0aWZ5O1xuICAgICAgICAgICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgIHBhZGRpbmc6IHZhcigtLXNjcmVlbi1wYWRkaW5nKTtcbiAgICAtd2Via2l0LWJveC1zaGFkb3c6IGluc2V0IHZhcigtLXNoYWRvdy1wcmltYXJ5KTtcbiAgICAgICAgICAgIGJveC1zaGFkb3c6IGluc2V0IHZhcigtLXNoYWRvdy1wcmltYXJ5KTtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKHZhcigtLXRoZW1lLWJnLWNvbG9yKSk7XG59XG5cbnVsIHtcbiAgICBkaXNwbGF5OiAtd2Via2l0LWJveDtcbiAgICBkaXNwbGF5OiAtbXMtZmxleGJveDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIG1hcmdpbjogLTNweDtcbn1cblxubGkge1xuICAgIHBhZGRpbmc6IDNweDtcbn08L3N0eWxlPlxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQWNBLE1BQU0sY0FBQyxDQUFDLEFBQ0osT0FBTyxDQUFFLFdBQVcsQ0FDcEIsT0FBTyxDQUFFLFdBQVcsQ0FDcEIsT0FBTyxDQUFFLElBQUksQ0FDYixpQkFBaUIsQ0FBRSxNQUFNLENBQ3JCLGNBQWMsQ0FBRSxNQUFNLENBQ2xCLFdBQVcsQ0FBRSxNQUFNLENBQzNCLGdCQUFnQixDQUFFLE9BQU8sQ0FDckIsYUFBYSxDQUFFLE9BQU8sQ0FDbEIsZUFBZSxDQUFFLGFBQWEsQ0FDdEMsT0FBTyxDQUFFLElBQUksZ0JBQWdCLENBQUMsQ0FDOUIsa0JBQWtCLENBQUUsS0FBSyxDQUFDLElBQUksZ0JBQWdCLENBQUMsQ0FDdkMsVUFBVSxDQUFFLEtBQUssQ0FBQyxJQUFJLGdCQUFnQixDQUFDLENBQy9DLGdCQUFnQixDQUFFLEtBQUssSUFBSSxnQkFBZ0IsQ0FBQyxDQUFDLEFBQ2pELENBQUMsQUFFRCxFQUFFLGNBQUMsQ0FBQyxBQUNBLE9BQU8sQ0FBRSxXQUFXLENBQ3BCLE9BQU8sQ0FBRSxXQUFXLENBQ3BCLE9BQU8sQ0FBRSxJQUFJLENBQ2IsTUFBTSxDQUFFLElBQUksQUFDaEIsQ0FBQyxBQUVELEVBQUUsY0FBQyxDQUFDLEFBQ0EsT0FBTyxDQUFFLEdBQUcsQUFDaEIsQ0FBQyJ9 */";
	append_dev(document.head, style);
}

// (9:12) <Button size="small" is="success">
function create_default_slot$H(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Action");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Action");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$H.name,
		type: "slot",
		source: "(9:12) <Button size=\\\"small\\\" is=\\\"success\\\">",
		ctx
	});

	return block;
}

function create_fragment$13(ctx) {
	let footer;
	let p;
	let t0;
	let t1_value = new Date().getFullYear() + "";
	let t1;
	let t2;
	let ul;
	let li;
	let button;
	let current;

	button = new Button({
			props: {
				size: "small",
				is: "success",
				$$slots: { default: [create_default_slot$H] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			footer = element("footer");
			p = element("p");
			t0 = text("© ");
			t1 = text(t1_value);
			t2 = space();
			ul = element("ul");
			li = element("li");
			create_component(button.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			footer = claim_element(nodes, "FOOTER", { class: true });
			var footer_nodes = children(footer);
			p = claim_element(footer_nodes, "P", {});
			var p_nodes = children(p);
			t0 = claim_text(p_nodes, "© ");
			t1 = claim_text(p_nodes, t1_value);
			p_nodes.forEach(detach_dev);
			t2 = claim_space(footer_nodes);
			ul = claim_element(footer_nodes, "UL", { class: true });
			var ul_nodes = children(ul);
			li = claim_element(ul_nodes, "LI", { class: true });
			var li_nodes = children(li);
			claim_component(button.$$.fragment, li_nodes);
			li_nodes.forEach(detach_dev);
			ul_nodes.forEach(detach_dev);
			footer_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(p, file$13, 5, 4, 84);
			attr_dev(li, "class", "svelte-e0hzot");
			add_location(li, file$13, 7, 8, 137);
			attr_dev(ul, "class", "svelte-e0hzot");
			add_location(ul, file$13, 6, 4, 124);
			attr_dev(footer, "class", "svelte-e0hzot");
			add_location(footer, file$13, 4, 0, 71);
		},
		m: function mount(target, anchor) {
			insert_dev(target, footer, anchor);
			append_dev(footer, p);
			append_dev(p, t0);
			append_dev(p, t1);
			append_dev(footer, t2);
			append_dev(footer, ul);
			append_dev(ul, li);
			mount_component(button, li, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const button_changes = {};

			if (dirty & /*$$scope*/ 1) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(footer);
			destroy_component(button);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$13.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$13($$self, $$props, $$invalidate) {
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Footer> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Footer", $$slots, []);
	$$self.$capture_state = () => ({ Button });
	return [];
}

class Footer extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document.getElementById("svelte-e0hzot-style")) add_css$n();
		init(this, options, instance$13, create_fragment$13, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Footer",
			options,
			id: create_fragment$13.name
		});
	}
}

/* src/components/app/SocialsX.svelte generated by Svelte v3.24.0 */
const file$14 = "src/components/app/SocialsX.svelte";

function add_css$o() {
	var style = element("style");
	style.id = "svelte-x7o1bc-style";
	style.textContent = ".social-icons.svelte-x7o1bc li.svelte-x7o1bc{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;width:40px;height:40px;border-radius:50%;overflow:hidden;margin:0 10px}.social-icons.svelte-x7o1bc .telegram.svelte-x7o1bc{background-color:#2197D2}.social-icons.svelte-x7o1bc .facebook.svelte-x7o1bc{background-color:#4267B2}.social-icons.svelte-x7o1bc .viber.svelte-x7o1bc{background-color:#665CAC}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU29jaWFsc1guc3ZlbHRlIiwic291cmNlcyI6WyJTb2NpYWxzWC5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdD5cbiAgICBpbXBvcnQgSWNvbiBmcm9tICcuLi9JY29uLnN2ZWx0ZSdcbiAgICBpbXBvcnQgTG9hZGVyIGZyb20gJy4uL2xvYWRlci9Mb2FkZXIuc3ZlbHRlJ1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge3tcbiAgICAgKiAgaHJlZjogc3RyaW5nLFxuICAgICAqICB0aXRsZTogc3RyaW5nLFxuICAgICAqICB0eXBlOiBDb25maWcuSWNvbnMsXG4gICAgICogfVtdfVxuICAgICAqL1xuICAgIGV4cG9ydCBsZXQgaXRlbXNcblxuICAgICQ6IGxpc3QgPSBpdGVtcyA9PT0gbnVsbCA/IFtudWxsLCBudWxsLCBudWxsXSA6IGl0ZW1zIHx8IFtdXG48L3NjcmlwdD5cblxuPHVsIGNsYXNzPVwiZmxleCBmbGV4LWp1c3RpZnktY2VudGVyIHNvY2lhbC1pY29uc1wiPlxuICAgIHsjZWFjaCBsaXN0IGFzIGl0ZW19XG4gICAgICAgIHsjaWYgaXRlbSAhPT0gbnVsbH1cbiAgICAgICAgICAgIDxsaSBjbGFzcz17aXRlbS50eXBlfT5cbiAgICAgICAgICAgICAgICA8c2xvdCB7aXRlbX0+XG4gICAgICAgICAgICAgICAgICAgIHsjaWYgaXRlbS5ocmVmfVxuICAgICAgICAgICAgICAgICAgICAgICAgPGEgaHJlZj17aXRlbS5ocmVmfSB0YXJnZXQ9XCJfYmxhbmtcIiB0aXRsZT17aXRlbS50aXRsZX0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPEljb24gdHlwZT17aXRlbS50eXBlfSBpcz1cImxpZ2h0XCIgc2l6ZT1cIm1lZGl1bVwiLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvYT5cbiAgICAgICAgICAgICAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gb246Y2xpY2s+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPEljb24gdHlwZT17aXRlbS50eXBlfSBpcz1cImxpZ2h0XCIgc2l6ZT1cIm1lZGl1bVwiLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgICAgICA8L3Nsb3Q+XG4gICAgICAgICAgICA8L2xpPlxuICAgICAgICB7OmVsc2V9XG4gICAgICAgICAgICA8bGkgc3R5bGU9XCJwYWRkaW5nOiAwIDEwcHg7IHdpZHRoOiA2MHB4OyBoZWlnaHQ6IDQ1cHg7IG92ZXJmbG93OiBoaWRkZW5cIj5cbiAgICAgICAgICAgICAgICA8TG9hZGVyIHR5cGU9XCJhdmF0YXJcIi8+XG4gICAgICAgICAgICA8L2xpPlxuICAgICAgICB7L2lmfVxuICAgIHsvZWFjaH1cbjwvdWw+XG5cbjxzdHlsZT5cbi5zb2NpYWwtaWNvbnMgbGkge1xuICAgIGRpc3BsYXk6IC13ZWJraXQtYm94O1xuICAgIGRpc3BsYXk6IC1tcy1mbGV4Ym94O1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgLXdlYmtpdC1ib3gtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgLW1zLWZsZXgtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgLXdlYmtpdC1ib3gtcGFjazogY2VudGVyO1xuICAgICAgICAtbXMtZmxleC1wYWNrOiBjZW50ZXI7XG4gICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICB3aWR0aDogNDBweDtcbiAgICBoZWlnaHQ6IDQwcHg7XG4gICAgYm9yZGVyLXJhZGl1czogNTAlO1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgbWFyZ2luOiAwIDEwcHg7XG59XG5cbi5zb2NpYWwtaWNvbnMgLnRlbGVncmFtIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMjE5N0QyO1xufVxuLnNvY2lhbC1pY29ucyAuZmFjZWJvb2sge1xuICAgIGJhY2tncm91bmQtY29sb3I6ICM0MjY3QjI7XG59XG4uc29jaWFsLWljb25zIC52aWJlciB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzY2NUNBQztcbn08L3N0eWxlPlxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQXlDQSwyQkFBYSxDQUFDLEVBQUUsY0FBQyxDQUFDLEFBQ2QsT0FBTyxDQUFFLFdBQVcsQ0FDcEIsT0FBTyxDQUFFLFdBQVcsQ0FDcEIsT0FBTyxDQUFFLElBQUksQ0FDYixpQkFBaUIsQ0FBRSxNQUFNLENBQ3JCLGNBQWMsQ0FBRSxNQUFNLENBQ2xCLFdBQVcsQ0FBRSxNQUFNLENBQzNCLGdCQUFnQixDQUFFLE1BQU0sQ0FDcEIsYUFBYSxDQUFFLE1BQU0sQ0FDakIsZUFBZSxDQUFFLE1BQU0sQ0FDL0IsS0FBSyxDQUFFLElBQUksQ0FDWCxNQUFNLENBQUUsSUFBSSxDQUNaLGFBQWEsQ0FBRSxHQUFHLENBQ2xCLFFBQVEsQ0FBRSxNQUFNLENBQ2hCLE1BQU0sQ0FBRSxDQUFDLENBQUMsSUFBSSxBQUNsQixDQUFDLEFBRUQsMkJBQWEsQ0FBQyxTQUFTLGNBQUMsQ0FBQyxBQUNyQixnQkFBZ0IsQ0FBRSxPQUFPLEFBQzdCLENBQUMsQUFDRCwyQkFBYSxDQUFDLFNBQVMsY0FBQyxDQUFDLEFBQ3JCLGdCQUFnQixDQUFFLE9BQU8sQUFDN0IsQ0FBQyxBQUNELDJCQUFhLENBQUMsTUFBTSxjQUFDLENBQUMsQUFDbEIsZ0JBQWdCLENBQUUsT0FBTyxBQUM3QixDQUFDIn0= */";
	append_dev(document.head, style);
}

const get_default_slot_changes$5 = dirty => ({ item: dirty & /*list*/ 1 });
const get_default_slot_context$5 = ctx => ({ item: /*item*/ ctx[5] });

function get_each_context$7(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[5] = list[i];
	return child_ctx;
}

// (33:8) {:else}
function create_else_block_1$1(ctx) {
	let li;
	let loader;
	let t;
	let current;

	loader = new Loader({
			props: { type: "avatar" },
			$$inline: true
		});

	const block = {
		c: function create() {
			li = element("li");
			create_component(loader.$$.fragment);
			t = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { style: true, class: true });
			var li_nodes = children(li);
			claim_component(loader.$$.fragment, li_nodes);
			t = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_style(li, "padding", "0 10px");
			set_style(li, "width", "60px");
			set_style(li, "height", "45px");
			set_style(li, "overflow", "hidden");
			attr_dev(li, "class", "svelte-x7o1bc");
			add_location(li, file$14, 33, 12, 977);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			mount_component(loader, li, null);
			append_dev(li, t);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(loader.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loader.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			destroy_component(loader);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1$1.name,
		type: "else",
		source: "(33:8) {:else}",
		ctx
	});

	return block;
}

// (19:8) {#if item !== null}
function create_if_block$l(ctx) {
	let li;
	let t;
	let li_class_value;
	let current;
	const default_slot_template = /*$$slots*/ ctx[3].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], get_default_slot_context$5);
	const default_slot_or_fallback = default_slot || fallback_block$7(ctx);

	const block = {
		c: function create() {
			li = element("li");
			if (default_slot_or_fallback) default_slot_or_fallback.c();
			t = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true });
			var li_nodes = children(li);
			if (default_slot_or_fallback) default_slot_or_fallback.l(li_nodes);
			t = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(li, "class", li_class_value = "" + (null_to_empty(/*item*/ ctx[5].type) + " svelte-x7o1bc"));
			add_location(li, file$14, 19, 12, 427);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);

			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(li, null);
			}

			append_dev(li, t);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope, list*/ 5) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[2], dirty, get_default_slot_changes$5, get_default_slot_context$5);
				}
			} else {
				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*list*/ 1) {
					default_slot_or_fallback.p(ctx, dirty);
				}
			}

			if (!current || dirty & /*list*/ 1 && li_class_value !== (li_class_value = "" + (null_to_empty(/*item*/ ctx[5].type) + " svelte-x7o1bc"))) {
				attr_dev(li, "class", li_class_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot_or_fallback, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot_or_fallback, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$l.name,
		type: "if",
		source: "(19:8) {#if item !== null}",
		ctx
	});

	return block;
}

// (26:20) {:else}
function create_else_block$6(ctx) {
	let span;
	let icon;
	let current;
	let mounted;
	let dispose;

	icon = new Icon({
			props: {
				type: /*item*/ ctx[5].type,
				is: "light",
				size: "medium"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			span = element("span");
			create_component(icon.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", {});
			var span_nodes = children(span);
			claim_component(icon.$$.fragment, span_nodes);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(span, file$14, 26, 24, 755);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			mount_component(icon, span, null);
			current = true;

			if (!mounted) {
				dispose = listen_dev(span, "click", /*click_handler*/ ctx[4], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			const icon_changes = {};
			if (dirty & /*list*/ 1) icon_changes.type = /*item*/ ctx[5].type;
			icon.$set(icon_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			destroy_component(icon);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$6.name,
		type: "else",
		source: "(26:20) {:else}",
		ctx
	});

	return block;
}

// (22:20) {#if item.href}
function create_if_block_1$d(ctx) {
	let a;
	let icon;
	let a_href_value;
	let a_title_value;
	let current;

	icon = new Icon({
			props: {
				type: /*item*/ ctx[5].type,
				is: "light",
				size: "medium"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			a = element("a");
			create_component(icon.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			a = claim_element(nodes, "A", { href: true, target: true, title: true });
			var a_nodes = children(a);
			claim_component(icon.$$.fragment, a_nodes);
			a_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a, "href", a_href_value = /*item*/ ctx[5].href);
			attr_dev(a, "target", "_blank");
			attr_dev(a, "title", a_title_value = /*item*/ ctx[5].title);
			add_location(a, file$14, 22, 24, 540);
		},
		m: function mount(target, anchor) {
			insert_dev(target, a, anchor);
			mount_component(icon, a, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const icon_changes = {};
			if (dirty & /*list*/ 1) icon_changes.type = /*item*/ ctx[5].type;
			icon.$set(icon_changes);

			if (!current || dirty & /*list*/ 1 && a_href_value !== (a_href_value = /*item*/ ctx[5].href)) {
				attr_dev(a, "href", a_href_value);
			}

			if (!current || dirty & /*list*/ 1 && a_title_value !== (a_title_value = /*item*/ ctx[5].title)) {
				attr_dev(a, "title", a_title_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(a);
			destroy_component(icon);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$d.name,
		type: "if",
		source: "(22:20) {#if item.href}",
		ctx
	});

	return block;
}

// (21:29)                      
function fallback_block$7(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_1$d, create_else_block$6];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*item*/ ctx[5].href) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_1(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: fallback_block$7.name,
		type: "fallback",
		source: "(21:29)                      ",
		ctx
	});

	return block;
}

// (18:4) {#each list as item}
function create_each_block$7(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$l, create_else_block_1$1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*item*/ ctx[5] !== null) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$7.name,
		type: "each",
		source: "(18:4) {#each list as item}",
		ctx
	});

	return block;
}

function create_fragment$14(ctx) {
	let ul;
	let current;
	let each_value = /*list*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(ul_nodes);
			}

			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(ul, "class", "flex flex-justify-center social-icons svelte-x7o1bc");
			add_location(ul, file$14, 16, 0, 311);
		},
		m: function mount(target, anchor) {
			insert_dev(target, ul, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*list, $$scope*/ 5) {
				each_value = /*list*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$7(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$7(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(ul, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(ul);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$14.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$14($$self, $$props, $$invalidate) {
	let { items } = $$props;
	const writable_props = ["items"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SocialsX> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("SocialsX", $$slots, ['default']);

	function click_handler(event) {
		bubble($$self, event);
	}

	$$self.$set = $$props => {
		if ("items" in $$props) $$invalidate(1, items = $$props.items);
		if ("$$scope" in $$props) $$invalidate(2, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({ Icon, Loader, items, list });

	$$self.$inject_state = $$props => {
		if ("items" in $$props) $$invalidate(1, items = $$props.items);
		if ("list" in $$props) $$invalidate(0, list = $$props.list);
	};

	let list;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*items*/ 2) {
			 $$invalidate(0, list = items === null ? [null, null, null] : items || []);
		}
	};

	return [list, items, $$scope, $$slots, click_handler];
}

class SocialsX extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document.getElementById("svelte-x7o1bc-style")) add_css$o();
		init(this, options, instance$14, create_fragment$14, safe_not_equal, { items: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "SocialsX",
			options,
			id: create_fragment$14.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*items*/ ctx[1] === undefined && !("items" in props)) {
			console.warn("<SocialsX> was created without expected prop 'items'");
		}
	}

	get items() {
		throw new Error("<SocialsX>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set items(value) {
		throw new Error("<SocialsX>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/app/SocialsY.svelte generated by Svelte v3.24.0 */
const file$15 = "src/components/app/SocialsY.svelte";

function add_css$p() {
	var style = element("style");
	style.id = "svelte-1qjherp-style";
	style.textContent = ".social-icons.svelte-1qjherp li.svelte-1qjherp{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;overflow:hidden;margin:7px 0}.social-icons.svelte-1qjherp .inner.svelte-1qjherp{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.social-icons.svelte-1qjherp .icon-wrap.svelte-1qjherp{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;width:26px;height:26px;border-radius:50%;background-color:rgba(var(--color-dark))}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU29jaWFsc1kuc3ZlbHRlIiwic291cmNlcyI6WyJTb2NpYWxzWS5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiXG48c2NyaXB0PlxuICAgIGltcG9ydCBJY29uIGZyb20gJy4uL0ljb24uc3ZlbHRlJ1xuICAgIGltcG9ydCBMb2FkZXIgZnJvbSAnLi4vbG9hZGVyL0xvYWRlci5zdmVsdGUnXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7e1xuICAgICAqICBocmVmOiBzdHJpbmcsXG4gICAgICogIHRpdGxlOiBzdHJpbmcsXG4gICAgICogIHR5cGU6IENvbmZpZy5JY29ucyxcbiAgICAgKiB9W119XG4gICAgICovXG4gICAgZXhwb3J0IGxldCBpdGVtc1xuXG4gICAgJDogbGlzdCA9IGl0ZW1zID09PSBudWxsID8gW251bGwsIG51bGwsIG51bGxdIDogaXRlbXMgfHwgW11cbjwvc2NyaXB0PlxuXG48dWwgY2xhc3M9XCJzb2NpYWwtaWNvbnNcIj5cbiAgICB7I2VhY2ggbGlzdCBhcyBpdGVtfVxuICAgICAgICA8bGk+XG4gICAgICAgICAgICB7I2lmIGl0ZW0gIT09IG51bGx9XG4gICAgICAgICAgICAgICAgPHNsb3Qge2l0ZW19PlxuICAgICAgICAgICAgICAgICAgICB7I2lmIGl0ZW0uaHJlZn1cbiAgICAgICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9e2l0ZW0uaHJlZn0gdGFyZ2V0PVwiX2JsYW5rXCIgY2xhc3M9XCJpbm5lclwiIHRpdGxlPXtpdGVtLnRpdGxlfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImljb24td3JhcFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8SWNvbiB0eXBlPXtpdGVtLnR5cGV9IGlzPVwibGlnaHRcIiBzaXplPVwidGlueVwiLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHM+PC9zPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzPjwvcz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cz48L3M+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHAgY2xhc3M9XCJoM1wiPntpdGVtLnRpdGxlfTwvcD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvYT5cbiAgICAgICAgICAgICAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBvbjpjbGljayBjbGFzcz1cImlubmVyXCIgdGl0bGU9e2l0ZW0udGl0bGV9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaWNvbi13cmFwXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxJY29uIHR5cGU9e2l0ZW0udHlwZX0gaXM9XCJsaWdodFwiIHNpemU9XCJ0aW55XCIvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cz48L3M+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHM+PC9zPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzPjwvcz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cCBjbGFzcz1cImgzXCI+e2l0ZW0udGl0bGV9PC9wPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICAgICAgPC9zbG90PlxuICAgICAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZmxleCBmbGV4LWFsaWduLWNlbnRlclwiIHN0eWxlPVwicGFkZGluZzogN3B4IDBcIj5cbiAgICAgICAgICAgICAgICAgICAgPExvYWRlciB0eXBlPVwiaDNcIi8+XG4gICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgey9pZn1cbiAgICAgICAgPC9saT5cbiAgICB7L2VhY2h9XG48L3VsPlxuXG48c3R5bGU+XG4uc29jaWFsLWljb25zIGxpIHtcbiAgICBkaXNwbGF5OiAtd2Via2l0LWJveDtcbiAgICBkaXNwbGF5OiAtbXMtZmxleGJveDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIC13ZWJraXQtYm94LWFsaWduOiBjZW50ZXI7XG4gICAgICAgIC1tcy1mbGV4LWFsaWduOiBjZW50ZXI7XG4gICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgbWFyZ2luOiA3cHggMDtcbn1cblxuLnNvY2lhbC1pY29ucyAuaW5uZXIge1xuICAgIGRpc3BsYXk6IC13ZWJraXQtYm94O1xuICAgIGRpc3BsYXk6IC1tcy1mbGV4Ym94O1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgLXdlYmtpdC1ib3gtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgLW1zLWZsZXgtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG59XG5cbi5zb2NpYWwtaWNvbnMgLmljb24td3JhcCB7XG4gICAgZGlzcGxheTogLXdlYmtpdC1ib3g7XG4gICAgZGlzcGxheTogLW1zLWZsZXhib3g7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICAtd2Via2l0LWJveC1hbGlnbjogY2VudGVyO1xuICAgICAgICAtbXMtZmxleC1hbGlnbjogY2VudGVyO1xuICAgICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAtd2Via2l0LWJveC1wYWNrOiBjZW50ZXI7XG4gICAgICAgIC1tcy1mbGV4LXBhY2s6IGNlbnRlcjtcbiAgICAgICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIHdpZHRoOiAyNnB4O1xuICAgIGhlaWdodDogMjZweDtcbiAgICBib3JkZXItcmFkaXVzOiA1MCU7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSh2YXIoLS1jb2xvci1kYXJrKSk7XG59PC9zdHlsZT5cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFzREEsNEJBQWEsQ0FBQyxFQUFFLGVBQUMsQ0FBQyxBQUNkLE9BQU8sQ0FBRSxXQUFXLENBQ3BCLE9BQU8sQ0FBRSxXQUFXLENBQ3BCLE9BQU8sQ0FBRSxJQUFJLENBQ2IsaUJBQWlCLENBQUUsTUFBTSxDQUNyQixjQUFjLENBQUUsTUFBTSxDQUNsQixXQUFXLENBQUUsTUFBTSxDQUMzQixRQUFRLENBQUUsTUFBTSxDQUNoQixNQUFNLENBQUUsR0FBRyxDQUFDLENBQUMsQUFDakIsQ0FBQyxBQUVELDRCQUFhLENBQUMsTUFBTSxlQUFDLENBQUMsQUFDbEIsT0FBTyxDQUFFLFdBQVcsQ0FDcEIsT0FBTyxDQUFFLFdBQVcsQ0FDcEIsT0FBTyxDQUFFLElBQUksQ0FDYixpQkFBaUIsQ0FBRSxNQUFNLENBQ3JCLGNBQWMsQ0FBRSxNQUFNLENBQ2xCLFdBQVcsQ0FBRSxNQUFNLEFBQy9CLENBQUMsQUFFRCw0QkFBYSxDQUFDLFVBQVUsZUFBQyxDQUFDLEFBQ3RCLE9BQU8sQ0FBRSxXQUFXLENBQ3BCLE9BQU8sQ0FBRSxXQUFXLENBQ3BCLE9BQU8sQ0FBRSxJQUFJLENBQ2IsaUJBQWlCLENBQUUsTUFBTSxDQUNyQixjQUFjLENBQUUsTUFBTSxDQUNsQixXQUFXLENBQUUsTUFBTSxDQUMzQixnQkFBZ0IsQ0FBRSxNQUFNLENBQ3BCLGFBQWEsQ0FBRSxNQUFNLENBQ2pCLGVBQWUsQ0FBRSxNQUFNLENBQy9CLEtBQUssQ0FBRSxJQUFJLENBQ1gsTUFBTSxDQUFFLElBQUksQ0FDWixhQUFhLENBQUUsR0FBRyxDQUNsQixnQkFBZ0IsQ0FBRSxLQUFLLElBQUksWUFBWSxDQUFDLENBQUMsQUFDN0MsQ0FBQyJ9 */";
	append_dev(document.head, style);
}

const get_default_slot_changes$6 = dirty => ({ item: dirty & /*list*/ 1 });
const get_default_slot_context$6 = ctx => ({ item: /*item*/ ctx[5] });

function get_each_context$8(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[5] = list[i];
	return child_ctx;
}

// (45:12) {:else}
function create_else_block_1$2(ctx) {
	let span;
	let loader;
	let current;
	loader = new Loader({ props: { type: "h3" }, $$inline: true });

	const block = {
		c: function create() {
			span = element("span");
			create_component(loader.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true, style: true });
			var span_nodes = children(span);
			claim_component(loader.$$.fragment, span_nodes);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "flex flex-align-center");
			set_style(span, "padding", "7px 0");
			add_location(span, file$15, 45, 16, 1486);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			mount_component(loader, span, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(loader.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loader.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			destroy_component(loader);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1$2.name,
		type: "else",
		source: "(45:12) {:else}",
		ctx
	});

	return block;
}

// (21:12) {#if item !== null}
function create_if_block$m(ctx) {
	let current;
	const default_slot_template = /*$$slots*/ ctx[3].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], get_default_slot_context$6);
	const default_slot_or_fallback = default_slot || fallback_block$8(ctx);

	const block = {
		c: function create() {
			if (default_slot_or_fallback) default_slot_or_fallback.c();
		},
		l: function claim(nodes) {
			if (default_slot_or_fallback) default_slot_or_fallback.l(nodes);
		},
		m: function mount(target, anchor) {
			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope, list*/ 5) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[2], dirty, get_default_slot_changes$6, get_default_slot_context$6);
				}
			} else {
				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*list*/ 1) {
					default_slot_or_fallback.p(ctx, dirty);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot_or_fallback, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot_or_fallback, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$m.name,
		type: "if",
		source: "(21:12) {#if item !== null}",
		ctx
	});

	return block;
}

// (33:20) {:else}
function create_else_block$7(ctx) {
	let div;
	let span;
	let icon;
	let t0;
	let s0;
	let t1;
	let s1;
	let t2;
	let s2;
	let t3;
	let p;
	let t4_value = /*item*/ ctx[5].title + "";
	let t4;
	let div_title_value;
	let current;
	let mounted;
	let dispose;

	icon = new Icon({
			props: {
				type: /*item*/ ctx[5].type,
				is: "light",
				size: "tiny"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div = element("div");
			span = element("span");
			create_component(icon.$$.fragment);
			t0 = space();
			s0 = element("s");
			t1 = space();
			s1 = element("s");
			t2 = space();
			s2 = element("s");
			t3 = space();
			p = element("p");
			t4 = text(t4_value);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true, title: true });
			var div_nodes = children(div);
			span = claim_element(div_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			claim_component(icon.$$.fragment, span_nodes);
			span_nodes.forEach(detach_dev);
			t0 = claim_space(div_nodes);
			s0 = claim_element(div_nodes, "S", {});
			children(s0).forEach(detach_dev);
			t1 = claim_space(div_nodes);
			s1 = claim_element(div_nodes, "S", {});
			children(s1).forEach(detach_dev);
			t2 = claim_space(div_nodes);
			s2 = claim_element(div_nodes, "S", {});
			children(s2).forEach(detach_dev);
			t3 = claim_space(div_nodes);
			p = claim_element(div_nodes, "P", { class: true });
			var p_nodes = children(p);
			t4 = claim_text(p_nodes, t4_value);
			p_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "icon-wrap svelte-1qjherp");
			add_location(span, file$15, 34, 28, 1061);
			add_location(s0, file$15, 37, 28, 1230);
			add_location(s1, file$15, 38, 28, 1266);
			add_location(s2, file$15, 39, 28, 1302);
			attr_dev(p, "class", "h3");
			add_location(p, file$15, 40, 28, 1338);
			attr_dev(div, "class", "inner svelte-1qjherp");
			attr_dev(div, "title", div_title_value = /*item*/ ctx[5].title);
			add_location(div, file$15, 33, 24, 985);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, span);
			mount_component(icon, span, null);
			append_dev(div, t0);
			append_dev(div, s0);
			append_dev(div, t1);
			append_dev(div, s1);
			append_dev(div, t2);
			append_dev(div, s2);
			append_dev(div, t3);
			append_dev(div, p);
			append_dev(p, t4);
			current = true;

			if (!mounted) {
				dispose = listen_dev(div, "click", /*click_handler*/ ctx[4], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			const icon_changes = {};
			if (dirty & /*list*/ 1) icon_changes.type = /*item*/ ctx[5].type;
			icon.$set(icon_changes);
			if ((!current || dirty & /*list*/ 1) && t4_value !== (t4_value = /*item*/ ctx[5].title + "")) set_data_dev(t4, t4_value);

			if (!current || dirty & /*list*/ 1 && div_title_value !== (div_title_value = /*item*/ ctx[5].title)) {
				attr_dev(div, "title", div_title_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(icon);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$7.name,
		type: "else",
		source: "(33:20) {:else}",
		ctx
	});

	return block;
}

// (23:20) {#if item.href}
function create_if_block_1$e(ctx) {
	let a;
	let span;
	let icon;
	let t0;
	let s0;
	let t1;
	let s1;
	let t2;
	let s2;
	let t3;
	let p;
	let t4_value = /*item*/ ctx[5].title + "";
	let t4;
	let a_href_value;
	let a_title_value;
	let current;

	icon = new Icon({
			props: {
				type: /*item*/ ctx[5].type,
				is: "light",
				size: "tiny"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			a = element("a");
			span = element("span");
			create_component(icon.$$.fragment);
			t0 = space();
			s0 = element("s");
			t1 = space();
			s1 = element("s");
			t2 = space();
			s2 = element("s");
			t3 = space();
			p = element("p");
			t4 = text(t4_value);
			this.h();
		},
		l: function claim(nodes) {
			a = claim_element(nodes, "A", {
				href: true,
				target: true,
				class: true,
				title: true
			});

			var a_nodes = children(a);
			span = claim_element(a_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			claim_component(icon.$$.fragment, span_nodes);
			span_nodes.forEach(detach_dev);
			t0 = claim_space(a_nodes);
			s0 = claim_element(a_nodes, "S", {});
			children(s0).forEach(detach_dev);
			t1 = claim_space(a_nodes);
			s1 = claim_element(a_nodes, "S", {});
			children(s1).forEach(detach_dev);
			t2 = claim_space(a_nodes);
			s2 = claim_element(a_nodes, "S", {});
			children(s2).forEach(detach_dev);
			t3 = claim_space(a_nodes);
			p = claim_element(a_nodes, "P", { class: true });
			var p_nodes = children(p);
			t4 = claim_text(p_nodes, t4_value);
			p_nodes.forEach(detach_dev);
			a_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "icon-wrap svelte-1qjherp");
			add_location(span, file$15, 24, 28, 596);
			add_location(s0, file$15, 27, 28, 765);
			add_location(s1, file$15, 28, 28, 801);
			add_location(s2, file$15, 29, 28, 837);
			attr_dev(p, "class", "h3");
			add_location(p, file$15, 30, 28, 873);
			attr_dev(a, "href", a_href_value = /*item*/ ctx[5].href);
			attr_dev(a, "target", "_blank");
			attr_dev(a, "class", "inner svelte-1qjherp");
			attr_dev(a, "title", a_title_value = /*item*/ ctx[5].title);
			add_location(a, file$15, 23, 24, 498);
		},
		m: function mount(target, anchor) {
			insert_dev(target, a, anchor);
			append_dev(a, span);
			mount_component(icon, span, null);
			append_dev(a, t0);
			append_dev(a, s0);
			append_dev(a, t1);
			append_dev(a, s1);
			append_dev(a, t2);
			append_dev(a, s2);
			append_dev(a, t3);
			append_dev(a, p);
			append_dev(p, t4);
			current = true;
		},
		p: function update(ctx, dirty) {
			const icon_changes = {};
			if (dirty & /*list*/ 1) icon_changes.type = /*item*/ ctx[5].type;
			icon.$set(icon_changes);
			if ((!current || dirty & /*list*/ 1) && t4_value !== (t4_value = /*item*/ ctx[5].title + "")) set_data_dev(t4, t4_value);

			if (!current || dirty & /*list*/ 1 && a_href_value !== (a_href_value = /*item*/ ctx[5].href)) {
				attr_dev(a, "href", a_href_value);
			}

			if (!current || dirty & /*list*/ 1 && a_title_value !== (a_title_value = /*item*/ ctx[5].title)) {
				attr_dev(a, "title", a_title_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(a);
			destroy_component(icon);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$e.name,
		type: "if",
		source: "(23:20) {#if item.href}",
		ctx
	});

	return block;
}

// (22:29)                      
function fallback_block$8(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_1$e, create_else_block$7];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*item*/ ctx[5].href) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_1(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: fallback_block$8.name,
		type: "fallback",
		source: "(22:29)                      ",
		ctx
	});

	return block;
}

// (19:4) {#each list as item}
function create_each_block$8(ctx) {
	let li;
	let current_block_type_index;
	let if_block;
	let t;
	let current;
	const if_block_creators = [create_if_block$m, create_else_block_1$2];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*item*/ ctx[5] !== null) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			li = element("li");
			if_block.c();
			t = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true });
			var li_nodes = children(li);
			if_block.l(li_nodes);
			t = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(li, "class", "svelte-1qjherp");
			add_location(li, file$15, 19, 8, 371);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			if_blocks[current_block_type_index].m(li, null);
			append_dev(li, t);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(li, t);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			if_blocks[current_block_type_index].d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$8.name,
		type: "each",
		source: "(19:4) {#each list as item}",
		ctx
	});

	return block;
}

function create_fragment$15(ctx) {
	let ul;
	let current;
	let each_value = /*list*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$8(get_each_context$8(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(ul_nodes);
			}

			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(ul, "class", "social-icons svelte-1qjherp");
			add_location(ul, file$15, 17, 0, 312);
		},
		m: function mount(target, anchor) {
			insert_dev(target, ul, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*list, $$scope*/ 5) {
				each_value = /*list*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$8(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$8(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(ul, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(ul);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$15.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$15($$self, $$props, $$invalidate) {
	let { items } = $$props;
	const writable_props = ["items"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SocialsY> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("SocialsY", $$slots, ['default']);

	function click_handler(event) {
		bubble($$self, event);
	}

	$$self.$set = $$props => {
		if ("items" in $$props) $$invalidate(1, items = $$props.items);
		if ("$$scope" in $$props) $$invalidate(2, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({ Icon, Loader, items, list });

	$$self.$inject_state = $$props => {
		if ("items" in $$props) $$invalidate(1, items = $$props.items);
		if ("list" in $$props) $$invalidate(0, list = $$props.list);
	};

	let list;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*items*/ 2) {
			 $$invalidate(0, list = items === null ? [null, null, null] : items || []);
		}
	};

	return [list, items, $$scope, $$slots, click_handler];
}

class SocialsY extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document.getElementById("svelte-1qjherp-style")) add_css$p();
		init(this, options, instance$15, create_fragment$15, safe_not_equal, { items: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "SocialsY",
			options,
			id: create_fragment$15.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*items*/ ctx[1] === undefined && !("items" in props)) {
			console.warn("<SocialsY> was created without expected prop 'items'");
		}
	}

	get items() {
		throw new Error("<SocialsY>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set items(value) {
		throw new Error("<SocialsY>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/app/Documents.svelte generated by Svelte v3.24.0 */
const file$16 = "src/components/app/Documents.svelte";

function add_css$q() {
	var style = element("style");
	style.id = "svelte-nrl6pf-style";
	style.textContent = ".documents.active .scroll-x-center > *{-webkit-transform:none;transform:none\n}section.svelte-nrl6pf{height:calc((100vw - var(--screen-padding) * 2) * 1.428);padding:0 var(--screen-padding)}div.svelte-nrl6pf{-webkit-box-flex:0;-ms-flex:none;flex:none;display:-webkit-box;display:-ms-flexbox;display:flex;-ms-flex-item-align:stretch;align-self:stretch;height:180px;width:126px;padding:15px 5px;-webkit-box-sizing:content-box;box-sizing:content-box}div.start.svelte-nrl6pf{padding-left:var(--screen-padding)}div.end.svelte-nrl6pf{padding-right:var(--screen-padding)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRG9jdW1lbnRzLnN2ZWx0ZSIsInNvdXJjZXMiOlsiRG9jdW1lbnRzLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0PlxuICAgIGltcG9ydCB7IGNsYXNzbmFtZXMgfSBmcm9tICdAdXRpbHMnXG4gICAgaW1wb3J0IENhcmQgZnJvbSAnQGNvbXBvbmVudHMvQ2FyZC5zdmVsdGUnXG4gICAgaW1wb3J0IFBpY3R1cmUgZnJvbSAnQGNvbXBvbmVudHMvUGljdHVyZS5zdmVsdGUnXG4gICAgaW1wb3J0IEZhbmN5Qm94IGZyb20gJ0Bjb21wb25lbnRzL0ZhbmN5Qm94LnN2ZWx0ZSdcbiAgICBpbXBvcnQgQ2Fyb3VzZWwgZnJvbSAnQGNvbXBvbmVudHMvQ2Fyb3VzZWwuc3ZlbHRlJ1xuXG4gICAgZXhwb3J0IGxldCBpdGVtcyA9IG5ldyBBcnJheSg1KS5maWxsKHt9KVxuXG4gICAgbGV0IGFjdGl2ZSA9IGZhbHNlXG48L3NjcmlwdD5cblxuPENhcm91c2VsIGl0ZW1zPXtpdGVtc30gc2l6ZT1cImF1dG9cIiBkb3RzPXtmYWxzZX0gbGV0Oml0ZW09e2l0ZW19IGxldDppbmRleD17aW5kZXh9IGNsYXNzPXtjbGFzc25hbWVzKCdkb2N1bWVudHMnLCB7IGFjdGl2ZSB9KX0+XG4gICAgPGRpdiBjbGFzcz17IWluZGV4ID8gJ3N0YXJ0JyA6IGluZGV4ID09PSBpdGVtcy5sZW5ndGggLSAxID8gJ2VuZCcgOiAnJ30+XG4gICAgICAgIDxGYW5jeUJveCBvbjpvcGVuPXsoKSA9PiBhY3RpdmUgPSB0cnVlfSBvbjpjbG9zZT17KCkgPT4gYWN0aXZlID0gZmFsc2V9PlxuICAgICAgICAgICAgPENhcmQgY2xhc3M9XCJmbGV4XCI+XG4gICAgICAgICAgICAgICAgPFBpY3R1cmUgc3JjPXtpdGVtLnNyY30gYWx0PXtpdGVtLnRpdGxlfSBzaXplPVwiY29udGFpblwiLz5cbiAgICAgICAgICAgIDwvQ2FyZD5cbiAgICAgICAgICAgIDxzZWN0aW9uIHNsb3Q9XCJib3hcIiBjbGFzcz1cImZsZXggZnVsbC1jb250YWluZXJcIj5cbiAgICAgICAgICAgICAgICA8Q2FyZCBjbGFzcz1cImZsZXhcIj5cbiAgICAgICAgICAgICAgICAgICAgPFBpY3R1cmUgc3JjPXtpdGVtLnNyY30gc3JjQmlnPXtpdGVtLnNyYzJ4fSBhbHQ9e2l0ZW0udGl0bGV9IHNpemU9XCJjb250YWluXCIvPlxuICAgICAgICAgICAgICAgIDwvQ2FyZD5cbiAgICAgICAgICAgIDwvc2VjdGlvbj5cbiAgICAgICAgPC9GYW5jeUJveD5cbiAgICA8L2Rpdj5cbjwvQ2Fyb3VzZWw+XG5cbjxzdHlsZT5cbjpnbG9iYWwoLmRvY3VtZW50cy5hY3RpdmUgLnNjcm9sbC14LWNlbnRlciA+ICopIHtcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogbm9uZTtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogbm9uZVxufVxuXG5zZWN0aW9uIHtcbiAgICBoZWlnaHQ6IGNhbGMoKDEwMHZ3IC0gdmFyKC0tc2NyZWVuLXBhZGRpbmcpICogMikgKiAxLjQyOCk7XG4gICAgcGFkZGluZzogMCB2YXIoLS1zY3JlZW4tcGFkZGluZyk7XG59XG5cbmRpdiB7XG4gICAgLXdlYmtpdC1ib3gtZmxleDogMDtcbiAgICAgICAgLW1zLWZsZXg6IG5vbmU7XG4gICAgICAgICAgICBmbGV4OiBub25lO1xuICAgIGRpc3BsYXk6IC13ZWJraXQtYm94O1xuICAgIGRpc3BsYXk6IC1tcy1mbGV4Ym94O1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgLW1zLWZsZXgtaXRlbS1hbGlnbjogc3RyZXRjaDtcbiAgICAgICAgYWxpZ24tc2VsZjogc3RyZXRjaDtcbiAgICBoZWlnaHQ6IDE4MHB4O1xuICAgIHdpZHRoOiAxMjZweDtcbiAgICBwYWRkaW5nOiAxNXB4IDVweDtcbiAgICAtd2Via2l0LWJveC1zaXppbmc6IGNvbnRlbnQtYm94O1xuICAgICAgICAgICAgYm94LXNpemluZzogY29udGVudC1ib3g7XG59XG5cbmRpdi5zdGFydCB7XG4gICAgcGFkZGluZy1sZWZ0OiB2YXIoLS1zY3JlZW4tcGFkZGluZyk7XG59XG5cbmRpdi5lbmQge1xuICAgIHBhZGRpbmctcmlnaHQ6IHZhcigtLXNjcmVlbi1wYWRkaW5nKTtcbn08L3N0eWxlPlxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQTRCUSxzQ0FBc0MsQUFBRSxDQUFDLEFBQzdDLGlCQUFpQixDQUFFLElBQUksQ0FDZixTQUFTLENBQUUsSUFBSTtBQUMzQixDQUFDLEFBRUQsT0FBTyxjQUFDLENBQUMsQUFDTCxNQUFNLENBQUUsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsSUFBSSxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQ3pELE9BQU8sQ0FBRSxDQUFDLENBQUMsSUFBSSxnQkFBZ0IsQ0FBQyxBQUNwQyxDQUFDLEFBRUQsR0FBRyxjQUFDLENBQUMsQUFDRCxnQkFBZ0IsQ0FBRSxDQUFDLENBQ2YsUUFBUSxDQUFFLElBQUksQ0FDVixJQUFJLENBQUUsSUFBSSxDQUNsQixPQUFPLENBQUUsV0FBVyxDQUNwQixPQUFPLENBQUUsV0FBVyxDQUNwQixPQUFPLENBQUUsSUFBSSxDQUNiLG1CQUFtQixDQUFFLE9BQU8sQ0FDeEIsVUFBVSxDQUFFLE9BQU8sQ0FDdkIsTUFBTSxDQUFFLEtBQUssQ0FDYixLQUFLLENBQUUsS0FBSyxDQUNaLE9BQU8sQ0FBRSxJQUFJLENBQUMsR0FBRyxDQUNqQixrQkFBa0IsQ0FBRSxXQUFXLENBQ3ZCLFVBQVUsQ0FBRSxXQUFXLEFBQ25DLENBQUMsQUFFRCxHQUFHLE1BQU0sY0FBQyxDQUFDLEFBQ1AsWUFBWSxDQUFFLElBQUksZ0JBQWdCLENBQUMsQUFDdkMsQ0FBQyxBQUVELEdBQUcsSUFBSSxjQUFDLENBQUMsQUFDTCxhQUFhLENBQUUsSUFBSSxnQkFBZ0IsQ0FBQyxBQUN4QyxDQUFDIn0= */";
	append_dev(document.head, style);
}

// (16:12) <Card class="flex">
function create_default_slot_3(ctx) {
	let picture;
	let current;

	picture = new Picture({
			props: {
				src: /*item*/ ctx[4].src,
				alt: /*item*/ ctx[4].title,
				size: "contain"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(picture.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(picture.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(picture, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const picture_changes = {};
			if (dirty & /*item*/ 16) picture_changes.src = /*item*/ ctx[4].src;
			if (dirty & /*item*/ 16) picture_changes.alt = /*item*/ ctx[4].title;
			picture.$set(picture_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(picture.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(picture.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(picture, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3.name,
		type: "slot",
		source: "(16:12) <Card class=\\\"flex\\\">",
		ctx
	});

	return block;
}

// (20:16) <Card class="flex">
function create_default_slot_2$1(ctx) {
	let picture;
	let current;

	picture = new Picture({
			props: {
				src: /*item*/ ctx[4].src,
				srcBig: /*item*/ ctx[4].src2x,
				alt: /*item*/ ctx[4].title,
				size: "contain"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(picture.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(picture.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(picture, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const picture_changes = {};
			if (dirty & /*item*/ 16) picture_changes.src = /*item*/ ctx[4].src;
			if (dirty & /*item*/ 16) picture_changes.srcBig = /*item*/ ctx[4].src2x;
			if (dirty & /*item*/ 16) picture_changes.alt = /*item*/ ctx[4].title;
			picture.$set(picture_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(picture.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(picture.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(picture, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$1.name,
		type: "slot",
		source: "(20:16) <Card class=\\\"flex\\\">",
		ctx
	});

	return block;
}

// (19:12) <section slot="box" class="flex full-container">
function create_box_slot$1(ctx) {
	let section;
	let card;
	let current;

	card = new Card({
			props: {
				class: "flex",
				$$slots: { default: [create_default_slot_2$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			section = element("section");
			create_component(card.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { slot: true, class: true });
			var section_nodes = children(section);
			claim_component(card.$$.fragment, section_nodes);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(section, "slot", "box");
			attr_dev(section, "class", "flex full-container svelte-nrl6pf");
			add_location(section, file$16, 18, 12, 764);
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			mount_component(card, section, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const card_changes = {};

			if (dirty & /*$$scope, item*/ 80) {
				card_changes.$$scope = { dirty, ctx };
			}

			card.$set(card_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(card.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(card.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			destroy_component(card);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_box_slot$1.name,
		type: "slot",
		source: "(19:12) <section slot=\\\"box\\\" class=\\\"flex full-container\\\">",
		ctx
	});

	return block;
}

// (15:8) <FancyBox on:open={() => active = true} on:close={() => active = false}>
function create_default_slot_1$2(ctx) {
	let card;
	let t;
	let current;

	card = new Card({
			props: {
				class: "flex",
				$$slots: { default: [create_default_slot_3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(card.$$.fragment);
			t = space();
		},
		l: function claim(nodes) {
			claim_component(card.$$.fragment, nodes);
			t = claim_space(nodes);
		},
		m: function mount(target, anchor) {
			mount_component(card, target, anchor);
			insert_dev(target, t, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const card_changes = {};

			if (dirty & /*$$scope, item*/ 80) {
				card_changes.$$scope = { dirty, ctx };
			}

			card.$set(card_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(card.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(card.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(card, detaching);
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$2.name,
		type: "slot",
		source: "(15:8) <FancyBox on:open={() => active = true} on:close={() => active = false}>",
		ctx
	});

	return block;
}

// (13:0) <Carousel items={items} size="auto" dots={false} let:item={item} let:index={index} class={classnames('documents', { active })}>
function create_default_slot$I(ctx) {
	let div;
	let fancybox;
	let div_class_value;
	let current;

	fancybox = new FancyBox({
			props: {
				$$slots: {
					default: [create_default_slot_1$2],
					box: [create_box_slot$1]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	fancybox.$on("open", /*open_handler*/ ctx[2]);
	fancybox.$on("close", /*close_handler*/ ctx[3]);

	const block = {
		c: function create() {
			div = element("div");
			create_component(fancybox.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			claim_component(fancybox.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", div_class_value = "" + (null_to_empty(!/*index*/ ctx[5]
			? "start"
			: /*index*/ ctx[5] === /*items*/ ctx[0].length - 1
				? "end"
				: "") + " svelte-nrl6pf"));

			add_location(div, file$16, 13, 4, 472);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(fancybox, div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const fancybox_changes = {};

			if (dirty & /*$$scope, item*/ 80) {
				fancybox_changes.$$scope = { dirty, ctx };
			}

			fancybox.$set(fancybox_changes);

			if (!current || dirty & /*index, items*/ 33 && div_class_value !== (div_class_value = "" + (null_to_empty(!/*index*/ ctx[5]
			? "start"
			: /*index*/ ctx[5] === /*items*/ ctx[0].length - 1
				? "end"
				: "") + " svelte-nrl6pf"))) {
				attr_dev(div, "class", div_class_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(fancybox.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(fancybox.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(fancybox);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$I.name,
		type: "slot",
		source: "(13:0) <Carousel items={items} size=\\\"auto\\\" dots={false} let:item={item} let:index={index} class={classnames('documents', { active })}>",
		ctx
	});

	return block;
}

function create_fragment$16(ctx) {
	let carousel;
	let current;

	carousel = new Carousel({
			props: {
				items: /*items*/ ctx[0],
				size: "auto",
				dots: false,
				class: classnames("documents", { active: /*active*/ ctx[1] }),
				$$slots: {
					default: [
						create_default_slot$I,
						({ item, index }) => ({ 4: item, 5: index }),
						({ item, index }) => (item ? 16 : 0) | (index ? 32 : 0)
					]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(carousel.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(carousel.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(carousel, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const carousel_changes = {};
			if (dirty & /*items*/ 1) carousel_changes.items = /*items*/ ctx[0];
			if (dirty & /*active*/ 2) carousel_changes.class = classnames("documents", { active: /*active*/ ctx[1] });

			if (dirty & /*$$scope, index, items, active, item*/ 115) {
				carousel_changes.$$scope = { dirty, ctx };
			}

			carousel.$set(carousel_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(carousel.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(carousel.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(carousel, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$16.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$16($$self, $$props, $$invalidate) {
	let { items = new Array(5).fill({}) } = $$props;
	let active = false;
	const writable_props = ["items"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Documents> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Documents", $$slots, []);
	const open_handler = () => $$invalidate(1, active = true);
	const close_handler = () => $$invalidate(1, active = false);

	$$self.$set = $$props => {
		if ("items" in $$props) $$invalidate(0, items = $$props.items);
	};

	$$self.$capture_state = () => ({
		classnames,
		Card,
		Picture,
		FancyBox,
		Carousel,
		items,
		active
	});

	$$self.$inject_state = $$props => {
		if ("items" in $$props) $$invalidate(0, items = $$props.items);
		if ("active" in $$props) $$invalidate(1, active = $$props.active);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [items, active, open_handler, close_handler];
}

class Documents extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document.getElementById("svelte-nrl6pf-style")) add_css$q();
		init(this, options, instance$16, create_fragment$16, safe_not_equal, { items: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Documents",
			options,
			id: create_fragment$16.name
		});
	}

	get items() {
		throw new Error("<Documents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set items(value) {
		throw new Error("<Documents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/app/ListItems.svelte generated by Svelte v3.24.0 */

const { console: console_1$1 } = globals;
const file$17 = "src/components/app/ListItems.svelte";

function add_css$r() {
	var style = element("style");
	style.id = "svelte-tzuf8q-style";
	style.textContent = ".item.svelte-tzuf8q.svelte-tzuf8q{display:block;-webkit-box-flex:1;-ms-flex:1 1 auto;flex:1 1 auto;padding:20px;-webkit-box-shadow:var(--shadow-primary);box-shadow:var(--shadow-primary);border-radius:var(--border-radius-big);background-color:rgba(var(--theme-bg-color))}span.svelte-tzuf8q.svelte-tzuf8q{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;overflow:hidden;padding:0 15px}span.svelte-tzuf8q h4.svelte-tzuf8q,span.svelte-tzuf8q sub.svelte-tzuf8q{max-width:100%;overflow:hidden;white-space:nowrap;text-overflow:ellipsis}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTGlzdEl0ZW1zLnN2ZWx0ZSIsInNvdXJjZXMiOlsiTGlzdEl0ZW1zLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0PlxuICAgIGltcG9ydCBBdmF0YXIgZnJvbSAnLi4vQXZhdGFyLnN2ZWx0ZSdcbiAgICBpbXBvcnQgeyBzYWZlR2V0IH0gZnJvbSAnQHV0aWxzJ1xuXG4gICAgZXhwb3J0IGxldCBpdGVtcyA9IFtdXG4gICAgZXhwb3J0IGxldCBiYXNlUGF0aCA9ICcnXG5cbiAgICAkOiBjb25zb2xlLmxvZyhpdGVtcylcbjwvc2NyaXB0PlxuXG57I2VhY2ggaXRlbXMgYXMgaXRlbX1cbiAgICA8YSBjbGFzcz1cIml0ZW0gY29udGFpbmVyXCIgaHJlZj17YCR7YmFzZVBhdGh9LyR7aXRlbS5pZH1gfT5cbiAgICAgICAgPEF2YXRhciBzcmM9e3NhZmVHZXQoKCkgPT4gaXRlbS5hdmF0YXJzWzBdLnNyYyl9IHNpemU9XCJtZWRpdW1cIiBhbHQ9e2l0ZW0udGl0bGV9Lz5cblxuICAgICAgICA8c3Bhbj5cbiAgICAgICAgICAgIDxoND57aXRlbS50aXRsZSB8fCAnaW5jb2duaXRvJ308L2g0PlxuICAgICAgICAgICAgPHN1Yj57aXRlbS5zdWJ0aXRsZX08L3N1Yj5cbiAgICAgICAgPC9zcGFuPlxuICAgIDwvYT5cbiAgICA8YnI+XG57OmVsc2V9XG4gICAgPHNlY3Rpb24gY2xhc3M9XCJpdGVtIGNvbnRhaW5lclwiPlxuICAgICAgICA8cCBjbGFzcz1cInRleHQtY2VudGVyXCI+Tm8gb3JnYW5pemF0aW9uczwvcD5cbiAgICA8L3NlY3Rpb24+XG57L2VhY2h9XG5cbjxzdHlsZT5cbi5pdGVtIHtcbiAgICBkaXNwbGF5OiBibG9jaztcbiAgICAtd2Via2l0LWJveC1mbGV4OiAxO1xuICAgICAgICAtbXMtZmxleDogMSAxIGF1dG87XG4gICAgICAgICAgICBmbGV4OiAxIDEgYXV0bztcbiAgICBwYWRkaW5nOiAyMHB4O1xuICAgIC13ZWJraXQtYm94LXNoYWRvdzogdmFyKC0tc2hhZG93LXByaW1hcnkpO1xuICAgICAgICAgICAgYm94LXNoYWRvdzogdmFyKC0tc2hhZG93LXByaW1hcnkpO1xuICAgIGJvcmRlci1yYWRpdXM6IHZhcigtLWJvcmRlci1yYWRpdXMtYmlnKTtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKHZhcigtLXRoZW1lLWJnLWNvbG9yKSk7XG59XG5cbnNwYW4ge1xuICAgIGRpc3BsYXk6IC13ZWJraXQtYm94O1xuICAgIGRpc3BsYXk6IC1tcy1mbGV4Ym94O1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgLXdlYmtpdC1ib3gtb3JpZW50OiB2ZXJ0aWNhbDtcbiAgICAtd2Via2l0LWJveC1kaXJlY3Rpb246IG5vcm1hbDtcbiAgICAgICAgLW1zLWZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIC13ZWJraXQtYm94LXBhY2s6IGNlbnRlcjtcbiAgICAgICAgLW1zLWZsZXgtcGFjazogY2VudGVyO1xuICAgICAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICBwYWRkaW5nOiAwIDE1cHg7XG59XG5cbnNwYW4gaDQsXG5zcGFuIHN1YiB7XG4gICAgbWF4LXdpZHRoOiAxMDAlO1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcbiAgICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcbn08L3N0eWxlPlxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQTJCQSxLQUFLLDRCQUFDLENBQUMsQUFDSCxPQUFPLENBQUUsS0FBSyxDQUNkLGdCQUFnQixDQUFFLENBQUMsQ0FDZixRQUFRLENBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQ2QsSUFBSSxDQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUN0QixPQUFPLENBQUUsSUFBSSxDQUNiLGtCQUFrQixDQUFFLElBQUksZ0JBQWdCLENBQUMsQ0FDakMsVUFBVSxDQUFFLElBQUksZ0JBQWdCLENBQUMsQ0FDekMsYUFBYSxDQUFFLElBQUksbUJBQW1CLENBQUMsQ0FDdkMsZ0JBQWdCLENBQUUsS0FBSyxJQUFJLGdCQUFnQixDQUFDLENBQUMsQUFDakQsQ0FBQyxBQUVELElBQUksNEJBQUMsQ0FBQyxBQUNGLE9BQU8sQ0FBRSxXQUFXLENBQ3BCLE9BQU8sQ0FBRSxXQUFXLENBQ3BCLE9BQU8sQ0FBRSxJQUFJLENBQ2Isa0JBQWtCLENBQUUsUUFBUSxDQUM1QixxQkFBcUIsQ0FBRSxNQUFNLENBQ3pCLGtCQUFrQixDQUFFLE1BQU0sQ0FDdEIsY0FBYyxDQUFFLE1BQU0sQ0FDOUIsZ0JBQWdCLENBQUUsTUFBTSxDQUNwQixhQUFhLENBQUUsTUFBTSxDQUNqQixlQUFlLENBQUUsTUFBTSxDQUMvQixRQUFRLENBQUUsTUFBTSxDQUNoQixPQUFPLENBQUUsQ0FBQyxDQUFDLElBQUksQUFDbkIsQ0FBQyxBQUVELGtCQUFJLENBQUMsZ0JBQUUsQ0FDUCxrQkFBSSxDQUFDLEdBQUcsY0FBQyxDQUFDLEFBQ04sU0FBUyxDQUFFLElBQUksQ0FDZixRQUFRLENBQUUsTUFBTSxDQUNoQixXQUFXLENBQUUsTUFBTSxDQUNuQixhQUFhLENBQUUsUUFBUSxBQUMzQixDQUFDIn0= */";
	append_dev(document.head, style);
}

function get_each_context$9(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[3] = list[i];
	return child_ctx;
}

// (21:0) {:else}
function create_else_block$8(ctx) {
	let section;
	let p;
	let t0;
	let t1;

	const block = {
		c: function create() {
			section = element("section");
			p = element("p");
			t0 = text("No organizations");
			t1 = space();
			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { class: true });
			var section_nodes = children(section);
			p = claim_element(section_nodes, "P", { class: true });
			var p_nodes = children(p);
			t0 = claim_text(p_nodes, "No organizations");
			p_nodes.forEach(detach_dev);
			t1 = claim_space(section_nodes);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(p, "class", "text-center");
			add_location(p, file$17, 22, 8, 548);
			attr_dev(section, "class", "item container svelte-tzuf8q");
			add_location(section, file$17, 21, 4, 507);
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			append_dev(section, p);
			append_dev(p, t0);
			append_dev(section, t1);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$8.name,
		type: "else",
		source: "(21:0) {:else}",
		ctx
	});

	return block;
}

// (11:0) {#each items as item}
function create_each_block$9(ctx) {
	let a;
	let avatar;
	let t0;
	let span;
	let h4;
	let t1_value = (/*item*/ ctx[3].title || "incognito") + "";
	let t1;
	let t2;
	let sub;
	let t3_value = /*item*/ ctx[3].subtitle + "";
	let t3;
	let a_href_value;
	let t4;
	let br;
	let current;

	function func(...args) {
		return /*func*/ ctx[2](/*item*/ ctx[3], ...args);
	}

	avatar = new Avatar({
			props: {
				src: safeGet(func),
				size: "medium",
				alt: /*item*/ ctx[3].title
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			a = element("a");
			create_component(avatar.$$.fragment);
			t0 = space();
			span = element("span");
			h4 = element("h4");
			t1 = text(t1_value);
			t2 = space();
			sub = element("sub");
			t3 = text(t3_value);
			t4 = space();
			br = element("br");
			this.h();
		},
		l: function claim(nodes) {
			a = claim_element(nodes, "A", { class: true, href: true });
			var a_nodes = children(a);
			claim_component(avatar.$$.fragment, a_nodes);
			t0 = claim_space(a_nodes);
			span = claim_element(a_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			h4 = claim_element(span_nodes, "H4", { class: true });
			var h4_nodes = children(h4);
			t1 = claim_text(h4_nodes, t1_value);
			h4_nodes.forEach(detach_dev);
			t2 = claim_space(span_nodes);
			sub = claim_element(span_nodes, "SUB", { class: true });
			var sub_nodes = children(sub);
			t3 = claim_text(sub_nodes, t3_value);
			sub_nodes.forEach(detach_dev);
			span_nodes.forEach(detach_dev);
			a_nodes.forEach(detach_dev);
			t4 = claim_space(nodes);
			br = claim_element(nodes, "BR", {});
			this.h();
		},
		h: function hydrate() {
			attr_dev(h4, "class", "svelte-tzuf8q");
			add_location(h4, file$17, 15, 12, 385);
			attr_dev(sub, "class", "svelte-tzuf8q");
			add_location(sub, file$17, 16, 12, 434);
			attr_dev(span, "class", "svelte-tzuf8q");
			add_location(span, file$17, 14, 8, 366);
			attr_dev(a, "class", "item container svelte-tzuf8q");
			attr_dev(a, "href", a_href_value = `${/*basePath*/ ctx[1]}/${/*item*/ ctx[3].id}`);
			add_location(a, file$17, 11, 4, 208);
			add_location(br, file$17, 19, 4, 490);
		},
		m: function mount(target, anchor) {
			insert_dev(target, a, anchor);
			mount_component(avatar, a, null);
			append_dev(a, t0);
			append_dev(a, span);
			append_dev(span, h4);
			append_dev(h4, t1);
			append_dev(span, t2);
			append_dev(span, sub);
			append_dev(sub, t3);
			insert_dev(target, t4, anchor);
			insert_dev(target, br, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const avatar_changes = {};
			if (dirty & /*items*/ 1) avatar_changes.src = safeGet(func);
			if (dirty & /*items*/ 1) avatar_changes.alt = /*item*/ ctx[3].title;
			avatar.$set(avatar_changes);
			if ((!current || dirty & /*items*/ 1) && t1_value !== (t1_value = (/*item*/ ctx[3].title || "incognito") + "")) set_data_dev(t1, t1_value);
			if ((!current || dirty & /*items*/ 1) && t3_value !== (t3_value = /*item*/ ctx[3].subtitle + "")) set_data_dev(t3, t3_value);

			if (!current || dirty & /*basePath, items*/ 3 && a_href_value !== (a_href_value = `${/*basePath*/ ctx[1]}/${/*item*/ ctx[3].id}`)) {
				attr_dev(a, "href", a_href_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(avatar.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(avatar.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(a);
			destroy_component(avatar);
			if (detaching) detach_dev(t4);
			if (detaching) detach_dev(br);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$9.name,
		type: "each",
		source: "(11:0) {#each items as item}",
		ctx
	});

	return block;
}

function create_fragment$17(ctx) {
	let each_1_anchor;
	let current;
	let each_value = /*items*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$9(get_each_context$9(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	let each_1_else = null;

	if (!each_value.length) {
		each_1_else = create_else_block$8(ctx);
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();

			if (each_1_else) {
				each_1_else.c();
			}
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();

			if (each_1_else) {
				each_1_else.l(nodes);
			}
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);

			if (each_1_else) {
				each_1_else.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*basePath, items, safeGet*/ 3) {
				each_value = /*items*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$9(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$9(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();

				if (each_value.length) {
					if (each_1_else) {
						each_1_else.d(1);
						each_1_else = null;
					}
				} else if (!each_1_else) {
					each_1_else = create_else_block$8(ctx);
					each_1_else.c();
					each_1_else.m(each_1_anchor.parentNode, each_1_anchor);
				}
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
			if (each_1_else) each_1_else.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$17.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$17($$self, $$props, $$invalidate) {
	let { items = [] } = $$props;
	let { basePath = "" } = $$props;
	const writable_props = ["items", "basePath"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$1.warn(`<ListItems> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("ListItems", $$slots, []);
	const func = item => item.avatars[0].src;

	$$self.$set = $$props => {
		if ("items" in $$props) $$invalidate(0, items = $$props.items);
		if ("basePath" in $$props) $$invalidate(1, basePath = $$props.basePath);
	};

	$$self.$capture_state = () => ({ Avatar, safeGet, items, basePath });

	$$self.$inject_state = $$props => {
		if ("items" in $$props) $$invalidate(0, items = $$props.items);
		if ("basePath" in $$props) $$invalidate(1, basePath = $$props.basePath);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*items*/ 1) {
			 console.log(items);
		}
	};

	return [items, basePath, func];
}

class ListItems extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document.getElementById("svelte-tzuf8q-style")) add_css$r();
		init(this, options, instance$17, create_fragment$17, safe_not_equal, { items: 0, basePath: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ListItems",
			options,
			id: create_fragment$17.name
		});
	}

	get items() {
		throw new Error("<ListItems>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set items(value) {
		throw new Error("<ListItems>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get basePath() {
		throw new Error("<ListItems>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set basePath(value) {
		throw new Error("<ListItems>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/app/StoryList.svelte generated by Svelte v3.24.0 */

const { Boolean: Boolean_1 } = globals;
const file$18 = "src/components/app/StoryList.svelte";

function add_css$s() {
	var style = element("style");
	style.id = "svelte-1rv59vc-style";
	style.textContent = "table.svelte-1rv59vc tr:not(:last-child) td.svelte-1rv59vc{padding-bottom:16px}table.svelte-1rv59vc td.svelte-1rv59vc:last-child{font-weight:300}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU3RvcnlMaXN0LnN2ZWx0ZSIsInNvdXJjZXMiOlsiU3RvcnlMaXN0LnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0PlxuICAgIGltcG9ydCB7IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJ3N2ZWx0ZSdcbiAgICBpbXBvcnQgeyBjbGFzc25hbWVzLCB0b0NTU1N0cmluZyB9IGZyb20gJ0B1dGlscydcbiAgICBpbXBvcnQgQnIgZnJvbSAnQGNvbXBvbmVudHMvQnIuc3ZlbHRlJ1xuICAgIGltcG9ydCBJY29uIGZyb20gJ0Bjb21wb25lbnRzL0ljb24uc3ZlbHRlJ1xuICAgIGltcG9ydCBNb2RhbCBmcm9tICdAY29tcG9uZW50cy9Nb2RhbC5zdmVsdGUnXG4gICAgaW1wb3J0IExvYWRlciBmcm9tICdAY29tcG9uZW50cy9sb2FkZXInXG4gICAgaW1wb3J0IEJ1dHRvbiBmcm9tICdAY29tcG9uZW50cy9CdXR0b24uc3ZlbHRlJ1xuICAgIGltcG9ydCBGb3JtQnVpbGRlciBmcm9tICdAY29tcG9uZW50cy9Gb3JtQnVpbGRlci5zdmVsdGUnXG5cbiAgICBjb25zdCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpXG5cbiAgICBleHBvcnQgbGV0IGlkID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCBuYW1lID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCBsYWJlbCA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgdmFsdWUgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IHN0eWxlID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCByZWFkb25seSA9IHVuZGVmaW5lZFxuXG4gICAgbGV0IG9wZW4gPSBmYWxzZVxuICAgIGxldCBmb3JtRXJyb3JzID0gW11cbiAgICBsZXQgZm9ybUZpZWxkcyA9IFtcbiAgICAgICAge1xuICAgICAgICAgICAgbGFiZWw6ICfQlNCw0YLQsDonLFxuICAgICAgICAgICAgdHlwZTogJ2RhdGUnLFxuICAgICAgICAgICAgbmFtZTogJ2RhdGUnLFxuICAgICAgICAgICAgbWV0YToge1xuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiAnMTguMDMuMjAxOS4uLicsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBsYWJlbDogJ9CU0L7QsdCw0LLRgtC1INC90LDQt9Cy0YMg0L/QvtC00ZbRlzonLFxuICAgICAgICAgICAgdHlwZTogJ3RleHRhcmVhJyxcbiAgICAgICAgICAgIG5hbWU6ICd0aXRsZScsXG4gICAgICAgICAgICBtZXRhOiB7XG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6ICfQl9Cw0LHRgNCw0LvQuCDQsiDQv9GA0LjRgtGD0LvQvtC6Li4uJyxcbiAgICAgICAgICAgICAgICByb3dzOiAzLFxuICAgICAgICAgICAgICAgIG1heGxlbmd0aDogNzVcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgXVxuXG4gICAgJDogaWRQcm9wID0gaWQgfHwgbmFtZVxuICAgICQ6IGNsYXNzUHJvcCA9IGNsYXNzbmFtZXMoJ3N0b3J5LWxpc3QnLCAkJHByb3BzLmNsYXNzKVxuICAgICQ6IHN0eWxlUHJvcCA9IHRvQ1NTU3RyaW5nKHsgLi4uc3R5bGUgfSlcblxuICAgIGZ1bmN0aW9uIG9uUmVtb3ZlKHsgaW5kZXggfSwgZSkge1xuICAgICAgICBjb25zdCB2YWwgPSBbLi4udmFsdWUuZmlsdGVyKChfLCBpbmQpID0+IGluZCAhPT0gaW5kZXgpXVxuICAgICAgICBkaXNwYXRjaCgnY2hhbmdlJywgeyBlLCBuYW1lLCB2YWx1ZTogdmFsIH0pXG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gb25TdWJtaXQodmFsdWVzLCBlKSB7XG4gICAgICAgIGNvbnN0IHZhbCA9IFsuLi52YWx1ZSwgdmFsdWVzXVxuICAgICAgICBkaXNwYXRjaCgnY2hhbmdlJywgeyBlLCBuYW1lLCB2YWx1ZTogdmFsIH0pXG4gICAgICAgIG9wZW4gPSBmYWxzZVxuICAgIH1cbjwvc2NyaXB0PlxuXG48c3R5bGU+XG50YWJsZSB0cjpub3QoOmxhc3QtY2hpbGQpIHRkIHtcbiAgICBwYWRkaW5nLWJvdHRvbTogMTZweDtcbn1cblxudGFibGUgdGQ6bGFzdC1jaGlsZCB7XG4gICAgZm9udC13ZWlnaHQ6IDMwMDtcbn08L3N0eWxlPlxuXG48c2VjdGlvbiBjbGFzcz17Y2xhc3NQcm9wfSBzdHlsZT17c3R5bGVQcm9wfT5cbiAgICB7I2lmIGxhYmVsfVxuICAgICAgICA8aDIgY2xhc3M9XCJ0ZXh0LWxlZnRcIj57bGFiZWx9PC9oMj5cbiAgICAgICAgPEJyIHNpemU9XCIxMFwiLz5cbiAgICB7L2lmfVxuXG4gICAgPHRhYmxlPlxuICAgICAgICA8dGJvZHk+XG4gICAgICAgICAgICB7I2lmIHZhbHVlICE9PSBudWxsICYmIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aH1cbiAgICAgICAgICAgICAgICB7I2VhY2ggdmFsdWUuZmlsdGVyKEJvb2xlYW4pIGFzIHZhbCwgaX1cbiAgICAgICAgICAgICAgICAgICAgPHRyPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHRkPnt2YWwuZGF0ZX08L3RkPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHRkPuKAlDwvdGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGQ+e3ZhbC50aXRsZX08L3RkPlxuICAgICAgICAgICAgICAgICAgICAgICAgeyNpZiAhcmVhZG9ubHl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8QnV0dG9uIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0byBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPVwidmVydGljYWwtYWxpZ246IG1pZGRsZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbjpjbGljaz17b25SZW1vdmUuYmluZChudWxsLCB7IGlkOiB2YWwuaWQsIGluZGV4OiBpIH0pfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8SWNvbiB0eXBlPVwiY2xvc2VcIiBzaXplPVwibWVkaXVtXCIvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgICAgICAgICAgPC90cj5cbiAgICAgICAgICAgICAgICB7L2VhY2h9XG4gICAgICAgICAgICB7OmVsc2UgaWYgdmFsdWUgPT09IG51bGx9XG4gICAgICAgICAgICAgICAgPHRyPlxuICAgICAgICAgICAgICAgICAgICA8dGQ+PExvYWRlciB0eXBlPVwicFwiLz48L3RkPlxuICAgICAgICAgICAgICAgICAgICA8dGQ+4oCUPC90ZD5cbiAgICAgICAgICAgICAgICAgICAgPHRkPlxuICAgICAgICAgICAgICAgICAgICAgICAgPExvYWRlciB0eXBlPVwicFwiLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxMb2FkZXIgdHlwZT1cInBcIi8+XG4gICAgICAgICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICAgICAgPC90cj5cbiAgICAgICAgICAgICAgICA8dHI+XG4gICAgICAgICAgICAgICAgICAgIDx0ZD48TG9hZGVyIHR5cGU9XCJwXCIvPjwvdGQ+XG4gICAgICAgICAgICAgICAgICAgIDx0ZD7igJQ8L3RkPlxuICAgICAgICAgICAgICAgICAgICA8dGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICA8TG9hZGVyIHR5cGU9XCJwXCIvPlxuICAgICAgICAgICAgICAgICAgICAgICAgPExvYWRlciB0eXBlPVwicFwiLz5cbiAgICAgICAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgICAgICA8L3RyPlxuICAgICAgICAgICAgICAgIDx0cj5cbiAgICAgICAgICAgICAgICAgICAgPHRkPjxMb2FkZXIgdHlwZT1cInBcIi8+PC90ZD5cbiAgICAgICAgICAgICAgICAgICAgPHRkPuKAlDwvdGQ+XG4gICAgICAgICAgICAgICAgICAgIDx0ZD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxMb2FkZXIgdHlwZT1cInBcIi8+XG4gICAgICAgICAgICAgICAgICAgICAgICA8TG9hZGVyIHR5cGU9XCJwXCIvPlxuICAgICAgICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgICAgIDwvdHI+XG4gICAgICAgICAgICB7L2lmfVxuICAgICAgICA8L3Rib2R5PlxuICAgIDwvdGFibGU+XG5cbiAgICB7I2lmICFyZWFkb25seX1cbiAgICAgICAgPEJyIHNpemU9XCIyNVwiLz5cbiAgICAgICAgPEJ1dHRvbiBhdXRvIGlzPVwiaW5mb1wiIG9uOmNsaWNrPXsoKSA9PiBvcGVuID0gdHJ1ZX0+XG4gICAgICAgICAgICA8aDMgc3R5bGU9XCJwYWRkaW5nOiAxMHB4IDI1cHhcIiBjbGFzcz1cImZvbnQtdy01MDBcIj5cbiAgICAgICAgICAgICAgICDQlNC+0LTQsNGC0Lgg0L/QvtC00ZbRjlxuICAgICAgICAgICAgPC9oMz5cbiAgICAgICAgPC9CdXR0b24+XG4gICAgey9pZn1cbjwvc2VjdGlvbj5cblxuPE1vZGFsIFxuICAgIHtvcGVufVxuICAgIHN3aXBlPVwiYWxsXCJcbiAgICBpZD1cInN0b3J5LWxpZmUtbW9kYWxcIlxuICAgIHNpemU9XCJtZWRpdW1cIlxuICAgIHRpdGxlPVwi0KHRgtCy0L7RgNC10L3QvdGPINC/0L7QtNGW0ZdcIlxuICAgIG9uOmNsb3NlPXsoKSA9PiBvcGVuID0gZmFsc2V9XG4+XG4gICAgPGRpdiBjbGFzcz1cImNvbnRhaW5lclwiPlxuICAgICAgICA8QnIgc2l6ZT1cIjIwXCIvPlxuICAgICAgICA8Rm9ybUJ1aWxkZXJcbiAgICAgICAgICAgICAgICBpZD1cInN0b3J5LWZvcm1cIlxuICAgICAgICAgICAgICAgIGl0ZW1zPXtmb3JtRmllbGRzfVxuICAgICAgICAgICAgICAgIGVycm9ycz17Zm9ybUVycm9yc31cbiAgICAgICAgICAgICAgICBzdWJtaXQ9e29uU3VibWl0fVxuICAgICAgICAvPlxuICAgICAgICA8QnIgc2l6ZT1cIjQwXCIvPlxuICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgICAgICAgaXM9XCJpbmZvXCJcbiAgICAgICAgICAgICAgICBzaXplPVwibWVkaXVtXCJcbiAgICAgICAgICAgICAgICB0eXBlPVwic3VibWl0XCJcbiAgICAgICAgICAgICAgICBmb3JtPVwic3RvcnktZm9ybVwiXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJmdWxsLXdpZHRoXCJcbiAgICAgICAgPlxuICAgICAgICAgICAgPGgzPtCX0LHQtdGA0LXQs9GC0Lg8L2gzPlxuICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgPEJyIHNpemU9XCIyMFwiLz5cbiAgICA8L2Rpdj5cbjwvTW9kYWw+XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBMkRBLG9CQUFLLENBQUMsRUFBRSxLQUFLLFdBQVcsQ0FBQyxDQUFDLEVBQUUsZUFBQyxDQUFDLEFBQzFCLGNBQWMsQ0FBRSxJQUFJLEFBQ3hCLENBQUMsQUFFRCxvQkFBSyxDQUFDLGlCQUFFLFdBQVcsQUFBQyxDQUFDLEFBQ2pCLFdBQVcsQ0FBRSxHQUFHLEFBQ3BCLENBQUMifQ== */";
	append_dev(document.head, style);
}

function get_each_context$a(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[18] = list[i];
	child_ctx[20] = i;
	return child_ctx;
}

// (69:4) {#if label}
function create_if_block_4$1(ctx) {
	let h2;
	let t0;
	let t1;
	let br;
	let current;
	br = new Br({ props: { size: "10" }, $$inline: true });

	const block = {
		c: function create() {
			h2 = element("h2");
			t0 = text(/*label*/ ctx[0]);
			t1 = space();
			create_component(br.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			h2 = claim_element(nodes, "H2", { class: true });
			var h2_nodes = children(h2);
			t0 = claim_text(h2_nodes, /*label*/ ctx[0]);
			h2_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			claim_component(br.$$.fragment, nodes);
			this.h();
		},
		h: function hydrate() {
			attr_dev(h2, "class", "text-left");
			add_location(h2, file$18, 69, 8, 1832);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h2, anchor);
			append_dev(h2, t0);
			insert_dev(target, t1, anchor);
			mount_component(br, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (!current || dirty & /*label*/ 1) set_data_dev(t0, /*label*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(br.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h2);
			if (detaching) detach_dev(t1);
			destroy_component(br, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4$1.name,
		type: "if",
		source: "(69:4) {#if label}",
		ctx
	});

	return block;
}

// (95:37) 
function create_if_block_3$2(ctx) {
	let tr0;
	let td0;
	let loader0;
	let t0;
	let td1;
	let t1;
	let t2;
	let td2;
	let loader1;
	let t3;
	let loader2;
	let t4;
	let tr1;
	let td3;
	let loader3;
	let t5;
	let td4;
	let t6;
	let t7;
	let td5;
	let loader4;
	let t8;
	let loader5;
	let t9;
	let tr2;
	let td6;
	let loader6;
	let t10;
	let td7;
	let t11;
	let t12;
	let td8;
	let loader7;
	let t13;
	let loader8;
	let current;
	loader0 = new Loader({ props: { type: "p" }, $$inline: true });
	loader1 = new Loader({ props: { type: "p" }, $$inline: true });
	loader2 = new Loader({ props: { type: "p" }, $$inline: true });
	loader3 = new Loader({ props: { type: "p" }, $$inline: true });
	loader4 = new Loader({ props: { type: "p" }, $$inline: true });
	loader5 = new Loader({ props: { type: "p" }, $$inline: true });
	loader6 = new Loader({ props: { type: "p" }, $$inline: true });
	loader7 = new Loader({ props: { type: "p" }, $$inline: true });
	loader8 = new Loader({ props: { type: "p" }, $$inline: true });

	const block = {
		c: function create() {
			tr0 = element("tr");
			td0 = element("td");
			create_component(loader0.$$.fragment);
			t0 = space();
			td1 = element("td");
			t1 = text("—");
			t2 = space();
			td2 = element("td");
			create_component(loader1.$$.fragment);
			t3 = space();
			create_component(loader2.$$.fragment);
			t4 = space();
			tr1 = element("tr");
			td3 = element("td");
			create_component(loader3.$$.fragment);
			t5 = space();
			td4 = element("td");
			t6 = text("—");
			t7 = space();
			td5 = element("td");
			create_component(loader4.$$.fragment);
			t8 = space();
			create_component(loader5.$$.fragment);
			t9 = space();
			tr2 = element("tr");
			td6 = element("td");
			create_component(loader6.$$.fragment);
			t10 = space();
			td7 = element("td");
			t11 = text("—");
			t12 = space();
			td8 = element("td");
			create_component(loader7.$$.fragment);
			t13 = space();
			create_component(loader8.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			tr0 = claim_element(nodes, "TR", {});
			var tr0_nodes = children(tr0);
			td0 = claim_element(tr0_nodes, "TD", { class: true });
			var td0_nodes = children(td0);
			claim_component(loader0.$$.fragment, td0_nodes);
			td0_nodes.forEach(detach_dev);
			t0 = claim_space(tr0_nodes);
			td1 = claim_element(tr0_nodes, "TD", { class: true });
			var td1_nodes = children(td1);
			t1 = claim_text(td1_nodes, "—");
			td1_nodes.forEach(detach_dev);
			t2 = claim_space(tr0_nodes);
			td2 = claim_element(tr0_nodes, "TD", { class: true });
			var td2_nodes = children(td2);
			claim_component(loader1.$$.fragment, td2_nodes);
			t3 = claim_space(td2_nodes);
			claim_component(loader2.$$.fragment, td2_nodes);
			td2_nodes.forEach(detach_dev);
			tr0_nodes.forEach(detach_dev);
			t4 = claim_space(nodes);
			tr1 = claim_element(nodes, "TR", {});
			var tr1_nodes = children(tr1);
			td3 = claim_element(tr1_nodes, "TD", { class: true });
			var td3_nodes = children(td3);
			claim_component(loader3.$$.fragment, td3_nodes);
			td3_nodes.forEach(detach_dev);
			t5 = claim_space(tr1_nodes);
			td4 = claim_element(tr1_nodes, "TD", { class: true });
			var td4_nodes = children(td4);
			t6 = claim_text(td4_nodes, "—");
			td4_nodes.forEach(detach_dev);
			t7 = claim_space(tr1_nodes);
			td5 = claim_element(tr1_nodes, "TD", { class: true });
			var td5_nodes = children(td5);
			claim_component(loader4.$$.fragment, td5_nodes);
			t8 = claim_space(td5_nodes);
			claim_component(loader5.$$.fragment, td5_nodes);
			td5_nodes.forEach(detach_dev);
			tr1_nodes.forEach(detach_dev);
			t9 = claim_space(nodes);
			tr2 = claim_element(nodes, "TR", {});
			var tr2_nodes = children(tr2);
			td6 = claim_element(tr2_nodes, "TD", { class: true });
			var td6_nodes = children(td6);
			claim_component(loader6.$$.fragment, td6_nodes);
			td6_nodes.forEach(detach_dev);
			t10 = claim_space(tr2_nodes);
			td7 = claim_element(tr2_nodes, "TD", { class: true });
			var td7_nodes = children(td7);
			t11 = claim_text(td7_nodes, "—");
			td7_nodes.forEach(detach_dev);
			t12 = claim_space(tr2_nodes);
			td8 = claim_element(tr2_nodes, "TD", { class: true });
			var td8_nodes = children(td8);
			claim_component(loader7.$$.fragment, td8_nodes);
			t13 = claim_space(td8_nodes);
			claim_component(loader8.$$.fragment, td8_nodes);
			td8_nodes.forEach(detach_dev);
			tr2_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(td0, "class", "svelte-1rv59vc");
			add_location(td0, file$18, 96, 20, 2864);
			attr_dev(td1, "class", "svelte-1rv59vc");
			add_location(td1, file$18, 97, 20, 2912);
			attr_dev(td2, "class", "svelte-1rv59vc");
			add_location(td2, file$18, 98, 20, 2943);
			add_location(tr0, file$18, 95, 16, 2839);
			attr_dev(td3, "class", "svelte-1rv59vc");
			add_location(td3, file$18, 104, 20, 3123);
			attr_dev(td4, "class", "svelte-1rv59vc");
			add_location(td4, file$18, 105, 20, 3171);
			attr_dev(td5, "class", "svelte-1rv59vc");
			add_location(td5, file$18, 106, 20, 3202);
			add_location(tr1, file$18, 103, 16, 3098);
			attr_dev(td6, "class", "svelte-1rv59vc");
			add_location(td6, file$18, 112, 20, 3382);
			attr_dev(td7, "class", "svelte-1rv59vc");
			add_location(td7, file$18, 113, 20, 3430);
			attr_dev(td8, "class", "svelte-1rv59vc");
			add_location(td8, file$18, 114, 20, 3461);
			add_location(tr2, file$18, 111, 16, 3357);
		},
		m: function mount(target, anchor) {
			insert_dev(target, tr0, anchor);
			append_dev(tr0, td0);
			mount_component(loader0, td0, null);
			append_dev(tr0, t0);
			append_dev(tr0, td1);
			append_dev(td1, t1);
			append_dev(tr0, t2);
			append_dev(tr0, td2);
			mount_component(loader1, td2, null);
			append_dev(td2, t3);
			mount_component(loader2, td2, null);
			insert_dev(target, t4, anchor);
			insert_dev(target, tr1, anchor);
			append_dev(tr1, td3);
			mount_component(loader3, td3, null);
			append_dev(tr1, t5);
			append_dev(tr1, td4);
			append_dev(td4, t6);
			append_dev(tr1, t7);
			append_dev(tr1, td5);
			mount_component(loader4, td5, null);
			append_dev(td5, t8);
			mount_component(loader5, td5, null);
			insert_dev(target, t9, anchor);
			insert_dev(target, tr2, anchor);
			append_dev(tr2, td6);
			mount_component(loader6, td6, null);
			append_dev(tr2, t10);
			append_dev(tr2, td7);
			append_dev(td7, t11);
			append_dev(tr2, t12);
			append_dev(tr2, td8);
			mount_component(loader7, td8, null);
			append_dev(td8, t13);
			mount_component(loader8, td8, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(loader0.$$.fragment, local);
			transition_in(loader1.$$.fragment, local);
			transition_in(loader2.$$.fragment, local);
			transition_in(loader3.$$.fragment, local);
			transition_in(loader4.$$.fragment, local);
			transition_in(loader5.$$.fragment, local);
			transition_in(loader6.$$.fragment, local);
			transition_in(loader7.$$.fragment, local);
			transition_in(loader8.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loader0.$$.fragment, local);
			transition_out(loader1.$$.fragment, local);
			transition_out(loader2.$$.fragment, local);
			transition_out(loader3.$$.fragment, local);
			transition_out(loader4.$$.fragment, local);
			transition_out(loader5.$$.fragment, local);
			transition_out(loader6.$$.fragment, local);
			transition_out(loader7.$$.fragment, local);
			transition_out(loader8.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(tr0);
			destroy_component(loader0);
			destroy_component(loader1);
			destroy_component(loader2);
			if (detaching) detach_dev(t4);
			if (detaching) detach_dev(tr1);
			destroy_component(loader3);
			destroy_component(loader4);
			destroy_component(loader5);
			if (detaching) detach_dev(t9);
			if (detaching) detach_dev(tr2);
			destroy_component(loader6);
			destroy_component(loader7);
			destroy_component(loader8);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$2.name,
		type: "if",
		source: "(95:37) ",
		ctx
	});

	return block;
}

// (76:12) {#if value !== null && Array.isArray(value) && value.length}
function create_if_block_1$f(ctx) {
	let each_1_anchor;
	let current;
	let each_value = /*value*/ ctx[1].filter(Boolean);
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$a(get_each_context$a(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty & /*onRemove, value, Boolean, readonly*/ 262) {
				each_value = /*value*/ ctx[1].filter(Boolean);
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$a(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$a(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean_1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$f.name,
		type: "if",
		source: "(76:12) {#if value !== null && Array.isArray(value) && value.length}",
		ctx
	});

	return block;
}

// (82:24) {#if !readonly}
function create_if_block_2$5(ctx) {
	let td;
	let button;
	let current;

	button = new Button({
			props: {
				auto: true,
				style: "vertical-align: middle",
				$$slots: { default: [create_default_slot_3$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button.$on("click", function () {
		if (is_function(/*onRemove*/ ctx[8].bind(null, {
			id: /*val*/ ctx[18].id,
			index: /*i*/ ctx[20]
		}))) /*onRemove*/ ctx[8].bind(null, {
			id: /*val*/ ctx[18].id,
			index: /*i*/ ctx[20]
		}).apply(this, arguments);
	});

	const block = {
		c: function create() {
			td = element("td");
			create_component(button.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			td = claim_element(nodes, "TD", { class: true });
			var td_nodes = children(td);
			claim_component(button.$$.fragment, td_nodes);
			td_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(td, "class", "svelte-1rv59vc");
			add_location(td, file$18, 82, 28, 2276);
		},
		m: function mount(target, anchor) {
			insert_dev(target, td, anchor);
			mount_component(button, td, null);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const button_changes = {};

			if (dirty & /*$$scope*/ 2097152) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(td);
			destroy_component(button);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$5.name,
		type: "if",
		source: "(82:24) {#if !readonly}",
		ctx
	});

	return block;
}

// (84:32) <Button                                      auto                                      style="vertical-align: middle"                                     on:click={onRemove.bind(null, { id: val.id, index: i })}                                 >
function create_default_slot_3$1(ctx) {
	let icon;
	let current;

	icon = new Icon({
			props: { type: "close", size: "medium" },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(icon.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3$1.name,
		type: "slot",
		source: "(84:32) <Button                                      auto                                      style=\\\"vertical-align: middle\\\"                                     on:click={onRemove.bind(null, { id: val.id, index: i })}                                 >",
		ctx
	});

	return block;
}

// (77:16) {#each value.filter(Boolean) as val, i}
function create_each_block$a(ctx) {
	let tr;
	let td0;
	let t0_value = /*val*/ ctx[18].date + "";
	let t0;
	let t1;
	let td1;
	let t2;
	let t3;
	let td2;
	let t4_value = /*val*/ ctx[18].title + "";
	let t4;
	let t5;
	let t6;
	let current;
	let if_block = !/*readonly*/ ctx[2] && create_if_block_2$5(ctx);

	const block = {
		c: function create() {
			tr = element("tr");
			td0 = element("td");
			t0 = text(t0_value);
			t1 = space();
			td1 = element("td");
			t2 = text("—");
			t3 = space();
			td2 = element("td");
			t4 = text(t4_value);
			t5 = space();
			if (if_block) if_block.c();
			t6 = space();
			this.h();
		},
		l: function claim(nodes) {
			tr = claim_element(nodes, "TR", {});
			var tr_nodes = children(tr);
			td0 = claim_element(tr_nodes, "TD", { class: true });
			var td0_nodes = children(td0);
			t0 = claim_text(td0_nodes, t0_value);
			td0_nodes.forEach(detach_dev);
			t1 = claim_space(tr_nodes);
			td1 = claim_element(tr_nodes, "TD", { class: true });
			var td1_nodes = children(td1);
			t2 = claim_text(td1_nodes, "—");
			td1_nodes.forEach(detach_dev);
			t3 = claim_space(tr_nodes);
			td2 = claim_element(tr_nodes, "TD", { class: true });
			var td2_nodes = children(td2);
			t4 = claim_text(td2_nodes, t4_value);
			td2_nodes.forEach(detach_dev);
			t5 = claim_space(tr_nodes);
			if (if_block) if_block.l(tr_nodes);
			t6 = claim_space(tr_nodes);
			tr_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(td0, "class", "svelte-1rv59vc");
			add_location(td0, file$18, 78, 24, 2108);
			attr_dev(td1, "class", "svelte-1rv59vc");
			add_location(td1, file$18, 79, 24, 2152);
			attr_dev(td2, "class", "svelte-1rv59vc");
			add_location(td2, file$18, 80, 24, 2187);
			add_location(tr, file$18, 77, 20, 2079);
		},
		m: function mount(target, anchor) {
			insert_dev(target, tr, anchor);
			append_dev(tr, td0);
			append_dev(td0, t0);
			append_dev(tr, t1);
			append_dev(tr, td1);
			append_dev(td1, t2);
			append_dev(tr, t3);
			append_dev(tr, td2);
			append_dev(td2, t4);
			append_dev(tr, t5);
			if (if_block) if_block.m(tr, null);
			append_dev(tr, t6);
			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty & /*value*/ 2) && t0_value !== (t0_value = /*val*/ ctx[18].date + "")) set_data_dev(t0, t0_value);
			if ((!current || dirty & /*value*/ 2) && t4_value !== (t4_value = /*val*/ ctx[18].title + "")) set_data_dev(t4, t4_value);

			if (!/*readonly*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*readonly*/ 4) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_2$5(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(tr, t6);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(tr);
			if (if_block) if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$a.name,
		type: "each",
		source: "(77:16) {#each value.filter(Boolean) as val, i}",
		ctx
	});

	return block;
}

// (124:4) {#if !readonly}
function create_if_block$n(ctx) {
	let br;
	let t;
	let button;
	let current;
	br = new Br({ props: { size: "25" }, $$inline: true });

	button = new Button({
			props: {
				auto: true,
				is: "info",
				$$slots: { default: [create_default_slot_2$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button.$on("click", /*click_handler*/ ctx[13]);

	const block = {
		c: function create() {
			create_component(br.$$.fragment);
			t = space();
			create_component(button.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(br.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(button.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(br, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(button, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const button_changes = {};

			if (dirty & /*$$scope*/ 2097152) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(br.$$.fragment, local);
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br.$$.fragment, local);
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(br, detaching);
			if (detaching) detach_dev(t);
			destroy_component(button, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$n.name,
		type: "if",
		source: "(124:4) {#if !readonly}",
		ctx
	});

	return block;
}

// (126:8) <Button auto is="info" on:click={() => open = true}>
function create_default_slot_2$2(ctx) {
	let h3;
	let t;

	const block = {
		c: function create() {
			h3 = element("h3");
			t = text("Додати подію");
			this.h();
		},
		l: function claim(nodes) {
			h3 = claim_element(nodes, "H3", { style: true, class: true });
			var h3_nodes = children(h3);
			t = claim_text(h3_nodes, "Додати подію");
			h3_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_style(h3, "padding", "10px 25px");
			attr_dev(h3, "class", "font-w-500");
			add_location(h3, file$18, 126, 12, 3766);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h3, anchor);
			append_dev(h3, t);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h3);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$2.name,
		type: "slot",
		source: "(126:8) <Button auto is=\\\"info\\\" on:click={() => open = true}>",
		ctx
	});

	return block;
}

// (151:8) <Button                 is="info"                 size="medium"                 type="submit"                 form="story-form"                 class="full-width"         >
function create_default_slot_1$3(ctx) {
	let h3;
	let t;

	const block = {
		c: function create() {
			h3 = element("h3");
			t = text("Зберегти");
			this.h();
		},
		l: function claim(nodes) {
			h3 = claim_element(nodes, "H3", {});
			var h3_nodes = children(h3);
			t = claim_text(h3_nodes, "Зберегти");
			h3_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(h3, file$18, 157, 12, 4485);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h3, anchor);
			append_dev(h3, t);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h3);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$3.name,
		type: "slot",
		source: "(151:8) <Button                 is=\\\"info\\\"                 size=\\\"medium\\\"                 type=\\\"submit\\\"                 form=\\\"story-form\\\"                 class=\\\"full-width\\\"         >",
		ctx
	});

	return block;
}

// (134:0) <Modal      {open}     swipe="all"     id="story-life-modal"     size="medium"     title="Створення події"     on:close={() => open = false} >
function create_default_slot$J(ctx) {
	let div;
	let br0;
	let t0;
	let formbuilder;
	let t1;
	let br1;
	let t2;
	let button;
	let t3;
	let br2;
	let current;
	br0 = new Br({ props: { size: "20" }, $$inline: true });

	formbuilder = new FormBuilder({
			props: {
				id: "story-form",
				items: /*formFields*/ ctx[7],
				errors: /*formErrors*/ ctx[6],
				submit: /*onSubmit*/ ctx[9]
			},
			$$inline: true
		});

	br1 = new Br({ props: { size: "40" }, $$inline: true });

	button = new Button({
			props: {
				is: "info",
				size: "medium",
				type: "submit",
				form: "story-form",
				class: "full-width",
				$$slots: { default: [create_default_slot_1$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	br2 = new Br({ props: { size: "20" }, $$inline: true });

	const block = {
		c: function create() {
			div = element("div");
			create_component(br0.$$.fragment);
			t0 = space();
			create_component(formbuilder.$$.fragment);
			t1 = space();
			create_component(br1.$$.fragment);
			t2 = space();
			create_component(button.$$.fragment);
			t3 = space();
			create_component(br2.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			claim_component(br0.$$.fragment, div_nodes);
			t0 = claim_space(div_nodes);
			claim_component(formbuilder.$$.fragment, div_nodes);
			t1 = claim_space(div_nodes);
			claim_component(br1.$$.fragment, div_nodes);
			t2 = claim_space(div_nodes);
			claim_component(button.$$.fragment, div_nodes);
			t3 = claim_space(div_nodes);
			claim_component(br2.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "container");
			add_location(div, file$18, 141, 4, 4051);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(br0, div, null);
			append_dev(div, t0);
			mount_component(formbuilder, div, null);
			append_dev(div, t1);
			mount_component(br1, div, null);
			append_dev(div, t2);
			mount_component(button, div, null);
			append_dev(div, t3);
			mount_component(br2, div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const button_changes = {};

			if (dirty & /*$$scope*/ 2097152) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(br0.$$.fragment, local);
			transition_in(formbuilder.$$.fragment, local);
			transition_in(br1.$$.fragment, local);
			transition_in(button.$$.fragment, local);
			transition_in(br2.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br0.$$.fragment, local);
			transition_out(formbuilder.$$.fragment, local);
			transition_out(br1.$$.fragment, local);
			transition_out(button.$$.fragment, local);
			transition_out(br2.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(br0);
			destroy_component(formbuilder);
			destroy_component(br1);
			destroy_component(button);
			destroy_component(br2);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$J.name,
		type: "slot",
		source: "(134:0) <Modal      {open}     swipe=\\\"all\\\"     id=\\\"story-life-modal\\\"     size=\\\"medium\\\"     title=\\\"Створення події\\\"     on:close={() => open = false} >",
		ctx
	});

	return block;
}

function create_fragment$18(ctx) {
	let section;
	let t0;
	let table;
	let tbody;
	let show_if;
	let current_block_type_index;
	let if_block1;
	let t1;
	let t2;
	let modal;
	let current;
	let if_block0 = /*label*/ ctx[0] && create_if_block_4$1(ctx);
	const if_block_creators = [create_if_block_1$f, create_if_block_3$2];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (dirty & /*value*/ 2) show_if = !!(/*value*/ ctx[1] !== null && Array.isArray(/*value*/ ctx[1]) && /*value*/ ctx[1].length);
		if (show_if) return 0;
		if (/*value*/ ctx[1] === null) return 1;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx, -1))) {
		if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	let if_block2 = !/*readonly*/ ctx[2] && create_if_block$n(ctx);

	modal = new Modal({
			props: {
				open: /*open*/ ctx[3],
				swipe: "all",
				id: "story-life-modal",
				size: "medium",
				title: "Створення події",
				$$slots: { default: [create_default_slot$J] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	modal.$on("close", /*close_handler*/ ctx[14]);

	const block = {
		c: function create() {
			section = element("section");
			if (if_block0) if_block0.c();
			t0 = space();
			table = element("table");
			tbody = element("tbody");
			if (if_block1) if_block1.c();
			t1 = space();
			if (if_block2) if_block2.c();
			t2 = space();
			create_component(modal.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { class: true, style: true });
			var section_nodes = children(section);
			if (if_block0) if_block0.l(section_nodes);
			t0 = claim_space(section_nodes);
			table = claim_element(section_nodes, "TABLE", { class: true });
			var table_nodes = children(table);
			tbody = claim_element(table_nodes, "TBODY", {});
			var tbody_nodes = children(tbody);
			if (if_block1) if_block1.l(tbody_nodes);
			tbody_nodes.forEach(detach_dev);
			table_nodes.forEach(detach_dev);
			t1 = claim_space(section_nodes);
			if (if_block2) if_block2.l(section_nodes);
			section_nodes.forEach(detach_dev);
			t2 = claim_space(nodes);
			claim_component(modal.$$.fragment, nodes);
			this.h();
		},
		h: function hydrate() {
			add_location(tbody, file$18, 74, 8, 1922);
			attr_dev(table, "class", "svelte-1rv59vc");
			add_location(table, file$18, 73, 4, 1906);
			attr_dev(section, "class", /*classProp*/ ctx[4]);
			attr_dev(section, "style", /*styleProp*/ ctx[5]);
			add_location(section, file$18, 67, 0, 1762);
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			if (if_block0) if_block0.m(section, null);
			append_dev(section, t0);
			append_dev(section, table);
			append_dev(table, tbody);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(tbody, null);
			}

			append_dev(section, t1);
			if (if_block2) if_block2.m(section, null);
			insert_dev(target, t2, anchor);
			mount_component(modal, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*label*/ ctx[0]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*label*/ 1) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_4$1(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(section, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block1) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block1 = if_blocks[current_block_type_index];

					if (!if_block1) {
						if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block1.c();
					}

					transition_in(if_block1, 1);
					if_block1.m(tbody, null);
				} else {
					if_block1 = null;
				}
			}

			if (!/*readonly*/ ctx[2]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty & /*readonly*/ 4) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block$n(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(section, null);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (!current || dirty & /*classProp*/ 16) {
				attr_dev(section, "class", /*classProp*/ ctx[4]);
			}

			if (!current || dirty & /*styleProp*/ 32) {
				attr_dev(section, "style", /*styleProp*/ ctx[5]);
			}

			const modal_changes = {};
			if (dirty & /*open*/ 8) modal_changes.open = /*open*/ ctx[3];

			if (dirty & /*$$scope*/ 2097152) {
				modal_changes.$$scope = { dirty, ctx };
			}

			modal.$set(modal_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(if_block2);
			transition_in(modal.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(if_block2);
			transition_out(modal.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			if (if_block0) if_block0.d();

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d();
			}

			if (if_block2) if_block2.d();
			if (detaching) detach_dev(t2);
			destroy_component(modal, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$18.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$18($$self, $$props, $$invalidate) {
	const dispatch = createEventDispatcher();
	let { id = undefined } = $$props;
	let { name = undefined } = $$props;
	let { label = undefined } = $$props;
	let { value = undefined } = $$props;
	let { style = undefined } = $$props;
	let { readonly = undefined } = $$props;
	let open = false;
	let formErrors = [];

	let formFields = [
		{
			label: "Дата:",
			type: "date",
			name: "date",
			meta: { placeholder: "18.03.2019..." }
		},
		{
			label: "Добавте назву події:",
			type: "textarea",
			name: "title",
			meta: {
				placeholder: "Забрали в притулок...",
				rows: 3,
				maxlength: 75
			}
		}
	];

	function onRemove({ index }, e) {
		const val = [...value.filter((_, ind) => ind !== index)];
		dispatch("change", { e, name, value: val });
	}

	async function onSubmit(values, e) {
		const val = [...value, values];
		dispatch("change", { e, name, value: val });
		$$invalidate(3, open = false);
	}

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("StoryList", $$slots, []);
	const click_handler = () => $$invalidate(3, open = true);
	const close_handler = () => $$invalidate(3, open = false);

	$$self.$set = $$new_props => {
		$$invalidate(17, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("id" in $$new_props) $$invalidate(10, id = $$new_props.id);
		if ("name" in $$new_props) $$invalidate(11, name = $$new_props.name);
		if ("label" in $$new_props) $$invalidate(0, label = $$new_props.label);
		if ("value" in $$new_props) $$invalidate(1, value = $$new_props.value);
		if ("style" in $$new_props) $$invalidate(12, style = $$new_props.style);
		if ("readonly" in $$new_props) $$invalidate(2, readonly = $$new_props.readonly);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		classnames,
		toCSSString,
		Br,
		Icon,
		Modal,
		Loader,
		Button,
		FormBuilder,
		dispatch,
		id,
		name,
		label,
		value,
		style,
		readonly,
		open,
		formErrors,
		formFields,
		onRemove,
		onSubmit,
		idProp,
		classProp,
		styleProp
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(17, $$props = assign(assign({}, $$props), $$new_props));
		if ("id" in $$props) $$invalidate(10, id = $$new_props.id);
		if ("name" in $$props) $$invalidate(11, name = $$new_props.name);
		if ("label" in $$props) $$invalidate(0, label = $$new_props.label);
		if ("value" in $$props) $$invalidate(1, value = $$new_props.value);
		if ("style" in $$props) $$invalidate(12, style = $$new_props.style);
		if ("readonly" in $$props) $$invalidate(2, readonly = $$new_props.readonly);
		if ("open" in $$props) $$invalidate(3, open = $$new_props.open);
		if ("formErrors" in $$props) $$invalidate(6, formErrors = $$new_props.formErrors);
		if ("formFields" in $$props) $$invalidate(7, formFields = $$new_props.formFields);
		if ("idProp" in $$props) idProp = $$new_props.idProp;
		if ("classProp" in $$props) $$invalidate(4, classProp = $$new_props.classProp);
		if ("styleProp" in $$props) $$invalidate(5, styleProp = $$new_props.styleProp);
	};

	let idProp;
	let classProp;
	let styleProp;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*id, name*/ 3072) {
			 idProp = id || name;
		}

		 $$invalidate(4, classProp = classnames("story-list", $$props.class));

		if ($$self.$$.dirty & /*style*/ 4096) {
			 $$invalidate(5, styleProp = toCSSString({ ...style }));
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		label,
		value,
		readonly,
		open,
		classProp,
		styleProp,
		formErrors,
		formFields,
		onRemove,
		onSubmit,
		id,
		name,
		style,
		click_handler,
		close_handler
	];
}

class StoryList extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document.getElementById("svelte-1rv59vc-style")) add_css$s();

		init(this, options, instance$18, create_fragment$18, safe_not_equal, {
			id: 10,
			name: 11,
			label: 0,
			value: 1,
			style: 12,
			readonly: 2
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "StoryList",
			options,
			id: create_fragment$18.name
		});
	}

	get id() {
		throw new Error("<StoryList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<StoryList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get name() {
		throw new Error("<StoryList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set name(value) {
		throw new Error("<StoryList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get label() {
		throw new Error("<StoryList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set label(value) {
		throw new Error("<StoryList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<StoryList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<StoryList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<StoryList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<StoryList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get readonly() {
		throw new Error("<StoryList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set readonly(value) {
		throw new Error("<StoryList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/app/SearchLine.svelte generated by Svelte v3.24.0 */
const file$19 = "src/components/app/SearchLine.svelte";

function add_css$t() {
	var style = element("style");
	style.id = "svelte-16zbu6b-style";
	style.textContent = ".search.svelte-16zbu6b{}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2VhcmNoTGluZS5zdmVsdGUiLCJzb3VyY2VzIjpbIlNlYXJjaExpbmUuc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzY3JpcHQ+XG4gICAgaW1wb3J0IElucHV0IGZyb20gJ0Bjb21wb25lbnRzL2ZpZWxkcy9JbnB1dC5zdmVsdGUnXG48L3NjcmlwdD5cblxuPHNlY3Rpb24gY2xhc3M9XCJzZWFyY2hcIj5cbiAgICA8SW5wdXQgdHlwZT1cInNlYXJjaFwiLz5cbjwvc2VjdGlvbj5cblxuPHN0eWxlPlxuLnNlYXJjaCB7XG5cbn08L3N0eWxlPlxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQVNBLE9BQU8sZUFBQyxDQUFDLEFBRVQsQ0FBQyJ9 */";
	append_dev(document.head, style);
}

function create_fragment$19(ctx) {
	let section;
	let input;
	let current;

	input = new Input({
			props: { type: "search" },
			$$inline: true
		});

	const block = {
		c: function create() {
			section = element("section");
			create_component(input.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { class: true });
			var section_nodes = children(section);
			claim_component(input.$$.fragment, section_nodes);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(section, "class", "search svelte-16zbu6b");
			add_location(section, file$19, 4, 0, 76);
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			mount_component(input, section, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(input.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(input.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			destroy_component(input);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$19.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$19($$self, $$props, $$invalidate) {
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SearchLine> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("SearchLine", $$slots, []);
	$$self.$capture_state = () => ({ Input });
	return [];
}

class SearchLine extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document.getElementById("svelte-16zbu6b-style")) add_css$t();
		init(this, options, instance$19, create_fragment$19, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "SearchLine",
			options,
			id: create_fragment$19.name
		});
	}
}

/* src/components/app/TrustButton.svelte generated by Svelte v3.24.0 */
const file$1a = "src/components/app/TrustButton.svelte";

function add_css$u() {
	var style = element("style");
	style.id = "svelte-1xs9p24-style";
	style.textContent = ".trust-btn.svelte-1xs9p24.svelte-1xs9p24{position:relative;display:block;width:100%;height:0;padding-bottom:100%;border-radius:50%;overflow:hidden}div.svelte-1xs9p24.svelte-1xs9p24{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;border-radius:50%;border:4px solid rgba(var(--color-danger));background-color:rgba(var(--color-danger), .2)}.trust-btn.isActive.svelte-1xs9p24 div.svelte-1xs9p24{background-color:rgba(var(--color-danger), 1)}.trust-btn.isActive.svelte-1xs9p24 span.svelte-1xs9p24{color:rgba(var(--color-white));-webkit-animation:none;animation:none;-webkit-transform:scale(1.1);transform:scale(1.1)\n}span.svelte-1xs9p24.svelte-1xs9p24{display:-webkit-box;display:-ms-flexbox;display:flex;width:50%;height:50%;margin-top:3px;max-width:calc(100% - 10px);max-height:calc(100% - 10px);color:rgba(var(--color-danger));-webkit-animation:svelte-1xs9p24-pulse 2s infinite;animation:svelte-1xs9p24-pulse 2s infinite}@-webkit-keyframes svelte-1xs9p24-pulse{10%{-webkit-transform:scale(1.1);transform:scale(1.1)\n    }20%{-webkit-transform:scale(1.05);transform:scale(1.05)\n    }30%{-webkit-transform:scale(1.15);transform:scale(1.15)\n    }}@keyframes svelte-1xs9p24-pulse{10%{-webkit-transform:scale(1.1);transform:scale(1.1)\n    }20%{-webkit-transform:scale(1.05);transform:scale(1.05)\n    }30%{-webkit-transform:scale(1.15);transform:scale(1.15)\n    }}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVHJ1c3RCdXR0b24uc3ZlbHRlIiwic291cmNlcyI6WyJUcnVzdEJ1dHRvbi5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBjcmVhdGVFdmVudERpc3BhdGNoZXIgfSBmcm9tICdzdmVsdGUnXG4gICAgaW1wb3J0IHsgY2xhc3NuYW1lcyB9IGZyb20gJ0B1dGlscydcbiAgICBpbXBvcnQgSWNvbiBmcm9tICdAY29tcG9uZW50cy9JY29uLnN2ZWx0ZSdcblxuICAgIGNvbnN0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKClcblxuICAgIGV4cG9ydCBsZXQgaXNBY3RpdmUgPSBudWxsXG4gICAgZXhwb3J0IGxldCBvbkFzeW5jQ2xpY2sgPSBudWxsXG5cbiAgICBsZXQgaXNBY3RpdmVMb2NhbCA9ICEhaXNBY3RpdmVcblxuICAgICQ6IGlzQWN0aXZlU3RhdGUgPSBpc0FjdGl2ZSA9PT0gbnVsbCA/IGlzQWN0aXZlTG9jYWwgOiBpc0FjdGl2ZVxuICAgICQ6IGNsYXNzUHJvcCA9IGNsYXNzbmFtZXMoJ3RydXN0LWJ0bicsICQkcHJvcHMuY2xhc3MsIHsgaXNBY3RpdmU6IGlzQWN0aXZlU3RhdGUgfSlcblxuICAgIGZ1bmN0aW9uIG9uQ2xpY2tIYW5kbGVyKGUpIHtcbiAgICAgICAgb25DbGlja0V2ZW50KGUpXG4gICAgICAgIG9uQ2xpY2tQcm9taXNlKGUpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25DbGlja0V2ZW50KGUpIHtcbiAgICAgICAgZGlzcGF0Y2goJ2NsaWNrJywgZSlcbiAgICB9XG5cbiAgICBjb25zdCBvbkNsaWNrUHJvbWlzZSA9IGFzeW5jIChlKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2Ygb25Bc3luY0NsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlzQWN0aXZlTG9jYWwgPSAhaXNBY3RpdmVMb2NhbFxuICAgICAgICAgICAgICAgIGF3YWl0IG9uQXN5bmNDbGljayhlKVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaXNBY3RpdmVMb2NhbCA9ICFpc0FjdGl2ZUxvY2FsXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG48L3NjcmlwdD5cblxuPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgdGl0bGU9XCJJIHRydXN0XCIgY2xhc3M9e2NsYXNzUHJvcH0gb246Y2xpY2s9e29uQ2xpY2tIYW5kbGVyfT5cbiAgICA8ZGl2IGNsYXNzPVwiZnVsbC1hYnNvbHV0ZVwiPlxuICAgICAgICA8c3Bhbj5cbiAgICAgICAgICAgIDxJY29uIHR5cGU9XCJoZWFydFwiIGlzPXtpc0FjdGl2ZSA/ICdsaWdodCcgOiAnZGFuZ2VyJ30vPlxuICAgICAgICA8L3NwYW4+XG4gICAgPC9kaXY+XG48L2J1dHRvbj5cblxuPHN0eWxlPlxuLnRydXN0LWJ0biB7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogMDtcbiAgICBwYWRkaW5nLWJvdHRvbTogMTAwJTtcbiAgICBib3JkZXItcmFkaXVzOiA1MCU7XG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcbn1cblxuZGl2IHtcbiAgICBkaXNwbGF5OiAtd2Via2l0LWJveDtcbiAgICBkaXNwbGF5OiAtbXMtZmxleGJveDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIC13ZWJraXQtYm94LWFsaWduOiBjZW50ZXI7XG4gICAgICAgIC1tcy1mbGV4LWFsaWduOiBjZW50ZXI7XG4gICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIC13ZWJraXQtYm94LXBhY2s6IGNlbnRlcjtcbiAgICAgICAgLW1zLWZsZXgtcGFjazogY2VudGVyO1xuICAgICAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgYm9yZGVyLXJhZGl1czogNTAlO1xuICAgIGJvcmRlcjogNHB4IHNvbGlkIHJnYmEodmFyKC0tY29sb3ItZGFuZ2VyKSk7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSh2YXIoLS1jb2xvci1kYW5nZXIpLCAuMik7XG59XG5cbi50cnVzdC1idG4uaXNBY3RpdmUgZGl2IHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKHZhcigtLWNvbG9yLWRhbmdlciksIDEpO1xufVxuXG4udHJ1c3QtYnRuLmlzQWN0aXZlIHNwYW4ge1xuICAgIGNvbG9yOiByZ2JhKHZhcigtLWNvbG9yLXdoaXRlKSk7XG4gICAgLXdlYmtpdC1hbmltYXRpb246IG5vbmU7XG4gICAgICAgICAgICBhbmltYXRpb246IG5vbmU7XG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDEuMSk7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDEuMSlcbn1cblxuc3BhbiB7XG4gICAgZGlzcGxheTogLXdlYmtpdC1ib3g7XG4gICAgZGlzcGxheTogLW1zLWZsZXhib3g7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICB3aWR0aDogNTAlO1xuICAgIGhlaWdodDogNTAlO1xuICAgIG1hcmdpbi10b3A6IDNweDtcbiAgICBtYXgtd2lkdGg6IGNhbGMoMTAwJSAtIDEwcHgpO1xuICAgIG1heC1oZWlnaHQ6IGNhbGMoMTAwJSAtIDEwcHgpO1xuICAgIGNvbG9yOiByZ2JhKHZhcigtLWNvbG9yLWRhbmdlcikpO1xuICAgIC13ZWJraXQtYW5pbWF0aW9uOiBwdWxzZSAycyBpbmZpbml0ZTtcbiAgICAgICAgICAgIGFuaW1hdGlvbjogcHVsc2UgMnMgaW5maW5pdGU7XG59XG5cbkAtd2Via2l0LWtleWZyYW1lcyBwdWxzZSB7XG4gICAgMTAlIHtcbiAgICAgICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDEuMSk7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgxLjEpXG4gICAgfVxuICAgIDIwJSB7XG4gICAgICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSgxLjA1KTtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDEuMDUpXG4gICAgfVxuICAgIDMwJSB7XG4gICAgICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSgxLjE1KTtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDEuMTUpXG4gICAgfVxufVxuXG5Aa2V5ZnJhbWVzIHB1bHNlIHtcbiAgICAxMCUge1xuICAgICAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMS4xKTtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDEuMSlcbiAgICB9XG4gICAgMjAlIHtcbiAgICAgICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDEuMDUpO1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMS4wNSlcbiAgICB9XG4gICAgMzAlIHtcbiAgICAgICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDEuMTUpO1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMS4xNSlcbiAgICB9XG59PC9zdHlsZT5cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUE2Q0EsVUFBVSw4QkFBQyxDQUFDLEFBQ1IsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsT0FBTyxDQUFFLEtBQUssQ0FDZCxLQUFLLENBQUUsSUFBSSxDQUNYLE1BQU0sQ0FBRSxDQUFDLENBQ1QsY0FBYyxDQUFFLElBQUksQ0FDcEIsYUFBYSxDQUFFLEdBQUcsQ0FDbEIsUUFBUSxDQUFFLE1BQU0sQUFDcEIsQ0FBQyxBQUVELEdBQUcsOEJBQUMsQ0FBQyxBQUNELE9BQU8sQ0FBRSxXQUFXLENBQ3BCLE9BQU8sQ0FBRSxXQUFXLENBQ3BCLE9BQU8sQ0FBRSxJQUFJLENBQ2IsaUJBQWlCLENBQUUsTUFBTSxDQUNyQixjQUFjLENBQUUsTUFBTSxDQUNsQixXQUFXLENBQUUsTUFBTSxDQUMzQixnQkFBZ0IsQ0FBRSxNQUFNLENBQ3BCLGFBQWEsQ0FBRSxNQUFNLENBQ2pCLGVBQWUsQ0FBRSxNQUFNLENBQy9CLGFBQWEsQ0FBRSxHQUFHLENBQ2xCLE1BQU0sQ0FBRSxHQUFHLENBQUMsS0FBSyxDQUFDLEtBQUssSUFBSSxjQUFjLENBQUMsQ0FBQyxDQUMzQyxnQkFBZ0IsQ0FBRSxLQUFLLElBQUksY0FBYyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQUFDbkQsQ0FBQyxBQUVELFVBQVUsd0JBQVMsQ0FBQyxHQUFHLGVBQUMsQ0FBQyxBQUNyQixnQkFBZ0IsQ0FBRSxLQUFLLElBQUksY0FBYyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQUFDbEQsQ0FBQyxBQUVELFVBQVUsd0JBQVMsQ0FBQyxJQUFJLGVBQUMsQ0FBQyxBQUN0QixLQUFLLENBQUUsS0FBSyxJQUFJLGFBQWEsQ0FBQyxDQUFDLENBQy9CLGlCQUFpQixDQUFFLElBQUksQ0FDZixTQUFTLENBQUUsSUFBSSxDQUN2QixpQkFBaUIsQ0FBRSxNQUFNLEdBQUcsQ0FBQyxDQUNyQixTQUFTLENBQUUsTUFBTSxHQUFHLENBQUM7QUFDakMsQ0FBQyxBQUVELElBQUksOEJBQUMsQ0FBQyxBQUNGLE9BQU8sQ0FBRSxXQUFXLENBQ3BCLE9BQU8sQ0FBRSxXQUFXLENBQ3BCLE9BQU8sQ0FBRSxJQUFJLENBQ2IsS0FBSyxDQUFFLEdBQUcsQ0FDVixNQUFNLENBQUUsR0FBRyxDQUNYLFVBQVUsQ0FBRSxHQUFHLENBQ2YsU0FBUyxDQUFFLEtBQUssSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FDNUIsVUFBVSxDQUFFLEtBQUssSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FDN0IsS0FBSyxDQUFFLEtBQUssSUFBSSxjQUFjLENBQUMsQ0FBQyxDQUNoQyxpQkFBaUIsQ0FBRSxvQkFBSyxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQzVCLFNBQVMsQ0FBRSxvQkFBSyxDQUFDLEVBQUUsQ0FBQyxRQUFRLEFBQ3hDLENBQUMsQUFFRCxtQkFBbUIsb0JBQU0sQ0FBQyxBQUN0QixHQUFHLEFBQUMsQ0FBQyxBQUNELGlCQUFpQixDQUFFLE1BQU0sR0FBRyxDQUFDLENBQ3JCLFNBQVMsQ0FBRSxNQUFNLEdBQUcsQ0FBQztJQUNqQyxDQUFDLEFBQ0QsR0FBRyxBQUFDLENBQUMsQUFDRCxpQkFBaUIsQ0FBRSxNQUFNLElBQUksQ0FBQyxDQUN0QixTQUFTLENBQUUsTUFBTSxJQUFJLENBQUM7SUFDbEMsQ0FBQyxBQUNELEdBQUcsQUFBQyxDQUFDLEFBQ0QsaUJBQWlCLENBQUUsTUFBTSxJQUFJLENBQUMsQ0FDdEIsU0FBUyxDQUFFLE1BQU0sSUFBSSxDQUFDO0lBQ2xDLENBQUMsQUFDTCxDQUFDLEFBRUQsV0FBVyxvQkFBTSxDQUFDLEFBQ2QsR0FBRyxBQUFDLENBQUMsQUFDRCxpQkFBaUIsQ0FBRSxNQUFNLEdBQUcsQ0FBQyxDQUNyQixTQUFTLENBQUUsTUFBTSxHQUFHLENBQUM7SUFDakMsQ0FBQyxBQUNELEdBQUcsQUFBQyxDQUFDLEFBQ0QsaUJBQWlCLENBQUUsTUFBTSxJQUFJLENBQUMsQ0FDdEIsU0FBUyxDQUFFLE1BQU0sSUFBSSxDQUFDO0lBQ2xDLENBQUMsQUFDRCxHQUFHLEFBQUMsQ0FBQyxBQUNELGlCQUFpQixDQUFFLE1BQU0sSUFBSSxDQUFDLENBQ3RCLFNBQVMsQ0FBRSxNQUFNLElBQUksQ0FBQztJQUNsQyxDQUFDLEFBQ0wsQ0FBQyJ9 */";
	append_dev(document.head, style);
}

function create_fragment$1a(ctx) {
	let button;
	let div;
	let span;
	let icon;
	let button_class_value;
	let current;
	let mounted;
	let dispose;

	icon = new Icon({
			props: {
				type: "heart",
				is: /*isActive*/ ctx[0] ? "light" : "danger"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			button = element("button");
			div = element("div");
			span = element("span");
			create_component(icon.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", { type: true, title: true, class: true });
			var button_nodes = children(button);
			div = claim_element(button_nodes, "DIV", { class: true });
			var div_nodes = children(div);
			span = claim_element(div_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			claim_component(icon.$$.fragment, span_nodes);
			span_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			button_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "svelte-1xs9p24");
			add_location(span, file$1a, 38, 8, 1044);
			attr_dev(div, "class", "full-absolute svelte-1xs9p24");
			add_location(div, file$1a, 37, 4, 1008);
			attr_dev(button, "type", "button");
			attr_dev(button, "title", "I trust");
			attr_dev(button, "class", button_class_value = "" + (null_to_empty(/*classProp*/ ctx[1]) + " svelte-1xs9p24"));
			add_location(button, file$1a, 36, 0, 921);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, div);
			append_dev(div, span);
			mount_component(icon, span, null);
			current = true;

			if (!mounted) {
				dispose = listen_dev(button, "click", /*onClickHandler*/ ctx[2], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			const icon_changes = {};
			if (dirty & /*isActive*/ 1) icon_changes.is = /*isActive*/ ctx[0] ? "light" : "danger";
			icon.$set(icon_changes);

			if (!current || dirty & /*classProp*/ 2 && button_class_value !== (button_class_value = "" + (null_to_empty(/*classProp*/ ctx[1]) + " svelte-1xs9p24"))) {
				attr_dev(button, "class", button_class_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			destroy_component(icon);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1a.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1a($$self, $$props, $$invalidate) {
	const dispatch = createEventDispatcher();
	let { isActive = null } = $$props;
	let { onAsyncClick = null } = $$props;
	let isActiveLocal = !!isActive;

	function onClickHandler(e) {
		onClickEvent(e);
		onClickPromise(e);
	}

	function onClickEvent(e) {
		dispatch("click", e);
	}

	const onClickPromise = async e => {
		if (typeof onAsyncClick === "function") {
			try {
				$$invalidate(4, isActiveLocal = !isActiveLocal);
				await onAsyncClick(e);
			} catch(err) {
				$$invalidate(4, isActiveLocal = !isActiveLocal);
			}
		}
	};

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("TrustButton", $$slots, []);

	$$self.$set = $$new_props => {
		$$invalidate(9, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("isActive" in $$new_props) $$invalidate(0, isActive = $$new_props.isActive);
		if ("onAsyncClick" in $$new_props) $$invalidate(3, onAsyncClick = $$new_props.onAsyncClick);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		classnames,
		Icon,
		dispatch,
		isActive,
		onAsyncClick,
		isActiveLocal,
		onClickHandler,
		onClickEvent,
		onClickPromise,
		isActiveState,
		classProp
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(9, $$props = assign(assign({}, $$props), $$new_props));
		if ("isActive" in $$props) $$invalidate(0, isActive = $$new_props.isActive);
		if ("onAsyncClick" in $$props) $$invalidate(3, onAsyncClick = $$new_props.onAsyncClick);
		if ("isActiveLocal" in $$props) $$invalidate(4, isActiveLocal = $$new_props.isActiveLocal);
		if ("isActiveState" in $$props) $$invalidate(5, isActiveState = $$new_props.isActiveState);
		if ("classProp" in $$props) $$invalidate(1, classProp = $$new_props.classProp);
	};

	let isActiveState;
	let classProp;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*isActive, isActiveLocal*/ 17) {
			 $$invalidate(5, isActiveState = isActive === null ? isActiveLocal : isActive);
		}

		 $$invalidate(1, classProp = classnames("trust-btn", $$props.class, { isActive: isActiveState }));
	};

	$$props = exclude_internal_props($$props);
	return [isActive, classProp, onClickHandler, onAsyncClick];
}

class TrustButton extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document.getElementById("svelte-1xs9p24-style")) add_css$u();
		init(this, options, instance$1a, create_fragment$1a, safe_not_equal, { isActive: 0, onAsyncClick: 3 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "TrustButton",
			options,
			id: create_fragment$1a.name
		});
	}

	get isActive() {
		throw new Error("<TrustButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isActive(value) {
		throw new Error("<TrustButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get onAsyncClick() {
		throw new Error("<TrustButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set onAsyncClick(value) {
		throw new Error("<TrustButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/app/TitleSubTitle.svelte generated by Svelte v3.24.0 */

const file$1b = "src/components/app/TitleSubTitle.svelte";

function add_css$v() {
	var style = element("style");
	style.id = "svelte-1cmj5fu-style";
	style.textContent = "section.svelte-1cmj5fu{text-align:center;padding:0 3vw}h2.svelte-1cmj5fu{font-weight:400}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGl0bGVTdWJUaXRsZS5zdmVsdGUiLCJzb3VyY2VzIjpbIlRpdGxlU3ViVGl0bGUuc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzY3JpcHQ+XG4gICAgZXhwb3J0IGxldCB0aXRsZSA9ICdUaGUgbWFpbiB0aXRsZSB0aGF0IGV4cGxhaW5zIHRoZSBjaGFyaXR5J1xuICAgIGV4cG9ydCBsZXQgc3VidGl0bGUgPSAnQW5kIGJpZ2dlciBkZXNjcmlwdGlvbiB0aGF0IGRlc2NyaWJlcyBpbiBzaG9ydCBrZXl3b3JkcyBhIGNoYXJpdHksIHRpdGxlIGFib3ZlIGFuZCBqdXN0IG1ha2VzIHRleHQgbG9uZ2VyJ1xuPC9zY3JpcHQ+XG5cbjxzZWN0aW9uPlxuICAgIDxoMT57dGl0bGV9PC9oMT5cbiAgICA8YnI+XG4gICAgPGgyPntzdWJ0aXRsZX08L2gyPlxuPC9zZWN0aW9uPlxuXG48c3R5bGU+XG5zZWN0aW9uIHtcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgcGFkZGluZzogMCAzdnc7XG59XG5cbmgyIHtcbiAgICBmb250LXdlaWdodDogNDAwO1xufTwvc3R5bGU+XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBWUEsT0FBTyxlQUFDLENBQUMsQUFDTCxVQUFVLENBQUUsTUFBTSxDQUNsQixPQUFPLENBQUUsQ0FBQyxDQUFDLEdBQUcsQUFDbEIsQ0FBQyxBQUVELEVBQUUsZUFBQyxDQUFDLEFBQ0EsV0FBVyxDQUFFLEdBQUcsQUFDcEIsQ0FBQyJ9 */";
	append_dev(document.head, style);
}

function create_fragment$1b(ctx) {
	let section;
	let h1;
	let t0;
	let t1;
	let br;
	let t2;
	let h2;
	let t3;

	const block = {
		c: function create() {
			section = element("section");
			h1 = element("h1");
			t0 = text(/*title*/ ctx[0]);
			t1 = space();
			br = element("br");
			t2 = space();
			h2 = element("h2");
			t3 = text(/*subtitle*/ ctx[1]);
			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { class: true });
			var section_nodes = children(section);
			h1 = claim_element(section_nodes, "H1", {});
			var h1_nodes = children(h1);
			t0 = claim_text(h1_nodes, /*title*/ ctx[0]);
			h1_nodes.forEach(detach_dev);
			t1 = claim_space(section_nodes);
			br = claim_element(section_nodes, "BR", {});
			t2 = claim_space(section_nodes);
			h2 = claim_element(section_nodes, "H2", { class: true });
			var h2_nodes = children(h2);
			t3 = claim_text(h2_nodes, /*subtitle*/ ctx[1]);
			h2_nodes.forEach(detach_dev);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(h1, file$1b, 6, 4, 234);
			add_location(br, file$1b, 7, 4, 255);
			attr_dev(h2, "class", "svelte-1cmj5fu");
			add_location(h2, file$1b, 8, 4, 264);
			attr_dev(section, "class", "svelte-1cmj5fu");
			add_location(section, file$1b, 5, 0, 220);
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			append_dev(section, h1);
			append_dev(h1, t0);
			append_dev(section, t1);
			append_dev(section, br);
			append_dev(section, t2);
			append_dev(section, h2);
			append_dev(h2, t3);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*title*/ 1) set_data_dev(t0, /*title*/ ctx[0]);
			if (dirty & /*subtitle*/ 2) set_data_dev(t3, /*subtitle*/ ctx[1]);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1b.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1b($$self, $$props, $$invalidate) {
	let { title = "The main title that explains the charity" } = $$props;
	let { subtitle = "And bigger description that describes in short keywords a charity, title above and just makes text longer" } = $$props;
	const writable_props = ["title", "subtitle"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<TitleSubTitle> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("TitleSubTitle", $$slots, []);

	$$self.$set = $$props => {
		if ("title" in $$props) $$invalidate(0, title = $$props.title);
		if ("subtitle" in $$props) $$invalidate(1, subtitle = $$props.subtitle);
	};

	$$self.$capture_state = () => ({ title, subtitle });

	$$self.$inject_state = $$props => {
		if ("title" in $$props) $$invalidate(0, title = $$props.title);
		if ("subtitle" in $$props) $$invalidate(1, subtitle = $$props.subtitle);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [title, subtitle];
}

class TitleSubTitle extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document.getElementById("svelte-1cmj5fu-style")) add_css$v();
		init(this, options, instance$1b, create_fragment$1b, safe_not_equal, { title: 0, subtitle: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "TitleSubTitle",
			options,
			id: create_fragment$1b.name
		});
	}

	get title() {
		throw new Error("<TitleSubTitle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<TitleSubTitle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get subtitle() {
		throw new Error("<TitleSubTitle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set subtitle(value) {
		throw new Error("<TitleSubTitle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/app/ContentHolder.svelte generated by Svelte v3.24.0 */

const file$1c = "src/components/app/ContentHolder.svelte";

function create_fragment$1c(ctx) {
	let h1;
	let t0;
	let t1;
	let br0;
	let t2;
	let br1;
	let t3;
	let pre0;
	let t4;
	let t5;
	let br2;
	let t6;
	let pre1;
	let t7;

	const block = {
		c: function create() {
			h1 = element("h1");
			t0 = text("About");
			t1 = space();
			br0 = element("br");
			t2 = space();
			br1 = element("br");
			t3 = space();
			pre0 = element("pre");
			t4 = text("This is the \"about\" section which explains people the main sense of our purpose.\n    There's not much here.\n    But this section is not the least!");
			t5 = space();
			br2 = element("br");
			t6 = space();
			pre1 = element("pre");
			t7 = text("We try to make our society more kind and we do kind things for it.\n    Nevertheless, this is the \"about\" page.\n    And there's not much here.");
			this.h();
		},
		l: function claim(nodes) {
			h1 = claim_element(nodes, "H1", { class: true });
			var h1_nodes = children(h1);
			t0 = claim_text(h1_nodes, "About");
			h1_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			br0 = claim_element(nodes, "BR", {});
			t2 = claim_space(nodes);
			br1 = claim_element(nodes, "BR", {});
			t3 = claim_space(nodes);
			pre0 = claim_element(nodes, "PRE", {});
			var pre0_nodes = children(pre0);
			t4 = claim_text(pre0_nodes, "This is the \"about\" section which explains people the main sense of our purpose.\n    There's not much here.\n    But this section is not the least!");
			pre0_nodes.forEach(detach_dev);
			t5 = claim_space(nodes);
			br2 = claim_element(nodes, "BR", {});
			t6 = claim_space(nodes);
			pre1 = claim_element(nodes, "PRE", {});
			var pre1_nodes = children(pre1);
			t7 = claim_text(pre1_nodes, "We try to make our society more kind and we do kind things for it.\n    Nevertheless, this is the \"about\" page.\n    And there's not much here.");
			pre1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(h1, "class", "text-center");
			add_location(h1, file$1c, 4, 0, 21);
			add_location(br0, file$1c, 5, 0, 56);
			add_location(br1, file$1c, 6, 0, 61);
			add_location(pre0, file$1c, 7, 0, 66);
			add_location(br2, file$1c, 12, 0, 230);
			add_location(pre1, file$1c, 13, 0, 235);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h1, anchor);
			append_dev(h1, t0);
			insert_dev(target, t1, anchor);
			insert_dev(target, br0, anchor);
			insert_dev(target, t2, anchor);
			insert_dev(target, br1, anchor);
			insert_dev(target, t3, anchor);
			insert_dev(target, pre0, anchor);
			append_dev(pre0, t4);
			insert_dev(target, t5, anchor);
			insert_dev(target, br2, anchor);
			insert_dev(target, t6, anchor);
			insert_dev(target, pre1, anchor);
			append_dev(pre1, t7);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(h1);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(br0);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(br1);
			if (detaching) detach_dev(t3);
			if (detaching) detach_dev(pre0);
			if (detaching) detach_dev(t5);
			if (detaching) detach_dev(br2);
			if (detaching) detach_dev(t6);
			if (detaching) detach_dev(pre1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1c.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1c($$self, $$props) {
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ContentHolder> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("ContentHolder", $$slots, []);
	return [];
}

class ContentHolder extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1c, create_fragment$1c, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ContentHolder",
			options,
			id: create_fragment$1c.name
		});
	}
}

/* src/components/app/DonationButton.svelte generated by Svelte v3.24.0 */
const file$1d = "src/components/app/DonationButton.svelte";

function add_css$w() {
	var style = element("style");
	style.id = "svelte-1nsvb2j-style";
	style.textContent = ".donate-btn.svelte-1nsvb2j{position:fixed;left:0;bottom:env(safe-area-inset-bottom);display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;width:100%;font-weight:600;font-size:1.85em;line-height:1.26;color:rgba(var(--color-white));padding:20px;z-index:9;-ms-touch-action:manipulation;touch-action:manipulation;text-align:center;-webkit-transition:.3s ease-in-out;transition:.3s ease-in-out;-webkit-transform:translateY(100%);transform:translateY(100%);background-color:rgba(var(--color-success))}span.svelte-1nsvb2j{-webkit-box-flex:0;-ms-flex:none;flex:none;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;height:32px;width:32px;border-radius:50%;overflow:hidden;background-color:rgba(var(--color-white))}.donate-btn.active.svelte-1nsvb2j{-webkit-transform:none;transform:none\n}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRG9uYXRpb25CdXR0b24uc3ZlbHRlIiwic291cmNlcyI6WyJEb25hdGlvbkJ1dHRvbi5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSAnc3ZlbHRlJ1xuICAgIGltcG9ydCB7IGNsYXNzbmFtZXMgfSBmcm9tICdAdXRpbHMnXG4gICAgaW1wb3J0IEljb24gZnJvbSAnQGNvbXBvbmVudHMvSWNvbi5zdmVsdGUnXG5cbiAgICBsZXQgYWN0aXZlRG9uYXRlQnRuID0gZmFsc2VcblxuICAgIG9uTW91bnQoKCkgPT4gc2V0VGltZW91dCgoKSA9PiBhY3RpdmVEb25hdGVCdG4gPSB0cnVlLCA1MDApKVxuXG4gICAgJDogY2xhc3NQcm9wRG9uYXRlQnRuID0gY2xhc3NuYW1lcygnZG9uYXRlLWJ0bicsIHsgYWN0aXZlOiBhY3RpdmVEb25hdGVCdG4gfSlcblxuICAgIGZ1bmN0aW9uIG9uRG9uYXRlKCkge1xuICAgICAgICBhbGVydCgn0JTRj9C60YPRjiEg8J+lsCcpXG4gICAgfVxuPC9zY3JpcHQ+XG5cbjxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPXtjbGFzc1Byb3BEb25hdGVCdG59IG9uOmNsaWNrPXtvbkRvbmF0ZX0+XG4gICAgPHNwYW4+XG4gICAgICAgIDxJY29uIHR5cGU9XCJjb2luXCIgc2l6ZT1cIm1lZGl1bVwiIGlzPVwicHJpbWFyeVwiLz5cbiAgICA8L3NwYW4+XG4gICAgPHM+PC9zPlxuICAgIDxzPjwvcz5cbiAgICDQlNC+0L/QvtC80L7Qs9GC0LhcbjwvYnV0dG9uPlxuXG48c3R5bGU+XG4uZG9uYXRlLWJ0biB7XG4gICAgcG9zaXRpb246IGZpeGVkO1xuICAgIGxlZnQ6IDA7XG4gICAgYm90dG9tOiBlbnYoc2FmZS1hcmVhLWluc2V0LWJvdHRvbSk7XG4gICAgZGlzcGxheTogLXdlYmtpdC1ib3g7XG4gICAgZGlzcGxheTogLW1zLWZsZXhib3g7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICAtd2Via2l0LWJveC1hbGlnbjogY2VudGVyO1xuICAgICAgICAtbXMtZmxleC1hbGlnbjogY2VudGVyO1xuICAgICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAtd2Via2l0LWJveC1wYWNrOiBjZW50ZXI7XG4gICAgICAgIC1tcy1mbGV4LXBhY2s6IGNlbnRlcjtcbiAgICAgICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGZvbnQtd2VpZ2h0OiA2MDA7XG4gICAgZm9udC1zaXplOiAxLjg1ZW07XG4gICAgbGluZS1oZWlnaHQ6IDEuMjY7XG4gICAgY29sb3I6IHJnYmEodmFyKC0tY29sb3Itd2hpdGUpKTtcbiAgICBwYWRkaW5nOiAyMHB4O1xuICAgIHotaW5kZXg6IDk7XG4gICAgLW1zLXRvdWNoLWFjdGlvbjogbWFuaXB1bGF0aW9uO1xuICAgICAgICB0b3VjaC1hY3Rpb246IG1hbmlwdWxhdGlvbjtcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgLXdlYmtpdC10cmFuc2l0aW9uOiAuM3MgZWFzZS1pbi1vdXQ7XG4gICAgdHJhbnNpdGlvbjogLjNzIGVhc2UtaW4tb3V0O1xuICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDEwMCUpO1xuICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDEwMCUpO1xuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEodmFyKC0tY29sb3Itc3VjY2VzcykpO1xufVxuXG5zcGFuIHtcbiAgICAtd2Via2l0LWJveC1mbGV4OiAwO1xuICAgICAgICAtbXMtZmxleDogbm9uZTtcbiAgICAgICAgICAgIGZsZXg6IG5vbmU7XG4gICAgZGlzcGxheTogLXdlYmtpdC1ib3g7XG4gICAgZGlzcGxheTogLW1zLWZsZXhib3g7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICAtd2Via2l0LWJveC1hbGlnbjogY2VudGVyO1xuICAgICAgICAtbXMtZmxleC1hbGlnbjogY2VudGVyO1xuICAgICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAtd2Via2l0LWJveC1wYWNrOiBjZW50ZXI7XG4gICAgICAgIC1tcy1mbGV4LXBhY2s6IGNlbnRlcjtcbiAgICAgICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIGhlaWdodDogMzJweDtcbiAgICB3aWR0aDogMzJweDtcbiAgICBib3JkZXItcmFkaXVzOiA1MCU7XG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKHZhcigtLWNvbG9yLXdoaXRlKSk7XG59XG5cbi5kb25hdGUtYnRuLmFjdGl2ZSB7XG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IG5vbmU7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IG5vbmVcbn08L3N0eWxlPlxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQTBCQSxXQUFXLGVBQUMsQ0FBQyxBQUNULFFBQVEsQ0FBRSxLQUFLLENBQ2YsSUFBSSxDQUFFLENBQUMsQ0FDUCxNQUFNLENBQUUsSUFBSSxzQkFBc0IsQ0FBQyxDQUNuQyxPQUFPLENBQUUsV0FBVyxDQUNwQixPQUFPLENBQUUsV0FBVyxDQUNwQixPQUFPLENBQUUsSUFBSSxDQUNiLGlCQUFpQixDQUFFLE1BQU0sQ0FDckIsY0FBYyxDQUFFLE1BQU0sQ0FDbEIsV0FBVyxDQUFFLE1BQU0sQ0FDM0IsZ0JBQWdCLENBQUUsTUFBTSxDQUNwQixhQUFhLENBQUUsTUFBTSxDQUNqQixlQUFlLENBQUUsTUFBTSxDQUMvQixLQUFLLENBQUUsSUFBSSxDQUNYLFdBQVcsQ0FBRSxHQUFHLENBQ2hCLFNBQVMsQ0FBRSxNQUFNLENBQ2pCLFdBQVcsQ0FBRSxJQUFJLENBQ2pCLEtBQUssQ0FBRSxLQUFLLElBQUksYUFBYSxDQUFDLENBQUMsQ0FDL0IsT0FBTyxDQUFFLElBQUksQ0FDYixPQUFPLENBQUUsQ0FBQyxDQUNWLGdCQUFnQixDQUFFLFlBQVksQ0FDMUIsWUFBWSxDQUFFLFlBQVksQ0FDOUIsVUFBVSxDQUFFLE1BQU0sQ0FDbEIsa0JBQWtCLENBQUUsR0FBRyxDQUFDLFdBQVcsQ0FDbkMsVUFBVSxDQUFFLEdBQUcsQ0FBQyxXQUFXLENBQzNCLGlCQUFpQixDQUFFLFdBQVcsSUFBSSxDQUFDLENBQzNCLFNBQVMsQ0FBRSxXQUFXLElBQUksQ0FBQyxDQUNuQyxnQkFBZ0IsQ0FBRSxLQUFLLElBQUksZUFBZSxDQUFDLENBQUMsQUFDaEQsQ0FBQyxBQUVELElBQUksZUFBQyxDQUFDLEFBQ0YsZ0JBQWdCLENBQUUsQ0FBQyxDQUNmLFFBQVEsQ0FBRSxJQUFJLENBQ1YsSUFBSSxDQUFFLElBQUksQ0FDbEIsT0FBTyxDQUFFLFdBQVcsQ0FDcEIsT0FBTyxDQUFFLFdBQVcsQ0FDcEIsT0FBTyxDQUFFLElBQUksQ0FDYixpQkFBaUIsQ0FBRSxNQUFNLENBQ3JCLGNBQWMsQ0FBRSxNQUFNLENBQ2xCLFdBQVcsQ0FBRSxNQUFNLENBQzNCLGdCQUFnQixDQUFFLE1BQU0sQ0FDcEIsYUFBYSxDQUFFLE1BQU0sQ0FDakIsZUFBZSxDQUFFLE1BQU0sQ0FDL0IsTUFBTSxDQUFFLElBQUksQ0FDWixLQUFLLENBQUUsSUFBSSxDQUNYLGFBQWEsQ0FBRSxHQUFHLENBQ2xCLFFBQVEsQ0FBRSxNQUFNLENBQ2hCLGdCQUFnQixDQUFFLEtBQUssSUFBSSxhQUFhLENBQUMsQ0FBQyxBQUM5QyxDQUFDLEFBRUQsV0FBVyxPQUFPLGVBQUMsQ0FBQyxBQUNoQixpQkFBaUIsQ0FBRSxJQUFJLENBQ2YsU0FBUyxDQUFFLElBQUk7QUFDM0IsQ0FBQyJ9 */";
	append_dev(document.head, style);
}

function create_fragment$1d(ctx) {
	let button;
	let span;
	let icon;
	let t0;
	let s0;
	let t1;
	let s1;
	let t2;
	let button_class_value;
	let current;
	let mounted;
	let dispose;

	icon = new Icon({
			props: {
				type: "coin",
				size: "medium",
				is: "primary"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			button = element("button");
			span = element("span");
			create_component(icon.$$.fragment);
			t0 = space();
			s0 = element("s");
			t1 = space();
			s1 = element("s");
			t2 = text("\n    Допомогти");
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", { type: true, class: true });
			var button_nodes = children(button);
			span = claim_element(button_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			claim_component(icon.$$.fragment, span_nodes);
			span_nodes.forEach(detach_dev);
			t0 = claim_space(button_nodes);
			s0 = claim_element(button_nodes, "S", {});
			children(s0).forEach(detach_dev);
			t1 = claim_space(button_nodes);
			s1 = claim_element(button_nodes, "S", {});
			children(s1).forEach(detach_dev);
			t2 = claim_text(button_nodes, "\n    Допомогти");
			button_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "svelte-1nsvb2j");
			add_location(span, file$1d, 17, 4, 460);
			add_location(s0, file$1d, 20, 4, 538);
			add_location(s1, file$1d, 21, 4, 550);
			attr_dev(button, "type", "button");
			attr_dev(button, "class", button_class_value = "" + (null_to_empty(/*classPropDonateBtn*/ ctx[0]) + " svelte-1nsvb2j"));
			add_location(button, file$1d, 16, 0, 386);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, span);
			mount_component(icon, span, null);
			append_dev(button, t0);
			append_dev(button, s0);
			append_dev(button, t1);
			append_dev(button, s1);
			append_dev(button, t2);
			current = true;

			if (!mounted) {
				dispose = listen_dev(button, "click", onDonate, false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (!current || dirty & /*classPropDonateBtn*/ 1 && button_class_value !== (button_class_value = "" + (null_to_empty(/*classPropDonateBtn*/ ctx[0]) + " svelte-1nsvb2j"))) {
				attr_dev(button, "class", button_class_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			destroy_component(icon);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1d.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function onDonate() {
	alert("Дякую! 🥰");
}

function instance$1d($$self, $$props, $$invalidate) {
	let activeDonateBtn = false;
	onMount(() => setTimeout(() => $$invalidate(1, activeDonateBtn = true), 500));
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<DonationButton> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("DonationButton", $$slots, []);

	$$self.$capture_state = () => ({
		onMount,
		classnames,
		Icon,
		activeDonateBtn,
		onDonate,
		classPropDonateBtn
	});

	$$self.$inject_state = $$props => {
		if ("activeDonateBtn" in $$props) $$invalidate(1, activeDonateBtn = $$props.activeDonateBtn);
		if ("classPropDonateBtn" in $$props) $$invalidate(0, classPropDonateBtn = $$props.classPropDonateBtn);
	};

	let classPropDonateBtn;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*activeDonateBtn*/ 2) {
			 $$invalidate(0, classPropDonateBtn = classnames("donate-btn", { active: activeDonateBtn }));
		}
	};

	return [classPropDonateBtn];
}

class DonationButton extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document.getElementById("svelte-1nsvb2j-style")) add_css$w();
		init(this, options, instance$1d, create_fragment$1d, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "DonationButton",
			options,
			id: create_fragment$1d.name
		});
	}
}

/* src/components/app/ListOfFeatures.svelte generated by Svelte v3.24.0 */

const file$1e = "src/components/app/ListOfFeatures.svelte";

function add_css$x() {
	var style = element("style");
	style.id = "svelte-us8ild-style";
	style.textContent = "ul.svelte-us8ild{list-style:disc outside none;padding:0 calc(var(--screen-padding) * 5)}li.svelte-us8ild{display:list-item}ul.svelte-us8ild,li.svelte-us8ild,h3.svelte-us8ild,p.svelte-us8ild{max-width:100%;vertical-align:middle}h3.svelte-us8ild,p.svelte-us8ild{overflow:hidden;display:inline-block;word-break:break-word;text-overflow:ellipsis}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTGlzdE9mRmVhdHVyZXMuc3ZlbHRlIiwic291cmNlcyI6WyJMaXN0T2ZGZWF0dXJlcy5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdD5cbiAgICBjb25zdCBpdGVtcyA9IFtcbiAgICAgICAge1xuICAgICAgICAgICAgdGl0bGU6ICdDb21mb3J0IGlzIHRoZSBtYWluIGZlYXR1cmUnLFxuICAgICAgICAgICAgdGV4dDogJ0p1c3QgaW1hZ2luZywgeW91IGRvIHNvbWV0aGluZyBzaW1wbGUgYW5kIHlvdSBjYW4gc2VlIHRoZSByZXN1bHQgb2YgeW91ciBzaG9ydCB3YXkuJyxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgdGl0bGU6ICdDb21mb3J0IGlzIHRoZSBtYWluIGZlYXR1cmUnLFxuICAgICAgICAgICAgdGV4dDogJ0p1c3QgaW1hZ2luZywgeW91IGRvIHNvbWV0aGluZyBzaW1wbGUgYW5kIHlvdSBjYW4gc2VlIHRoZSByZXN1bHQgb2YgeW91ciBzaG9ydCB3YXkuJyxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgdGl0bGU6ICdDb21mb3J0IGlzIHRoZSBtYWluIGZlYXR1cmUnLFxuICAgICAgICAgICAgdGV4dDogJ0p1c3QgaW1hZ2luZywgeW91IGRvIHNvbWV0aGluZyBzaW1wbGUgYW5kIHlvdSBjYW4gc2VlIHRoZSByZXN1bHQgb2YgeW91ciBzaG9ydCB3YXkuJyxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgdGl0bGU6ICdDb21mb3J0IGlzIHRoZSBtYWluIGZlYXR1cmUnLFxuICAgICAgICAgICAgdGV4dDogJ0p1c3QgaW1hZ2luZywgeW91IGRvIHNvbWV0aGluZyBzaW1wbGUgYW5kIHlvdSBjYW4gc2VlIHRoZSByZXN1bHQgb2YgeW91ciBzaG9ydCB3YXkuJyxcbiAgICAgICAgfSxcbiAgICBdXG48L3NjcmlwdD5cblxuPHVsPlxuICAgIHsjZWFjaCBpdGVtcyBhcyBpdGVtfVxuICAgICAgICA8bGk+XG4gICAgICAgICAgICA8aDM+e2l0ZW0udGl0bGV9PC9oMz5cbiAgICAgICAgICAgIDxwPntpdGVtLnRleHR9PC9wPlxuICAgICAgICAgICAgPGJyPlxuICAgICAgICA8L2xpPlxuICAgIHsvZWFjaH1cbjwvdWw+XG5cbjxzdHlsZT5cbnVsIHtcbiAgICBsaXN0LXN0eWxlOiBkaXNjIG91dHNpZGUgbm9uZTtcbiAgICBwYWRkaW5nOiAwIGNhbGModmFyKC0tc2NyZWVuLXBhZGRpbmcpICogNSk7XG4gICAgLypsaXN0LXN0eWxlLWltYWdlOiB1cmwoXCJkYXRhOmltYWdlL3N2Zyt4bWw7dXRmOCw8c3ZnIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zycgd2lkdGg9JzEwJyBoZWlnaHQ9JzEwJyB2aWV3Qm94PSctMSAtMSAyIDInPjxjaXJjbGUgcj0nMScgLz48L3N2Zz5cIik7Ki9cbn1cblxubGkge1xuICAgIGRpc3BsYXk6IGxpc3QtaXRlbTtcbn1cblxudWwsIGxpLCBoMywgcCB7XG4gICAgbWF4LXdpZHRoOiAxMDAlO1xuICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XG59XG5cbmgzLCBwIHtcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICB3b3JkLWJyZWFrOiBicmVhay13b3JkO1xuICAgIHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xufTwvc3R5bGU+XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBZ0NBLEVBQUUsY0FBQyxDQUFDLEFBQ0EsVUFBVSxDQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUM3QixPQUFPLENBQUUsQ0FBQyxDQUFDLEtBQUssSUFBSSxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQUFFOUMsQ0FBQyxBQUVELEVBQUUsY0FBQyxDQUFDLEFBQ0EsT0FBTyxDQUFFLFNBQVMsQUFDdEIsQ0FBQyxBQUVELGdCQUFFLENBQUUsZ0JBQUUsQ0FBRSxnQkFBRSxDQUFFLENBQUMsY0FBQyxDQUFDLEFBQ1gsU0FBUyxDQUFFLElBQUksQ0FDZixjQUFjLENBQUUsTUFBTSxBQUMxQixDQUFDLEFBRUQsZ0JBQUUsQ0FBRSxDQUFDLGNBQUMsQ0FBQyxBQUNILFFBQVEsQ0FBRSxNQUFNLENBQ2hCLE9BQU8sQ0FBRSxZQUFZLENBQ3JCLFVBQVUsQ0FBRSxVQUFVLENBQ3RCLGFBQWEsQ0FBRSxRQUFRLEFBQzNCLENBQUMifQ== */";
	append_dev(document.head, style);
}

function get_each_context$b(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[1] = list[i];
	return child_ctx;
}

// (23:4) {#each items as item}
function create_each_block$b(ctx) {
	let li;
	let h3;
	let t0_value = /*item*/ ctx[1].title + "";
	let t0;
	let t1;
	let p;
	let t2_value = /*item*/ ctx[1].text + "";
	let t2;
	let t3;
	let br;
	let t4;

	const block = {
		c: function create() {
			li = element("li");
			h3 = element("h3");
			t0 = text(t0_value);
			t1 = space();
			p = element("p");
			t2 = text(t2_value);
			t3 = space();
			br = element("br");
			t4 = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true });
			var li_nodes = children(li);
			h3 = claim_element(li_nodes, "H3", { class: true });
			var h3_nodes = children(h3);
			t0 = claim_text(h3_nodes, t0_value);
			h3_nodes.forEach(detach_dev);
			t1 = claim_space(li_nodes);
			p = claim_element(li_nodes, "P", { class: true });
			var p_nodes = children(p);
			t2 = claim_text(p_nodes, t2_value);
			p_nodes.forEach(detach_dev);
			t3 = claim_space(li_nodes);
			br = claim_element(li_nodes, "BR", {});
			t4 = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(h3, "class", "svelte-us8ild");
			add_location(h3, file$1e, 24, 12, 806);
			attr_dev(p, "class", "svelte-us8ild");
			add_location(p, file$1e, 25, 12, 840);
			add_location(br, file$1e, 26, 12, 871);
			attr_dev(li, "class", "svelte-us8ild");
			add_location(li, file$1e, 23, 8, 789);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, h3);
			append_dev(h3, t0);
			append_dev(li, t1);
			append_dev(li, p);
			append_dev(p, t2);
			append_dev(li, t3);
			append_dev(li, br);
			append_dev(li, t4);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$b.name,
		type: "each",
		source: "(23:4) {#each items as item}",
		ctx
	});

	return block;
}

function create_fragment$1e(ctx) {
	let ul;
	let each_value = /*items*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$b(get_each_context$b(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(ul_nodes);
			}

			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(ul, "class", "svelte-us8ild");
			add_location(ul, file$1e, 21, 0, 750);
		},
		m: function mount(target, anchor) {
			insert_dev(target, ul, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*items*/ 1) {
				each_value = /*items*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$b(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$b(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(ul, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(ul);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1e.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1e($$self, $$props, $$invalidate) {
	const items = [
		{
			title: "Comfort is the main feature",
			text: "Just imaging, you do something simple and you can see the result of your short way."
		},
		{
			title: "Comfort is the main feature",
			text: "Just imaging, you do something simple and you can see the result of your short way."
		},
		{
			title: "Comfort is the main feature",
			text: "Just imaging, you do something simple and you can see the result of your short way."
		},
		{
			title: "Comfort is the main feature",
			text: "Just imaging, you do something simple and you can see the result of your short way."
		}
	];

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ListOfFeatures> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("ListOfFeatures", $$slots, []);
	$$self.$capture_state = () => ({ items });
	return [items];
}

class ListOfFeatures extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document.getElementById("svelte-us8ild-style")) add_css$x();
		init(this, options, instance$1e, create_fragment$1e, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ListOfFeatures",
			options,
			id: create_fragment$1e.name
		});
	}
}

/* src/components/app/OfflineMessage.svelte generated by Svelte v3.24.0 */

const file$1f = "src/components/app/OfflineMessage.svelte";

function add_css$y() {
	var style = element("style");
	style.id = "svelte-11znwq0-style";
	style.textContent = "#offline-message{position:fixed;z-index:11;bottom:calc(env(safe-area-inset-bottom) + 100px);left:50%;padding:10px 20px;background-color:rgba(var(--theme-bg-color));border-radius:var(--border-radius-small);overflow:hidden;-webkit-transition:.2s ease-out;transition:.2s ease-out;opacity:0;pointer-events:none;-webkit-transform:translate3d(-50%, 20px, 0);transform:translate3d(-50%, 20px, 0)}#offline-message.active{opacity:1;pointer-events:auto;-webkit-transform:translate3d(-50%, 0, 0);transform:translate3d(-50%, 0, 0)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiT2ZmbGluZU1lc3NhZ2Uuc3ZlbHRlIiwic291cmNlcyI6WyJPZmZsaW5lTWVzc2FnZS5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdD5cbjwvc2NyaXB0PlxuXG48c2VjdGlvbiBpZD1cIm9mZmxpbmUtbWVzc2FnZVwiPlxuICAgINCh0YLQvtGA0ZbQvdC60LAg0L7RhNGE0LvQsNC50L1cbjwvc2VjdGlvbj5cblxuPHN0eWxlPlxuOmdsb2JhbCgjb2ZmbGluZS1tZXNzYWdlKSB7XG4gICAgcG9zaXRpb246IGZpeGVkO1xuICAgIHotaW5kZXg6IDExO1xuICAgIGJvdHRvbTogY2FsYyhlbnYoc2FmZS1hcmVhLWluc2V0LWJvdHRvbSkgKyAxMDBweCk7XG4gICAgbGVmdDogNTAlO1xuICAgIHBhZGRpbmc6IDEwcHggMjBweDtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKHZhcigtLXRoZW1lLWJnLWNvbG9yKSk7XG4gICAgYm9yZGVyLXJhZGl1czogdmFyKC0tYm9yZGVyLXJhZGl1cy1zbWFsbCk7XG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAtd2Via2l0LXRyYW5zaXRpb246IC4ycyBlYXNlLW91dDtcbiAgICB0cmFuc2l0aW9uOiAuMnMgZWFzZS1vdXQ7XG4gICAgb3BhY2l0eTogMDtcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlM2QoLTUwJSwgMjBweCwgMCk7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKC01MCUsIDIwcHgsIDApO1xufVxuOmdsb2JhbCgjb2ZmbGluZS1tZXNzYWdlLmFjdGl2ZSkge1xuICAgIG9wYWNpdHk6IDE7XG4gICAgcG9pbnRlci1ldmVudHM6IGF1dG87XG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKC01MCUsIDAsIDApO1xuICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgtNTAlLCAwLCAwKTtcbn08L3N0eWxlPlxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQVFRLGdCQUFnQixBQUFFLENBQUMsQUFDdkIsUUFBUSxDQUFFLEtBQUssQ0FDZixPQUFPLENBQUUsRUFBRSxDQUNYLE1BQU0sQ0FBRSxLQUFLLElBQUksc0JBQXNCLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQ2pELElBQUksQ0FBRSxHQUFHLENBQ1QsT0FBTyxDQUFFLElBQUksQ0FBQyxJQUFJLENBQ2xCLGdCQUFnQixDQUFFLEtBQUssSUFBSSxnQkFBZ0IsQ0FBQyxDQUFDLENBQzdDLGFBQWEsQ0FBRSxJQUFJLHFCQUFxQixDQUFDLENBQ3pDLFFBQVEsQ0FBRSxNQUFNLENBQ2hCLGtCQUFrQixDQUFFLEdBQUcsQ0FBQyxRQUFRLENBQ2hDLFVBQVUsQ0FBRSxHQUFHLENBQUMsUUFBUSxDQUN4QixPQUFPLENBQUUsQ0FBQyxDQUNWLGNBQWMsQ0FBRSxJQUFJLENBQ3BCLGlCQUFpQixDQUFFLFlBQVksSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQ3JDLFNBQVMsQ0FBRSxZQUFZLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxBQUNqRCxDQUFDLEFBQ08sdUJBQXVCLEFBQUUsQ0FBQyxBQUM5QixPQUFPLENBQUUsQ0FBQyxDQUNWLGNBQWMsQ0FBRSxJQUFJLENBQ3BCLGlCQUFpQixDQUFFLFlBQVksSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQ2xDLFNBQVMsQ0FBRSxZQUFZLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxBQUM5QyxDQUFDIn0= */";
	append_dev(document.head, style);
}

function create_fragment$1f(ctx) {
	let section;
	let t;

	const block = {
		c: function create() {
			section = element("section");
			t = text("Сторінка оффлайн");
			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { id: true });
			var section_nodes = children(section);
			t = claim_text(section_nodes, "Сторінка оффлайн");
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(section, "id", "offline-message");
			add_location(section, file$1f, 3, 0, 20);
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			append_dev(section, t);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1f.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1f($$self, $$props) {
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<OfflineMessage> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("OfflineMessage", $$slots, []);
	return [];
}

class OfflineMessage extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document.getElementById("svelte-11znwq0-style")) add_css$y();
		init(this, options, instance$1f, create_fragment$1f, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "OfflineMessage",
			options,
			id: create_fragment$1f.name
		});
	}
}

const contextMapbox = {};

/* src/components/map/Map.svelte generated by Svelte v3.24.0 */

const { document: document_1$4 } = globals;
const file$1g = "src/components/map/Map.svelte";

function add_css$z() {
	var style = element("style");
	style.id = "svelte-eljdnw-style";
	style.textContent = "section.svelte-eljdnw{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-item-align:stretch;align-self:stretch}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTWFwLnN2ZWx0ZSIsInNvdXJjZXMiOlsiTWFwLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c3R5bGU+XG5zZWN0aW9uIHtcbiAgICAtd2Via2l0LWJveC1mbGV4OiAxO1xuICAgICAgICAtbXMtZmxleC1wb3NpdGl2ZTogMTtcbiAgICAgICAgICAgIGZsZXgtZ3JvdzogMTtcbiAgICAtbXMtZmxleC1pdGVtLWFsaWduOiBzdHJldGNoO1xuICAgICAgICBhbGlnbi1zZWxmOiBzdHJldGNoO1xufTwvc3R5bGU+XG5cbjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgb25Nb3VudCwgb25EZXN0cm95LCBzZXRDb250ZXh0LCBjcmVhdGVFdmVudERpc3BhdGNoZXIgfSBmcm9tICdzdmVsdGUnXG4gICAgaW1wb3J0IHsgY29udGV4dE1hcGJveCB9IGZyb20gJy4vY29udGV4dCdcblxuICAgIGNvbnN0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKClcblxuICAgIGV4cG9ydCBsZXQgY2VudGVyID0gWzMxLjE2NTYsIDQ4LjM3OTRdXG4gICAgZXhwb3J0IGxldCB6b29tID0gMy43NVxuXG4gICAgbGV0IG1hcFxuICAgIGxldCBjb250YWluZXJcblxuICAgIHNldENvbnRleHQoY29udGV4dE1hcGJveCwge1xuICAgICAgICBnZXRNYXA6ICgpID0+IG1hcCxcbiAgICAgICAgZ2V0TWFwYm94OiAoKSA9PiB3aW5kb3cubWFwYm94Z2xcbiAgICB9KVxuXG4gICAgZnVuY3Rpb24gb25DcmVhdGVNYXAoKSB7XG4gICAgICAgIG1hcCA9IG5ldyBtYXBib3hnbC5NYXAoe1xuICAgICAgICAgICAgem9vbSxcbiAgICAgICAgICAgIGNlbnRlcixcbiAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgIHN0eWxlOiAnbWFwYm94Oi8vc3R5bGVzL21hcGJveC9zdHJlZXRzLXYxMScsXG4gICAgICAgIH0pXG5cbiAgICAgICAgbWFwLm9uKCdkcmFnZW5kJywgKCkgPT4gZGlzcGF0Y2goJ3JlY2VudHJlJywgeyBtYXAsIGNlbnRlcjogbWFwLmdldENlbnRlcigpIH0pKVxuICAgICAgICBtYXAub24oJ2xvYWQnLCAoKSA9PiBkaXNwYXRjaCgncmVhZHknLCBtYXApKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZU1hcCgpIHtcbiAgICAgICAgY29uc3Qgc2NyaXB0VGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JylcbiAgICAgICAgc2NyaXB0VGFnLnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0J1xuICAgICAgICBzY3JpcHRUYWcuc3JjID0gJ2h0dHBzOi8vYXBpLm1hcGJveC5jb20vbWFwYm94LWdsLWpzL3YxLjcuMC9tYXBib3gtZ2wuanMnXG5cbiAgICAgICAgY29uc3QgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpbmsnKVxuICAgICAgICBsaW5rLnJlbCA9ICdzdHlsZXNoZWV0J1xuICAgICAgICBsaW5rLmhyZWYgPSAnaHR0cHM6Ly9hcGkubWFwYm94LmNvbS9tYXBib3gtZ2wtanMvdjEuNy4wL21hcGJveC1nbC5jc3MnXG5cbiAgICAgICAgc2NyaXB0VGFnLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuID0gJ3BrLmV5SjFJam9pWW5WaWJHbHJJaXdpWVNJNkltTnJOWHB4ZHpneGJUQXdObmN6Ykd4d2VHMHdjVFYzY2pBaWZRLnJ0MXBlTGpDUUhaVWtyTTRBV3o1TXcnXG4gICAgICAgICAgICBtYXBib3hnbC5hY2Nlc3NUb2tlbiA9IHRva2VuXG5cbiAgICAgICAgICAgIGxpbmsub25sb2FkID0gb25DcmVhdGVNYXBcblxuICAgICAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChsaW5rKVxuICAgICAgICB9XG5cbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzY3JpcHRUYWcpXG4gICAgfVxuXG4gICAgb25Nb3VudCgoKSA9PiB7XG4gICAgICAgIGlmICgnbWFwYm94Z2wnIGluIHdpbmRvdykge1xuICAgICAgICAgICAgb25DcmVhdGVNYXAoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3JlYXRlTWFwKClcbiAgICAgICAgfVxuICAgIH0pXG5cbiAgICBvbkRlc3Ryb3koKCkgPT4ge1xuICAgICAgICBtYXAgJiYgbWFwLnJlbW92ZSgpXG4gICAgfSlcbjwvc2NyaXB0PlxuXG48c2VjdGlvbiBiaW5kOnRoaXM9e2NvbnRhaW5lcn0+XG4gICAgeyNpZiBtYXB9XG4gICAgICAgIDxzbG90Pjwvc2xvdD5cbiAgICB7L2lmfVxuPC9zZWN0aW9uPlxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUNBLE9BQU8sY0FBQyxDQUFDLEFBQ0wsZ0JBQWdCLENBQUUsQ0FBQyxDQUNmLGlCQUFpQixDQUFFLENBQUMsQ0FDaEIsU0FBUyxDQUFFLENBQUMsQ0FDcEIsbUJBQW1CLENBQUUsT0FBTyxDQUN4QixVQUFVLENBQUUsT0FBTyxBQUMzQixDQUFDIn0= */";
	append_dev(document_1$4.head, style);
}

// (74:4) {#if map}
function create_if_block$o(ctx) {
	let current;
	const default_slot_template = /*$$slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		l: function claim(nodes) {
			if (default_slot) default_slot.l(nodes);
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 16) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[4], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$o.name,
		type: "if",
		source: "(74:4) {#if map}",
		ctx
	});

	return block;
}

function create_fragment$1g(ctx) {
	let section;
	let current;
	let if_block = /*map*/ ctx[0] && create_if_block$o(ctx);

	const block = {
		c: function create() {
			section = element("section");
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { class: true });
			var section_nodes = children(section);
			if (if_block) if_block.l(section_nodes);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(section, "class", "svelte-eljdnw");
			add_location(section, file$1g, 72, 0, 1833);
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			if (if_block) if_block.m(section, null);
			/*section_binding*/ ctx[6](section);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*map*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*map*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$o(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(section, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			if (if_block) if_block.d();
			/*section_binding*/ ctx[6](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1g.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1g($$self, $$props, $$invalidate) {
	const dispatch = createEventDispatcher();
	let { center = [31.1656, 48.3794] } = $$props;
	let { zoom = 3.75 } = $$props;
	let map;
	let container;

	setContext(contextMapbox, {
		getMap: () => map,
		getMapbox: () => window.mapboxgl
	});

	function onCreateMap() {
		$$invalidate(0, map = new mapboxgl.Map({
				zoom,
				center,
				container,
				style: "mapbox://styles/mapbox/streets-v11"
			}));

		map.on("dragend", () => dispatch("recentre", { map, center: map.getCenter() }));
		map.on("load", () => dispatch("ready", map));
	}

	function createMap() {
		const scriptTag = document.createElement("script");
		scriptTag.type = "text/javascript";
		scriptTag.src = "https://api.mapbox.com/mapbox-gl-js/v1.7.0/mapbox-gl.js";
		const link = document.createElement("link");
		link.rel = "stylesheet";
		link.href = "https://api.mapbox.com/mapbox-gl-js/v1.7.0/mapbox-gl.css";

		scriptTag.onload = () => {
			const token = "pk.eyJ1IjoiYnVibGlrIiwiYSI6ImNrNXpxdzgxbTAwNnczbGxweG0wcTV3cjAifQ.rt1peLjCQHZUkrM4AWz5Mw";
			mapboxgl.accessToken = token;
			link.onload = onCreateMap;
			document.head.appendChild(link);
		};

		document.body.appendChild(scriptTag);
	}

	onMount(() => {
		if ("mapboxgl" in window) {
			onCreateMap();
		} else {
			createMap();
		}
	});

	onDestroy(() => {
		map && map.remove();
	});

	const writable_props = ["center", "zoom"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Map> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Map", $$slots, ['default']);

	function section_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			container = $$value;
			$$invalidate(1, container);
		});
	}

	$$self.$set = $$props => {
		if ("center" in $$props) $$invalidate(2, center = $$props.center);
		if ("zoom" in $$props) $$invalidate(3, zoom = $$props.zoom);
		if ("$$scope" in $$props) $$invalidate(4, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		onMount,
		onDestroy,
		setContext,
		createEventDispatcher,
		contextMapbox,
		dispatch,
		center,
		zoom,
		map,
		container,
		onCreateMap,
		createMap
	});

	$$self.$inject_state = $$props => {
		if ("center" in $$props) $$invalidate(2, center = $$props.center);
		if ("zoom" in $$props) $$invalidate(3, zoom = $$props.zoom);
		if ("map" in $$props) $$invalidate(0, map = $$props.map);
		if ("container" in $$props) $$invalidate(1, container = $$props.container);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [map, container, center, zoom, $$scope, $$slots, section_binding];
}

class Map$2 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document_1$4.getElementById("svelte-eljdnw-style")) add_css$z();
		init(this, options, instance$1g, create_fragment$1g, safe_not_equal, { center: 2, zoom: 3 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Map",
			options,
			id: create_fragment$1g.name
		});
	}

	get center() {
		throw new Error("<Map>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set center(value) {
		throw new Error("<Map>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get zoom() {
		throw new Error("<Map>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set zoom(value) {
		throw new Error("<Map>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/map/MapMarker.svelte generated by Svelte v3.24.0 */

function create_fragment$1h(ctx) {
	const block = {
		c: noop,
		l: noop,
		m: noop,
		p: noop,
		i: noop,
		o: noop,
		d: noop
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1h.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1h($$self, $$props, $$invalidate) {
	const dispatch = createEventDispatcher();
	const { getMap, getMapbox } = getContext(contextMapbox);
	const map = getMap();
	const mapbox = getMapbox();
	let { lng } = $$props;
	let { lat } = $$props;

	// export let label = 'label'
	// const popup = new mapbox.Popup({ offset: 25 }).setText(label)
	const markerEl = document.createElement("div");

	markerEl.style.fontSize = "50px";
	markerEl.style.cursor = "pointer";
	markerEl.innerHTML = "📍";

	const marker = new mapbox.Marker(markerEl, { offset: [0, -25] }).setLngLat([lng, lat]).// .setPopup(popup)
	addTo(map);

	markerEl.addEventListener("click", dispatch.bind(null, "click"));
	const writable_props = ["lng", "lat"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<MapMarker> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("MapMarker", $$slots, []);

	$$self.$set = $$props => {
		if ("lng" in $$props) $$invalidate(0, lng = $$props.lng);
		if ("lat" in $$props) $$invalidate(1, lat = $$props.lat);
	};

	$$self.$capture_state = () => ({
		getContext,
		createEventDispatcher,
		contextMapbox,
		dispatch,
		getMap,
		getMapbox,
		map,
		mapbox,
		lng,
		lat,
		markerEl,
		marker
	});

	$$self.$inject_state = $$props => {
		if ("lng" in $$props) $$invalidate(0, lng = $$props.lng);
		if ("lat" in $$props) $$invalidate(1, lat = $$props.lat);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [lng, lat];
}

class MapMarker extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1h, create_fragment$1h, safe_not_equal, { lng: 0, lat: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "MapMarker",
			options,
			id: create_fragment$1h.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*lng*/ ctx[0] === undefined && !("lng" in props)) {
			console.warn("<MapMarker> was created without expected prop 'lng'");
		}

		if (/*lat*/ ctx[1] === undefined && !("lat" in props)) {
			console.warn("<MapMarker> was created without expected prop 'lat'");
		}
	}

	get lng() {
		throw new Error("<MapMarker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set lng(value) {
		throw new Error("<MapMarker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get lat() {
		throw new Error("<MapMarker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set lat(value) {
		throw new Error("<MapMarker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/comments/Comment.svelte generated by Svelte v3.24.0 */
const file$1h = "src/components/comments/Comment.svelte";

// (25:16) <section slot="box" class="flex full-width full-height" style="height: 100vw">
function create_box_slot$2(ctx) {
	let section;
	let div;
	let avatar;
	let current;

	avatar = new Avatar({
			props: {
				src: /*src*/ ctx[0],
				alt: /*title*/ ctx[2]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			section = element("section");
			div = element("div");
			create_component(avatar.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { slot: true, class: true, style: true });
			var section_nodes = children(section);
			div = claim_element(section_nodes, "DIV", { class: true, style: true });
			var div_nodes = children(div);
			claim_component(avatar.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "flex flex-self-stretch flex-1 overflow-hidden flex-justify-stretch");
			set_style(div, "padding", "var(--screen-padding) 0");
			add_location(div, file$1h, 25, 20, 870);
			attr_dev(section, "slot", "box");
			attr_dev(section, "class", "flex full-width full-height");
			set_style(section, "height", "100vw");
			add_location(section, file$1h, 24, 16, 771);
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			append_dev(section, div);
			mount_component(avatar, div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const avatar_changes = {};
			if (dirty & /*src*/ 1) avatar_changes.src = /*src*/ ctx[0];
			if (dirty & /*title*/ 4) avatar_changes.alt = /*title*/ ctx[2];
			avatar.$set(avatar_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(avatar.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(avatar.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			destroy_component(avatar);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_box_slot$2.name,
		type: "slot",
		source: "(25:16) <section slot=\\\"box\\\" class=\\\"flex full-width full-height\\\" style=\\\"height: 100vw\\\">",
		ctx
	});

	return block;
}

// (23:12) <FancyBox>
function create_default_slot_1$4(ctx) {
	let avatar;
	let t;
	let current;

	avatar = new Avatar({
			props: {
				src: /*src*/ ctx[0],
				alt: /*title*/ ctx[2],
				size: "medium"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(avatar.$$.fragment);
			t = space();
		},
		l: function claim(nodes) {
			claim_component(avatar.$$.fragment, nodes);
			t = claim_space(nodes);
		},
		m: function mount(target, anchor) {
			mount_component(avatar, target, anchor);
			insert_dev(target, t, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const avatar_changes = {};
			if (dirty & /*src*/ 1) avatar_changes.src = /*src*/ ctx[0];
			if (dirty & /*title*/ 4) avatar_changes.alt = /*title*/ ctx[2];
			avatar.$set(avatar_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(avatar.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(avatar.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(avatar, detaching);
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$4.name,
		type: "slot",
		source: "(23:12) <FancyBox>",
		ctx
	});

	return block;
}

// (32:12) {#if checked}
function create_if_block_3$3(ctx) {
	let div1;
	let icon0;
	let t;
	let div0;
	let icon1;
	let current;

	icon0 = new Icon({
			props: { type: "polygon", is: "info" },
			$$inline: true
		});

	icon1 = new Icon({
			props: { type: "check-flag", is: "light" },
			$$inline: true
		});

	const block = {
		c: function create() {
			div1 = element("div");
			create_component(icon0.$$.fragment);
			t = space();
			div0 = element("div");
			create_component(icon1.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true, style: true });
			var div1_nodes = children(div1);
			claim_component(icon0.$$.fragment, div1_nodes);
			t = claim_space(div1_nodes);
			div0 = claim_element(div1_nodes, "DIV", { class: true, style: true });
			var div0_nodes = children(div0);
			claim_component(icon1.$$.fragment, div0_nodes);
			div0_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "absolute-center flex");
			set_style(div0, "width", "10px");
			set_style(div0, "height", "10px");
			add_location(div0, file$1h, 34, 16, 1334);
			attr_dev(div1, "class", "absolute flex");
			set_style(div1, "top", "-1px");
			set_style(div1, "right", "-1px");
			set_style(div1, "width", "20px");
			set_style(div1, "height", "20px");
			set_style(div1, "overflow", "hidden");
			add_location(div1, file$1h, 32, 12, 1165);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			mount_component(icon0, div1, null);
			append_dev(div1, t);
			append_dev(div1, div0);
			mount_component(icon1, div0, null);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon0.$$.fragment, local);
			transition_in(icon1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon0.$$.fragment, local);
			transition_out(icon1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			destroy_component(icon0);
			destroy_component(icon1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$3.name,
		type: "if",
		source: "(32:12) {#if checked}",
		ctx
	});

	return block;
}

// (51:12) {:else}
function create_else_block_2$1(ctx) {
	let div;
	let loader;
	let current;
	loader = new Loader({ props: { type: "h3" }, $$inline: true });

	const block = {
		c: function create() {
			div = element("div");
			create_component(loader.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { style: true });
			var div_nodes = children(div);
			claim_component(loader.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_style(div, "width", "60%");
			add_location(div, file$1h, 51, 16, 1811);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(loader, div, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(loader.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loader.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(loader);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_2$1.name,
		type: "else",
		source: "(51:12) {:else}",
		ctx
	});

	return block;
}

// (49:12) {#if title !== null}
function create_if_block_2$6(ctx) {
	let h3;
	let t;

	const block = {
		c: function create() {
			h3 = element("h3");
			t = text(/*title*/ ctx[2]);
			this.h();
		},
		l: function claim(nodes) {
			h3 = claim_element(nodes, "H3", { class: true });
			var h3_nodes = children(h3);
			t = claim_text(h3_nodes, /*title*/ ctx[2]);
			h3_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(h3, "class", "text-ellipsis font-w-500");
			add_location(h3, file$1h, 49, 16, 1723);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h3, anchor);
			append_dev(h3, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*title*/ 4) set_data_dev(t, /*title*/ ctx[2]);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(h3);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$6.name,
		type: "if",
		source: "(49:12) {#if title !== null}",
		ctx
	});

	return block;
}

// (58:22)                       [No comment]                 
function fallback_block$9(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("[No comment]");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "[No comment]");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: fallback_block$9.name,
		type: "fallback",
		source: "(58:22)                       [No comment]                 ",
		ctx
	});

	return block;
}

// (76:20) {:else}
function create_else_block_1$3(ctx) {
	let div;
	let loader;
	let current;
	loader = new Loader({ props: { type: "h4" }, $$inline: true });

	const block = {
		c: function create() {
			div = element("div");
			create_component(loader.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { style: true });
			var div_nodes = children(div);
			claim_component(loader.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_style(div, "width", "80%");
			add_location(div, file$1h, 76, 24, 2688);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(loader, div, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(loader.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loader.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(loader);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1$3.name,
		type: "else",
		source: "(76:20) {:else}",
		ctx
	});

	return block;
}

// (67:20) {#if date !== null}
function create_if_block_1$g(ctx) {
	let span0;
	let t0;
	let t1;
	let s0;
	let t2;
	let s1;
	let t3;
	let s2;
	let t4;
	let s3;
	let t5;
	let span1;
	let t6;
	let t7;
	let s4;
	let t8;
	let s5;

	const block = {
		c: function create() {
			span0 = element("span");
			t0 = text(/*date*/ ctx[1]);
			t1 = space();
			s0 = element("s");
			t2 = space();
			s1 = element("s");
			t3 = space();
			s2 = element("s");
			t4 = space();
			s3 = element("s");
			t5 = space();
			span1 = element("span");
			t6 = text("Відповісти");
			t7 = space();
			s4 = element("s");
			t8 = space();
			s5 = element("s");
			this.h();
		},
		l: function claim(nodes) {
			span0 = claim_element(nodes, "SPAN", { class: true, style: true });
			var span0_nodes = children(span0);
			t0 = claim_text(span0_nodes, /*date*/ ctx[1]);
			span0_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			s0 = claim_element(nodes, "S", {});
			children(s0).forEach(detach_dev);
			t2 = claim_space(nodes);
			s1 = claim_element(nodes, "S", {});
			children(s1).forEach(detach_dev);
			t3 = claim_space(nodes);
			s2 = claim_element(nodes, "S", {});
			children(s2).forEach(detach_dev);
			t4 = claim_space(nodes);
			s3 = claim_element(nodes, "S", {});
			children(s3).forEach(detach_dev);
			t5 = claim_space(nodes);
			span1 = claim_element(nodes, "SPAN", { class: true, style: true });
			var span1_nodes = children(span1);
			t6 = claim_text(span1_nodes, "Відповісти");
			span1_nodes.forEach(detach_dev);
			t7 = claim_space(nodes);
			s4 = claim_element(nodes, "S", {});
			children(s4).forEach(detach_dev);
			t8 = claim_space(nodes);
			s5 = claim_element(nodes, "S", {});
			children(s5).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span0, "class", "h4");
			set_style(span0, "opacity", ".3");
			add_location(span0, file$1h, 67, 24, 2312);
			add_location(s0, file$1h, 68, 24, 2389);
			add_location(s1, file$1h, 69, 24, 2421);
			add_location(s2, file$1h, 70, 24, 2453);
			add_location(s3, file$1h, 71, 24, 2485);
			attr_dev(span1, "class", "h4");
			set_style(span1, "opacity", ".7");
			add_location(span1, file$1h, 72, 24, 2517);
			add_location(s4, file$1h, 73, 24, 2596);
			add_location(s5, file$1h, 74, 24, 2628);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span0, anchor);
			append_dev(span0, t0);
			insert_dev(target, t1, anchor);
			insert_dev(target, s0, anchor);
			insert_dev(target, t2, anchor);
			insert_dev(target, s1, anchor);
			insert_dev(target, t3, anchor);
			insert_dev(target, s2, anchor);
			insert_dev(target, t4, anchor);
			insert_dev(target, s3, anchor);
			insert_dev(target, t5, anchor);
			insert_dev(target, span1, anchor);
			append_dev(span1, t6);
			insert_dev(target, t7, anchor);
			insert_dev(target, s4, anchor);
			insert_dev(target, t8, anchor);
			insert_dev(target, s5, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*date*/ 2) set_data_dev(t0, /*date*/ ctx[1]);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(span0);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(s0);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(s1);
			if (detaching) detach_dev(t3);
			if (detaching) detach_dev(s2);
			if (detaching) detach_dev(t4);
			if (detaching) detach_dev(s3);
			if (detaching) detach_dev(t5);
			if (detaching) detach_dev(span1);
			if (detaching) detach_dev(t7);
			if (detaching) detach_dev(s4);
			if (detaching) detach_dev(t8);
			if (detaching) detach_dev(s5);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$g.name,
		type: "if",
		source: "(67:20) {#if date !== null}",
		ctx
	});

	return block;
}

// (88:20) {:else}
function create_else_block$9(ctx) {
	let span1;
	let span0;
	let t0;
	let t1;
	let loader;
	let current;

	loader = new Loader({
			props: { type: "h4", absolute: true },
			$$inline: true
		});

	const block = {
		c: function create() {
			span1 = element("span");
			span0 = element("span");
			t0 = text("199");
			t1 = space();
			create_component(loader.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			span1 = claim_element(nodes, "SPAN", { class: true });
			var span1_nodes = children(span1);
			span0 = claim_element(span1_nodes, "SPAN", { style: true });
			var span0_nodes = children(span0);
			t0 = claim_text(span0_nodes, "199");
			span0_nodes.forEach(detach_dev);
			t1 = claim_space(span1_nodes);
			claim_component(loader.$$.fragment, span1_nodes);
			span1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_style(span0, "visibility", "hidden");
			add_location(span0, file$1h, 89, 28, 3313);
			attr_dev(span1, "class", "h4 relative flex-self-start");
			add_location(span1, file$1h, 88, 24, 3242);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span1, anchor);
			append_dev(span1, span0);
			append_dev(span0, t0);
			append_dev(span1, t1);
			mount_component(loader, span1, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(loader.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loader.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span1);
			destroy_component(loader);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$9.name,
		type: "else",
		source: "(88:20) {:else}",
		ctx
	});

	return block;
}

// (86:20) {#if amount !== null}
function create_if_block$p(ctx) {
	let h4;
	let t;

	const block = {
		c: function create() {
			h4 = element("h4");
			t = text(/*amount*/ ctx[3]);
			this.h();
		},
		l: function claim(nodes) {
			h4 = claim_element(nodes, "H4", {});
			var h4_nodes = children(h4);
			t = claim_text(h4_nodes, /*amount*/ ctx[3]);
			h4_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(h4, file$1h, 86, 24, 3170);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h4, anchor);
			append_dev(h4, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*amount*/ 8) set_data_dev(t, /*amount*/ ctx[3]);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(h4);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$p.name,
		type: "if",
		source: "(86:20) {#if amount !== null}",
		ctx
	});

	return block;
}

// (19:0) <Card class={classProp}>
function create_default_slot$K(ctx) {
	let section;
	let div0;
	let fancybox;
	let t0;
	let t1;
	let s0;
	let t2;
	let s1;
	let t3;
	let s2;
	let t4;
	let s3;
	let t5;
	let div2;
	let current_block_type_index;
	let if_block1;
	let t6;
	let br0;
	let t7;
	let pre;
	let t8;
	let br1;
	let t9;
	let div1;
	let p;
	let current_block_type_index_1;
	let if_block2;
	let t10;
	let span1;
	let span0;
	let icon;
	let span0_style_value;
	let t11;
	let s4;
	let t12;
	let s5;
	let t13;
	let current_block_type_index_2;
	let if_block3;
	let current;

	fancybox = new FancyBox({
			props: {
				$$slots: {
					default: [create_default_slot_1$4],
					box: [create_box_slot$2]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	let if_block0 = /*checked*/ ctx[4] && create_if_block_3$3(ctx);
	const if_block_creators = [create_if_block_2$6, create_else_block_2$1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*title*/ ctx[2] !== null) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	br0 = new Br({ props: { size: "5" }, $$inline: true });
	const default_slot_template = /*$$slots*/ ctx[6].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);
	const default_slot_or_fallback = default_slot || fallback_block$9(ctx);
	br1 = new Br({ props: { size: "10" }, $$inline: true });
	const if_block_creators_1 = [create_if_block_1$g, create_else_block_1$3];
	const if_blocks_1 = [];

	function select_block_type_1(ctx, dirty) {
		if (/*date*/ ctx[1] !== null) return 0;
		return 1;
	}

	current_block_type_index_1 = select_block_type_1(ctx);
	if_block2 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);

	icon = new Icon({
			props: {
				type: "heart",
				is: "danger",
				size: "small"
			},
			$$inline: true
		});

	const if_block_creators_2 = [create_if_block$p, create_else_block$9];
	const if_blocks_2 = [];

	function select_block_type_2(ctx, dirty) {
		if (/*amount*/ ctx[3] !== null) return 0;
		return 1;
	}

	current_block_type_index_2 = select_block_type_2(ctx);
	if_block3 = if_blocks_2[current_block_type_index_2] = if_block_creators_2[current_block_type_index_2](ctx);

	const block = {
		c: function create() {
			section = element("section");
			div0 = element("div");
			create_component(fancybox.$$.fragment);
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			s0 = element("s");
			t2 = space();
			s1 = element("s");
			t3 = space();
			s2 = element("s");
			t4 = space();
			s3 = element("s");
			t5 = space();
			div2 = element("div");
			if_block1.c();
			t6 = space();
			create_component(br0.$$.fragment);
			t7 = space();
			pre = element("pre");
			if (default_slot_or_fallback) default_slot_or_fallback.c();
			t8 = space();
			create_component(br1.$$.fragment);
			t9 = space();
			div1 = element("div");
			p = element("p");
			if_block2.c();
			t10 = space();
			span1 = element("span");
			span0 = element("span");
			create_component(icon.$$.fragment);
			t11 = space();
			s4 = element("s");
			t12 = space();
			s5 = element("s");
			t13 = space();
			if_block3.c();
			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { class: true, style: true });
			var section_nodes = children(section);
			div0 = claim_element(section_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			claim_component(fancybox.$$.fragment, div0_nodes);
			t0 = claim_space(div0_nodes);
			if (if_block0) if_block0.l(div0_nodes);
			div0_nodes.forEach(detach_dev);
			t1 = claim_space(section_nodes);
			s0 = claim_element(section_nodes, "S", {});
			children(s0).forEach(detach_dev);
			t2 = claim_space(section_nodes);
			s1 = claim_element(section_nodes, "S", {});
			children(s1).forEach(detach_dev);
			t3 = claim_space(section_nodes);
			s2 = claim_element(section_nodes, "S", {});
			children(s2).forEach(detach_dev);
			t4 = claim_space(section_nodes);
			s3 = claim_element(section_nodes, "S", {});
			children(s3).forEach(detach_dev);
			t5 = claim_space(section_nodes);
			div2 = claim_element(section_nodes, "DIV", { class: true, style: true });
			var div2_nodes = children(div2);
			if_block1.l(div2_nodes);
			t6 = claim_space(div2_nodes);
			claim_component(br0.$$.fragment, div2_nodes);
			t7 = claim_space(div2_nodes);
			pre = claim_element(div2_nodes, "PRE", { class: true, style: true });
			var pre_nodes = children(pre);
			if (default_slot_or_fallback) default_slot_or_fallback.l(pre_nodes);
			pre_nodes.forEach(detach_dev);
			t8 = claim_space(div2_nodes);
			claim_component(br1.$$.fragment, div2_nodes);
			t9 = claim_space(div2_nodes);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			p = claim_element(div1_nodes, "P", { class: true });
			var p_nodes = children(p);
			if_block2.l(p_nodes);
			p_nodes.forEach(detach_dev);
			t10 = claim_space(div1_nodes);
			span1 = claim_element(div1_nodes, "SPAN", { class: true, style: true });
			var span1_nodes = children(span1);
			span0 = claim_element(span1_nodes, "SPAN", { style: true });
			var span0_nodes = children(span0);
			claim_component(icon.$$.fragment, span0_nodes);
			span0_nodes.forEach(detach_dev);
			t11 = claim_space(span1_nodes);
			s4 = claim_element(span1_nodes, "S", {});
			children(s4).forEach(detach_dev);
			t12 = claim_space(span1_nodes);
			s5 = claim_element(span1_nodes, "S", {});
			children(s5).forEach(detach_dev);
			t13 = claim_space(span1_nodes);
			if_block3.l(span1_nodes);
			span1_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "flex relative");
			add_location(div0, file$1h, 21, 8, 642);
			add_location(s0, file$1h, 41, 8, 1545);
			add_location(s1, file$1h, 42, 8, 1561);
			add_location(s2, file$1h, 43, 8, 1577);
			add_location(s3, file$1h, 44, 8, 1593);
			attr_dev(pre, "class", "h4 font-w-300");
			set_style(pre, "line-height", "1.46");
			add_location(pre, file$1h, 56, 12, 1921);
			attr_dev(p, "class", "flex flex-align-center flex-justify-between");
			add_location(p, file$1h, 65, 16, 2192);
			attr_dev(span0, "style", span0_style_value = `opacity: ${/*amount*/ ctx[3] > 2 ? 1 : 0.5}`);
			add_location(span0, file$1h, 80, 20, 2901);
			add_location(s4, file$1h, 83, 20, 3068);
			add_location(s5, file$1h, 84, 20, 3096);
			attr_dev(span1, "class", "h5 flex flex-align-center font-secondary");
			set_style(span1, "min-width", "4em");
			add_location(span1, file$1h, 79, 16, 2802);
			attr_dev(div1, "class", "flex flex-align-center flex-justify-between");
			add_location(div1, file$1h, 64, 12, 2118);
			attr_dev(div2, "class", "flex flex-column flex-1");
			set_style(div2, "overflow", "hidden");
			add_location(div2, file$1h, 46, 8, 1610);
			attr_dev(section, "class", "comment flex flex-align-start");
			set_style(section, "padding", "20px");
			add_location(section, file$1h, 19, 4, 563);
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			append_dev(section, div0);
			mount_component(fancybox, div0, null);
			append_dev(div0, t0);
			if (if_block0) if_block0.m(div0, null);
			append_dev(section, t1);
			append_dev(section, s0);
			append_dev(section, t2);
			append_dev(section, s1);
			append_dev(section, t3);
			append_dev(section, s2);
			append_dev(section, t4);
			append_dev(section, s3);
			append_dev(section, t5);
			append_dev(section, div2);
			if_blocks[current_block_type_index].m(div2, null);
			append_dev(div2, t6);
			mount_component(br0, div2, null);
			append_dev(div2, t7);
			append_dev(div2, pre);

			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(pre, null);
			}

			append_dev(div2, t8);
			mount_component(br1, div2, null);
			append_dev(div2, t9);
			append_dev(div2, div1);
			append_dev(div1, p);
			if_blocks_1[current_block_type_index_1].m(p, null);
			append_dev(div1, t10);
			append_dev(div1, span1);
			append_dev(span1, span0);
			mount_component(icon, span0, null);
			append_dev(span1, t11);
			append_dev(span1, s4);
			append_dev(span1, t12);
			append_dev(span1, s5);
			append_dev(span1, t13);
			if_blocks_2[current_block_type_index_2].m(span1, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const fancybox_changes = {};

			if (dirty & /*$$scope, src, title*/ 133) {
				fancybox_changes.$$scope = { dirty, ctx };
			}

			fancybox.$set(fancybox_changes);

			if (/*checked*/ ctx[4]) {
				if (if_block0) {
					if (dirty & /*checked*/ 16) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_3$3(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div0, null);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block1 = if_blocks[current_block_type_index];

				if (!if_block1) {
					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block1.c();
				}

				transition_in(if_block1, 1);
				if_block1.m(div2, t6);
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 128) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[7], dirty, null, null);
				}
			}

			let previous_block_index_1 = current_block_type_index_1;
			current_block_type_index_1 = select_block_type_1(ctx);

			if (current_block_type_index_1 === previous_block_index_1) {
				if_blocks_1[current_block_type_index_1].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
					if_blocks_1[previous_block_index_1] = null;
				});

				check_outros();
				if_block2 = if_blocks_1[current_block_type_index_1];

				if (!if_block2) {
					if_block2 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
					if_block2.c();
				}

				transition_in(if_block2, 1);
				if_block2.m(p, null);
			}

			if (!current || dirty & /*amount*/ 8 && span0_style_value !== (span0_style_value = `opacity: ${/*amount*/ ctx[3] > 2 ? 1 : 0.5}`)) {
				attr_dev(span0, "style", span0_style_value);
			}

			let previous_block_index_2 = current_block_type_index_2;
			current_block_type_index_2 = select_block_type_2(ctx);

			if (current_block_type_index_2 === previous_block_index_2) {
				if_blocks_2[current_block_type_index_2].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks_2[previous_block_index_2], 1, 1, () => {
					if_blocks_2[previous_block_index_2] = null;
				});

				check_outros();
				if_block3 = if_blocks_2[current_block_type_index_2];

				if (!if_block3) {
					if_block3 = if_blocks_2[current_block_type_index_2] = if_block_creators_2[current_block_type_index_2](ctx);
					if_block3.c();
				}

				transition_in(if_block3, 1);
				if_block3.m(span1, null);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(fancybox.$$.fragment, local);
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(br0.$$.fragment, local);
			transition_in(default_slot_or_fallback, local);
			transition_in(br1.$$.fragment, local);
			transition_in(if_block2);
			transition_in(icon.$$.fragment, local);
			transition_in(if_block3);
			current = true;
		},
		o: function outro(local) {
			transition_out(fancybox.$$.fragment, local);
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(br0.$$.fragment, local);
			transition_out(default_slot_or_fallback, local);
			transition_out(br1.$$.fragment, local);
			transition_out(if_block2);
			transition_out(icon.$$.fragment, local);
			transition_out(if_block3);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			destroy_component(fancybox);
			if (if_block0) if_block0.d();
			if_blocks[current_block_type_index].d();
			destroy_component(br0);
			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
			destroy_component(br1);
			if_blocks_1[current_block_type_index_1].d();
			destroy_component(icon);
			if_blocks_2[current_block_type_index_2].d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$K.name,
		type: "slot",
		source: "(19:0) <Card class={classProp}>",
		ctx
	});

	return block;
}

function create_fragment$1i(ctx) {
	let card;
	let current;

	card = new Card({
			props: {
				class: /*classProp*/ ctx[5],
				$$slots: { default: [create_default_slot$K] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(card.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(card.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(card, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const card_changes = {};
			if (dirty & /*classProp*/ 32) card_changes.class = /*classProp*/ ctx[5];

			if (dirty & /*$$scope, amount, date, title, checked, src*/ 159) {
				card_changes.$$scope = { dirty, ctx };
			}

			card.$set(card_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(card.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(card.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(card, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1i.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1i($$self, $$props, $$invalidate) {
	let { src = null } = $$props;
	let { date = null } = $$props;
	let { title = null } = $$props;
	let { amount = null } = $$props;
	let { checked = null } = $$props;
	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Comment", $$slots, ['default']);

	$$self.$set = $$new_props => {
		$$invalidate(8, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("src" in $$new_props) $$invalidate(0, src = $$new_props.src);
		if ("date" in $$new_props) $$invalidate(1, date = $$new_props.date);
		if ("title" in $$new_props) $$invalidate(2, title = $$new_props.title);
		if ("amount" in $$new_props) $$invalidate(3, amount = $$new_props.amount);
		if ("checked" in $$new_props) $$invalidate(4, checked = $$new_props.checked);
		if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		classnames,
		Br,
		Icon,
		Card,
		Avatar,
		FancyBox,
		Loader,
		src,
		date,
		title,
		amount,
		checked,
		classProp
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(8, $$props = assign(assign({}, $$props), $$new_props));
		if ("src" in $$props) $$invalidate(0, src = $$new_props.src);
		if ("date" in $$props) $$invalidate(1, date = $$new_props.date);
		if ("title" in $$props) $$invalidate(2, title = $$new_props.title);
		if ("amount" in $$props) $$invalidate(3, amount = $$new_props.amount);
		if ("checked" in $$props) $$invalidate(4, checked = $$new_props.checked);
		if ("classProp" in $$props) $$invalidate(5, classProp = $$new_props.classProp);
	};

	let classProp;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(5, classProp = classnames($$props.class));
	};

	$$props = exclude_internal_props($$props);
	return [src, date, title, amount, checked, classProp, $$slots, $$scope];
}

class Comment extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1i, create_fragment$1i, safe_not_equal, {
			src: 0,
			date: 1,
			title: 2,
			amount: 3,
			checked: 4
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Comment",
			options,
			id: create_fragment$1i.name
		});
	}

	get src() {
		throw new Error("<Comment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set src(value) {
		throw new Error("<Comment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get date() {
		throw new Error("<Comment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set date(value) {
		throw new Error("<Comment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get title() {
		throw new Error("<Comment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<Comment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get amount() {
		throw new Error("<Comment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set amount(value) {
		throw new Error("<Comment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get checked() {
		throw new Error("<Comment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set checked(value) {
		throw new Error("<Comment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/comments/Comments.svelte generated by Svelte v3.24.0 */
const file$1i = "src/components/comments/Comments.svelte";

function add_css$A() {
	var style = element("style");
	style.id = "svelte-gsvbhk-style";
	style.textContent = ".comments.svelte-gsvbhk.svelte-gsvbhk{width:100%;-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;display:-webkit-box;display:-ms-flexbox;display:flex;overflow-y:auto;overflow-x:hidden;-ms-flex-item-align:stretch;align-self:stretch;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;padding:15px}.comments-form.svelte-gsvbhk.svelte-gsvbhk{position:relative;-webkit-box-flex:0;-ms-flex:none;flex:none}.comments-wrap.svelte-gsvbhk.svelte-gsvbhk{width:100%;margin:-5px 0}.comments-wrap.svelte-gsvbhk li.svelte-gsvbhk{width:100%;padding:5px 0}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ29tbWVudHMuc3ZlbHRlIiwic291cmNlcyI6WyJDb21tZW50cy5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBjcmVhdGVFdmVudERpc3BhdGNoZXIgfSBmcm9tICdzdmVsdGUnXG5cbiAgICBpbXBvcnQgQnIgZnJvbSAnQGNvbXBvbmVudHMvQnIuc3ZlbHRlJ1xuICAgIGltcG9ydCBJY29uIGZyb20gJ0Bjb21wb25lbnRzL0ljb24uc3ZlbHRlJ1xuICAgIGltcG9ydCBGb3JtIGZyb20gJ0Bjb21wb25lbnRzL0Zvcm0uc3ZlbHRlJ1xuICAgIGltcG9ydCBJbnB1dCBmcm9tICdAY29tcG9uZW50cy9maWVsZHMvSW5wdXQuc3ZlbHRlJ1xuICAgIGltcG9ydCBCdXR0b24gZnJvbSAnQGNvbXBvbmVudHMvQnV0dG9uLnN2ZWx0ZSdcbiAgICBpbXBvcnQgTG9hZGVyIGZyb20gJ0Bjb21wb25lbnRzL2xvYWRlcidcbiAgICBpbXBvcnQgQ29tbWVudCBmcm9tICcuL0NvbW1lbnQuc3ZlbHRlJ1xuXG4gICAgY29uc3QgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXIoKVxuXG4gICAgLyoqXG4gICAgICogXG4gICAgICogQGV2ZW50OiBzdWJtaXQgLSBzdWJtaXQgdmFsdWVzIG9mIGEgbmV3IGNvbW1lbnQgXG4gICAgICogXG4gICAgICovXG4gICAgXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgZXhwb3J0IGxldCB3aXRoRm9ybSA9IHRydWVcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHt7XG4gICAgICogICAgICBsaWtlczogbnVtYmVyLFxuICAgICAqICAgICAgYXZhdGFyOiBzdHJpbmcsXG4gICAgICogICAgICBhdXRob3I6IHN0cmluZyxcbiAgICAgKiAgICAgIGNvbW1lbnQ6IHN0cmluZyxcbiAgICAgKiAgICAgIGNoZWNrZWQ6IGJvb2xlYW4sXG4gICAgICogICAgICBjcmVhdGVkX2F0OiBzdHJpbmcsXG4gICAgICogfX1cbiAgICAgKi9cbiAgICBleHBvcnQgbGV0IGl0ZW1zID0gbmV3IEFycmF5KDQpLmZpbGwoeyBjb21tZW50OiBudWxsIH0pXG48L3NjcmlwdD5cblxuPHNlY3Rpb24gY2xhc3M9XCJjb21tZW50c1wiPlxuICAgIDx1bCBjbGFzcz1cImNvbW1lbnRzLXdyYXBcIj5cbiAgICAgICAgeyNlYWNoIGl0ZW1zIGFzIGNvbW1lbnR9XG4gICAgICAgICAgICA8bGk+XG4gICAgICAgICAgICAgICAgPENvbW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyYz17Y29tbWVudC5hdmF0YXJ9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZT17Y29tbWVudC5hdXRob3J9XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlPXtjb21tZW50LmNyZWF0ZWRfYXQgJiYgbmV3IERhdGUoY29tbWVudC5jcmVhdGVkX2F0KS50b0xvY2FsZURhdGVTdHJpbmcoKX1cbiAgICAgICAgICAgICAgICAgICAgICAgIGFtb3VudD17Y29tbWVudC5saWtlc31cbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ9e2NvbW1lbnQuY2hlY2tlZH1cbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIHsjaWYgY29tbWVudC5jb21tZW50ICE9PSBudWxsfVxuICAgICAgICAgICAgICAgICAgICAgICAge2NvbW1lbnQuY29tbWVudH1cbiAgICAgICAgICAgICAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgICAgICAgICAgICAgPExvYWRlciB0eXBlPVwiaDRcIi8+XG4gICAgICAgICAgICAgICAgICAgICAgICA8TG9hZGVyIHR5cGU9XCJoNFwiLz5cbiAgICAgICAgICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgICAgICA8L0NvbW1lbnQ+XG4gICAgICAgICAgICA8L2xpPlxuICAgICAgICB7L2VhY2h9XG4gICAgPC91bD5cblxuICAgIDxCciBzaXplPVwiMjBcIi8+ICBcblxuICAgIDxwIGNsYXNzPVwiaDMgZm9udC13LTUwMCBmb250LXNlY29uZGFyeSB1bmRlcmxpbmUgdGV4dC1jZW50ZXJcIj5cbiAgICAgICAgPHNwYW4+0JLRgdGWINC60L7QvNC10L3RgtCw0YDRljwvc3Bhbj5cbiAgICAgICAgPEljb24gdHlwZT1cImNhcmV0LWRvd25cIiBzaXplPVwic21hbGxcIi8+XG4gICAgPC9wPlxuXG4gICAgeyNpZiB3aXRoRm9ybX1cbiAgICAgICAgPEJyIHNpemU9XCI0MFwiLz4gIFxuICAgICAgICA8ZGl2IGNsYXNzPVwiY29tbWVudHMtZm9ybSBmb250LXNlY29uZGFyeSBoM1wiPlxuICAgICAgICAgICAgPEZvcm0gY2xhc3M9XCJmbGV4XCIgbmFtZT1cImNvbW1lbnQtZm9ybVwiIG9uOnN1Ym1pdD17dmFsdWVzID0+IGRpc3BhdGNoKCdzdW1iaXQnLCB2YWx1ZXMpfT5cbiAgICAgICAgICAgICAgICA8SW5wdXRcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJ0ZXh0YXJlYVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lPVwiY29tbWVudFwiXG4gICAgICAgICAgICAgICAgICAgICAgICByb3dzPVwiMVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImNvbW1lbnQtZmllbGQgZmxleC1zZWxmLXN0cmV0Y2hcIlxuICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCLQl9Cw0LvQuNGI0YLQtSDRgdCy0ZbQuSDQutC+0LzQtdC90YLQsNGAXCJcbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgPC9Gb3JtPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZsZXggYWJzb2x1dGVcIiBzdHlsZT1cInRvcDogMDsgcmlnaHQ6IDA7IGhlaWdodDogMTAwJTsgd2lkdGg6IDUwcHhcIj5cbiAgICAgICAgICAgICAgICA8QnV0dG9uIHR5cGU9XCJzdWJtaXRcIiBjbGFzcz1cImZsZXggZnVsbC13aWR0aCBmbGV4LXNlbGYtc3RyZXRjaCBmbGV4LWp1c3RpZnktc3RhcnRcIj5cbiAgICAgICAgICAgICAgICAgICAgPEljb24gdHlwZT1cInNlbmRcIiBpcz1cImluZm9cIiBzaXplPVwibWVkaXVtXCIvPlxuICAgICAgICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgIHsvaWZ9XG48L3NlY3Rpb24+XG5cbjxzdHlsZT5cbi5jb21tZW50cyB7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgLXdlYmtpdC1ib3gtZmxleDogMTtcbiAgICAgICAgLW1zLWZsZXgtcG9zaXRpdmU6IDE7XG4gICAgICAgICAgICBmbGV4LWdyb3c6IDE7XG4gICAgZGlzcGxheTogLXdlYmtpdC1ib3g7XG4gICAgZGlzcGxheTogLW1zLWZsZXhib3g7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBvdmVyZmxvdy15OiBhdXRvO1xuICAgIG92ZXJmbG93LXg6IGhpZGRlbjtcbiAgICAtbXMtZmxleC1pdGVtLWFsaWduOiBzdHJldGNoO1xuICAgICAgICBhbGlnbi1zZWxmOiBzdHJldGNoO1xuICAgIC13ZWJraXQtYm94LW9yaWVudDogdmVydGljYWw7XG4gICAgLXdlYmtpdC1ib3gtZGlyZWN0aW9uOiBub3JtYWw7XG4gICAgICAgIC1tcy1mbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBwYWRkaW5nOiAxNXB4O1xufVxuXG4uY29tbWVudHMtZm9ybSB7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIC13ZWJraXQtYm94LWZsZXg6IDA7XG4gICAgICAgIC1tcy1mbGV4OiBub25lO1xuICAgICAgICAgICAgZmxleDogbm9uZTtcbn1cblxuLmNvbW1lbnRzLXdyYXAge1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIG1hcmdpbjogLTVweCAwO1xufVxuXG4uY29tbWVudHMtd3JhcCBsaSB7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgcGFkZGluZzogNXB4IDA7XG59PC9zdHlsZT5cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUF3RkEsU0FBUyw0QkFBQyxDQUFDLEFBQ1AsS0FBSyxDQUFFLElBQUksQ0FDWCxnQkFBZ0IsQ0FBRSxDQUFDLENBQ2YsaUJBQWlCLENBQUUsQ0FBQyxDQUNoQixTQUFTLENBQUUsQ0FBQyxDQUNwQixPQUFPLENBQUUsV0FBVyxDQUNwQixPQUFPLENBQUUsV0FBVyxDQUNwQixPQUFPLENBQUUsSUFBSSxDQUNiLFVBQVUsQ0FBRSxJQUFJLENBQ2hCLFVBQVUsQ0FBRSxNQUFNLENBQ2xCLG1CQUFtQixDQUFFLE9BQU8sQ0FDeEIsVUFBVSxDQUFFLE9BQU8sQ0FDdkIsa0JBQWtCLENBQUUsUUFBUSxDQUM1QixxQkFBcUIsQ0FBRSxNQUFNLENBQ3pCLGtCQUFrQixDQUFFLE1BQU0sQ0FDdEIsY0FBYyxDQUFFLE1BQU0sQ0FDOUIsT0FBTyxDQUFFLElBQUksQUFDakIsQ0FBQyxBQUVELGNBQWMsNEJBQUMsQ0FBQyxBQUNaLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLGdCQUFnQixDQUFFLENBQUMsQ0FDZixRQUFRLENBQUUsSUFBSSxDQUNWLElBQUksQ0FBRSxJQUFJLEFBQ3RCLENBQUMsQUFFRCxjQUFjLDRCQUFDLENBQUMsQUFDWixLQUFLLENBQUUsSUFBSSxDQUNYLE1BQU0sQ0FBRSxJQUFJLENBQUMsQ0FBQyxBQUNsQixDQUFDLEFBRUQsNEJBQWMsQ0FBQyxFQUFFLGNBQUMsQ0FBQyxBQUNmLEtBQUssQ0FBRSxJQUFJLENBQ1gsT0FBTyxDQUFFLEdBQUcsQ0FBQyxDQUFDLEFBQ2xCLENBQUMifQ== */";
	append_dev(document.head, style);
}

function get_each_context$c(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[4] = list[i];
	return child_ctx;
}

// (51:20) {:else}
function create_else_block$a(ctx) {
	let loader0;
	let t;
	let loader1;
	let current;
	loader0 = new Loader({ props: { type: "h4" }, $$inline: true });
	loader1 = new Loader({ props: { type: "h4" }, $$inline: true });

	const block = {
		c: function create() {
			create_component(loader0.$$.fragment);
			t = space();
			create_component(loader1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(loader0.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(loader1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(loader0, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(loader1, target, anchor);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(loader0.$$.fragment, local);
			transition_in(loader1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loader0.$$.fragment, local);
			transition_out(loader1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(loader0, detaching);
			if (detaching) detach_dev(t);
			destroy_component(loader1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$a.name,
		type: "else",
		source: "(51:20) {:else}",
		ctx
	});

	return block;
}

// (49:20) {#if comment.comment !== null}
function create_if_block_1$h(ctx) {
	let t_value = /*comment*/ ctx[4].comment + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		l: function claim(nodes) {
			t = claim_text(nodes, t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*items*/ 2 && t_value !== (t_value = /*comment*/ ctx[4].comment + "")) set_data_dev(t, t_value);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$h.name,
		type: "if",
		source: "(49:20) {#if comment.comment !== null}",
		ctx
	});

	return block;
}

// (42:16) <Comment                         src={comment.avatar}                         title={comment.author}                         date={comment.created_at && new Date(comment.created_at).toLocaleDateString()}                         amount={comment.likes}                         checked={comment.checked}                 >
function create_default_slot_2$3(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_1$h, create_else_block$a];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*comment*/ ctx[4].comment !== null) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$3.name,
		type: "slot",
		source: "(42:16) <Comment                         src={comment.avatar}                         title={comment.author}                         date={comment.created_at && new Date(comment.created_at).toLocaleDateString()}                         amount={comment.likes}                         checked={comment.checked}                 >",
		ctx
	});

	return block;
}

// (40:8) {#each items as comment}
function create_each_block$c(ctx) {
	let li;
	let comment;
	let t;
	let current;

	comment = new Comment({
			props: {
				src: /*comment*/ ctx[4].avatar,
				title: /*comment*/ ctx[4].author,
				date: /*comment*/ ctx[4].created_at && new Date(/*comment*/ ctx[4].created_at).toLocaleDateString(),
				amount: /*comment*/ ctx[4].likes,
				checked: /*comment*/ ctx[4].checked,
				$$slots: { default: [create_default_slot_2$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			li = element("li");
			create_component(comment.$$.fragment);
			t = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true });
			var li_nodes = children(li);
			claim_component(comment.$$.fragment, li_nodes);
			t = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(li, "class", "svelte-gsvbhk");
			add_location(li, file$1i, 40, 12, 993);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			mount_component(comment, li, null);
			append_dev(li, t);
			current = true;
		},
		p: function update(ctx, dirty) {
			const comment_changes = {};
			if (dirty & /*items*/ 2) comment_changes.src = /*comment*/ ctx[4].avatar;
			if (dirty & /*items*/ 2) comment_changes.title = /*comment*/ ctx[4].author;
			if (dirty & /*items*/ 2) comment_changes.date = /*comment*/ ctx[4].created_at && new Date(/*comment*/ ctx[4].created_at).toLocaleDateString();
			if (dirty & /*items*/ 2) comment_changes.amount = /*comment*/ ctx[4].likes;
			if (dirty & /*items*/ 2) comment_changes.checked = /*comment*/ ctx[4].checked;

			if (dirty & /*$$scope, items*/ 130) {
				comment_changes.$$scope = { dirty, ctx };
			}

			comment.$set(comment_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(comment.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(comment.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			destroy_component(comment);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$c.name,
		type: "each",
		source: "(40:8) {#each items as comment}",
		ctx
	});

	return block;
}

// (67:4) {#if withForm}
function create_if_block$q(ctx) {
	let br;
	let t0;
	let div1;
	let form;
	let t1;
	let div0;
	let button;
	let current;
	br = new Br({ props: { size: "40" }, $$inline: true });

	form = new Form({
			props: {
				class: "flex",
				name: "comment-form",
				$$slots: { default: [create_default_slot_1$5] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	form.$on("submit", /*submit_handler*/ ctx[3]);

	button = new Button({
			props: {
				type: "submit",
				class: "flex full-width flex-self-stretch flex-justify-start",
				$$slots: { default: [create_default_slot$L] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(br.$$.fragment);
			t0 = space();
			div1 = element("div");
			create_component(form.$$.fragment);
			t1 = space();
			div0 = element("div");
			create_component(button.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			claim_component(br.$$.fragment, nodes);
			t0 = claim_space(nodes);
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			claim_component(form.$$.fragment, div1_nodes);
			t1 = claim_space(div1_nodes);
			div0 = claim_element(div1_nodes, "DIV", { class: true, style: true });
			var div0_nodes = children(div0);
			claim_component(button.$$.fragment, div0_nodes);
			div0_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "flex absolute");
			set_style(div0, "top", "0");
			set_style(div0, "right", "0");
			set_style(div0, "height", "100%");
			set_style(div0, "width", "50px");
			add_location(div0, file$1i, 78, 12, 2332);
			attr_dev(div1, "class", "comments-form font-secondary h3 svelte-gsvbhk");
			add_location(div1, file$1i, 68, 8, 1875);
		},
		m: function mount(target, anchor) {
			mount_component(br, target, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, div1, anchor);
			mount_component(form, div1, null);
			append_dev(div1, t1);
			append_dev(div1, div0);
			mount_component(button, div0, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const form_changes = {};

			if (dirty & /*$$scope*/ 128) {
				form_changes.$$scope = { dirty, ctx };
			}

			form.$set(form_changes);
			const button_changes = {};

			if (dirty & /*$$scope*/ 128) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(br.$$.fragment, local);
			transition_in(form.$$.fragment, local);
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br.$$.fragment, local);
			transition_out(form.$$.fragment, local);
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(br, detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div1);
			destroy_component(form);
			destroy_component(button);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$q.name,
		type: "if",
		source: "(67:4) {#if withForm}",
		ctx
	});

	return block;
}

// (70:12) <Form class="flex" name="comment-form" on:submit={values => dispatch('sumbit', values)}>
function create_default_slot_1$5(ctx) {
	let input;
	let current;

	input = new Input({
			props: {
				type: "textarea",
				name: "comment",
				rows: "1",
				class: "comment-field flex-self-stretch",
				placeholder: "Залиште свій коментар"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(input.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(input.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(input, target, anchor);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(input.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(input.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(input, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$5.name,
		type: "slot",
		source: "(70:12) <Form class=\\\"flex\\\" name=\\\"comment-form\\\" on:submit={values => dispatch('sumbit', values)}>",
		ctx
	});

	return block;
}

// (80:16) <Button type="submit" class="flex full-width flex-self-stretch flex-justify-start">
function create_default_slot$L(ctx) {
	let icon;
	let current;

	icon = new Icon({
			props: { type: "send", is: "info", size: "medium" },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(icon.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$L.name,
		type: "slot",
		source: "(80:16) <Button type=\\\"submit\\\" class=\\\"flex full-width flex-self-stretch flex-justify-start\\\">",
		ctx
	});

	return block;
}

function create_fragment$1j(ctx) {
	let section;
	let ul;
	let t0;
	let br;
	let t1;
	let p;
	let span;
	let t2;
	let t3;
	let icon;
	let t4;
	let current;
	let each_value = /*items*/ ctx[1];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$c(get_each_context$c(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	br = new Br({ props: { size: "20" }, $$inline: true });

	icon = new Icon({
			props: { type: "caret-down", size: "small" },
			$$inline: true
		});

	let if_block = /*withForm*/ ctx[0] && create_if_block$q(ctx);

	const block = {
		c: function create() {
			section = element("section");
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t0 = space();
			create_component(br.$$.fragment);
			t1 = space();
			p = element("p");
			span = element("span");
			t2 = text("Всі коментарі");
			t3 = space();
			create_component(icon.$$.fragment);
			t4 = space();
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { class: true });
			var section_nodes = children(section);
			ul = claim_element(section_nodes, "UL", { class: true });
			var ul_nodes = children(ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(ul_nodes);
			}

			ul_nodes.forEach(detach_dev);
			t0 = claim_space(section_nodes);
			claim_component(br.$$.fragment, section_nodes);
			t1 = claim_space(section_nodes);
			p = claim_element(section_nodes, "P", { class: true });
			var p_nodes = children(p);
			span = claim_element(p_nodes, "SPAN", {});
			var span_nodes = children(span);
			t2 = claim_text(span_nodes, "Всі коментарі");
			span_nodes.forEach(detach_dev);
			t3 = claim_space(p_nodes);
			claim_component(icon.$$.fragment, p_nodes);
			p_nodes.forEach(detach_dev);
			t4 = claim_space(section_nodes);
			if (if_block) if_block.l(section_nodes);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(ul, "class", "comments-wrap svelte-gsvbhk");
			add_location(ul, file$1i, 38, 4, 921);
			add_location(span, file$1i, 62, 8, 1738);
			attr_dev(p, "class", "h3 font-w-500 font-secondary underline text-center");
			add_location(p, file$1i, 61, 4, 1667);
			attr_dev(section, "class", "comments svelte-gsvbhk");
			add_location(section, file$1i, 37, 0, 890);
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			append_dev(section, ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}

			append_dev(section, t0);
			mount_component(br, section, null);
			append_dev(section, t1);
			append_dev(section, p);
			append_dev(p, span);
			append_dev(span, t2);
			append_dev(p, t3);
			mount_component(icon, p, null);
			append_dev(section, t4);
			if (if_block) if_block.m(section, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*items, Date*/ 2) {
				each_value = /*items*/ ctx[1];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$c(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$c(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(ul, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}

			if (/*withForm*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*withForm*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$q(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(section, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			transition_in(br.$$.fragment, local);
			transition_in(icon.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			transition_out(br.$$.fragment, local);
			transition_out(icon.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			destroy_each(each_blocks, detaching);
			destroy_component(br);
			destroy_component(icon);
			if (if_block) if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1j.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1j($$self, $$props, $$invalidate) {
	const dispatch = createEventDispatcher();
	let { withForm = true } = $$props;
	let { items = new Array(4).fill({ comment: null }) } = $$props;
	const writable_props = ["withForm", "items"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Comments> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Comments", $$slots, []);
	const submit_handler = values => dispatch("sumbit", values);

	$$self.$set = $$props => {
		if ("withForm" in $$props) $$invalidate(0, withForm = $$props.withForm);
		if ("items" in $$props) $$invalidate(1, items = $$props.items);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		Br,
		Icon,
		Form,
		Input,
		Button,
		Loader,
		Comment,
		dispatch,
		withForm,
		items
	});

	$$self.$inject_state = $$props => {
		if ("withForm" in $$props) $$invalidate(0, withForm = $$props.withForm);
		if ("items" in $$props) $$invalidate(1, items = $$props.items);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [withForm, items, dispatch, submit_handler];
}

class Comments extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document.getElementById("svelte-gsvbhk-style")) add_css$A();
		init(this, options, instance$1j, create_fragment$1j, safe_not_equal, { withForm: 0, items: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Comments",
			options,
			id: create_fragment$1j.name
		});
	}

	get withForm() {
		throw new Error("<Comments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set withForm(value) {
		throw new Error("<Comments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get items() {
		throw new Error("<Comments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set items(value) {
		throw new Error("<Comments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/donators/DonatorsCard.svelte generated by Svelte v3.24.0 */
const file$1j = "src/components/donators/DonatorsCard.svelte";

function add_css$B() {
	var style = element("style");
	style.id = "svelte-3bffko-style";
	style.textContent = "li.svelte-3bffko{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;padding:20px;width:100%}li.svelte-3bffko:not(:last-child){background-image:-webkit-gradient(linear, left top, right top, color-stop(50%, rgba(var(--theme-color-primary-opposite), 0.1)), color-stop(0%, rgba(var(--theme-color-primary-opposite), 0)));background-image:linear-gradient(to right, rgba(var(--theme-color-primary-opposite), 0.1) 50%, rgba(var(--theme-color-primary-opposite), 0) 0%);background-position:bottom;background-size:20px 1px;background-repeat:repeat-x}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRG9uYXRvcnNDYXJkLnN2ZWx0ZSIsInNvdXJjZXMiOlsiRG9uYXRvcnNDYXJkLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0PlxuICAgIGltcG9ydCBJY29uIGZyb20gJ0Bjb21wb25lbnRzL0ljb24uc3ZlbHRlJ1xuICAgIGltcG9ydCBDYXJkIGZyb20gJ0Bjb21wb25lbnRzL0NhcmQuc3ZlbHRlJ1xuICAgIGltcG9ydCBBdmF0YXIgZnJvbSAnQGNvbXBvbmVudHMvQXZhdGFyLnN2ZWx0ZSdcbiAgICBpbXBvcnQgTG9hZGVyIGZyb20gJ0Bjb21wb25lbnRzL2xvYWRlcidcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHt7XG4gICAgICogIGlkOiBzdHJpbmcsXG4gICAgICogIHNyYzogc3RyaW5nLFxuICAgICAqICB0aXRsZTogc3RyaW5nLFxuICAgICAqICBzdWJ0aXRsZTogc3RyaW5nLFxuICAgICAqICBjaGVja2VkOiBib29sZWFuLFxuICAgICAqIH19XG4gICAgICovXG4gICAgZXhwb3J0IGxldCBpdGVtc1xuPC9zY3JpcHQ+XG5cbnsjaWYgQXJyYXkuaXNBcnJheShpdGVtcykgJiYgaXRlbXMubGVuZ3RofVxuICAgIDxDYXJkPlxuICAgICAgICA8dWwgY2xhc3M9XCJmdWxsLXdpZHRoXCI+XG4gICAgICAgICAgICB7I2VhY2ggaXRlbXMgYXMgaXRlbX1cbiAgICAgICAgICAgICAgICA8bGkga2V5PXtpdGVtLmlkfT5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInJlbGF0aXZlXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8QXZhdGFyIHNyYz17aXRlbS5zcmN9IHNpemU9XCJtZWRpdW1cIiBhbHQ9e2l0ZW0uc3VidGl0bGV9Lz5cbiAgICAgICAgICAgICAgICAgICAgICAgIHsjaWYgaXRlbS5jaGVja2VkfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJhYnNvbHV0ZSBmbGV4XCIgc3R5bGU9XCJ0b3A6IC0xcHg7IHJpZ2h0OiAtMXB4OyB3aWR0aDogMjBweDsgaGVpZ2h0OiAyMHB4OyBvdmVyZmxvdzogaGlkZGVuXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxJY29uIHR5cGU9XCJwb2x5Z29uXCIgaXM9XCJpbmZvXCIvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiYWJzb2x1dGUtY2VudGVyIGZsZXhcIiBzdHlsZT1cIndpZHRoOiAxMHB4OyBoZWlnaHQ6IDEwcHg7XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8SWNvbiB0eXBlPVwiY2hlY2stZmxhZ1wiIGlzPVwibGlnaHRcIi8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDxzPjwvcz5cbiAgICAgICAgICAgICAgICAgICAgPHM+PC9zPlxuICAgICAgICAgICAgICAgICAgICA8cz48L3M+XG4gICAgICAgICAgICAgICAgICAgIDxzPjwvcz5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBzdHlsZT1cIm92ZXJmbG93OiBoaWRkZW47XCIgY2xhc3M9XCJmbGV4IGZsZXgtY29sdW1uIGZsZXgtanVzdGlmeS1jZW50ZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIHsjaWYgaXRlbS50aXRsZSAhPT0gbnVsbH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aDIgY2xhc3M9XCJ0ZXh0LWVsbGlwc2lzXCI+eyBpdGVtLnRpdGxlIH08L2gyPlxuICAgICAgICAgICAgICAgICAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaDIgcmVsYXRpdmUgZmxleC1zZWxmLXN0YXJ0XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIHN0eWxlPVwidmlzaWJpbGl0eTogaGlkZGVuXCI+4oK0IDEwMDA8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxMb2FkZXIgdHlwZT1cImgyXCIgYWJzb2x1dGUvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj4gIFxuICAgICAgICAgICAgICAgICAgICAgICAgey9pZn1cblxuICAgICAgICAgICAgICAgICAgICAgICAgeyNpZiBpdGVtLnN1YnRpdGxlICE9PSBudWxsfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaDQgZm9udC13LTMwMCB0ZXh0LWVsbGlwc2lzXCI+eyBpdGVtLnN1YnRpdGxlIH08L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICB7OmVsc2V9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPExvYWRlciB0eXBlPVwiaDRcIi8+XG4gICAgICAgICAgICAgICAgICAgICAgICB7L2lmfVxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgey9lYWNofVxuICAgICAgICA8L3VsPlxuICAgIDwvQ2FyZD5cbnsvaWZ9XG5cbjxzdHlsZT5cbmxpIHtcbiAgICBkaXNwbGF5OiAtd2Via2l0LWJveDtcbiAgICBkaXNwbGF5OiAtbXMtZmxleGJveDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIC13ZWJraXQtYm94LWFsaWduOiBjZW50ZXI7XG4gICAgICAgIC1tcy1mbGV4LWFsaWduOiBjZW50ZXI7XG4gICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIHBhZGRpbmc6IDIwcHg7XG4gICAgd2lkdGg6IDEwMCU7XG59XG5cbmxpOm5vdCg6bGFzdC1jaGlsZCkge1xuICAgIGJhY2tncm91bmQtaW1hZ2U6IC13ZWJraXQtZ3JhZGllbnQobGluZWFyLCBsZWZ0IHRvcCwgcmlnaHQgdG9wLCBjb2xvci1zdG9wKDUwJSwgcmdiYSh2YXIoLS10aGVtZS1jb2xvci1wcmltYXJ5LW9wcG9zaXRlKSwgMC4xKSksIGNvbG9yLXN0b3AoMCUsIHJnYmEodmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeS1vcHBvc2l0ZSksIDApKSk7XG4gICAgYmFja2dyb3VuZC1pbWFnZTogbGluZWFyLWdyYWRpZW50KHRvIHJpZ2h0LCByZ2JhKHZhcigtLXRoZW1lLWNvbG9yLXByaW1hcnktb3Bwb3NpdGUpLCAwLjEpIDUwJSwgcmdiYSh2YXIoLS10aGVtZS1jb2xvci1wcmltYXJ5LW9wcG9zaXRlKSwgMCkgMCUpO1xuICAgIGJhY2tncm91bmQtcG9zaXRpb246IGJvdHRvbTtcbiAgICBiYWNrZ3JvdW5kLXNpemU6IDIwcHggMXB4O1xuICAgIGJhY2tncm91bmQtcmVwZWF0OiByZXBlYXQteDtcbn08L3N0eWxlPlxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQTZEQSxFQUFFLGNBQUMsQ0FBQyxBQUNBLE9BQU8sQ0FBRSxXQUFXLENBQ3BCLE9BQU8sQ0FBRSxXQUFXLENBQ3BCLE9BQU8sQ0FBRSxJQUFJLENBQ2IsaUJBQWlCLENBQUUsTUFBTSxDQUNyQixjQUFjLENBQUUsTUFBTSxDQUNsQixXQUFXLENBQUUsTUFBTSxDQUMzQixPQUFPLENBQUUsSUFBSSxDQUNiLEtBQUssQ0FBRSxJQUFJLEFBQ2YsQ0FBQyxBQUVELGdCQUFFLEtBQUssV0FBVyxDQUFDLEFBQUMsQ0FBQyxBQUNqQixnQkFBZ0IsQ0FBRSxpQkFBaUIsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxXQUFXLEdBQUcsQ0FBQyxDQUFDLEtBQUssSUFBSSw4QkFBOEIsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUMsS0FBSyxJQUFJLDhCQUE4QixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQzlMLGdCQUFnQixDQUFFLGdCQUFnQixFQUFFLENBQUMsS0FBSyxDQUFDLENBQUMsS0FBSyxJQUFJLDhCQUE4QixDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLElBQUksOEJBQThCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUNoSixtQkFBbUIsQ0FBRSxNQUFNLENBQzNCLGVBQWUsQ0FBRSxJQUFJLENBQUMsR0FBRyxDQUN6QixpQkFBaUIsQ0FBRSxRQUFRLEFBQy9CLENBQUMifQ== */";
	append_dev(document.head, style);
}

function get_each_context$d(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[1] = list[i];
	return child_ctx;
}

// (19:0) {#if Array.isArray(items) && items.length}
function create_if_block$r(ctx) {
	let card;
	let current;

	card = new Card({
			props: {
				$$slots: { default: [create_default_slot$M] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(card.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(card.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(card, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const card_changes = {};

			if (dirty & /*$$scope, items*/ 17) {
				card_changes.$$scope = { dirty, ctx };
			}

			card.$set(card_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(card.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(card.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(card, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$r.name,
		type: "if",
		source: "(19:0) {#if Array.isArray(items) && items.length}",
		ctx
	});

	return block;
}

// (26:24) {#if item.checked}
function create_if_block_3$4(ctx) {
	let div1;
	let icon0;
	let t;
	let div0;
	let icon1;
	let current;

	icon0 = new Icon({
			props: { type: "polygon", is: "info" },
			$$inline: true
		});

	icon1 = new Icon({
			props: { type: "check-flag", is: "light" },
			$$inline: true
		});

	const block = {
		c: function create() {
			div1 = element("div");
			create_component(icon0.$$.fragment);
			t = space();
			div0 = element("div");
			create_component(icon1.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true, style: true });
			var div1_nodes = children(div1);
			claim_component(icon0.$$.fragment, div1_nodes);
			t = claim_space(div1_nodes);
			div0 = claim_element(div1_nodes, "DIV", { class: true, style: true });
			var div0_nodes = children(div0);
			claim_component(icon1.$$.fragment, div0_nodes);
			div0_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "absolute-center flex");
			set_style(div0, "width", "10px");
			set_style(div0, "height", "10px");
			add_location(div0, file$1j, 28, 32, 942);
			attr_dev(div1, "class", "absolute flex");
			set_style(div1, "top", "-1px");
			set_style(div1, "right", "-1px");
			set_style(div1, "width", "20px");
			set_style(div1, "height", "20px");
			set_style(div1, "overflow", "hidden");
			add_location(div1, file$1j, 26, 28, 741);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			mount_component(icon0, div1, null);
			append_dev(div1, t);
			append_dev(div1, div0);
			mount_component(icon1, div0, null);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon0.$$.fragment, local);
			transition_in(icon1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon0.$$.fragment, local);
			transition_out(icon1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			destroy_component(icon0);
			destroy_component(icon1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$4.name,
		type: "if",
		source: "(26:24) {#if item.checked}",
		ctx
	});

	return block;
}

// (42:24) {:else}
function create_else_block_1$4(ctx) {
	let span1;
	let span0;
	let t0;
	let t1;
	let loader;
	let current;

	loader = new Loader({
			props: { type: "h2", absolute: true },
			$$inline: true
		});

	const block = {
		c: function create() {
			span1 = element("span");
			span0 = element("span");
			t0 = text("₴ 1000");
			t1 = space();
			create_component(loader.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			span1 = claim_element(nodes, "SPAN", { class: true });
			var span1_nodes = children(span1);
			span0 = claim_element(span1_nodes, "SPAN", { style: true });
			var span0_nodes = children(span0);
			t0 = claim_text(span0_nodes, "₴ 1000");
			span0_nodes.forEach(detach_dev);
			t1 = claim_space(span1_nodes);
			claim_component(loader.$$.fragment, span1_nodes);
			span1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_style(span0, "visibility", "hidden");
			add_location(span0, file$1j, 43, 32, 1684);
			attr_dev(span1, "class", "h2 relative flex-self-start");
			add_location(span1, file$1j, 42, 28, 1609);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span1, anchor);
			append_dev(span1, span0);
			append_dev(span0, t0);
			append_dev(span1, t1);
			mount_component(loader, span1, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(loader.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loader.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span1);
			destroy_component(loader);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1$4.name,
		type: "else",
		source: "(42:24) {:else}",
		ctx
	});

	return block;
}

// (40:24) {#if item.title !== null}
function create_if_block_2$7(ctx) {
	let h2;
	let t_value = /*item*/ ctx[1].title + "";
	let t;

	const block = {
		c: function create() {
			h2 = element("h2");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			h2 = claim_element(nodes, "H2", { class: true });
			var h2_nodes = children(h2);
			t = claim_text(h2_nodes, t_value);
			h2_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(h2, "class", "text-ellipsis");
			add_location(h2, file$1j, 40, 28, 1503);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h2, anchor);
			append_dev(h2, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*items*/ 1 && t_value !== (t_value = /*item*/ ctx[1].title + "")) set_data_dev(t, t_value);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(h2);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$7.name,
		type: "if",
		source: "(40:24) {#if item.title !== null}",
		ctx
	});

	return block;
}

// (51:24) {:else}
function create_else_block$b(ctx) {
	let loader;
	let current;
	loader = new Loader({ props: { type: "h4" }, $$inline: true });

	const block = {
		c: function create() {
			create_component(loader.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(loader.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(loader, target, anchor);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(loader.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loader.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(loader, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$b.name,
		type: "else",
		source: "(51:24) {:else}",
		ctx
	});

	return block;
}

// (49:24) {#if item.subtitle !== null}
function create_if_block_1$i(ctx) {
	let span;
	let t_value = /*item*/ ctx[1].subtitle + "";
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t = claim_text(span_nodes, t_value);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "h4 font-w-300 text-ellipsis");
			add_location(span, file$1j, 49, 28, 1942);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*items*/ 1 && t_value !== (t_value = /*item*/ ctx[1].subtitle + "")) set_data_dev(t, t_value);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$i.name,
		type: "if",
		source: "(49:24) {#if item.subtitle !== null}",
		ctx
	});

	return block;
}

// (22:12) {#each items as item}
function create_each_block$d(ctx) {
	let li;
	let div0;
	let avatar;
	let t0;
	let t1;
	let s0;
	let t2;
	let s1;
	let t3;
	let s2;
	let t4;
	let s3;
	let t5;
	let div1;
	let current_block_type_index;
	let if_block1;
	let t6;
	let current_block_type_index_1;
	let if_block2;
	let t7;
	let li_key_value;
	let current;

	avatar = new Avatar({
			props: {
				src: /*item*/ ctx[1].src,
				size: "medium",
				alt: /*item*/ ctx[1].subtitle
			},
			$$inline: true
		});

	let if_block0 = /*item*/ ctx[1].checked && create_if_block_3$4(ctx);
	const if_block_creators = [create_if_block_2$7, create_else_block_1$4];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*item*/ ctx[1].title !== null) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	const if_block_creators_1 = [create_if_block_1$i, create_else_block$b];
	const if_blocks_1 = [];

	function select_block_type_1(ctx, dirty) {
		if (/*item*/ ctx[1].subtitle !== null) return 0;
		return 1;
	}

	current_block_type_index_1 = select_block_type_1(ctx);
	if_block2 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);

	const block = {
		c: function create() {
			li = element("li");
			div0 = element("div");
			create_component(avatar.$$.fragment);
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			s0 = element("s");
			t2 = space();
			s1 = element("s");
			t3 = space();
			s2 = element("s");
			t4 = space();
			s3 = element("s");
			t5 = space();
			div1 = element("div");
			if_block1.c();
			t6 = space();
			if_block2.c();
			t7 = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { key: true, class: true });
			var li_nodes = children(li);
			div0 = claim_element(li_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			claim_component(avatar.$$.fragment, div0_nodes);
			t0 = claim_space(div0_nodes);
			if (if_block0) if_block0.l(div0_nodes);
			div0_nodes.forEach(detach_dev);
			t1 = claim_space(li_nodes);
			s0 = claim_element(li_nodes, "S", {});
			children(s0).forEach(detach_dev);
			t2 = claim_space(li_nodes);
			s1 = claim_element(li_nodes, "S", {});
			children(s1).forEach(detach_dev);
			t3 = claim_space(li_nodes);
			s2 = claim_element(li_nodes, "S", {});
			children(s2).forEach(detach_dev);
			t4 = claim_space(li_nodes);
			s3 = claim_element(li_nodes, "S", {});
			children(s3).forEach(detach_dev);
			t5 = claim_space(li_nodes);
			div1 = claim_element(li_nodes, "DIV", { style: true, class: true });
			var div1_nodes = children(div1);
			if_block1.l(div1_nodes);
			t6 = claim_space(div1_nodes);
			if_block2.l(div1_nodes);
			div1_nodes.forEach(detach_dev);
			t7 = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "relative");
			add_location(div0, file$1j, 23, 20, 564);
			add_location(s0, file$1j, 34, 20, 1236);
			add_location(s1, file$1j, 35, 20, 1264);
			add_location(s2, file$1j, 36, 20, 1292);
			add_location(s3, file$1j, 37, 20, 1320);
			set_style(div1, "overflow", "hidden");
			attr_dev(div1, "class", "flex flex-column flex-justify-center");
			add_location(div1, file$1j, 38, 20, 1348);
			attr_dev(li, "key", li_key_value = /*item*/ ctx[1].id);
			attr_dev(li, "class", "svelte-3bffko");
			add_location(li, file$1j, 22, 16, 525);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, div0);
			mount_component(avatar, div0, null);
			append_dev(div0, t0);
			if (if_block0) if_block0.m(div0, null);
			append_dev(li, t1);
			append_dev(li, s0);
			append_dev(li, t2);
			append_dev(li, s1);
			append_dev(li, t3);
			append_dev(li, s2);
			append_dev(li, t4);
			append_dev(li, s3);
			append_dev(li, t5);
			append_dev(li, div1);
			if_blocks[current_block_type_index].m(div1, null);
			append_dev(div1, t6);
			if_blocks_1[current_block_type_index_1].m(div1, null);
			append_dev(li, t7);
			current = true;
		},
		p: function update(ctx, dirty) {
			const avatar_changes = {};
			if (dirty & /*items*/ 1) avatar_changes.src = /*item*/ ctx[1].src;
			if (dirty & /*items*/ 1) avatar_changes.alt = /*item*/ ctx[1].subtitle;
			avatar.$set(avatar_changes);

			if (/*item*/ ctx[1].checked) {
				if (if_block0) {
					if (dirty & /*items*/ 1) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_3$4(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div0, null);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block1 = if_blocks[current_block_type_index];

				if (!if_block1) {
					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block1.c();
				}

				transition_in(if_block1, 1);
				if_block1.m(div1, t6);
			}

			let previous_block_index_1 = current_block_type_index_1;
			current_block_type_index_1 = select_block_type_1(ctx);

			if (current_block_type_index_1 === previous_block_index_1) {
				if_blocks_1[current_block_type_index_1].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
					if_blocks_1[previous_block_index_1] = null;
				});

				check_outros();
				if_block2 = if_blocks_1[current_block_type_index_1];

				if (!if_block2) {
					if_block2 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
					if_block2.c();
				}

				transition_in(if_block2, 1);
				if_block2.m(div1, null);
			}

			if (!current || dirty & /*items*/ 1 && li_key_value !== (li_key_value = /*item*/ ctx[1].id)) {
				attr_dev(li, "key", li_key_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(avatar.$$.fragment, local);
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(if_block2);
			current = true;
		},
		o: function outro(local) {
			transition_out(avatar.$$.fragment, local);
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(if_block2);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			destroy_component(avatar);
			if (if_block0) if_block0.d();
			if_blocks[current_block_type_index].d();
			if_blocks_1[current_block_type_index_1].d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$d.name,
		type: "each",
		source: "(22:12) {#each items as item}",
		ctx
	});

	return block;
}

// (20:4) <Card>
function create_default_slot$M(ctx) {
	let ul;
	let current;
	let each_value = /*items*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$d(get_each_context$d(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(ul_nodes);
			}

			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(ul, "class", "full-width");
			add_location(ul, file$1j, 20, 8, 451);
		},
		m: function mount(target, anchor) {
			insert_dev(target, ul, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty & /*items*/ 1) {
				each_value = /*items*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$d(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$d(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(ul, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(ul);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$M.name,
		type: "slot",
		source: "(20:4) <Card>",
		ctx
	});

	return block;
}

function create_fragment$1k(ctx) {
	let show_if = Array.isArray(/*items*/ ctx[0]) && /*items*/ ctx[0].length;
	let if_block_anchor;
	let current;
	let if_block = show_if && create_if_block$r(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*items*/ 1) show_if = Array.isArray(/*items*/ ctx[0]) && /*items*/ ctx[0].length;

			if (show_if) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*items*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$r(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1k.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1k($$self, $$props, $$invalidate) {
	let { items } = $$props;
	const writable_props = ["items"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<DonatorsCard> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("DonatorsCard", $$slots, []);

	$$self.$set = $$props => {
		if ("items" in $$props) $$invalidate(0, items = $$props.items);
	};

	$$self.$capture_state = () => ({ Icon, Card, Avatar, Loader, items });

	$$self.$inject_state = $$props => {
		if ("items" in $$props) $$invalidate(0, items = $$props.items);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [items];
}

class DonatorsCard extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document.getElementById("svelte-3bffko-style")) add_css$B();
		init(this, options, instance$1k, create_fragment$1k, safe_not_equal, { items: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "DonatorsCard",
			options,
			id: create_fragment$1k.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*items*/ ctx[0] === undefined && !("items" in props)) {
			console.warn("<DonatorsCard> was created without expected prop 'items'");
		}
	}

	get items() {
		throw new Error("<DonatorsCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set items(value) {
		throw new Error("<DonatorsCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/donators/DonatorsList.svelte generated by Svelte v3.24.0 */

const { console: console_1$2 } = globals;
const file$1k = "src/components/donators/DonatorsList.svelte";

function add_css$C() {
	var style = element("style");
	style.id = "svelte-1pn9uv2-style";
	style.textContent = "ul.svelte-1pn9uv2{width:100%;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start;max-width:100%;overflow-y:hidden;overflow-x:auto;padding:var(--screen-padding) 0}li.svelte-1pn9uv2{-webkit-box-flex:0;-ms-flex:none;flex:none;-ms-flex-item-align:stretch;align-self:stretch;width:260px;padding:0 5px}li.svelte-1pn9uv2:first-child{padding-left:15px}li.svelte-1pn9uv2:last-child{padding-right:15px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRG9uYXRvcnNMaXN0LnN2ZWx0ZSIsInNvdXJjZXMiOlsiRG9uYXRvcnNMaXN0LnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0PlxuICAgIGltcG9ydCB7IHRpY2sgfSBmcm9tICdzdmVsdGUnXG4gICAgaW1wb3J0IERvbmF0b3JzQ2FyZCBmcm9tICcuL0RvbmF0b3JzQ2FyZC5zdmVsdGUnXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7e1xuICAgICAqICBpZDogc3RyaW5nLFxuICAgICAqICBzcmM6IHN0cmluZyxcbiAgICAgKiAgdGl0bGU6IHN0cmluZyxcbiAgICAgKiAgc3VidGl0bGU6IHN0cmluZyxcbiAgICAgKiAgY2hlY2tlZDogYm9vbGVhbixcbiAgICAgKiB9W119XG4gICAgICovXG4gICAgZXhwb3J0IGxldCBpdGVtcyA9IG5ldyBBcnJheSg4KS5maWxsKHsgdGl0bGU6IG51bGwsIHN1YnRpdGxlOiBudWxsIH0pXG5cbiAgICBsZXQgaXRlbXNQcmV2ID0gW11cbiAgICBsZXQgY29udGFpbmVyID0gbnVsbFxuICAgIGxldCBncm91cGVkID0gW11cbiAgICBcbiAgICAkOiBncm91cGVkID0gaXRlbXMucmV2ZXJzZSgpLnJlZHVjZSgoYWNjLCBpdGVtKSA9PiB7XG4gICAgICAgIGNvbnN0IGxhc3RJbmQgPSBNYXRoLm1heChhY2MubGVuZ3RoIC0gMSwgMClcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFjY1tsYXN0SW5kXSkpIHtcbiAgICAgICAgICAgIGFjY1tsYXN0SW5kXSA9IFtdXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFjY1tsYXN0SW5kXS5sZW5ndGggPCAzKSB7XG4gICAgICAgICAgICBhY2NbbGFzdEluZF0ucHVzaChpdGVtKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWNjLnB1c2goW10pXG4gICAgICAgICAgICBhY2NbbGFzdEluZCArIDFdLnB1c2goaXRlbSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjXG4gICAgfSwgW10pLnJldmVyc2UoKVxuXG4gICAgJDogb25JdGVtc0NoYW5nZShpdGVtcywgY29udGFpbmVyKVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gb25JdGVtc0NoYW5nZShpdGVtcywgY29udGFpbmVyKSB7XG4gICAgICAgIGlmIChpdGVtcyAmJiBpdGVtcy5sZW5ndGggJiYgIShpdGVtc1ByZXYgJiYgaXRlbXNQcmV2Lmxlbmd0aCkpIHtcbiAgICAgICAgICAgIGF3YWl0IHRpY2soKVxuICAgICAgICAgICAgc2Nyb2xsRW5kKGNvbnRhaW5lcilcbiAgICAgICAgfVxuICAgICAgICBpdGVtc1ByZXYgPSBpdGVtc1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjcm9sbEVuZChub2RlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBub2RlICYmIG5vZGUuc2Nyb2xsVG8obm9kZS5zY3JvbGxXaWR0aCwgMClcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFRoZSBNYWdpYyB0b2xkIG1lIFwiJHtlcnIubWVzc2FnZX1cIi4gSXQncyBhIHdlaXJkIHJlYXNvbiwgSSBrbm93LCBidXQgSSBjb3VsZG4ndCBzY3JvbGwgdG8gdGhlIGVuZCBvZiAke25vZGV9IHdpdGggaXQ6IGAsIGVycilcbiAgICAgICAgfVxuICAgIH1cbjwvc2NyaXB0PlxuXG48dWwgY2xhc3M9XCJkb25hdG9ycyBzY3JvbGwteC1jZW50ZXJcIiBiaW5kOnRoaXM9e2NvbnRhaW5lcn0+XG4gICAgeyNlYWNoIGdyb3VwZWQgYXMgY2FyZHN9XG4gICAgICAgIDxsaT5cbiAgICAgICAgICAgIDxEb25hdG9yc0NhcmQgaXRlbXM9e2NhcmRzfS8+XG4gICAgICAgIDwvbGk+XG4gICAgey9lYWNofVxuPC91bD5cblxuPHN0eWxlPlxudWwge1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGRpc3BsYXk6IC13ZWJraXQtYm94O1xuICAgIGRpc3BsYXk6IC1tcy1mbGV4Ym94O1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgLXdlYmtpdC1ib3gtYWxpZ246IHN0YXJ0O1xuICAgICAgICAtbXMtZmxleC1hbGlnbjogc3RhcnQ7XG4gICAgICAgICAgICBhbGlnbi1pdGVtczogZmxleC1zdGFydDtcbiAgICBtYXgtd2lkdGg6IDEwMCU7XG4gICAgb3ZlcmZsb3cteTogaGlkZGVuO1xuICAgIG92ZXJmbG93LXg6IGF1dG87XG4gICAgcGFkZGluZzogdmFyKC0tc2NyZWVuLXBhZGRpbmcpIDA7XG59XG5cbmxpIHtcbiAgICAtd2Via2l0LWJveC1mbGV4OiAwO1xuICAgICAgICAtbXMtZmxleDogbm9uZTtcbiAgICAgICAgICAgIGZsZXg6IG5vbmU7XG4gICAgLW1zLWZsZXgtaXRlbS1hbGlnbjogc3RyZXRjaDtcbiAgICAgICAgYWxpZ24tc2VsZjogc3RyZXRjaDtcbiAgICB3aWR0aDogMjYwcHg7XG4gICAgcGFkZGluZzogMCA1cHg7XG59XG5cbmxpOmZpcnN0LWNoaWxkIHtcbiAgICBwYWRkaW5nLWxlZnQ6IDE1cHg7XG59XG5cbmxpOmxhc3QtY2hpbGQge1xuICAgIHBhZGRpbmctcmlnaHQ6IDE1cHg7XG59PC9zdHlsZT5cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUE2REEsRUFBRSxlQUFDLENBQUMsQUFDQSxLQUFLLENBQUUsSUFBSSxDQUNYLE9BQU8sQ0FBRSxXQUFXLENBQ3BCLE9BQU8sQ0FBRSxXQUFXLENBQ3BCLE9BQU8sQ0FBRSxJQUFJLENBQ2IsaUJBQWlCLENBQUUsS0FBSyxDQUNwQixjQUFjLENBQUUsS0FBSyxDQUNqQixXQUFXLENBQUUsVUFBVSxDQUMvQixTQUFTLENBQUUsSUFBSSxDQUNmLFVBQVUsQ0FBRSxNQUFNLENBQ2xCLFVBQVUsQ0FBRSxJQUFJLENBQ2hCLE9BQU8sQ0FBRSxJQUFJLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxBQUNwQyxDQUFDLEFBRUQsRUFBRSxlQUFDLENBQUMsQUFDQSxnQkFBZ0IsQ0FBRSxDQUFDLENBQ2YsUUFBUSxDQUFFLElBQUksQ0FDVixJQUFJLENBQUUsSUFBSSxDQUNsQixtQkFBbUIsQ0FBRSxPQUFPLENBQ3hCLFVBQVUsQ0FBRSxPQUFPLENBQ3ZCLEtBQUssQ0FBRSxLQUFLLENBQ1osT0FBTyxDQUFFLENBQUMsQ0FBQyxHQUFHLEFBQ2xCLENBQUMsQUFFRCxpQkFBRSxZQUFZLEFBQUMsQ0FBQyxBQUNaLFlBQVksQ0FBRSxJQUFJLEFBQ3RCLENBQUMsQUFFRCxpQkFBRSxXQUFXLEFBQUMsQ0FBQyxBQUNYLGFBQWEsQ0FBRSxJQUFJLEFBQ3ZCLENBQUMifQ== */";
	append_dev(document.head, style);
}

function get_each_context$e(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[6] = list[i];
	return child_ctx;
}

// (54:4) {#each grouped as cards}
function create_each_block$e(ctx) {
	let li;
	let donatorscard;
	let t;
	let current;

	donatorscard = new DonatorsCard({
			props: { items: /*cards*/ ctx[6] },
			$$inline: true
		});

	const block = {
		c: function create() {
			li = element("li");
			create_component(donatorscard.$$.fragment);
			t = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true });
			var li_nodes = children(li);
			claim_component(donatorscard.$$.fragment, li_nodes);
			t = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(li, "class", "svelte-1pn9uv2");
			add_location(li, file$1k, 54, 8, 1474);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			mount_component(donatorscard, li, null);
			append_dev(li, t);
			current = true;
		},
		p: function update(ctx, dirty) {
			const donatorscard_changes = {};
			if (dirty & /*grouped*/ 2) donatorscard_changes.items = /*cards*/ ctx[6];
			donatorscard.$set(donatorscard_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(donatorscard.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(donatorscard.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			destroy_component(donatorscard);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$e.name,
		type: "each",
		source: "(54:4) {#each grouped as cards}",
		ctx
	});

	return block;
}

function create_fragment$1l(ctx) {
	let ul;
	let current;
	let each_value = /*grouped*/ ctx[1];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$e(get_each_context$e(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(ul_nodes);
			}

			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(ul, "class", "donators scroll-x-center svelte-1pn9uv2");
			add_location(ul, file$1k, 52, 0, 1377);
		},
		m: function mount(target, anchor) {
			insert_dev(target, ul, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}

			/*ul_binding*/ ctx[3](ul);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*grouped*/ 2) {
				each_value = /*grouped*/ ctx[1];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$e(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$e(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(ul, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(ul);
			destroy_each(each_blocks, detaching);
			/*ul_binding*/ ctx[3](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1l.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function scrollEnd(node) {
	try {
		node && node.scrollTo(node.scrollWidth, 0);
	} catch(err) {
		console.warn(`The Magic told me "${err.message}". It's a weird reason, I know, but I couldn't scroll to the end of ${node} with it: `, err);
	}
}

function instance$1l($$self, $$props, $$invalidate) {
	let { items = new Array(8).fill({ title: null, subtitle: null }) } = $$props;
	let itemsPrev = [];
	let container = null;
	let grouped = [];

	async function onItemsChange(items, container) {
		if (items && items.length && !(itemsPrev && itemsPrev.length)) {
			await tick();
			scrollEnd(container);
		}

		itemsPrev = items;
	}

	const writable_props = ["items"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$2.warn(`<DonatorsList> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("DonatorsList", $$slots, []);

	function ul_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			container = $$value;
			$$invalidate(0, container);
		});
	}

	$$self.$set = $$props => {
		if ("items" in $$props) $$invalidate(2, items = $$props.items);
	};

	$$self.$capture_state = () => ({
		tick,
		DonatorsCard,
		items,
		itemsPrev,
		container,
		grouped,
		onItemsChange,
		scrollEnd
	});

	$$self.$inject_state = $$props => {
		if ("items" in $$props) $$invalidate(2, items = $$props.items);
		if ("itemsPrev" in $$props) itemsPrev = $$props.itemsPrev;
		if ("container" in $$props) $$invalidate(0, container = $$props.container);
		if ("grouped" in $$props) $$invalidate(1, grouped = $$props.grouped);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*items*/ 4) {
			 $$invalidate(1, grouped = items.reverse().reduce(
				(acc, item) => {
					const lastInd = Math.max(acc.length - 1, 0);

					if (!Array.isArray(acc[lastInd])) {
						acc[lastInd] = [];
					}

					if (acc[lastInd].length < 3) {
						acc[lastInd].push(item);
					} else {
						acc.push([]);
						acc[lastInd + 1].push(item);
					}

					return acc;
				},
				[]
			).reverse());
		}

		if ($$self.$$.dirty & /*items, container*/ 5) {
			 onItemsChange(items, container);
		}
	};

	return [container, grouped, items, ul_binding];
}

class DonatorsList extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document.getElementById("svelte-1pn9uv2-style")) add_css$C();
		init(this, options, instance$1l, create_fragment$1l, safe_not_equal, { items: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "DonatorsList",
			options,
			id: create_fragment$1l.name
		});
	}

	get items() {
		throw new Error("<DonatorsList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set items(value) {
		throw new Error("<DonatorsList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/newsList/NewsItem.svelte generated by Svelte v3.24.0 */
const file$1l = "src/components/newsList/NewsItem.svelte";

// (34:12) {:else}
function create_else_block_3$1(ctx) {
	let div0;
	let loader0;
	let t;
	let div1;
	let loader1;
	let current;
	loader0 = new Loader({ props: { type: "h3" }, $$inline: true });
	loader1 = new Loader({ props: { type: "h3" }, $$inline: true });

	const block = {
		c: function create() {
			div0 = element("div");
			create_component(loader0.$$.fragment);
			t = space();
			div1 = element("div");
			create_component(loader1.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div0 = claim_element(nodes, "DIV", { style: true });
			var div0_nodes = children(div0);
			claim_component(loader0.$$.fragment, div0_nodes);
			div0_nodes.forEach(detach_dev);
			t = claim_space(nodes);
			div1 = claim_element(nodes, "DIV", { style: true });
			var div1_nodes = children(div1);
			claim_component(loader1.$$.fragment, div1_nodes);
			div1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_style(div0, "width", "80%");
			add_location(div0, file$1l, 34, 16, 1140);
			set_style(div1, "width", "80%");
			add_location(div1, file$1l, 35, 16, 1206);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div0, anchor);
			mount_component(loader0, div0, null);
			insert_dev(target, t, anchor);
			insert_dev(target, div1, anchor);
			mount_component(loader1, div1, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(loader0.$$.fragment, local);
			transition_in(loader1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loader0.$$.fragment, local);
			transition_out(loader1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div0);
			destroy_component(loader0);
			if (detaching) detach_dev(t);
			if (detaching) detach_dev(div1);
			destroy_component(loader1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_3$1.name,
		type: "else",
		source: "(34:12) {:else}",
		ctx
	});

	return block;
}

// (32:12) {#if title !== null}
function create_if_block_3$5(ctx) {
	let h3;
	let t;

	const block = {
		c: function create() {
			h3 = element("h3");
			t = text(/*title*/ ctx[2]);
			this.h();
		},
		l: function claim(nodes) {
			h3 = claim_element(nodes, "H3", { class: true, style: true });
			var h3_nodes = children(h3);
			t = claim_text(h3_nodes, /*title*/ ctx[2]);
			h3_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(h3, "class", "font-w-500 text-ellipsis-multiline");
			set_style(h3, "--max-lines", "2");
			add_location(h3, file$1l, 32, 16, 1019);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h3, anchor);
			append_dev(h3, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*title*/ 4) set_data_dev(t, /*title*/ ctx[2]);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(h3);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$5.name,
		type: "if",
		source: "(32:12) {#if title !== null}",
		ctx
	});

	return block;
}

// (43:12) {:else}
function create_else_block_2$2(ctx) {
	let div0;
	let loader0;
	let t;
	let div1;
	let loader1;
	let current;
	loader0 = new Loader({ props: { type: "p" }, $$inline: true });
	loader1 = new Loader({ props: { type: "p" }, $$inline: true });

	const block = {
		c: function create() {
			div0 = element("div");
			create_component(loader0.$$.fragment);
			t = space();
			div1 = element("div");
			create_component(loader1.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div0 = claim_element(nodes, "DIV", { style: true });
			var div0_nodes = children(div0);
			claim_component(loader0.$$.fragment, div0_nodes);
			div0_nodes.forEach(detach_dev);
			t = claim_space(nodes);
			div1 = claim_element(nodes, "DIV", { style: true });
			var div1_nodes = children(div1);
			claim_component(loader1.$$.fragment, div1_nodes);
			div1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_style(div0, "width", "100%");
			add_location(div0, file$1l, 43, 16, 1478);
			set_style(div1, "width", "100%");
			add_location(div1, file$1l, 44, 16, 1544);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div0, anchor);
			mount_component(loader0, div0, null);
			insert_dev(target, t, anchor);
			insert_dev(target, div1, anchor);
			mount_component(loader1, div1, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(loader0.$$.fragment, local);
			transition_in(loader1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loader0.$$.fragment, local);
			transition_out(loader1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div0);
			destroy_component(loader0);
			if (detaching) detach_dev(t);
			if (detaching) detach_dev(div1);
			destroy_component(loader1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_2$2.name,
		type: "else",
		source: "(43:12) {:else}",
		ctx
	});

	return block;
}

// (41:12) {#if subtitle !== null}
function create_if_block_2$8(ctx) {
	let p;
	let t;

	const block = {
		c: function create() {
			p = element("p");
			t = text(/*subtitle*/ ctx[5]);
			this.h();
		},
		l: function claim(nodes) {
			p = claim_element(nodes, "P", { class: true, style: true });
			var p_nodes = children(p);
			t = claim_text(p_nodes, /*subtitle*/ ctx[5]);
			p_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(p, "class", "font-w-300 text-ellipsis-multiline");
			set_style(p, "--max-lines", "3");
			add_location(p, file$1l, 41, 16, 1356);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*subtitle*/ 32) set_data_dev(t, /*subtitle*/ ctx[5]);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$8.name,
		type: "if",
		source: "(41:12) {#if subtitle !== null}",
		ctx
	});

	return block;
}

// (52:20) {:else}
function create_else_block_1$5(ctx) {
	let div;
	let loader;
	let current;
	loader = new Loader({ props: { type: "h4" }, $$inline: true });

	const block = {
		c: function create() {
			div = element("div");
			create_component(loader.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { style: true });
			var div_nodes = children(div);
			claim_component(loader.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_style(div, "width", "60%");
			add_location(div, file$1l, 52, 24, 1872);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(loader, div, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(loader.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loader.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(loader);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1$5.name,
		type: "else",
		source: "(52:20) {:else}",
		ctx
	});

	return block;
}

// (50:20) {#if date !== null}
function create_if_block_1$j(ctx) {
	let span;
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(/*date*/ ctx[1]);
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true, style: true });
			var span_nodes = children(span);
			t = claim_text(span_nodes, /*date*/ ctx[1]);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "h4");
			set_style(span, "opacity", ".3");
			add_location(span, file$1l, 50, 24, 1767);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*date*/ 2) set_data_dev(t, /*date*/ ctx[1]);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$j.name,
		type: "if",
		source: "(50:20) {#if date !== null}",
		ctx
	});

	return block;
}

// (67:24) {:else}
function create_else_block$c(ctx) {
	let span1;
	let span0;
	let t0;
	let t1;
	let loader;
	let current;

	loader = new Loader({
			props: { type: "h4", absolute: true },
			$$inline: true
		});

	const block = {
		c: function create() {
			span1 = element("span");
			span0 = element("span");
			t0 = text("199");
			t1 = space();
			create_component(loader.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			span1 = claim_element(nodes, "SPAN", { class: true });
			var span1_nodes = children(span1);
			span0 = claim_element(span1_nodes, "SPAN", { style: true });
			var span0_nodes = children(span0);
			t0 = claim_text(span0_nodes, "199");
			span0_nodes.forEach(detach_dev);
			t1 = claim_space(span1_nodes);
			claim_component(loader.$$.fragment, span1_nodes);
			span1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_style(span0, "visibility", "hidden");
			add_location(span0, file$1l, 68, 32, 2653);
			attr_dev(span1, "class", "h4 relative");
			add_location(span1, file$1l, 67, 28, 2594);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span1, anchor);
			append_dev(span1, span0);
			append_dev(span0, t0);
			append_dev(span1, t1);
			mount_component(loader, span1, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(loader.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loader.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span1);
			destroy_component(loader);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$c.name,
		type: "else",
		source: "(67:24) {:else}",
		ctx
	});

	return block;
}

// (65:24) {#if likes !== null}
function create_if_block$s(ctx) {
	let h4;
	let t;

	const block = {
		c: function create() {
			h4 = element("h4");
			t = text(/*likes*/ ctx[3]);
			this.h();
		},
		l: function claim(nodes) {
			h4 = claim_element(nodes, "H4", {});
			var h4_nodes = children(h4);
			t = claim_text(h4_nodes, /*likes*/ ctx[3]);
			h4_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(h4, file$1l, 65, 28, 2515);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h4, anchor);
			append_dev(h4, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*likes*/ 8) set_data_dev(t, /*likes*/ ctx[3]);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(h4);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$s.name,
		type: "if",
		source: "(65:24) {#if likes !== null}",
		ctx
	});

	return block;
}

// (59:20) <Button size="medium" on:click={(e) => dispatch('onLike', !isLiked)}>
function create_default_slot_1$6(ctx) {
	let span;
	let icon;
	let span_style_value;
	let t0;
	let s0;
	let t1;
	let s1;
	let t2;
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;

	icon = new Icon({
			props: {
				type: "heart",
				is: "danger",
				size: "small"
			},
			$$inline: true
		});

	const if_block_creators = [create_if_block$s, create_else_block$c];
	const if_blocks = [];

	function select_block_type_3(ctx, dirty) {
		if (/*likes*/ ctx[3] !== null) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_3(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			span = element("span");
			create_component(icon.$$.fragment);
			t0 = space();
			s0 = element("s");
			t1 = space();
			s1 = element("s");
			t2 = space();
			if_block.c();
			if_block_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { style: true });
			var span_nodes = children(span);
			claim_component(icon.$$.fragment, span_nodes);
			span_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			s0 = claim_element(nodes, "S", {});
			children(s0).forEach(detach_dev);
			t1 = claim_space(nodes);
			s1 = claim_element(nodes, "S", {});
			children(s1).forEach(detach_dev);
			t2 = claim_space(nodes);
			if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "style", span_style_value = `opacity: ${/*isLiked*/ ctx[4] ? 1 : 0.5}`);
			add_location(span, file$1l, 59, 24, 2226);
			add_location(s0, file$1l, 62, 24, 2402);
			add_location(s1, file$1l, 63, 24, 2434);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			mount_component(icon, span, null);
			insert_dev(target, t0, anchor);
			insert_dev(target, s0, anchor);
			insert_dev(target, t1, anchor);
			insert_dev(target, s1, anchor);
			insert_dev(target, t2, anchor);
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (!current || dirty & /*isLiked*/ 16 && span_style_value !== (span_style_value = `opacity: ${/*isLiked*/ ctx[4] ? 1 : 0.5}`)) {
				attr_dev(span, "style", span_style_value);
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_3(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			destroy_component(icon);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(s0);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(s1);
			if (detaching) detach_dev(t2);
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$6.name,
		type: "slot",
		source: "(59:20) <Button size=\\\"medium\\\" on:click={(e) => dispatch('onLike', !isLiked)}>",
		ctx
	});

	return block;
}

// (23:0) <Card class={classProp}>
function create_default_slot$N(ctx) {
	let section;
	let div0;
	let picture;
	let t0;
	let div2;
	let current_block_type_index;
	let if_block0;
	let t1;
	let br;
	let t2;
	let current_block_type_index_1;
	let if_block1;
	let t3;
	let div1;
	let p;
	let current_block_type_index_2;
	let if_block2;
	let t4;
	let s0;
	let t5;
	let s1;
	let t6;
	let span;
	let button;
	let current;

	picture = new Picture({
			props: {
				src: /*src*/ ctx[0],
				alt: /*title*/ ctx[2]
			},
			$$inline: true
		});

	const if_block_creators = [create_if_block_3$5, create_else_block_3$1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*title*/ ctx[2] !== null) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	br = new Br({ props: { size: "10" }, $$inline: true });
	const if_block_creators_1 = [create_if_block_2$8, create_else_block_2$2];
	const if_blocks_1 = [];

	function select_block_type_1(ctx, dirty) {
		if (/*subtitle*/ ctx[5] !== null) return 0;
		return 1;
	}

	current_block_type_index_1 = select_block_type_1(ctx);
	if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
	const if_block_creators_2 = [create_if_block_1$j, create_else_block_1$5];
	const if_blocks_2 = [];

	function select_block_type_2(ctx, dirty) {
		if (/*date*/ ctx[1] !== null) return 0;
		return 1;
	}

	current_block_type_index_2 = select_block_type_2(ctx);
	if_block2 = if_blocks_2[current_block_type_index_2] = if_block_creators_2[current_block_type_index_2](ctx);

	button = new Button({
			props: {
				size: "medium",
				$$slots: { default: [create_default_slot_1$6] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button.$on("click", /*click_handler*/ ctx[8]);

	const block = {
		c: function create() {
			section = element("section");
			div0 = element("div");
			create_component(picture.$$.fragment);
			t0 = space();
			div2 = element("div");
			if_block0.c();
			t1 = space();
			create_component(br.$$.fragment);
			t2 = space();
			if_block1.c();
			t3 = space();
			div1 = element("div");
			p = element("p");
			if_block2.c();
			t4 = space();
			s0 = element("s");
			t5 = space();
			s1 = element("s");
			t6 = space();
			span = element("span");
			create_component(button.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { class: true });
			var section_nodes = children(section);
			div0 = claim_element(section_nodes, "DIV", { class: true, style: true });
			var div0_nodes = children(div0);
			claim_component(picture.$$.fragment, div0_nodes);
			div0_nodes.forEach(detach_dev);
			t0 = claim_space(section_nodes);
			div2 = claim_element(section_nodes, "DIV", { class: true, style: true });
			var div2_nodes = children(div2);
			if_block0.l(div2_nodes);
			t1 = claim_space(div2_nodes);
			claim_component(br.$$.fragment, div2_nodes);
			t2 = claim_space(div2_nodes);
			if_block1.l(div2_nodes);
			t3 = claim_space(div2_nodes);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			p = claim_element(div1_nodes, "P", {});
			var p_nodes = children(p);
			if_block2.l(p_nodes);
			p_nodes.forEach(detach_dev);
			t4 = claim_space(div1_nodes);
			s0 = claim_element(div1_nodes, "S", {});
			children(s0).forEach(detach_dev);
			t5 = claim_space(div1_nodes);
			s1 = claim_element(div1_nodes, "S", {});
			children(s1).forEach(detach_dev);
			t6 = claim_space(div1_nodes);
			span = claim_element(div1_nodes, "SPAN", { class: true, style: true });
			var span_nodes = children(span);
			claim_component(button.$$.fragment, span_nodes);
			span_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "flex flex-none relative");
			set_style(div0, "width", "110px");
			add_location(div0, file$1l, 25, 8, 730);
			add_location(p, file$1l, 48, 16, 1699);
			add_location(s0, file$1l, 55, 16, 1985);
			add_location(s1, file$1l, 56, 16, 2009);
			attr_dev(span, "class", "h5 flex flex-align-center font-secondary");
			set_style(span, "min-width", "4em");
			add_location(span, file$1l, 57, 16, 2033);
			attr_dev(div1, "class", "flex flex-align-center flex-justify-between");
			add_location(div1, file$1l, 47, 12, 1625);
			attr_dev(div2, "class", "flex flex-column flex-1 container overflow-hidden");
			set_style(div2, "padding-top", "20px");
			set_style(div2, "padding-bottom", "5px");
			add_location(div2, file$1l, 29, 8, 858);
			attr_dev(section, "class", "news-item flex");
			add_location(section, file$1l, 23, 4, 688);
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			append_dev(section, div0);
			mount_component(picture, div0, null);
			append_dev(section, t0);
			append_dev(section, div2);
			if_blocks[current_block_type_index].m(div2, null);
			append_dev(div2, t1);
			mount_component(br, div2, null);
			append_dev(div2, t2);
			if_blocks_1[current_block_type_index_1].m(div2, null);
			append_dev(div2, t3);
			append_dev(div2, div1);
			append_dev(div1, p);
			if_blocks_2[current_block_type_index_2].m(p, null);
			append_dev(div1, t4);
			append_dev(div1, s0);
			append_dev(div1, t5);
			append_dev(div1, s1);
			append_dev(div1, t6);
			append_dev(div1, span);
			mount_component(button, span, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const picture_changes = {};
			if (dirty & /*src*/ 1) picture_changes.src = /*src*/ ctx[0];
			if (dirty & /*title*/ 4) picture_changes.alt = /*title*/ ctx[2];
			picture.$set(picture_changes);
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block0 = if_blocks[current_block_type_index];

				if (!if_block0) {
					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block0.c();
				}

				transition_in(if_block0, 1);
				if_block0.m(div2, t1);
			}

			let previous_block_index_1 = current_block_type_index_1;
			current_block_type_index_1 = select_block_type_1(ctx);

			if (current_block_type_index_1 === previous_block_index_1) {
				if_blocks_1[current_block_type_index_1].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
					if_blocks_1[previous_block_index_1] = null;
				});

				check_outros();
				if_block1 = if_blocks_1[current_block_type_index_1];

				if (!if_block1) {
					if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
					if_block1.c();
				}

				transition_in(if_block1, 1);
				if_block1.m(div2, t3);
			}

			let previous_block_index_2 = current_block_type_index_2;
			current_block_type_index_2 = select_block_type_2(ctx);

			if (current_block_type_index_2 === previous_block_index_2) {
				if_blocks_2[current_block_type_index_2].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks_2[previous_block_index_2], 1, 1, () => {
					if_blocks_2[previous_block_index_2] = null;
				});

				check_outros();
				if_block2 = if_blocks_2[current_block_type_index_2];

				if (!if_block2) {
					if_block2 = if_blocks_2[current_block_type_index_2] = if_block_creators_2[current_block_type_index_2](ctx);
					if_block2.c();
				}

				transition_in(if_block2, 1);
				if_block2.m(p, null);
			}

			const button_changes = {};

			if (dirty & /*$$scope, likes, isLiked*/ 1048) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(picture.$$.fragment, local);
			transition_in(if_block0);
			transition_in(br.$$.fragment, local);
			transition_in(if_block1);
			transition_in(if_block2);
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(picture.$$.fragment, local);
			transition_out(if_block0);
			transition_out(br.$$.fragment, local);
			transition_out(if_block1);
			transition_out(if_block2);
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			destroy_component(picture);
			if_blocks[current_block_type_index].d();
			destroy_component(br);
			if_blocks_1[current_block_type_index_1].d();
			if_blocks_2[current_block_type_index_2].d();
			destroy_component(button);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$N.name,
		type: "slot",
		source: "(23:0) <Card class={classProp}>",
		ctx
	});

	return block;
}

function create_fragment$1m(ctx) {
	let card;
	let current;

	card = new Card({
			props: {
				class: /*classProp*/ ctx[6],
				$$slots: { default: [create_default_slot$N] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(card.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(card.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(card, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const card_changes = {};
			if (dirty & /*classProp*/ 64) card_changes.class = /*classProp*/ ctx[6];

			if (dirty & /*$$scope, isLiked, likes, date, subtitle, title, src*/ 1087) {
				card_changes.$$scope = { dirty, ctx };
			}

			card.$set(card_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(card.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(card.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(card, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1m.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1m($$self, $$props, $$invalidate) {
	const dispatch = createEventDispatcher();
	let { src = null } = $$props;
	let { date = null } = $$props;
	let { title = null } = $$props;
	let { likes = null } = $$props;
	let { isLiked = null } = $$props;
	let { subtitle = null } = $$props;
	let { $$slots = {}, $$scope } = $$props;
	validate_slots("NewsItem", $$slots, []);
	const click_handler = e => dispatch("onLike", !isLiked);

	$$self.$set = $$new_props => {
		$$invalidate(9, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("src" in $$new_props) $$invalidate(0, src = $$new_props.src);
		if ("date" in $$new_props) $$invalidate(1, date = $$new_props.date);
		if ("title" in $$new_props) $$invalidate(2, title = $$new_props.title);
		if ("likes" in $$new_props) $$invalidate(3, likes = $$new_props.likes);
		if ("isLiked" in $$new_props) $$invalidate(4, isLiked = $$new_props.isLiked);
		if ("subtitle" in $$new_props) $$invalidate(5, subtitle = $$new_props.subtitle);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		classnames,
		Br,
		Icon,
		Card,
		Button,
		Picture,
		Loader,
		dispatch,
		src,
		date,
		title,
		likes,
		isLiked,
		subtitle,
		classProp
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(9, $$props = assign(assign({}, $$props), $$new_props));
		if ("src" in $$props) $$invalidate(0, src = $$new_props.src);
		if ("date" in $$props) $$invalidate(1, date = $$new_props.date);
		if ("title" in $$props) $$invalidate(2, title = $$new_props.title);
		if ("likes" in $$props) $$invalidate(3, likes = $$new_props.likes);
		if ("isLiked" in $$props) $$invalidate(4, isLiked = $$new_props.isLiked);
		if ("subtitle" in $$props) $$invalidate(5, subtitle = $$new_props.subtitle);
		if ("classProp" in $$props) $$invalidate(6, classProp = $$new_props.classProp);
	};

	let classProp;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(6, classProp = classnames($$props.class));
	};

	$$props = exclude_internal_props($$props);
	return [src, date, title, likes, isLiked, subtitle, classProp, dispatch, click_handler];
}

class NewsItem extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1m, create_fragment$1m, safe_not_equal, {
			src: 0,
			date: 1,
			title: 2,
			likes: 3,
			isLiked: 4,
			subtitle: 5
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "NewsItem",
			options,
			id: create_fragment$1m.name
		});
	}

	get src() {
		throw new Error("<NewsItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set src(value) {
		throw new Error("<NewsItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get date() {
		throw new Error("<NewsItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set date(value) {
		throw new Error("<NewsItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get title() {
		throw new Error("<NewsItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<NewsItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get likes() {
		throw new Error("<NewsItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set likes(value) {
		throw new Error("<NewsItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isLiked() {
		throw new Error("<NewsItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isLiked(value) {
		throw new Error("<NewsItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get subtitle() {
		throw new Error("<NewsItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set subtitle(value) {
		throw new Error("<NewsItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/newsList/NewsList.svelte generated by Svelte v3.24.0 */
const file$1m = "src/components/newsList/NewsList.svelte";

function add_css$D() {
	var style = element("style");
	style.id = "svelte-11jv2m5-style";
	style.textContent = ".news-list.svelte-11jv2m5.svelte-11jv2m5{width:100%;-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;display:-webkit-box;display:-ms-flexbox;display:flex;overflow-y:auto;overflow-x:hidden;-ms-flex-item-align:stretch;align-self:stretch;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column}.news-list-wrap.svelte-11jv2m5.svelte-11jv2m5{width:100%;margin:-5px 0}.news-list-wrap.svelte-11jv2m5 li.svelte-11jv2m5{position:relative;width:100%;padding:5px 0}.arrow.svelte-11jv2m5.svelte-11jv2m5{position:absolute;top:8px;right:15px;color:rgba(var(--color-info))}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTmV3c0xpc3Quc3ZlbHRlIiwic291cmNlcyI6WyJOZXdzTGlzdC5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBjcmVhdGVFdmVudERpc3BhdGNoZXIgfSBmcm9tICdzdmVsdGUnXG4gICAgaW1wb3J0IHsgb25Nb3VudCB9IGZyb20gJ3N2ZWx0ZSdcbiAgICBpbXBvcnQgeyBBUEksIERhdGVzIH0gZnJvbSAnQHNlcnZpY2VzJ1xuICAgIFxuICAgIGltcG9ydCBCciBmcm9tICdAY29tcG9uZW50cy9Cci5zdmVsdGUnXG4gICAgaW1wb3J0IEljb24gZnJvbSAnQGNvbXBvbmVudHMvSWNvbi5zdmVsdGUnXG4gICAgaW1wb3J0IEJ1dHRvbiBmcm9tICdAY29tcG9uZW50cy9CdXR0b24uc3ZlbHRlJ1xuICAgIGltcG9ydCBOZXdzSXRlbSBmcm9tICcuL05ld3NJdGVtLnN2ZWx0ZSdcblxuICAgIGNvbnN0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKClcbiAgIFxuICAgLyoqXG4gICAgKiBAdHlwZSB7e1xuICAgICogICBpZDogc3RyaW5nLFxuICAgICogICBzcmM6IHN0cmluZyxcbiAgICAqICAgbGlrZXM6IG51bWJlcixcbiAgICAqICAgdGl0bGU6IHN0cmluZyxcbiAgICAqICAgc3VidGl0bGU6IHN0cmluZyxcbiAgICAqICAgY3JlYXRlZF9hdDogc3RyaW5nLFxuICAgICogfX1cbiAgICAqL1xuICAgIGV4cG9ydCBsZXQgaXRlbXMgPSBuZXcgQXJyYXkoMykuZmlsbCh7IHRpdGxlOiBudWxsLCBzdWJ0aXRsZTogbnVsbCwgY3JlYXRlZF9hdDogbnVsbCwgbGlrZXM6IG51bGwgfSlcbjwvc2NyaXB0PlxuXG48c2VjdGlvbiBjbGFzcz1cIm5ld3MtbGlzdFwiPlxuICAgIDx1bCBjbGFzcz1cIm5ld3MtbGlzdC13cmFwXCI+XG4gICAgICAgIHsjZWFjaCBpdGVtcyBhcyBpdGVtLCBpbmRleH1cbiAgICAgICAgICAgIDxsaSByb2xlPVwiYnV0dG9uXCIgb246Y2xpY2s9eygpID0+IGRpc3BhdGNoKCdjbGljaycsIHsgaXRlbSwgaW5kZXggfSl9IGtleT17aXRlbS5pZH0+XG4gICAgICAgICAgICAgICAgPE5ld3NJdGVtXG4gICAgICAgICAgICAgICAgICAgICAgICBzcmM9e2l0ZW0uc3JjfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU9e2l0ZW0udGl0bGV9XG4gICAgICAgICAgICAgICAgICAgICAgICBsaWtlcz17aXRlbS5saWtlc31cbiAgICAgICAgICAgICAgICAgICAgICAgIGlzTGlrZWQ9e2l0ZW0uaXNMaWtlZH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnRpdGxlPXtpdGVtLnN1YnRpdGxlfVxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZT17aXRlbS5jcmVhdGVkX2F0ID09PSBudWxsID8gbnVsbCA6IERhdGVzKGl0ZW0uY3JlYXRlZF9hdCkuZnJvbU5vdygpfVxuICAgICAgICAgICAgICAgIC8+XG5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImFycm93XCI+XG4gICAgICAgICAgICAgICAgICAgIDxJY29uIHR5cGU9XCJhcnJvdy1yaWdodFwiIHNpemU9XCJzbWFsbFwiIGlzPVwiaW5mb1wiLz5cbiAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICA8L2xpPlxuICAgICAgICB7L2VhY2h9XG4gICAgPC91bD5cblxuICAgIDxCciBzaXplPVwiMjBcIi8+ICBcblxuICAgIDxwIGNsYXNzPVwiaDMgZm9udC13LTUwMCBmb250LXNlY29uZGFyeSB1bmRlcmxpbmUgdGV4dC1jZW50ZXJcIj5cbiAgICAgICAgPHNwYW4+0JLRgdGWINC90L7QstC40L3QuDwvc3Bhbj5cbiAgICAgICAgPEljb24gdHlwZT1cImNhcmV0LWRvd25cIiBzaXplPVwic21hbGxcIi8+XG4gICAgPC9wPlxuPC9zZWN0aW9uPlxuXG48c3R5bGU+XG4ubmV3cy1saXN0IHtcbiAgICB3aWR0aDogMTAwJTtcbiAgICAtd2Via2l0LWJveC1mbGV4OiAxO1xuICAgICAgICAtbXMtZmxleC1wb3NpdGl2ZTogMTtcbiAgICAgICAgICAgIGZsZXgtZ3JvdzogMTtcbiAgICBkaXNwbGF5OiAtd2Via2l0LWJveDtcbiAgICBkaXNwbGF5OiAtbXMtZmxleGJveDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIG92ZXJmbG93LXk6IGF1dG87XG4gICAgb3ZlcmZsb3cteDogaGlkZGVuO1xuICAgIC1tcy1mbGV4LWl0ZW0tYWxpZ246IHN0cmV0Y2g7XG4gICAgICAgIGFsaWduLXNlbGY6IHN0cmV0Y2g7XG4gICAgLXdlYmtpdC1ib3gtb3JpZW50OiB2ZXJ0aWNhbDtcbiAgICAtd2Via2l0LWJveC1kaXJlY3Rpb246IG5vcm1hbDtcbiAgICAgICAgLW1zLWZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xufVxuXG4ubmV3cy1saXN0LXdyYXAge1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIG1hcmdpbjogLTVweCAwO1xufVxuXG4ubmV3cy1saXN0LXdyYXAgbGkge1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBwYWRkaW5nOiA1cHggMDtcbn1cblxuLmFycm93IHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgdG9wOiA4cHg7XG4gICAgcmlnaHQ6IDE1cHg7XG4gICAgY29sb3I6IHJnYmEodmFyKC0tY29sb3ItaW5mbykpO1xufTwvc3R5bGU+XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBc0RBLFVBQVUsOEJBQUMsQ0FBQyxBQUNSLEtBQUssQ0FBRSxJQUFJLENBQ1gsZ0JBQWdCLENBQUUsQ0FBQyxDQUNmLGlCQUFpQixDQUFFLENBQUMsQ0FDaEIsU0FBUyxDQUFFLENBQUMsQ0FDcEIsT0FBTyxDQUFFLFdBQVcsQ0FDcEIsT0FBTyxDQUFFLFdBQVcsQ0FDcEIsT0FBTyxDQUFFLElBQUksQ0FDYixVQUFVLENBQUUsSUFBSSxDQUNoQixVQUFVLENBQUUsTUFBTSxDQUNsQixtQkFBbUIsQ0FBRSxPQUFPLENBQ3hCLFVBQVUsQ0FBRSxPQUFPLENBQ3ZCLGtCQUFrQixDQUFFLFFBQVEsQ0FDNUIscUJBQXFCLENBQUUsTUFBTSxDQUN6QixrQkFBa0IsQ0FBRSxNQUFNLENBQ3RCLGNBQWMsQ0FBRSxNQUFNLEFBQ2xDLENBQUMsQUFFRCxlQUFlLDhCQUFDLENBQUMsQUFDYixLQUFLLENBQUUsSUFBSSxDQUNYLE1BQU0sQ0FBRSxJQUFJLENBQUMsQ0FBQyxBQUNsQixDQUFDLEFBRUQsOEJBQWUsQ0FBQyxFQUFFLGVBQUMsQ0FBQyxBQUNoQixRQUFRLENBQUUsUUFBUSxDQUNsQixLQUFLLENBQUUsSUFBSSxDQUNYLE9BQU8sQ0FBRSxHQUFHLENBQUMsQ0FBQyxBQUNsQixDQUFDLEFBRUQsTUFBTSw4QkFBQyxDQUFDLEFBQ0osUUFBUSxDQUFFLFFBQVEsQ0FDbEIsR0FBRyxDQUFFLEdBQUcsQ0FDUixLQUFLLENBQUUsSUFBSSxDQUNYLEtBQUssQ0FBRSxLQUFLLElBQUksWUFBWSxDQUFDLENBQUMsQUFDbEMsQ0FBQyJ9 */";
	append_dev(document.head, style);
}

function get_each_context$f(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[3] = list[i];
	child_ctx[5] = i;
	return child_ctx;
}

// (28:8) {#each items as item, index}
function create_each_block$f(ctx) {
	let li;
	let newsitem;
	let t0;
	let span;
	let icon;
	let t1;
	let li_key_value;
	let current;
	let mounted;
	let dispose;

	newsitem = new NewsItem({
			props: {
				src: /*item*/ ctx[3].src,
				title: /*item*/ ctx[3].title,
				likes: /*item*/ ctx[3].likes,
				isLiked: /*item*/ ctx[3].isLiked,
				subtitle: /*item*/ ctx[3].subtitle,
				date: /*item*/ ctx[3].created_at === null
				? null
				: dayjs_min(/*item*/ ctx[3].created_at).fromNow()
			},
			$$inline: true
		});

	icon = new Icon({
			props: {
				type: "arrow-right",
				size: "small",
				is: "info"
			},
			$$inline: true
		});

	function click_handler(...args) {
		return /*click_handler*/ ctx[2](/*item*/ ctx[3], /*index*/ ctx[5], ...args);
	}

	const block = {
		c: function create() {
			li = element("li");
			create_component(newsitem.$$.fragment);
			t0 = space();
			span = element("span");
			create_component(icon.$$.fragment);
			t1 = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { role: true, key: true, class: true });
			var li_nodes = children(li);
			claim_component(newsitem.$$.fragment, li_nodes);
			t0 = claim_space(li_nodes);
			span = claim_element(li_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			claim_component(icon.$$.fragment, span_nodes);
			span_nodes.forEach(detach_dev);
			t1 = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "arrow svelte-11jv2m5");
			add_location(span, file$1m, 38, 16, 1251);
			attr_dev(li, "role", "button");
			attr_dev(li, "key", li_key_value = /*item*/ ctx[3].id);
			attr_dev(li, "class", "svelte-11jv2m5");
			add_location(li, file$1m, 28, 12, 785);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			mount_component(newsitem, li, null);
			append_dev(li, t0);
			append_dev(li, span);
			mount_component(icon, span, null);
			append_dev(li, t1);
			current = true;

			if (!mounted) {
				dispose = listen_dev(li, "click", click_handler, false, false, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const newsitem_changes = {};
			if (dirty & /*items*/ 1) newsitem_changes.src = /*item*/ ctx[3].src;
			if (dirty & /*items*/ 1) newsitem_changes.title = /*item*/ ctx[3].title;
			if (dirty & /*items*/ 1) newsitem_changes.likes = /*item*/ ctx[3].likes;
			if (dirty & /*items*/ 1) newsitem_changes.isLiked = /*item*/ ctx[3].isLiked;
			if (dirty & /*items*/ 1) newsitem_changes.subtitle = /*item*/ ctx[3].subtitle;

			if (dirty & /*items*/ 1) newsitem_changes.date = /*item*/ ctx[3].created_at === null
			? null
			: dayjs_min(/*item*/ ctx[3].created_at).fromNow();

			newsitem.$set(newsitem_changes);

			if (!current || dirty & /*items*/ 1 && li_key_value !== (li_key_value = /*item*/ ctx[3].id)) {
				attr_dev(li, "key", li_key_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(newsitem.$$.fragment, local);
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(newsitem.$$.fragment, local);
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			destroy_component(newsitem);
			destroy_component(icon);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$f.name,
		type: "each",
		source: "(28:8) {#each items as item, index}",
		ctx
	});

	return block;
}

function create_fragment$1n(ctx) {
	let section;
	let ul;
	let t0;
	let br;
	let t1;
	let p;
	let span;
	let t2;
	let t3;
	let icon;
	let current;
	let each_value = /*items*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$f(get_each_context$f(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	br = new Br({ props: { size: "20" }, $$inline: true });

	icon = new Icon({
			props: { type: "caret-down", size: "small" },
			$$inline: true
		});

	const block = {
		c: function create() {
			section = element("section");
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t0 = space();
			create_component(br.$$.fragment);
			t1 = space();
			p = element("p");
			span = element("span");
			t2 = text("Всі новини");
			t3 = space();
			create_component(icon.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { class: true });
			var section_nodes = children(section);
			ul = claim_element(section_nodes, "UL", { class: true });
			var ul_nodes = children(ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(ul_nodes);
			}

			ul_nodes.forEach(detach_dev);
			t0 = claim_space(section_nodes);
			claim_component(br.$$.fragment, section_nodes);
			t1 = claim_space(section_nodes);
			p = claim_element(section_nodes, "P", { class: true });
			var p_nodes = children(p);
			span = claim_element(p_nodes, "SPAN", {});
			var span_nodes = children(span);
			t2 = claim_text(span_nodes, "Всі новини");
			span_nodes.forEach(detach_dev);
			t3 = claim_space(p_nodes);
			claim_component(icon.$$.fragment, p_nodes);
			p_nodes.forEach(detach_dev);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(ul, "class", "news-list-wrap svelte-11jv2m5");
			add_location(ul, file$1m, 26, 4, 708);
			add_location(span, file$1m, 48, 8, 1509);
			attr_dev(p, "class", "h3 font-w-500 font-secondary underline text-center");
			add_location(p, file$1m, 47, 4, 1438);
			attr_dev(section, "class", "news-list svelte-11jv2m5");
			add_location(section, file$1m, 25, 0, 676);
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			append_dev(section, ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}

			append_dev(section, t0);
			mount_component(br, section, null);
			append_dev(section, t1);
			append_dev(section, p);
			append_dev(p, span);
			append_dev(span, t2);
			append_dev(p, t3);
			mount_component(icon, p, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*items, dispatch, Dates*/ 3) {
				each_value = /*items*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$f(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$f(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(ul, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			transition_in(br.$$.fragment, local);
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			transition_out(br.$$.fragment, local);
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			destroy_each(each_blocks, detaching);
			destroy_component(br);
			destroy_component(icon);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1n.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1n($$self, $$props, $$invalidate) {
	const dispatch = createEventDispatcher();

	let { items = new Array(3).fill({
		title: null,
		subtitle: null,
		created_at: null,
		likes: null
	}) } = $$props;

	const writable_props = ["items"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<NewsList> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("NewsList", $$slots, []);
	const click_handler = (item, index) => dispatch("click", { item, index });

	$$self.$set = $$props => {
		if ("items" in $$props) $$invalidate(0, items = $$props.items);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		onMount,
		API,
		Dates: dayjs_min,
		Br,
		Icon,
		Button,
		NewsItem,
		dispatch,
		items
	});

	$$self.$inject_state = $$props => {
		if ("items" in $$props) $$invalidate(0, items = $$props.items);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [items, dispatch, click_handler];
}

class NewsList extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document.getElementById("svelte-11jv2m5-style")) add_css$D();
		init(this, options, instance$1n, create_fragment$1n, safe_not_equal, { items: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "NewsList",
			options,
			id: create_fragment$1n.name
		});
	}

	get items() {
		throw new Error("<NewsList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set items(value) {
		throw new Error("<NewsList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/fundCards/FundCard.svelte generated by Svelte v3.24.0 */
const file$1n = "src/components/fundCards/FundCard.svelte";
const get_button_slot_changes = dirty => ({});
const get_button_slot_context = ctx => ({});

// (39:12) {:else}
function create_else_block_2$3(ctx) {
	let loader0;
	let t;
	let loader1;
	let current;
	loader0 = new Loader({ props: { type: "h2" }, $$inline: true });
	loader1 = new Loader({ props: { type: "h2" }, $$inline: true });

	const block = {
		c: function create() {
			create_component(loader0.$$.fragment);
			t = space();
			create_component(loader1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(loader0.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(loader1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(loader0, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(loader1, target, anchor);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(loader0.$$.fragment, local);
			transition_in(loader1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loader0.$$.fragment, local);
			transition_out(loader1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(loader0, detaching);
			if (detaching) detach_dev(t);
			destroy_component(loader1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_2$3.name,
		type: "else",
		source: "(39:12) {:else}",
		ctx
	});

	return block;
}

// (35:12) {#if title !== null}
function create_if_block_2$9(ctx) {
	let h2;
	let t;

	const block = {
		c: function create() {
			h2 = element("h2");
			t = text(/*title*/ ctx[2]);
			this.h();
		},
		l: function claim(nodes) {
			h2 = claim_element(nodes, "H2", { class: true, style: true });
			var h2_nodes = children(h2);
			t = claim_text(h2_nodes, /*title*/ ctx[2]);
			h2_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(h2, "class", "text-ellipsis-multiline");
			set_style(h2, "--max-lines", "2");
			add_location(h2, file$1n, 35, 16, 1242);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h2, anchor);
			append_dev(h2, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*title*/ 4) set_data_dev(t, /*title*/ ctx[2]);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(h2);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$9.name,
		type: "if",
		source: "(35:12) {#if title !== null}",
		ctx
	});

	return block;
}

// (53:12) {:else}
function create_else_block_1$6(ctx) {
	let div;
	let loader;
	let current;
	loader = new Loader({ props: { type: "p" }, $$inline: true });

	const block = {
		c: function create() {
			div = element("div");
			create_component(loader.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { style: true });
			var div_nodes = children(div);
			claim_component(loader.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_style(div, "width", "40%");
			add_location(div, file$1n, 53, 16, 1865);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(loader, div, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(loader.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loader.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(loader);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1$6.name,
		type: "else",
		source: "(53:12) {:else}",
		ctx
	});

	return block;
}

// (46:12) {#if city !== null}
function create_if_block_1$k(ctx) {
	let p;
	let icon;
	let t0;
	let s;
	let t1;
	let span;
	let t2;
	let t3;
	let br;
	let current;

	icon = new Icon({
			props: { type: "location", size: "small" },
			$$inline: true
		});

	br = new Br({ props: { size: "10" }, $$inline: true });

	const block = {
		c: function create() {
			p = element("p");
			create_component(icon.$$.fragment);
			t0 = space();
			s = element("s");
			t1 = space();
			span = element("span");
			t2 = text(/*city*/ ctx[1]);
			t3 = space();
			create_component(br.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			p = claim_element(nodes, "P", { class: true, style: true });
			var p_nodes = children(p);
			claim_component(icon.$$.fragment, p_nodes);
			t0 = claim_space(p_nodes);
			s = claim_element(p_nodes, "S", {});
			children(s).forEach(detach_dev);
			t1 = claim_space(p_nodes);
			span = claim_element(p_nodes, "SPAN", {});
			var span_nodes = children(span);
			t2 = claim_text(span_nodes, /*city*/ ctx[1]);
			span_nodes.forEach(detach_dev);
			p_nodes.forEach(detach_dev);
			t3 = claim_space(nodes);
			claim_component(br.$$.fragment, nodes);
			this.h();
		},
		h: function hydrate() {
			add_location(s, file$1n, 48, 20, 1723);
			add_location(span, file$1n, 49, 20, 1751);
			attr_dev(p, "class", "flex flex-align-center font-secondary font-w-500");
			set_style(p, "opacity", ".7");
			set_style(p, "margin-left", "-2px");
			add_location(p, file$1n, 46, 16, 1546);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			mount_component(icon, p, null);
			append_dev(p, t0);
			append_dev(p, s);
			append_dev(p, t1);
			append_dev(p, span);
			append_dev(span, t2);
			insert_dev(target, t3, anchor);
			mount_component(br, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (!current || dirty & /*city*/ 2) set_data_dev(t2, /*city*/ ctx[1]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			transition_in(br.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			transition_out(br.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
			destroy_component(icon);
			if (detaching) detach_dev(t3);
			destroy_component(br, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$k.name,
		type: "if",
		source: "(46:12) {#if city !== null}",
		ctx
	});

	return block;
}

// (64:16) {:else}
function create_else_block$d(ctx) {
	let div;
	let loader;
	let current;
	loader = new Loader({ props: { type: "h1" }, $$inline: true });

	const block = {
		c: function create() {
			div = element("div");
			create_component(loader.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { style: true });
			var div_nodes = children(div);
			claim_component(loader.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_style(div, "width", "80%");
			set_style(div, "flex", "none");
			add_location(div, file$1n, 64, 20, 2333);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(loader, div, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(loader.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loader.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(loader);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$d.name,
		type: "else",
		source: "(64:16) {:else}",
		ctx
	});

	return block;
}

// (60:16) {#if current !== null && total !== null}
function create_if_block$t(ctx) {
	let span0;
	let t0;
	let t1;
	let t2;
	let t3;
	let s;
	let t4;
	let span1;
	let t5;
	let t6;
	let t7;
	let t8;

	const block = {
		c: function create() {
			span0 = element("span");
			t0 = text(/*currency*/ ctx[5]);
			t1 = space();
			t2 = text(/*current*/ ctx[4]);
			t3 = space();
			s = element("s");
			t4 = space();
			span1 = element("span");
			t5 = text("/ ");
			t6 = text(/*currency*/ ctx[5]);
			t7 = space();
			t8 = text(/*total*/ ctx[3]);
			this.h();
		},
		l: function claim(nodes) {
			span0 = claim_element(nodes, "SPAN", { class: true });
			var span0_nodes = children(span0);
			t0 = claim_text(span0_nodes, /*currency*/ ctx[5]);
			t1 = claim_space(span0_nodes);
			t2 = claim_text(span0_nodes, /*current*/ ctx[4]);
			span0_nodes.forEach(detach_dev);
			t3 = claim_space(nodes);
			s = claim_element(nodes, "S", {});
			children(s).forEach(detach_dev);
			t4 = claim_space(nodes);
			span1 = claim_element(nodes, "SPAN", { class: true });
			var span1_nodes = children(span1);
			t5 = claim_text(span1_nodes, "/ ");
			t6 = claim_text(span1_nodes, /*currency*/ ctx[5]);
			t7 = claim_space(span1_nodes);
			t8 = claim_text(span1_nodes, /*total*/ ctx[3]);
			span1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span0, "class", "h1 font-w-500");
			add_location(span0, file$1n, 60, 20, 2140);
			add_location(s, file$1n, 61, 20, 2216);
			attr_dev(span1, "class", "h4");
			add_location(span1, file$1n, 62, 20, 2244);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span0, anchor);
			append_dev(span0, t0);
			append_dev(span0, t1);
			append_dev(span0, t2);
			insert_dev(target, t3, anchor);
			insert_dev(target, s, anchor);
			insert_dev(target, t4, anchor);
			insert_dev(target, span1, anchor);
			append_dev(span1, t5);
			append_dev(span1, t6);
			append_dev(span1, t7);
			append_dev(span1, t8);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*currency*/ 32) set_data_dev(t0, /*currency*/ ctx[5]);
			if (dirty & /*current*/ 16) set_data_dev(t2, /*current*/ ctx[4]);
			if (dirty & /*currency*/ 32) set_data_dev(t6, /*currency*/ ctx[5]);
			if (dirty & /*total*/ 8) set_data_dev(t8, /*total*/ ctx[3]);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(span0);
			if (detaching) detach_dev(t3);
			if (detaching) detach_dev(s);
			if (detaching) detach_dev(t4);
			if (detaching) detach_dev(span1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$t.name,
		type: "if",
		source: "(60:16) {#if current !== null && total !== null}",
		ctx
	});

	return block;
}

// (19:0) <Card class="flex flex-column">
function create_default_slot$O(ctx) {
	let div0;
	let carousel;
	let t0;
	let section;
	let div1;
	let br0;
	let t1;
	let current_block_type_index;
	let if_block0;
	let t2;
	let br1;
	let t3;
	let current_block_type_index_1;
	let if_block1;
	let t4;
	let div2;
	let p;
	let current_block_type_index_2;
	let if_block2;
	let t5;
	let br2;
	let t6;
	let progress;
	let t7;
	let br3;
	let t8;
	let t9;
	let br4;
	let current;

	carousel = new Carousel({
			props: {
				items: [
					{
						src: /*src*/ ctx[0],
						alt: /*title*/ ctx[2]
					},
					{
						src: /*src*/ ctx[0],
						alt: /*title*/ ctx[2]
					},
					{
						src: /*src*/ ctx[0],
						alt: /*title*/ ctx[2]
					}
				],
				disableFancy: true,
				dotsBelow: false,
				rounded: false,
				stopPropagation: true
			},
			$$inline: true
		});

	br0 = new Br({ props: { size: "20" }, $$inline: true });
	const if_block_creators = [create_if_block_2$9, create_else_block_2$3];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*title*/ ctx[2] !== null) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	br1 = new Br({ props: { size: "5" }, $$inline: true });
	const if_block_creators_1 = [create_if_block_1$k, create_else_block_1$6];
	const if_blocks_1 = [];

	function select_block_type_1(ctx, dirty) {
		if (/*city*/ ctx[1] !== null) return 0;
		return 1;
	}

	current_block_type_index_1 = select_block_type_1(ctx);
	if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
	const if_block_creators_2 = [create_if_block$t, create_else_block$d];
	const if_blocks_2 = [];

	function select_block_type_2(ctx, dirty) {
		if (/*current*/ ctx[4] !== null && /*total*/ ctx[3] !== null) return 0;
		return 1;
	}

	current_block_type_index_2 = select_block_type_2(ctx);
	if_block2 = if_blocks_2[current_block_type_index_2] = if_block_creators_2[current_block_type_index_2](ctx);
	br2 = new Br({ props: { size: "20" }, $$inline: true });

	progress = new Progress({
			props: {
				value: Math.floor(/*current*/ ctx[4] / /*total*/ ctx[3] * 100)
			},
			$$inline: true
		});

	br3 = new Br({ props: { size: "40" }, $$inline: true });
	const button_slot_template = /*$$slots*/ ctx[6].button;
	const button_slot = create_slot(button_slot_template, ctx, /*$$scope*/ ctx[7], get_button_slot_context);
	br4 = new Br({ props: { size: "30" }, $$inline: true });

	const block = {
		c: function create() {
			div0 = element("div");
			create_component(carousel.$$.fragment);
			t0 = space();
			section = element("section");
			div1 = element("div");
			create_component(br0.$$.fragment);
			t1 = space();
			if_block0.c();
			t2 = space();
			create_component(br1.$$.fragment);
			t3 = space();
			if_block1.c();
			t4 = space();
			div2 = element("div");
			p = element("p");
			if_block2.c();
			t5 = space();
			create_component(br2.$$.fragment);
			t6 = space();
			create_component(progress.$$.fragment);
			t7 = space();
			create_component(br3.$$.fragment);
			t8 = space();
			if (button_slot) button_slot.c();
			t9 = space();
			create_component(br4.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div0 = claim_element(nodes, "DIV", { style: true, class: true });
			var div0_nodes = children(div0);
			claim_component(carousel.$$.fragment, div0_nodes);
			div0_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			section = claim_element(nodes, "SECTION", { class: true });
			var section_nodes = children(section);
			div1 = claim_element(section_nodes, "DIV", { class: true, style: true });
			var div1_nodes = children(div1);
			claim_component(br0.$$.fragment, div1_nodes);
			t1 = claim_space(div1_nodes);
			if_block0.l(div1_nodes);
			t2 = claim_space(div1_nodes);
			claim_component(br1.$$.fragment, div1_nodes);
			t3 = claim_space(div1_nodes);
			if_block1.l(div1_nodes);
			div1_nodes.forEach(detach_dev);
			t4 = claim_space(section_nodes);
			div2 = claim_element(section_nodes, "DIV", {});
			var div2_nodes = children(div2);
			p = claim_element(div2_nodes, "P", { class: true, style: true });
			var p_nodes = children(p);
			if_block2.l(p_nodes);
			p_nodes.forEach(detach_dev);
			t5 = claim_space(div2_nodes);
			claim_component(br2.$$.fragment, div2_nodes);
			t6 = claim_space(div2_nodes);
			claim_component(progress.$$.fragment, div2_nodes);
			t7 = claim_space(div2_nodes);
			claim_component(br3.$$.fragment, div2_nodes);
			t8 = claim_space(div2_nodes);
			if (button_slot) button_slot.l(div2_nodes);
			t9 = claim_space(div2_nodes);
			claim_component(br4.$$.fragment, div2_nodes);
			div2_nodes.forEach(detach_dev);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_style(div0, "height", "160px");
			attr_dev(div0, "class", "flex flex-none");
			add_location(div0, file$1n, 20, 4, 629);
			attr_dev(div1, "class", "flex-none overflow-hidden");
			set_style(div1, "height", "calc(2 * var(--font-line-height-h2) + var(--font-line-height) + 20px + 5px + 10px)");
			add_location(div1, file$1n, 31, 8, 1020);
			attr_dev(p, "class", "font-secondary flex flex-wrap flex-align-end");
			set_style(p, "letter-spacing", "-0.5px");
			add_location(p, file$1n, 58, 12, 1975);
			add_location(div2, file$1n, 57, 8, 1957);
			attr_dev(section, "class", "container flex flex-column flex-justify-between flex-1");
			add_location(section, file$1n, 30, 4, 939);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div0, anchor);
			mount_component(carousel, div0, null);
			insert_dev(target, t0, anchor);
			insert_dev(target, section, anchor);
			append_dev(section, div1);
			mount_component(br0, div1, null);
			append_dev(div1, t1);
			if_blocks[current_block_type_index].m(div1, null);
			append_dev(div1, t2);
			mount_component(br1, div1, null);
			append_dev(div1, t3);
			if_blocks_1[current_block_type_index_1].m(div1, null);
			append_dev(section, t4);
			append_dev(section, div2);
			append_dev(div2, p);
			if_blocks_2[current_block_type_index_2].m(p, null);
			append_dev(div2, t5);
			mount_component(br2, div2, null);
			append_dev(div2, t6);
			mount_component(progress, div2, null);
			append_dev(div2, t7);
			mount_component(br3, div2, null);
			append_dev(div2, t8);

			if (button_slot) {
				button_slot.m(div2, null);
			}

			append_dev(div2, t9);
			mount_component(br4, div2, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const carousel_changes = {};

			if (dirty & /*src, title*/ 5) carousel_changes.items = [
				{
					src: /*src*/ ctx[0],
					alt: /*title*/ ctx[2]
				},
				{
					src: /*src*/ ctx[0],
					alt: /*title*/ ctx[2]
				},
				{
					src: /*src*/ ctx[0],
					alt: /*title*/ ctx[2]
				}
			];

			carousel.$set(carousel_changes);
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block0 = if_blocks[current_block_type_index];

				if (!if_block0) {
					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block0.c();
				}

				transition_in(if_block0, 1);
				if_block0.m(div1, t2);
			}

			let previous_block_index_1 = current_block_type_index_1;
			current_block_type_index_1 = select_block_type_1(ctx);

			if (current_block_type_index_1 === previous_block_index_1) {
				if_blocks_1[current_block_type_index_1].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
					if_blocks_1[previous_block_index_1] = null;
				});

				check_outros();
				if_block1 = if_blocks_1[current_block_type_index_1];

				if (!if_block1) {
					if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
					if_block1.c();
				}

				transition_in(if_block1, 1);
				if_block1.m(div1, null);
			}

			let previous_block_index_2 = current_block_type_index_2;
			current_block_type_index_2 = select_block_type_2(ctx);

			if (current_block_type_index_2 === previous_block_index_2) {
				if_blocks_2[current_block_type_index_2].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks_2[previous_block_index_2], 1, 1, () => {
					if_blocks_2[previous_block_index_2] = null;
				});

				check_outros();
				if_block2 = if_blocks_2[current_block_type_index_2];

				if (!if_block2) {
					if_block2 = if_blocks_2[current_block_type_index_2] = if_block_creators_2[current_block_type_index_2](ctx);
					if_block2.c();
				}

				transition_in(if_block2, 1);
				if_block2.m(p, null);
			}

			const progress_changes = {};
			if (dirty & /*current, total*/ 24) progress_changes.value = Math.floor(/*current*/ ctx[4] / /*total*/ ctx[3] * 100);
			progress.$set(progress_changes);

			if (button_slot) {
				if (button_slot.p && dirty & /*$$scope*/ 128) {
					update_slot(button_slot, button_slot_template, ctx, /*$$scope*/ ctx[7], dirty, get_button_slot_changes, get_button_slot_context);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(carousel.$$.fragment, local);
			transition_in(br0.$$.fragment, local);
			transition_in(if_block0);
			transition_in(br1.$$.fragment, local);
			transition_in(if_block1);
			transition_in(if_block2);
			transition_in(br2.$$.fragment, local);
			transition_in(progress.$$.fragment, local);
			transition_in(br3.$$.fragment, local);
			transition_in(button_slot, local);
			transition_in(br4.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(carousel.$$.fragment, local);
			transition_out(br0.$$.fragment, local);
			transition_out(if_block0);
			transition_out(br1.$$.fragment, local);
			transition_out(if_block1);
			transition_out(if_block2);
			transition_out(br2.$$.fragment, local);
			transition_out(progress.$$.fragment, local);
			transition_out(br3.$$.fragment, local);
			transition_out(button_slot, local);
			transition_out(br4.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div0);
			destroy_component(carousel);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(section);
			destroy_component(br0);
			if_blocks[current_block_type_index].d();
			destroy_component(br1);
			if_blocks_1[current_block_type_index_1].d();
			if_blocks_2[current_block_type_index_2].d();
			destroy_component(br2);
			destroy_component(progress);
			destroy_component(br3);
			if (button_slot) button_slot.d(detaching);
			destroy_component(br4);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$O.name,
		type: "slot",
		source: "(19:0) <Card class=\\\"flex flex-column\\\">",
		ctx
	});

	return block;
}

function create_fragment$1o(ctx) {
	let card;
	let current;

	card = new Card({
			props: {
				class: "flex flex-column",
				$$slots: { default: [create_default_slot$O] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(card.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(card.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(card, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const card_changes = {};

			if (dirty & /*$$scope, current, total, currency, city, title, src*/ 191) {
				card_changes.$$scope = { dirty, ctx };
			}

			card.$set(card_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(card.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(card.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(card, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1o.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1o($$self, $$props, $$invalidate) {
	let { src = null } = $$props;
	let { city = null } = $$props;
	let { title = null } = $$props;
	let { total = null } = $$props;
	let { current = null } = $$props;
	let { currency = null } = $$props;
	const writable_props = ["src", "city", "title", "total", "current", "currency"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<FundCard> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("FundCard", $$slots, ['button']);

	$$self.$set = $$props => {
		if ("src" in $$props) $$invalidate(0, src = $$props.src);
		if ("city" in $$props) $$invalidate(1, city = $$props.city);
		if ("title" in $$props) $$invalidate(2, title = $$props.title);
		if ("total" in $$props) $$invalidate(3, total = $$props.total);
		if ("current" in $$props) $$invalidate(4, current = $$props.current);
		if ("currency" in $$props) $$invalidate(5, currency = $$props.currency);
		if ("$$scope" in $$props) $$invalidate(7, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		Br,
		Icon,
		Card,
		Loader,
		Button,
		Progress,
		FancyBox,
		Carousel,
		src,
		city,
		title,
		total,
		current,
		currency
	});

	$$self.$inject_state = $$props => {
		if ("src" in $$props) $$invalidate(0, src = $$props.src);
		if ("city" in $$props) $$invalidate(1, city = $$props.city);
		if ("title" in $$props) $$invalidate(2, title = $$props.title);
		if ("total" in $$props) $$invalidate(3, total = $$props.total);
		if ("current" in $$props) $$invalidate(4, current = $$props.current);
		if ("currency" in $$props) $$invalidate(5, currency = $$props.currency);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [src, city, title, total, current, currency, $$slots, $$scope];
}

class FundCard extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1o, create_fragment$1o, safe_not_equal, {
			src: 0,
			city: 1,
			title: 2,
			total: 3,
			current: 4,
			currency: 5
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "FundCard",
			options,
			id: create_fragment$1o.name
		});
	}

	get src() {
		throw new Error("<FundCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set src(value) {
		throw new Error("<FundCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get city() {
		throw new Error("<FundCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set city(value) {
		throw new Error("<FundCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get title() {
		throw new Error("<FundCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<FundCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get total() {
		throw new Error("<FundCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set total(value) {
		throw new Error("<FundCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get current() {
		throw new Error("<FundCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set current(value) {
		throw new Error("<FundCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get currency() {
		throw new Error("<FundCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set currency(value) {
		throw new Error("<FundCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/fundCards/FundCards.svelte generated by Svelte v3.24.0 */
const file$1o = "src/components/fundCards/FundCards.svelte";

function add_css$E() {
	var style = element("style");
	style.id = "svelte-yc0ge7-style";
	style.textContent = ".charities.active .scroll-x-center > *{-webkit-transform:none;transform:none\n}div.svelte-yc0ge7{-webkit-box-flex:0;-ms-flex:none;flex:none;display:-webkit-box;display:-ms-flexbox;display:flex;-ms-flex-item-align:stretch;align-self:stretch;height:500px;width:77vw;max-width:350px;padding:15px 5px;-webkit-box-sizing:content-box;box-sizing:content-box}div.start.svelte-yc0ge7{padding-left:var(--screen-padding)}div.end.svelte-yc0ge7{padding-right:var(--screen-padding)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRnVuZENhcmRzLnN2ZWx0ZSIsInNvdXJjZXMiOlsiRnVuZENhcmRzLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0PlxuICAgIGltcG9ydCBDYXJvdXNlbCBmcm9tICdAY29tcG9uZW50cy9DYXJvdXNlbC5zdmVsdGUnXG4gICAgaW1wb3J0IEJ1dHRvbiBmcm9tICdAY29tcG9uZW50cy9CdXR0b24uc3ZlbHRlJ1xuICAgIGltcG9ydCBGdW5kQ2FyZCBmcm9tICcuL0Z1bmRDYXJkLnN2ZWx0ZSdcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHt7XG4gICAgICogIGlkOiBzdHJpbmcsXG4gICAgICogIHNyYzogc3RyaW5nLFxuICAgICAqICB0b3RhbDogbnVtYmVyLFxuICAgICAqICBjdXJyZW50OiBudW1iZXIsXG4gICAgICogIGN1cnJlbmN5OiBzdHJpbmcsXG4gICAgICogIGNpdHk6IHN0cmluZyxcbiAgICAgKiAgdGl0bGU6IHN0cmluZyxcbiAgICAgKiB9fVxuICAgICAqL1xuICAgIGV4cG9ydCBsZXQgaXRlbXMgPSBbe30sIHt9LCB7fV1cbjwvc2NyaXB0PlxuXG48Q2Fyb3VzZWwge2l0ZW1zfSBzaXplPVwiYXV0b1wiIGxldDppbmRleD17aW5kZXh9IGxldDppdGVtPXtpdGVtfSBjbGFzcz1cImNoYXJpdGllc1wiPlxuICAgIDxkaXYgY2xhc3M9eyFpbmRleCA/ICdzdGFydCcgOiBpbmRleCA9PT0gaXRlbXMubGVuZ3RoIC0gMSA/ICdlbmQnIDogJyd9IGtleT17aXRlbS5pZH0+XG4gICAgICAgIDxGdW5kQ2FyZFxuICAgICAgICAgICAgc3JjPXtpdGVtLnNyY31cbiAgICAgICAgICAgIHRvdGFsPXtpdGVtLnRvdGFsfVxuICAgICAgICAgICAgY3VycmVudD17aXRlbS5jdXJyZW50fVxuICAgICAgICAgICAgY3VycmVuY3k9e2l0ZW0uY3VycmVuY3l9XG4gICAgICAgICAgICBjaXR5PXtpdGVtLmNpdHl9XG4gICAgICAgICAgICB0aXRsZT17aXRlbS50aXRsZX1cbiAgICAgICAgPlxuICAgICAgICAgICAgPHNwYW4gc2xvdD1cImJ1dHRvblwiIGxldDppZD17aWR9PlxuICAgICAgICAgICAgICAgIDxzbG90IG5hbWU9XCJidXR0b25cIj5cbiAgICAgICAgICAgICAgICAgICAgPEJ1dHRvbiBzaXplPVwiYmlnXCIgaXM9XCJzdWNjZXNzXCIgaHJlZj17aWR9PlxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJoMiBmb250LXNlY29uZGFyeSBmb250LXctNjAwXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAg0JTQvtC/0L7QvNC+0LPRgtC4XG4gICAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICAgICAgICAgIDwvc2xvdD5cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgPC9GdW5kQ2FyZD5cbiAgICA8L2Rpdj5cbjwvQ2Fyb3VzZWw+XG5cbjxzdHlsZT5cbjpnbG9iYWwoLmNoYXJpdGllcy5hY3RpdmUgLnNjcm9sbC14LWNlbnRlciA+ICopIHtcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogbm9uZTtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogbm9uZVxufVxuZGl2IHtcbiAgICAtd2Via2l0LWJveC1mbGV4OiAwO1xuICAgICAgICAtbXMtZmxleDogbm9uZTtcbiAgICAgICAgICAgIGZsZXg6IG5vbmU7XG4gICAgZGlzcGxheTogLXdlYmtpdC1ib3g7XG4gICAgZGlzcGxheTogLW1zLWZsZXhib3g7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICAtbXMtZmxleC1pdGVtLWFsaWduOiBzdHJldGNoO1xuICAgICAgICBhbGlnbi1zZWxmOiBzdHJldGNoO1xuICAgIGhlaWdodDogNTAwcHg7XG4gICAgd2lkdGg6IDc3dnc7XG4gICAgbWF4LXdpZHRoOiAzNTBweDtcbiAgICBwYWRkaW5nOiAxNXB4IDVweDtcbiAgICAtd2Via2l0LWJveC1zaXppbmc6IGNvbnRlbnQtYm94O1xuICAgICAgICAgICAgYm94LXNpemluZzogY29udGVudC1ib3g7XG59XG5cbmRpdi5zdGFydCB7XG4gICAgcGFkZGluZy1sZWZ0OiB2YXIoLS1zY3JlZW4tcGFkZGluZyk7XG59XG5cbmRpdi5lbmQge1xuICAgIHBhZGRpbmctcmlnaHQ6IHZhcigtLXNjcmVlbi1wYWRkaW5nKTtcbn08L3N0eWxlPlxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQTJDUSxzQ0FBc0MsQUFBRSxDQUFDLEFBQzdDLGlCQUFpQixDQUFFLElBQUksQ0FDZixTQUFTLENBQUUsSUFBSTtBQUMzQixDQUFDLEFBQ0QsR0FBRyxjQUFDLENBQUMsQUFDRCxnQkFBZ0IsQ0FBRSxDQUFDLENBQ2YsUUFBUSxDQUFFLElBQUksQ0FDVixJQUFJLENBQUUsSUFBSSxDQUNsQixPQUFPLENBQUUsV0FBVyxDQUNwQixPQUFPLENBQUUsV0FBVyxDQUNwQixPQUFPLENBQUUsSUFBSSxDQUNiLG1CQUFtQixDQUFFLE9BQU8sQ0FDeEIsVUFBVSxDQUFFLE9BQU8sQ0FDdkIsTUFBTSxDQUFFLEtBQUssQ0FDYixLQUFLLENBQUUsSUFBSSxDQUNYLFNBQVMsQ0FBRSxLQUFLLENBQ2hCLE9BQU8sQ0FBRSxJQUFJLENBQUMsR0FBRyxDQUNqQixrQkFBa0IsQ0FBRSxXQUFXLENBQ3ZCLFVBQVUsQ0FBRSxXQUFXLEFBQ25DLENBQUMsQUFFRCxHQUFHLE1BQU0sY0FBQyxDQUFDLEFBQ1AsWUFBWSxDQUFFLElBQUksZ0JBQWdCLENBQUMsQUFDdkMsQ0FBQyxBQUVELEdBQUcsSUFBSSxjQUFDLENBQUMsQUFDTCxhQUFhLENBQUUsSUFBSSxnQkFBZ0IsQ0FBQyxBQUN4QyxDQUFDIn0= */";
	append_dev(document.head, style);
}

const get_button_slot_changes$1 = dirty => ({});
const get_button_slot_context$1 = ctx => ({});

// (32:20) <Button size="big" is="success" href={id}>
function create_default_slot_2$4(ctx) {
	let span;
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text("Допомогти");
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t = claim_text(span_nodes, "Допомогти");
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "h2 font-secondary font-w-600");
			add_location(span, file$1o, 32, 24, 971);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$4.name,
		type: "slot",
		source: "(32:20) <Button size=\\\"big\\\" is=\\\"success\\\" href={id}>",
		ctx
	});

	return block;
}

// (31:36)                      
function fallback_block$a(ctx) {
	let button;
	let current;

	button = new Button({
			props: {
				size: "big",
				is: "success",
				href: /*id*/ ctx[5],
				$$slots: { default: [create_default_slot_2$4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(button.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(button.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const button_changes = {};
			if (dirty & /*id*/ 32) button_changes.href = /*id*/ ctx[5];

			if (dirty & /*$$scope*/ 4) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(button, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: fallback_block$a.name,
		type: "fallback",
		source: "(31:36)                      ",
		ctx
	});

	return block;
}

// (30:12) <span slot="button" let:id={id}>
function create_button_slot(ctx) {
	let span;
	let current;
	const button_slot_template = /*$$slots*/ ctx[1].button;
	const button_slot = create_slot(button_slot_template, ctx, /*$$scope*/ ctx[2], get_button_slot_context$1);
	const button_slot_or_fallback = button_slot || fallback_block$a(ctx);

	const block = {
		c: function create() {
			span = element("span");
			if (button_slot_or_fallback) button_slot_or_fallback.c();
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { slot: true });
			var span_nodes = children(span);
			if (button_slot_or_fallback) button_slot_or_fallback.l(span_nodes);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "slot", "button");
			add_location(span, file$1o, 29, 12, 814);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);

			if (button_slot_or_fallback) {
				button_slot_or_fallback.m(span, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (button_slot) {
				if (button_slot.p && dirty & /*$$scope*/ 4) {
					update_slot(button_slot, button_slot_template, ctx, /*$$scope*/ ctx[2], dirty, get_button_slot_changes$1, get_button_slot_context$1);
				}
			} else {
				if (button_slot_or_fallback && button_slot_or_fallback.p && dirty & /*id*/ 32) {
					button_slot_or_fallback.p(ctx, dirty);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button_slot_or_fallback, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button_slot_or_fallback, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			if (button_slot_or_fallback) button_slot_or_fallback.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_button_slot.name,
		type: "slot",
		source: "(30:12) <span slot=\\\"button\\\" let:id={id}>",
		ctx
	});

	return block;
}

// (20:0) <Carousel {items} size="auto" let:index={index} let:item={item} class="charities">
function create_default_slot$P(ctx) {
	let div;
	let fundcard;
	let div_class_value;
	let div_key_value;
	let current;

	fundcard = new FundCard({
			props: {
				src: /*item*/ ctx[4].src,
				total: /*item*/ ctx[4].total,
				current: /*item*/ ctx[4].current,
				currency: /*item*/ ctx[4].currency,
				city: /*item*/ ctx[4].city,
				title: /*item*/ ctx[4].title,
				$$slots: {
					button: [create_button_slot, ({ id }) => ({ 5: id }), ({ id }) => id ? 32 : 0]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div = element("div");
			create_component(fundcard.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true, key: true });
			var div_nodes = children(div);
			claim_component(fundcard.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", div_class_value = "" + (null_to_empty(!/*index*/ ctx[3]
			? "start"
			: /*index*/ ctx[3] === /*items*/ ctx[0].length - 1
				? "end"
				: "") + " svelte-yc0ge7"));

			attr_dev(div, "key", div_key_value = /*item*/ ctx[4].id);
			add_location(div, file$1o, 20, 4, 497);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(fundcard, div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const fundcard_changes = {};
			if (dirty & /*item*/ 16) fundcard_changes.src = /*item*/ ctx[4].src;
			if (dirty & /*item*/ 16) fundcard_changes.total = /*item*/ ctx[4].total;
			if (dirty & /*item*/ 16) fundcard_changes.current = /*item*/ ctx[4].current;
			if (dirty & /*item*/ 16) fundcard_changes.currency = /*item*/ ctx[4].currency;
			if (dirty & /*item*/ 16) fundcard_changes.city = /*item*/ ctx[4].city;
			if (dirty & /*item*/ 16) fundcard_changes.title = /*item*/ ctx[4].title;

			if (dirty & /*$$scope, id*/ 36) {
				fundcard_changes.$$scope = { dirty, ctx };
			}

			fundcard.$set(fundcard_changes);

			if (!current || dirty & /*index, items*/ 9 && div_class_value !== (div_class_value = "" + (null_to_empty(!/*index*/ ctx[3]
			? "start"
			: /*index*/ ctx[3] === /*items*/ ctx[0].length - 1
				? "end"
				: "") + " svelte-yc0ge7"))) {
				attr_dev(div, "class", div_class_value);
			}

			if (!current || dirty & /*item*/ 16 && div_key_value !== (div_key_value = /*item*/ ctx[4].id)) {
				attr_dev(div, "key", div_key_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(fundcard.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(fundcard.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(fundcard);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$P.name,
		type: "slot",
		source: "(20:0) <Carousel {items} size=\\\"auto\\\" let:index={index} let:item={item} class=\\\"charities\\\">",
		ctx
	});

	return block;
}

function create_fragment$1p(ctx) {
	let carousel;
	let current;

	carousel = new Carousel({
			props: {
				items: /*items*/ ctx[0],
				size: "auto",
				class: "charities",
				$$slots: {
					default: [
						create_default_slot$P,
						({ index, item }) => ({ 3: index, 4: item }),
						({ index, item }) => (index ? 8 : 0) | (item ? 16 : 0)
					]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(carousel.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(carousel.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(carousel, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const carousel_changes = {};
			if (dirty & /*items*/ 1) carousel_changes.items = /*items*/ ctx[0];

			if (dirty & /*$$scope, index, items, item*/ 29) {
				carousel_changes.$$scope = { dirty, ctx };
			}

			carousel.$set(carousel_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(carousel.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(carousel.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(carousel, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1p.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1p($$self, $$props, $$invalidate) {
	let { items = [{}, {}, {}] } = $$props;
	const writable_props = ["items"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<FundCards> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("FundCards", $$slots, ['button']);

	$$self.$set = $$props => {
		if ("items" in $$props) $$invalidate(0, items = $$props.items);
		if ("$$scope" in $$props) $$invalidate(2, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({ Carousel, Button, FundCard, items });

	$$self.$inject_state = $$props => {
		if ("items" in $$props) $$invalidate(0, items = $$props.items);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [items, $$slots, $$scope];
}

class FundCards extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document.getElementById("svelte-yc0ge7-style")) add_css$E();
		init(this, options, instance$1p, create_fragment$1p, safe_not_equal, { items: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "FundCards",
			options,
			id: create_fragment$1p.name
		});
	}

	get items() {
		throw new Error("<FundCards>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set items(value) {
		throw new Error("<FundCards>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/_layout.svelte generated by Svelte v3.24.0 */
const file$1p = "src/routes/_layout.svelte";

function create_fragment$1q(ctx) {
	let main;
	let header;
	let t0;
	let section;
	let t1;
	let offlinemessage;
	let current;

	header = new Header({
			props: { segment: /*segment*/ ctx[0] },
			$$inline: true
		});

	const default_slot_template = /*$$slots*/ ctx[3].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);
	offlinemessage = new OfflineMessage({ $$inline: true });

	const block = {
		c: function create() {
			main = element("main");
			create_component(header.$$.fragment);
			t0 = space();
			section = element("section");
			if (default_slot) default_slot.c();
			t1 = space();
			create_component(offlinemessage.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			main = claim_element(nodes, "MAIN", { id: true, class: true });
			var main_nodes = children(main);
			claim_component(header.$$.fragment, main_nodes);
			t0 = claim_space(main_nodes);
			section = claim_element(main_nodes, "SECTION", { class: true });
			var section_nodes = children(section);
			if (default_slot) default_slot.l(section_nodes);
			section_nodes.forEach(detach_dev);
			t1 = claim_space(main_nodes);
			claim_component(offlinemessage.$$.fragment, main_nodes);
			main_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(section, "class", "pages");
			add_location(section, file$1p, 20, 1, 519);
			attr_dev(main, "id", "main");
			attr_dev(main, "class", /*classProp*/ ctx[1]);
			add_location(main, file$1p, 17, 0, 461);
		},
		m: function mount(target, anchor) {
			insert_dev(target, main, anchor);
			mount_component(header, main, null);
			append_dev(main, t0);
			append_dev(main, section);

			if (default_slot) {
				default_slot.m(section, null);
			}

			append_dev(main, t1);
			mount_component(offlinemessage, main, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const header_changes = {};
			if (dirty & /*segment*/ 1) header_changes.segment = /*segment*/ ctx[0];
			header.$set(header_changes);

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 4) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[2], dirty, null, null);
				}
			}

			if (!current || dirty & /*classProp*/ 2) {
				attr_dev(main, "class", /*classProp*/ ctx[1]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(header.$$.fragment, local);
			transition_in(default_slot, local);
			transition_in(offlinemessage.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(header.$$.fragment, local);
			transition_out(default_slot, local);
			transition_out(offlinemessage.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(main);
			destroy_component(header);
			if (default_slot) default_slot.d(detaching);
			destroy_component(offlinemessage);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1q.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1q($$self, $$props, $$invalidate) {
	let { segment } = $$props;
	let theme = safeGet(() => cookieStorage.get("theme") || localStorage.get("theme"));

	onMount(() => {
		disableDoubleTapZoom([document]);
	});

	const writable_props = ["segment"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Layout> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Layout", $$slots, ['default']);

	$$self.$set = $$props => {
		if ("segment" in $$props) $$invalidate(0, segment = $$props.segment);
		if ("$$scope" in $$props) $$invalidate(2, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		onMount,
		Header,
		OfflineMessage,
		Storages,
		safeGet,
		disableDoubleTapZoom,
		classnames,
		segment,
		theme,
		classProp
	});

	$$self.$inject_state = $$props => {
		if ("segment" in $$props) $$invalidate(0, segment = $$props.segment);
		if ("theme" in $$props) $$invalidate(4, theme = $$props.theme);
		if ("classProp" in $$props) $$invalidate(1, classProp = $$props.classProp);
	};

	let classProp;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	 $$invalidate(1, classProp = classnames("theme-bg-color-secondary", theme));
	return [segment, classProp, $$scope, $$slots];
}

class Layout extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1q, create_fragment$1q, safe_not_equal, { segment: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Layout",
			options,
			id: create_fragment$1q.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*segment*/ ctx[0] === undefined && !("segment" in props)) {
			console.warn("<Layout> was created without expected prop 'segment'");
		}
	}

	get segment() {
		throw new Error("<Layout>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set segment(value) {
		throw new Error("<Layout>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/_error.svelte generated by Svelte v3.24.0 */

const { Error: Error_1$1 } = globals;
const file$1q = "src/routes/_error.svelte";

function create_fragment$1r(ctx) {
	let title_value;
	let t0;
	let br0;
	let t1;
	let br1;
	let t2;
	let br2;
	let t3;
	let br3;
	let t4;
	let div0;
	let h10;
	let t5;
	let t6;
	let div1;
	let h11;
	let t7;
	let t8;
	let t9;
	let br4;
	let t10;
	let p;
	let t11;
	let t12_value = /*error*/ ctx[1].message + "";
	let t12;
	let t13;
	let br5;
	let t14;
	let br6;
	document.title = title_value = "Error: " + /*status*/ ctx[0];

	const block = {
		c: function create() {
			t0 = space();
			br0 = element("br");
			t1 = space();
			br1 = element("br");
			t2 = space();
			br2 = element("br");
			t3 = space();
			br3 = element("br");
			t4 = space();
			div0 = element("div");
			h10 = element("h1");
			t5 = text("ой 🙃");
			t6 = space();
			div1 = element("div");
			h11 = element("h1");
			t7 = text("Error: ");
			t8 = text(/*status*/ ctx[0]);
			t9 = space();
			br4 = element("br");
			t10 = space();
			p = element("p");
			t11 = text("Reason: ");
			t12 = text(t12_value);
			t13 = space();
			br5 = element("br");
			t14 = space();
			br6 = element("br");
			this.h();
		},
		l: function claim(nodes) {
			const head_nodes = query_selector_all("[data-svelte=\"svelte-oxohxa\"]", document.head);
			head_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			br0 = claim_element(nodes, "BR", {});
			t1 = claim_space(nodes);
			br1 = claim_element(nodes, "BR", {});
			t2 = claim_space(nodes);
			br2 = claim_element(nodes, "BR", {});
			t3 = claim_space(nodes);
			br3 = claim_element(nodes, "BR", {});
			t4 = claim_space(nodes);
			div0 = claim_element(nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			h10 = claim_element(div0_nodes, "H1", {});
			var h10_nodes = children(h10);
			t5 = claim_text(h10_nodes, "ой 🙃");
			h10_nodes.forEach(detach_dev);
			div0_nodes.forEach(detach_dev);
			t6 = claim_space(nodes);
			div1 = claim_element(nodes, "DIV", { hidden: true, class: true });
			var div1_nodes = children(div1);
			h11 = claim_element(div1_nodes, "H1", {});
			var h11_nodes = children(h11);
			t7 = claim_text(h11_nodes, "Error: ");
			t8 = claim_text(h11_nodes, /*status*/ ctx[0]);
			h11_nodes.forEach(detach_dev);
			t9 = claim_space(div1_nodes);
			br4 = claim_element(div1_nodes, "BR", {});
			t10 = claim_space(div1_nodes);
			p = claim_element(div1_nodes, "P", {});
			var p_nodes = children(p);
			t11 = claim_text(p_nodes, "Reason: ");
			t12 = claim_text(p_nodes, t12_value);
			p_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			t13 = claim_space(nodes);
			br5 = claim_element(nodes, "BR", {});
			t14 = claim_space(nodes);
			br6 = claim_element(nodes, "BR", {});
			this.h();
		},
		h: function hydrate() {
			add_location(br0, file$1q, 13, 0, 185);
			add_location(br1, file$1q, 14, 0, 190);
			add_location(br2, file$1q, 15, 0, 195);
			add_location(br3, file$1q, 16, 0, 200);
			add_location(h10, file$1q, 18, 1, 232);
			attr_dev(div0, "class", "text-center");
			add_location(div0, file$1q, 17, 0, 205);
			add_location(h11, file$1q, 21, 1, 288);
			add_location(br4, file$1q, 22, 1, 314);
			add_location(p, file$1q, 23, 1, 320);
			div1.hidden = true;
			attr_dev(div1, "class", "text-center");
			add_location(div1, file$1q, 20, 0, 254);
			add_location(br5, file$1q, 25, 0, 358);
			add_location(br6, file$1q, 26, 0, 363);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, br0, anchor);
			insert_dev(target, t1, anchor);
			insert_dev(target, br1, anchor);
			insert_dev(target, t2, anchor);
			insert_dev(target, br2, anchor);
			insert_dev(target, t3, anchor);
			insert_dev(target, br3, anchor);
			insert_dev(target, t4, anchor);
			insert_dev(target, div0, anchor);
			append_dev(div0, h10);
			append_dev(h10, t5);
			insert_dev(target, t6, anchor);
			insert_dev(target, div1, anchor);
			append_dev(div1, h11);
			append_dev(h11, t7);
			append_dev(h11, t8);
			append_dev(div1, t9);
			append_dev(div1, br4);
			append_dev(div1, t10);
			append_dev(div1, p);
			append_dev(p, t11);
			append_dev(p, t12);
			insert_dev(target, t13, anchor);
			insert_dev(target, br5, anchor);
			insert_dev(target, t14, anchor);
			insert_dev(target, br6, anchor);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*status*/ 1 && title_value !== (title_value = "Error: " + /*status*/ ctx[0])) {
				document.title = title_value;
			}

			if (dirty & /*status*/ 1) set_data_dev(t8, /*status*/ ctx[0]);
			if (dirty & /*error*/ 2 && t12_value !== (t12_value = /*error*/ ctx[1].message + "")) set_data_dev(t12, t12_value);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(br0);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(br1);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(br2);
			if (detaching) detach_dev(t3);
			if (detaching) detach_dev(br3);
			if (detaching) detach_dev(t4);
			if (detaching) detach_dev(div0);
			if (detaching) detach_dev(t6);
			if (detaching) detach_dev(div1);
			if (detaching) detach_dev(t13);
			if (detaching) detach_dev(br5);
			if (detaching) detach_dev(t14);
			if (detaching) detach_dev(br6);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1r.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1r($$self, $$props, $$invalidate) {
	let { status } = $$props;
	let { error } = $$props;
	const dev = "development" === "development";
	const writable_props = ["status", "error"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Error> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Error", $$slots, []);

	$$self.$set = $$props => {
		if ("status" in $$props) $$invalidate(0, status = $$props.status);
		if ("error" in $$props) $$invalidate(1, error = $$props.error);
	};

	$$self.$capture_state = () => ({ status, error, dev });

	$$self.$inject_state = $$props => {
		if ("status" in $$props) $$invalidate(0, status = $$props.status);
		if ("error" in $$props) $$invalidate(1, error = $$props.error);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [status, error];
}

class Error$1 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1r, create_fragment$1r, safe_not_equal, { status: 0, error: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Error",
			options,
			id: create_fragment$1r.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*status*/ ctx[0] === undefined && !("status" in props)) {
			console.warn("<Error> was created without expected prop 'status'");
		}

		if (/*error*/ ctx[1] === undefined && !("error" in props)) {
			console.warn("<Error> was created without expected prop 'error'");
		}
	}

	get status() {
		throw new Error_1$1("<Error>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set status(value) {
		throw new Error_1$1("<Error>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get error() {
		throw new Error_1$1("<Error>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set error(value) {
		throw new Error_1$1("<Error>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/node_modules/@sapper/internal/App.svelte generated by Svelte v3.24.0 */

const { Error: Error_1$2 } = globals;

// (24:1) {:else}
function create_else_block$e(ctx) {
	let switch_instance;
	let switch_instance_anchor;
	let current;
	const switch_instance_spread_levels = [{ segment: /*segments*/ ctx[2][1] }, /*level1*/ ctx[4].props];
	var switch_value = /*level1*/ ctx[4].component;

	function switch_props(ctx) {
		let switch_instance_props = {
			$$slots: { default: [create_default_slot_1$7] },
			$$scope: { ctx }
		};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		return {
			props: switch_instance_props,
			$$inline: true
		};
	}

	if (switch_value) {
		switch_instance = new switch_value(switch_props(ctx));
	}

	const block = {
		c: function create() {
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
		},
		l: function claim(nodes) {
			if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
			switch_instance_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (switch_instance) {
				mount_component(switch_instance, target, anchor);
			}

			insert_dev(target, switch_instance_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const switch_instance_changes = (dirty & /*segments, level1*/ 20)
			? get_spread_update(switch_instance_spread_levels, [
					dirty & /*segments*/ 4 && { segment: /*segments*/ ctx[2][1] },
					dirty & /*level1*/ 16 && get_spread_object(/*level1*/ ctx[4].props)
				])
			: {};

			if (dirty & /*$$scope, level2*/ 288) {
				switch_instance_changes.$$scope = { dirty, ctx };
			}

			if (switch_value !== (switch_value = /*level1*/ ctx[4].component)) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i: function intro(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$e.name,
		type: "else",
		source: "(24:1) {:else}",
		ctx
	});

	return block;
}

// (22:1) {#if error}
function create_if_block$u(ctx) {
	let error_1;
	let current;

	error_1 = new Error$1({
			props: {
				error: /*error*/ ctx[0],
				status: /*status*/ ctx[1]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(error_1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(error_1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(error_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const error_1_changes = {};
			if (dirty & /*error*/ 1) error_1_changes.error = /*error*/ ctx[0];
			if (dirty & /*status*/ 2) error_1_changes.status = /*status*/ ctx[1];
			error_1.$set(error_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(error_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(error_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(error_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$u.name,
		type: "if",
		source: "(22:1) {#if error}",
		ctx
	});

	return block;
}

// (26:3) {#if level2}
function create_if_block_1$l(ctx) {
	let switch_instance;
	let switch_instance_anchor;
	let current;
	const switch_instance_spread_levels = [/*level2*/ ctx[5].props];
	var switch_value = /*level2*/ ctx[5].component;

	function switch_props(ctx) {
		let switch_instance_props = {};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		return {
			props: switch_instance_props,
			$$inline: true
		};
	}

	if (switch_value) {
		switch_instance = new switch_value(switch_props());
	}

	const block = {
		c: function create() {
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
		},
		l: function claim(nodes) {
			if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
			switch_instance_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (switch_instance) {
				mount_component(switch_instance, target, anchor);
			}

			insert_dev(target, switch_instance_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const switch_instance_changes = (dirty & /*level2*/ 32)
			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*level2*/ ctx[5].props)])
			: {};

			if (switch_value !== (switch_value = /*level2*/ ctx[5].component)) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props());
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i: function intro(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$l.name,
		type: "if",
		source: "(26:3) {#if level2}",
		ctx
	});

	return block;
}

// (25:2) <svelte:component this="{level1.component}" segment="{segments[1]}" {...level1.props}>
function create_default_slot_1$7(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*level2*/ ctx[5] && create_if_block_1$l(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*level2*/ ctx[5]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*level2*/ 32) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_1$l(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$7.name,
		type: "slot",
		source: "(25:2) <svelte:component this=\\\"{level1.component}\\\" segment=\\\"{segments[1]}\\\" {...level1.props}>",
		ctx
	});

	return block;
}

// (21:0) <Layout segment="{segments[0]}" {...level0.props}>
function create_default_slot$Q(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$u, create_else_block$e];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*error*/ ctx[0]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$Q.name,
		type: "slot",
		source: "(21:0) <Layout segment=\\\"{segments[0]}\\\" {...level0.props}>",
		ctx
	});

	return block;
}

function create_fragment$1s(ctx) {
	let layout;
	let current;
	const layout_spread_levels = [{ segment: /*segments*/ ctx[2][0] }, /*level0*/ ctx[3].props];

	let layout_props = {
		$$slots: { default: [create_default_slot$Q] },
		$$scope: { ctx }
	};

	for (let i = 0; i < layout_spread_levels.length; i += 1) {
		layout_props = assign(layout_props, layout_spread_levels[i]);
	}

	layout = new Layout({ props: layout_props, $$inline: true });

	const block = {
		c: function create() {
			create_component(layout.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(layout.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(layout, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const layout_changes = (dirty & /*segments, level0*/ 12)
			? get_spread_update(layout_spread_levels, [
					dirty & /*segments*/ 4 && { segment: /*segments*/ ctx[2][0] },
					dirty & /*level0*/ 8 && get_spread_object(/*level0*/ ctx[3].props)
				])
			: {};

			if (dirty & /*$$scope, error, status, level1, segments, level2*/ 311) {
				layout_changes.$$scope = { dirty, ctx };
			}

			layout.$set(layout_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(layout.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(layout.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(layout, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1s.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1s($$self, $$props, $$invalidate) {
	let { stores } = $$props;
	let { error } = $$props;
	let { status } = $$props;
	let { segments } = $$props;
	let { level0 } = $$props;
	let { level1 = null } = $$props;
	let { level2 = null } = $$props;
	let { notify } = $$props;
	afterUpdate(notify);
	setContext(CONTEXT_KEY, stores);

	const writable_props = [
		"stores",
		"error",
		"status",
		"segments",
		"level0",
		"level1",
		"level2",
		"notify"
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<App> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("App", $$slots, []);

	$$self.$set = $$props => {
		if ("stores" in $$props) $$invalidate(6, stores = $$props.stores);
		if ("error" in $$props) $$invalidate(0, error = $$props.error);
		if ("status" in $$props) $$invalidate(1, status = $$props.status);
		if ("segments" in $$props) $$invalidate(2, segments = $$props.segments);
		if ("level0" in $$props) $$invalidate(3, level0 = $$props.level0);
		if ("level1" in $$props) $$invalidate(4, level1 = $$props.level1);
		if ("level2" in $$props) $$invalidate(5, level2 = $$props.level2);
		if ("notify" in $$props) $$invalidate(7, notify = $$props.notify);
	};

	$$self.$capture_state = () => ({
		setContext,
		afterUpdate,
		CONTEXT_KEY,
		Layout,
		Error: Error$1,
		stores,
		error,
		status,
		segments,
		level0,
		level1,
		level2,
		notify
	});

	$$self.$inject_state = $$props => {
		if ("stores" in $$props) $$invalidate(6, stores = $$props.stores);
		if ("error" in $$props) $$invalidate(0, error = $$props.error);
		if ("status" in $$props) $$invalidate(1, status = $$props.status);
		if ("segments" in $$props) $$invalidate(2, segments = $$props.segments);
		if ("level0" in $$props) $$invalidate(3, level0 = $$props.level0);
		if ("level1" in $$props) $$invalidate(4, level1 = $$props.level1);
		if ("level2" in $$props) $$invalidate(5, level2 = $$props.level2);
		if ("notify" in $$props) $$invalidate(7, notify = $$props.notify);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [error, status, segments, level0, level1, level2, stores, notify];
}

class App extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1s, create_fragment$1s, safe_not_equal, {
			stores: 6,
			error: 0,
			status: 1,
			segments: 2,
			level0: 3,
			level1: 4,
			level2: 5,
			notify: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "App",
			options,
			id: create_fragment$1s.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*stores*/ ctx[6] === undefined && !("stores" in props)) {
			console.warn("<App> was created without expected prop 'stores'");
		}

		if (/*error*/ ctx[0] === undefined && !("error" in props)) {
			console.warn("<App> was created without expected prop 'error'");
		}

		if (/*status*/ ctx[1] === undefined && !("status" in props)) {
			console.warn("<App> was created without expected prop 'status'");
		}

		if (/*segments*/ ctx[2] === undefined && !("segments" in props)) {
			console.warn("<App> was created without expected prop 'segments'");
		}

		if (/*level0*/ ctx[3] === undefined && !("level0" in props)) {
			console.warn("<App> was created without expected prop 'level0'");
		}

		if (/*notify*/ ctx[7] === undefined && !("notify" in props)) {
			console.warn("<App> was created without expected prop 'notify'");
		}
	}

	get stores() {
		throw new Error_1$2("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set stores(value) {
		throw new Error_1$2("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get error() {
		throw new Error_1$2("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set error(value) {
		throw new Error_1$2("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get status() {
		throw new Error_1$2("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set status(value) {
		throw new Error_1$2("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get segments() {
		throw new Error_1$2("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set segments(value) {
		throw new Error_1$2("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get level0() {
		throw new Error_1$2("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set level0(value) {
		throw new Error_1$2("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get level1() {
		throw new Error_1$2("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set level1(value) {
		throw new Error_1$2("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get level2() {
		throw new Error_1$2("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set level2(value) {
		throw new Error_1$2("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get notify() {
		throw new Error_1$2("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set notify(value) {
		throw new Error_1$2("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

// This file is generated by Sapper — do not edit it!

const ignore = [/^\/organizations\/components\/?$/, /^\/organizations\/edit\/?$/, /^\/organizations\/view\/?$/, /^\/funds\/components\/?$/, /^\/funds\/edit\/?$/, /^\/funds\/view\/?$/, /^\/lists\/components\/?$/];

const components = [
	{
		js: () => import('./index.790ab27b.js'),
		css: []
	},
	{
		js: () => import('./[id].7fbc8ac0.js'),
		css: []
	},
	{
		js: () => import('./[id].95efea46.js'),
		css: []
	},
	{
		js: () => import('./_layout.44d3b9ba.js'),
		css: []
	},
	{
		js: () => import('./index.efa5bbf8.js'),
		css: []
	},
	{
		js: () => import('./organizations.631f951c.js'),
		css: []
	},
	{
		js: () => import('./funds.6edc473f.js'),
		css: []
	},
	{
		js: () => import('./index.52ee1720.js'),
		css: []
	},
	{
		js: () => import('./me.c2e18192.js'),
		css: []
	},
	{
		js: () => import('./[id].83cec44a.js'),
		css: []
	},
	{
		js: () => import('./index.99d5483b.js'),
		css: []
	},
	{
		js: () => import('./[id].bb4690ff.js'),
		css: []
	}
];

const routes = (d => [
	{
		// index.svelte
		pattern: /^\/$/,
		parts: [
			{ i: 0 }
		]
	},

	{
		// organizations/[id].svelte
		pattern: /^\/organizations\/([^\/]+?)\/?$/,
		parts: [
			null,
			{ i: 1, params: match => ({ id: d(match[1]) }) }
		]
	},

	{
		// funds/[id].svelte
		pattern: /^\/funds\/([^\/]+?)\/?$/,
		parts: [
			null,
			{ i: 2, params: match => ({ id: d(match[1]) }) }
		]
	},

	{
		// lists/index.svelte
		pattern: /^\/lists\/?$/,
		parts: [
			{ i: 3 },
			{ i: 4 }
		]
	},

	{
		// lists/organizations.svelte
		pattern: /^\/lists\/organizations\/?$/,
		parts: [
			{ i: 3 },
			{ i: 5 }
		]
	},

	{
		// lists/funds.svelte
		pattern: /^\/lists\/funds\/?$/,
		parts: [
			{ i: 3 },
			{ i: 6 }
		]
	},

	{
		// users/index.svelte
		pattern: /^\/users\/?$/,
		parts: [
			{ i: 7 }
		]
	},

	{
		// users/me.svelte
		pattern: /^\/users\/me\/?$/,
		parts: [
			null,
			{ i: 8 }
		]
	},

	{
		// users/[id].svelte
		pattern: /^\/users\/([^\/]+?)\/?$/,
		parts: [
			null,
			{ i: 9, params: match => ({ id: d(match[1]) }) }
		]
	},

	{
		// map/index.svelte
		pattern: /^\/map\/?$/,
		parts: [
			{ i: 10 }
		]
	},

	{
		// map/[id].svelte
		pattern: /^\/map\/([^\/]+?)\/?$/,
		parts: [
			null,
			{ i: 11, params: match => ({ id: d(match[1]) }) }
		]
	}
])(decodeURIComponent);

if (typeof window !== 'undefined') {
	import('./sapper-dev-client.1e7a4a5e.js').then(client => {
		client.connect(10000);
	});
}

function goto(href, opts = { replaceState: false }) {
	const target = select_target(new URL(href, document.baseURI));

	if (target) {
		_history[opts.replaceState ? 'replaceState' : 'pushState']({ id: cid }, '', href);
		return navigate(target, null).then(() => {});
	}

	location.href = href;
	return new Promise(f => {}); // never resolves
}

/** Callback to inform of a value updates. */



















function page_store(value) {
	const store = writable(value);
	let ready = true;

	function notify() {
		ready = true;
		store.update(val => val);
	}

	function set(new_value) {
		ready = false;
		store.set(new_value);
	}

	function subscribe(run) {
		let old_value;
		return store.subscribe((value) => {
			if (old_value === undefined || (ready && value !== old_value)) {
				run(old_value = value);
			}
		});
	}

	return { notify, set, subscribe };
}

const initial_data = typeof __SAPPER__ !== 'undefined' && __SAPPER__;

let ready = false;
let root_component;
let current_token;
let root_preloaded;
let current_branch = [];
let current_query = '{}';

const stores = {
	page: page_store({}),
	preloading: writable(null),
	session: writable(initial_data && initial_data.session)
};

let $session;
let session_dirty;

stores.session.subscribe(async value => {
	$session = value;

	if (!ready) return;
	session_dirty = true;

	const target = select_target(new URL(location.href));

	const token = current_token = {};
	const { redirect, props, branch } = await hydrate_target(target);
	if (token !== current_token) return; // a secondary navigation happened while we were loading

	await render(redirect, branch, props, target.page);
});

let prefetching


 = null;
function set_prefetching(href, promise) {
	prefetching = { href, promise };
}

let target;
function set_target(element) {
	target = element;
}

let uid = 1;
function set_uid(n) {
	uid = n;
}

let cid;
function set_cid(n) {
	cid = n;
}

const _history = typeof history !== 'undefined' ? history : {
	pushState: (state, title, href) => {},
	replaceState: (state, title, href) => {},
	scrollRestoration: ''
};

const scroll_history = {};

function extract_query(search) {
	const query = Object.create(null);
	if (search.length > 0) {
		search.slice(1).split('&').forEach(searchParam => {
			let [, key, value = ''] = /([^=]*)(?:=(.*))?/.exec(decodeURIComponent(searchParam.replace(/\+/g, ' ')));
			if (typeof query[key] === 'string') query[key] = [query[key]];
			if (typeof query[key] === 'object') (query[key] ).push(value);
			else query[key] = value;
		});
	}
	return query;
}

function select_target(url) {
	if (url.origin !== location.origin) return null;
	if (!url.pathname.startsWith(initial_data.baseUrl)) return null;

	let path = url.pathname.slice(initial_data.baseUrl.length);

	if (path === '') {
		path = '/';
	}

	// avoid accidental clashes between server routes and page routes
	if (ignore.some(pattern => pattern.test(path))) return;

	for (let i = 0; i < routes.length; i += 1) {
		const route = routes[i];

		const match = route.pattern.exec(path);

		if (match) {
			const query = extract_query(url.search);
			const part = route.parts[route.parts.length - 1];
			const params = part.params ? part.params(match) : {};

			const page = { host: location.host, path, query, params };

			return { href: url.href, route, match, page };
		}
	}
}

function handle_error(url) {
	const { host, pathname, search } = location;
	const { session, preloaded, status, error } = initial_data;

	if (!root_preloaded) {
		root_preloaded = preloaded && preloaded[0];
	}

	const props = {
		error,
		status,
		session,
		level0: {
			props: root_preloaded
		},
		level1: {
			props: {
				status,
				error
			},
			component: Error$1
		},
		segments: preloaded

	};
	const query = extract_query(search);
	render(null, [], props, { host, path: pathname, query, params: {} });
}

function scroll_state() {
	return {
		x: pageXOffset,
		y: pageYOffset
	};
}

async function navigate(target, id, noscroll, hash) {
	if (id) {
		// popstate or initial navigation
		cid = id;
	} else {
		const current_scroll = scroll_state();

		// clicked on a link. preserve scroll state
		scroll_history[cid] = current_scroll;

		id = cid = ++uid;
		scroll_history[cid] = noscroll ? current_scroll : { x: 0, y: 0 };
	}

	cid = id;

	if (root_component) stores.preloading.set(true);

	const loaded = prefetching && prefetching.href === target.href ?
		prefetching.promise :
		hydrate_target(target);

	prefetching = null;

	const token = current_token = {};
	const { redirect, props, branch } = await loaded;
	if (token !== current_token) return; // a secondary navigation happened while we were loading

	await render(redirect, branch, props, target.page);
	if (document.activeElement) document.activeElement.blur();

	if (!noscroll) {
		let scroll = scroll_history[id];

		if (hash) {
			// scroll is an element id (from a hash), we need to compute y.
			const deep_linked = document.getElementById(hash.slice(1));

			if (deep_linked) {
				scroll = {
					x: 0,
					y: deep_linked.getBoundingClientRect().top + scrollY
				};
			}
		}

		scroll_history[cid] = scroll;
		if (scroll) scrollTo(scroll.x, scroll.y);
	}
}

async function render(redirect, branch, props, page) {
	if (redirect) return goto(redirect.location, { replaceState: true });

	stores.page.set(page);
	stores.preloading.set(false);

	if (root_component) {
		root_component.$set(props);
	} else {
		props.stores = {
			page: { subscribe: stores.page.subscribe },
			preloading: { subscribe: stores.preloading.subscribe },
			session: stores.session
		};
		props.level0 = {
			props: await root_preloaded
		};
		props.notify = stores.page.notify;

		// first load — remove SSR'd <head> contents
		const start = document.querySelector('#sapper-head-start');
		const end = document.querySelector('#sapper-head-end');

		if (start && end) {
			while (start.nextSibling !== end) detach$1(start.nextSibling);
			detach$1(start);
			detach$1(end);
		}

		root_component = new App({
			target,
			props,
			hydrate: true
		});
	}

	current_branch = branch;
	current_query = JSON.stringify(page.query);
	ready = true;
	session_dirty = false;
}

function part_changed(i, segment, match, stringified_query) {
	// TODO only check query string changes for preload functions
	// that do in fact depend on it (using static analysis or
	// runtime instrumentation)
	if (stringified_query !== current_query) return true;

	const previous = current_branch[i];

	if (!previous) return false;
	if (segment !== previous.segment) return true;
	if (previous.match) {
		if (JSON.stringify(previous.match.slice(1, i + 2)) !== JSON.stringify(match.slice(1, i + 2))) {
			return true;
		}
	}
}

async function hydrate_target(target)



 {
	const { route, page } = target;
	const segments = page.path.split('/').filter(Boolean);

	let redirect = null;

	const props = { error: null, status: 200, segments: [segments[0]] };

	const preload_context = {
		fetch: (url, opts) => fetch(url, opts),
		redirect: (statusCode, location) => {
			if (redirect && (redirect.statusCode !== statusCode || redirect.location !== location)) {
				throw new Error(`Conflicting redirects`);
			}
			redirect = { statusCode, location };
		},
		error: (status, error) => {
			props.error = typeof error === 'string' ? new Error(error) : error;
			props.status = status;
		}
	};

	if (!root_preloaded) {
		root_preloaded = initial_data.preloaded[0] || preload.call(preload_context, {
			host: page.host,
			path: page.path,
			query: page.query,
			params: {}
		}, $session);
	}

	let branch;
	let l = 1;

	try {
		const stringified_query = JSON.stringify(page.query);
		const match = route.pattern.exec(page.path);

		let segment_dirty = false;

		branch = await Promise.all(route.parts.map(async (part, i) => {
			const segment = segments[i];

			if (part_changed(i, segment, match, stringified_query)) segment_dirty = true;

			props.segments[l] = segments[i + 1]; // TODO make this less confusing
			if (!part) return { segment };

			const j = l++;

			if (!session_dirty && !segment_dirty && current_branch[i] && current_branch[i].part === part.i) {
				return current_branch[i];
			}

			segment_dirty = false;

			const { default: component, preload } = await load_component(components[part.i]);

			let preloaded;
			if (ready || !initial_data.preloaded[i + 1]) {
				preloaded = preload
					? await preload.call(preload_context, {
						host: page.host,
						path: page.path,
						query: page.query,
						params: part.params ? part.params(target.match) : {}
					}, $session)
					: {};
			} else {
				preloaded = initial_data.preloaded[i + 1];
			}

			return (props[`level${j}`] = { component, props: preloaded, segment, match, part: part.i });
		}));
	} catch (error) {
		props.error = error;
		props.status = 500;
		branch = [];
	}

	return { redirect, props, branch };
}

function load_css(chunk) {
	const href = `client/${chunk}`;
	if (document.querySelector(`link[href="${href}"]`)) return;

	return new Promise((fulfil, reject) => {
		const link = document.createElement('link');
		link.rel = 'stylesheet';
		link.href = href;

		link.onload = () => fulfil();
		link.onerror = reject;

		document.head.appendChild(link);
	});
}

function load_component(component)


 {
	// TODO this is temporary — once placeholders are
	// always rewritten, scratch the ternary
	const promises = (typeof component.css === 'string' ? [] : component.css.map(load_css));
	promises.unshift(component.js());
	return Promise.all(promises).then(values => values[0]);
}

function detach$1(node) {
	node.parentNode.removeChild(node);
}

function prefetch(href) {
	const target = select_target(new URL(href, document.baseURI));

	if (target) {
		if (!prefetching || href !== prefetching.href) {
			set_prefetching(href, hydrate_target(target));
		}

		return prefetching.promise;
	}
}

function start(opts

) {
	if ('scrollRestoration' in _history) {
		_history.scrollRestoration = 'manual';
	}
	
	// Adopted from Nuxt.js
	// Reset scrollRestoration to auto when leaving page, allowing page reload
	// and back-navigation from other pages to use the browser to restore the
	// scrolling position.
	addEventListener('beforeunload', () => {
		_history.scrollRestoration = 'auto';
	});

	// Setting scrollRestoration to manual again when returning to this page.
	addEventListener('load', () => {
		_history.scrollRestoration = 'manual';
	});

	set_target(opts.target);

	addEventListener('click', handle_click);
	addEventListener('popstate', handle_popstate);

	// prefetch
	addEventListener('touchstart', trigger_prefetch);
	addEventListener('mousemove', handle_mousemove);

	return Promise.resolve().then(() => {
		const { hash, href } = location;

		_history.replaceState({ id: uid }, '', href);

		const url = new URL(location.href);

		if (initial_data.error) return handle_error();

		const target = select_target(url);
		if (target) return navigate(target, uid, true, hash);
	});
}

let mousemove_timeout;

function handle_mousemove(event) {
	clearTimeout(mousemove_timeout);
	mousemove_timeout = setTimeout(() => {
		trigger_prefetch(event);
	}, 20);
}

function trigger_prefetch(event) {
	const a = find_anchor(event.target);
	if (!a || a.rel !== 'prefetch') return;

	prefetch(a.href);
}

function handle_click(event) {
	// Adapted from https://github.com/visionmedia/page.js
	// MIT license https://github.com/visionmedia/page.js#license
	if (which(event) !== 1) return;
	if (event.metaKey || event.ctrlKey || event.shiftKey) return;
	if (event.defaultPrevented) return;

	const a = find_anchor(event.target);
	if (!a) return;

	if (!a.href) return;

	// check if link is inside an svg
	// in this case, both href and target are always inside an object
	const svg = typeof a.href === 'object' && a.href.constructor.name === 'SVGAnimatedString';
	const href = String(svg ? (a).href.baseVal : a.href);

	if (href === location.href) {
		if (!location.hash) event.preventDefault();
		return;
	}

	// Ignore if tag has
	// 1. 'download' attribute
	// 2. rel='external' attribute
	if (a.hasAttribute('download') || a.getAttribute('rel') === 'external') return;

	// Ignore if <a> has a target
	if (svg ? (a).target.baseVal : a.target) return;

	const url = new URL(href);

	// Don't handle hash changes
	if (url.pathname === location.pathname && url.search === location.search) return;

	const target = select_target(url);
	if (target) {
		const noscroll = a.hasAttribute('sapper-noscroll');
		navigate(target, null, noscroll, url.hash);
		event.preventDefault();
		_history.pushState({ id: cid }, '', url.href);
	}
}

function which(event) {
	return event.which === null ? event.button : event.which;
}

function find_anchor(node) {
	while (node && node.nodeName.toUpperCase() !== 'A') node = node.parentNode; // SVG <a> elements have a lowercase name
	return node;
}

function handle_popstate(event) {
	scroll_history[cid] = scroll_state();

	if (event.state) {
		const url = new URL(location.href);
		const target = select_target(url);
		if (target) {
			navigate(target, event.state.id);
		} else {
			location.href = location.href;
		}
	} else {
		// hashchange
		set_uid(uid + 1);
		set_cid(uid);
		_history.replaceState({ id: cid }, '', location.href);
	}
}

const stores$1 = () => getContext(CONTEXT_KEY);

start({
	target: document.querySelector('#sapper')
});

export { Documents as $, TrustButton as A, Br as B, Carousel as C, Divider as D, createEventDispatcher as E, Footer as F, set_style as G, Button as H, Icon as I, DonatorsList as J, FundCards as K, ListOfFeatures as L, Modal as M, set_data_dev as N, Loader as O, Progress as P, empty as Q, group_outros as R, SvelteComponentDev as S, TitleSubTitle as T, check_outros as U, NewsList as V, onMount as W, modals as X, bodyScroll as Y, safeGet as Z, FancyBox as _, append_dev as a, Card as a0, Avatar as a1, SocialsX as a2, SocialsY as a3, Picture as a4, classnames as a5, null_to_empty as a6, EditCard as a7, FormBuilder as a8, bubble as a9, run_all as aA, SearchLine as aB, create_slot as aC, binding_callbacks as aD, bind as aE, add_flush_callback as aF, update_slot as aG, goto as aH, ListItems as aI, Map$2 as aJ, MapMarker as aK, options as aa, LazyToggle as ab, stores$1 as ac, validate_store as ad, component_subscribe as ae, API as af, delay as ag, EditArea as ah, globals as ai, validate_each_argument as aj, destroy_each as ak, _ as al, StoryList as am, find as an, vaccinations as ao, formatTextToBullets as ap, Square as aq, RadioRect as ar, assign as as, is_function as at, get_spread_update as au, get_spread_object as av, DonationButton as aw, toggle_class as ax, exclude_internal_props as ay, listen_dev as az, ContentHolder as b, Comments as c, dispatch_dev as d, element as e, space as f, create_component as g, detach_dev as h, init as i, claim_space as j, claim_element as k, children as l, claim_component as m, claim_text as n, attr_dev as o, add_location as p, query_selector_all as q, insert_dev as r, safe_not_equal as s, text as t, mount_component as u, validate_slots as v, noop as w, transition_in as x, transition_out as y, destroy_component as z };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xpZW50LjAyYjFkZjk0LmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlL2ludGVybmFsL2luZGV4Lm1qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3RvcmUvaW5kZXgubWpzIiwiLi4vLi4vLi4vc3JjL25vZGVfbW9kdWxlcy9Ac2FwcGVyL2ludGVybmFsL3NoYXJlZC5tanMiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9Cci5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQXJyYXkuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19mcmVlR2xvYmFsLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fcm9vdC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX1N5bWJvbC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldFJhd1RhZy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX29iamVjdFRvU3RyaW5nLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUdldFRhZy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNPYmplY3RMaWtlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc1N5bWJvbC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2lzS2V5LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc09iamVjdC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNGdW5jdGlvbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NvcmVKc0RhdGEuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc01hc2tlZC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3RvU291cmNlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzTmF0aXZlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0VmFsdWUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXROYXRpdmUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19uYXRpdmVDcmVhdGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19oYXNoQ2xlYXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19oYXNoRGVsZXRlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faGFzaEdldC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2hhc2hIYXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19oYXNoU2V0LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fSGFzaC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2xpc3RDYWNoZUNsZWFyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9lcS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Fzc29jSW5kZXhPZi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2xpc3RDYWNoZURlbGV0ZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2xpc3RDYWNoZUdldC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2xpc3RDYWNoZUhhcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2xpc3RDYWNoZVNldC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX0xpc3RDYWNoZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX01hcC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcENhY2hlQ2xlYXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc0tleWFibGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRNYXBEYXRhLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbWFwQ2FjaGVEZWxldGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19tYXBDYWNoZUdldC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcENhY2hlSGFzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbWFwQ2FjaGVTZXQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19NYXBDYWNoZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvbWVtb2l6ZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21lbW9pemVDYXBwZWQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zdHJpbmdUb1BhdGguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheU1hcC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VUb1N0cmluZy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdG9TdHJpbmcuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jYXN0UGF0aC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3RvS2V5LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUdldC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvZ2V0LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZGVmaW5lUHJvcGVydHkuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlQXNzaWduVmFsdWUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hc3NpZ25WYWx1ZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2lzSW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlU2V0LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9zZXQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zdGFja0NsZWFyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc3RhY2tEZWxldGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zdGFja0dldC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3N0YWNrSGFzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc3RhY2tTZXQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19TdGFjay5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3NldENhY2hlQWRkLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc2V0Q2FjaGVIYXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19TZXRDYWNoZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FycmF5U29tZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NhY2hlSGFzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZXF1YWxBcnJheXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19VaW50OEFycmF5LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbWFwVG9BcnJheS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3NldFRvQXJyYXkuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19lcXVhbEJ5VGFnLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXJyYXlQdXNoLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUdldEFsbEtleXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheUZpbHRlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvc3R1YkFycmF5LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0U3ltYm9scy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VUaW1lcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VJc0FyZ3VtZW50cy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNBcmd1bWVudHMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3N0dWJGYWxzZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNCdWZmZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzTGVuZ3RoLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzVHlwZWRBcnJheS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VVbmFyeS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX25vZGVVdGlsLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc1R5cGVkQXJyYXkuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheUxpa2VLZXlzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNQcm90b3R5cGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19vdmVyQXJnLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbmF0aXZlS2V5cy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VLZXlzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0FycmF5TGlrZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMva2V5cy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldEFsbEtleXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19lcXVhbE9iamVjdHMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19EYXRhVmlldy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX1Byb21pc2UuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19TZXQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19XZWFrTWFwLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0VGFnLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzRXF1YWxEZWVwLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzRXF1YWwuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXNNYXRjaC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2lzU3RyaWN0Q29tcGFyYWJsZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldE1hdGNoRGF0YS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZU1hdGNoZXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSGFzSW4uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19oYXNQYXRoLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9oYXNJbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VNYXRjaGVzUHJvcGVydHkuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lkZW50aXR5LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVByb3BlcnR5LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVByb3BlcnR5RGVlcC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvcHJvcGVydHkuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXRlcmF0ZWUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jcmVhdGVCYXNlRm9yLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUZvci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VGb3JPd24uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jcmVhdGVCYXNlRWFjaC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VFYWNoLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZU1hcC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvbWFwLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY3JlYXRlRmluZC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VGaW5kSW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3RvTnVtYmVyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy90b0Zpbml0ZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdG9JbnRlZ2VyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9maW5kSW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2ZpbmQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzRW1wdHkuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheUVhY2guanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jb3B5T2JqZWN0LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUFzc2lnbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX25hdGl2ZUtleXNJbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VLZXlzSW4uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2tleXNJbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VBc3NpZ25Jbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Nsb25lQnVmZmVyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY29weUFycmF5LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY29weVN5bWJvbHMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRQcm90b3R5cGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRTeW1ib2xzSW4uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jb3B5U3ltYm9sc0luLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0QWxsS2V5c0luLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faW5pdENsb25lQXJyYXkuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jbG9uZUFycmF5QnVmZmVyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY2xvbmVEYXRhVmlldy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Nsb25lUmVnRXhwLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY2xvbmVTeW1ib2wuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jbG9uZVR5cGVkQXJyYXkuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pbml0Q2xvbmVCeVRhZy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VDcmVhdGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pbml0Q2xvbmVPYmplY3QuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXNNYXAuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzTWFwLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzU2V0LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc1NldC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VDbG9uZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvY2xvbmVEZWVwLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JvZHktc2Nyb2xsLWxvY2svbGliL2JvZHlTY3JvbGxMb2NrLmVzbS5qcyIsIi4uLy4uLy4uL3NyYy91dGlscy9ib2R5U2Nyb2xsLmpzIiwiLi4vLi4vLi4vc3JjL3V0aWxzL3V1aWQuanMiLCIuLi8uLi8uLi9zcmMvdXRpbHMvZGVsYXkuanMiLCIuLi8uLi8uLi9zcmMvdXRpbHMvc2FmZUdldC5qcyIsIi4uLy4uLy4uL3NyYy91dGlscy93YWl0VW50aWwuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY2xhc3NuYW1lcy9pbmRleC5qcyIsIi4uLy4uLy4uL3NyYy91dGlscy90b0NTU1N0cmluZy5qcyIsIi4uLy4uLy4uL3NyYy91dGlscy9nZXRTY3JvbGxQZXJjZW50LmpzIiwiLi4vLi4vLi4vc3JjL3V0aWxzL2Zvcm1hdFRleHRUb0J1bGxldHMuanMiLCIuLi8uLi8uLi9zcmMvdXRpbHMvZGlzYWJsZURvdWJsZVRhcFpvb20uanMiLCIuLi8uLi8uLi9zcmMvdXRpbHMvc3RvcFByb3BhZ2F0aW9uSW5SYW5nZXMuanMiLCIuLi8uLi8uLi9zcmMvY29uZmlnL3NldHVwLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS1pY29ucy9jb21wb25lbnRzL0ljb25CYXNlLnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUtaWNvbnMvZmEvRmFBdC5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlLWljb25zL2ZhL0ZhTW9vbi5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlLWljb25zL21kL01kTGluay5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlLWljb25zL2dpL0dpTWFsZS5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlLWljb25zL21kL01kRWRpdC5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlLWljb25zL2ZhL0ZhSGVhcnQuc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS1pY29ucy9mYS9GYVZpYmVyLnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUtaWNvbnMvZmEvRmFTaGFyZS5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlLWljb25zL21kL01kQ2hlY2suc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS1pY29ucy9naS9HaUZlbWFsZS5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlLWljb25zL2lvL0lvTWRTZW5kLnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUtaWNvbnMvZ28vR29TZWFyY2guc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS1pY29ucy9pby9Jb01kQ2xvc2Uuc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS1pY29ucy9mYS9GYVBob25lQWx0LnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUtaWNvbnMvZmEvRmFGYWNlYm9va0Yuc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS1pY29ucy9mYS9GYVJlZ1NxdWFyZS5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlLWljb25zL3RpL1RpU3RhcmJ1cnN0LnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUtaWNvbnMvZmEvRmFEb2xsYXJTaWduLnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUtaWNvbnMvZmEvRmFDYWxlbmRhckFsdC5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlLWljb25zL2ZhL0ZhQ2hlY2tTcXVhcmUuc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS1pY29ucy9tZC9NZENsb3VkVXBsb2FkLnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUtaWNvbnMvbWQvTWRSZW1vdmVSZWRFeWUuc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS1pY29ucy9mYS9GYU1hcE1hcmtlckFsdC5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlLWljb25zL2ZhL0ZhVGVsZWdyYW1QbGFuZS5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlLWljb25zL2ZhL0ZhTG9uZ0Fycm93QWx0VXAuc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS1pY29ucy9mYS9GYUxvbmdBcnJvd0FsdERvd24uc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS1pY29ucy9mYS9GYUxvbmdBcnJvd0FsdExlZnQuc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS1pY29ucy9mYS9GYUxvbmdBcnJvd0FsdFJpZ2h0LnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUtaWNvbnMvbWQvTWRLZXlib2FyZEFycm93VXAuc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS1pY29ucy9tZC9NZEtleWJvYXJkQXJyb3dMZWZ0LnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUtaWNvbnMvbWQvTWRLZXlib2FyZEFycm93RG93bi5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlLWljb25zL21kL01kS2V5Ym9hcmRBcnJvd1JpZ2h0LnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUtaWNvbnMvaW8vSW9Jb3NDaGVja21hcmtDaXJjbGUuc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS1pY29ucy9pby9Jb0lvc0Nsb3NlQ2lyY2xlT3V0bGluZS5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29uZmlnL2ljb25zLmpzIiwiLi4vLi4vLi4vc3JjL2NvbmZpZy9lbmRwb2ludHMuanMiLCIuLi8uLi8uLi9zcmMvY29uZmlnL29wdGlvbnMuanMiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9JY29uLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL0Zvcm0uc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvQ2FyZC5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlL2Vhc2luZy9pbmRleC5tanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3RyYW5zaXRpb24vaW5kZXgubWpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nyb3NzLWZldGNoL2Rpc3QvYnJvd3Nlci1wb2x5ZmlsbC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9idG9hL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3psLWZldGNoL2Rpc3QvaW5kZXguanMiLCIuLi8uLi8uLi9zcmMvc2VydmljZXMvYXBpLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2RheWpzL2RheWpzLm1pbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9kYXlqcy9wbHVnaW4vcmVsYXRpdmVUaW1lLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2RheWpzL3BsdWdpbi91dGMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZGF5anMvcGx1Z2luL3dlZWtkYXkuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZGF5anMvbG9jYWxlL2VuLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2RheWpzL2xvY2FsZS9ydS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9kYXlqcy9sb2NhbGUvdWsuanMiLCIuLi8uLi8uLi9zcmMvc2VydmljZXMvRGF0ZXMuanMiLCIuLi8uLi8uLi9zcmMvc2VydmljZXMvU3dpcGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvanMtc3RvcmFnZS9qcy5zdG9yYWdlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pzLWNvb2tpZS9zcmMvanMuY29va2llLmpzIiwiLi4vLi4vLi4vc3JjL3NlcnZpY2VzL1N0b3JhZ2VzLmpzIiwiLi4vLi4vLi4vc3JjL3N0b3JlL21vZGFscy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUtcGVyc2lzdGVudC1zdG9yZS9kaXN0L2xvY2FsLm1qcyIsIi4uLy4uLy4uL3NyYy9zdG9yZS9vcmdhbml6YXRpb24uanMiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9Qb3J0YWwuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvTW9kYWwuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvU3F1YXJlLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL1BpY3R1cmUuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvQXZhdGFyLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL0J1dHRvbi5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9EaXZpZGVyLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL1Byb2dyZXNzLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL0ZhbmN5Qm94LnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL0Nhcm91c2VsLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL0VkaXRBcmVhLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL0VkaXRDYXJkLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL0xhenlUb2dnbGUuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvbG9hZGVyL0xvYWRlci5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9GaWVsZEVycm9ycy5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9maWVsZHMvSW5wdXQuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvZmllbGRzL1NlbGVjdC5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9maWVsZHMvUmVhZEZpZWxkLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL2ZpZWxkcy9SYWRpb1JlY3Quc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvZmllbGRzL3VwbG9hZEZpbGVzL1VwbG9hZEJveC5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9maWVsZHMvdXBsb2FkRmlsZXMvVXBsb2FkQm94R3JvdXAuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvZmllbGRzL0F2YXRhclVwbG9hZC5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9maWVsZHMvY2hlY2tib3hlcy9DaGVja2JveC5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9maWVsZHMvY2hlY2tib3hlcy9DaGVja2JveEdyb3VwLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL0Zvcm1CdWlsZGVyLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL2FwcC9IZWFkZXIuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvYXBwL0Zvb3Rlci5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9hcHAvU29jaWFsc1guc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvYXBwL1NvY2lhbHNZLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL2FwcC9Eb2N1bWVudHMuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvYXBwL0xpc3RJdGVtcy5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9hcHAvU3RvcnlMaXN0LnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL2FwcC9UcnVzdEJ1dHRvbi5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9hcHAvVGl0bGVTdWJUaXRsZS5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9hcHAvRG9uYXRpb25CdXR0b24uc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvYXBwL0xpc3RPZkZlYXR1cmVzLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL21hcC9jb250ZXh0LmpzIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvbWFwL01hcC5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9tYXAvTWFwTWFya2VyLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL2NvbW1lbnRzL0NvbW1lbnQuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvY29tbWVudHMvQ29tbWVudHMuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvZG9uYXRvcnMvRG9uYXRvcnNDYXJkLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL2RvbmF0b3JzL0RvbmF0b3JzTGlzdC5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9uZXdzTGlzdC9OZXdzSXRlbS5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9uZXdzTGlzdC9OZXdzTGlzdC5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9mdW5kQ2FyZHMvRnVuZENhcmQuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvZnVuZENhcmRzL0Z1bmRDYXJkcy5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvcm91dGVzL19sYXlvdXQuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy9fZXJyb3Iuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL25vZGVfbW9kdWxlcy9Ac2FwcGVyL2ludGVybmFsL0FwcC5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvbm9kZV9tb2R1bGVzL0BzYXBwZXIvaW50ZXJuYWwvbWFuaWZlc3QtY2xpZW50Lm1qcyIsIi4uLy4uLy4uL3NyYy9ub2RlX21vZHVsZXMvQHNhcHBlci9hcHAubWpzIiwiLi4vLi4vLi4vc3JjL2NsaWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBub29wKCkgeyB9XG5jb25zdCBpZGVudGl0eSA9IHggPT4geDtcbmZ1bmN0aW9uIGFzc2lnbih0YXIsIHNyYykge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBmb3IgKGNvbnN0IGsgaW4gc3JjKVxuICAgICAgICB0YXJba10gPSBzcmNba107XG4gICAgcmV0dXJuIHRhcjtcbn1cbmZ1bmN0aW9uIGlzX3Byb21pc2UodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJztcbn1cbmZ1bmN0aW9uIGFkZF9sb2NhdGlvbihlbGVtZW50LCBmaWxlLCBsaW5lLCBjb2x1bW4sIGNoYXIpIHtcbiAgICBlbGVtZW50Ll9fc3ZlbHRlX21ldGEgPSB7XG4gICAgICAgIGxvYzogeyBmaWxlLCBsaW5lLCBjb2x1bW4sIGNoYXIgfVxuICAgIH07XG59XG5mdW5jdGlvbiBydW4oZm4pIHtcbiAgICByZXR1cm4gZm4oKTtcbn1cbmZ1bmN0aW9uIGJsYW5rX29iamVjdCgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZShudWxsKTtcbn1cbmZ1bmN0aW9uIHJ1bl9hbGwoZm5zKSB7XG4gICAgZm5zLmZvckVhY2gocnVuKTtcbn1cbmZ1bmN0aW9uIGlzX2Z1bmN0aW9uKHRoaW5nKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGluZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmZ1bmN0aW9uIHNhZmVfbm90X2VxdWFsKGEsIGIpIHtcbiAgICByZXR1cm4gYSAhPSBhID8gYiA9PSBiIDogYSAhPT0gYiB8fCAoKGEgJiYgdHlwZW9mIGEgPT09ICdvYmplY3QnKSB8fCB0eXBlb2YgYSA9PT0gJ2Z1bmN0aW9uJyk7XG59XG5mdW5jdGlvbiBub3RfZXF1YWwoYSwgYikge1xuICAgIHJldHVybiBhICE9IGEgPyBiID09IGIgOiBhICE9PSBiO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVfc3RvcmUoc3RvcmUsIG5hbWUpIHtcbiAgICBpZiAoc3RvcmUgIT0gbnVsbCAmJiB0eXBlb2Ygc3RvcmUuc3Vic2NyaWJlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJyR7bmFtZX0nIGlzIG5vdCBhIHN0b3JlIHdpdGggYSAnc3Vic2NyaWJlJyBtZXRob2RgKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzdWJzY3JpYmUoc3RvcmUsIC4uLmNhbGxiYWNrcykge1xuICAgIGlmIChzdG9yZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBub29wO1xuICAgIH1cbiAgICBjb25zdCB1bnN1YiA9IHN0b3JlLnN1YnNjcmliZSguLi5jYWxsYmFja3MpO1xuICAgIHJldHVybiB1bnN1Yi51bnN1YnNjcmliZSA/ICgpID0+IHVuc3ViLnVuc3Vic2NyaWJlKCkgOiB1bnN1Yjtcbn1cbmZ1bmN0aW9uIGdldF9zdG9yZV92YWx1ZShzdG9yZSkge1xuICAgIGxldCB2YWx1ZTtcbiAgICBzdWJzY3JpYmUoc3RvcmUsIF8gPT4gdmFsdWUgPSBfKSgpO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGNvbXBvbmVudF9zdWJzY3JpYmUoY29tcG9uZW50LCBzdG9yZSwgY2FsbGJhY2spIHtcbiAgICBjb21wb25lbnQuJCQub25fZGVzdHJveS5wdXNoKHN1YnNjcmliZShzdG9yZSwgY2FsbGJhY2spKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZV9zbG90KGRlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgZm4pIHtcbiAgICBpZiAoZGVmaW5pdGlvbikge1xuICAgICAgICBjb25zdCBzbG90X2N0eCA9IGdldF9zbG90X2NvbnRleHQoZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBmbik7XG4gICAgICAgIHJldHVybiBkZWZpbml0aW9uWzBdKHNsb3RfY3R4KTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRfc2xvdF9jb250ZXh0KGRlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgZm4pIHtcbiAgICByZXR1cm4gZGVmaW5pdGlvblsxXSAmJiBmblxuICAgICAgICA/IGFzc2lnbigkJHNjb3BlLmN0eC5zbGljZSgpLCBkZWZpbml0aW9uWzFdKGZuKGN0eCkpKVxuICAgICAgICA6ICQkc2NvcGUuY3R4O1xufVxuZnVuY3Rpb24gZ2V0X3Nsb3RfY2hhbmdlcyhkZWZpbml0aW9uLCAkJHNjb3BlLCBkaXJ0eSwgZm4pIHtcbiAgICBpZiAoZGVmaW5pdGlvblsyXSAmJiBmbikge1xuICAgICAgICBjb25zdCBsZXRzID0gZGVmaW5pdGlvblsyXShmbihkaXJ0eSkpO1xuICAgICAgICBpZiAoJCRzY29wZS5kaXJ0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbGV0cztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGxldHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBjb25zdCBtZXJnZWQgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IE1hdGgubWF4KCQkc2NvcGUuZGlydHkubGVuZ3RoLCBsZXRzLmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VkW2ldID0gJCRzY29wZS5kaXJ0eVtpXSB8IGxldHNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVyZ2VkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkJHNjb3BlLmRpcnR5IHwgbGV0cztcbiAgICB9XG4gICAgcmV0dXJuICQkc2NvcGUuZGlydHk7XG59XG5mdW5jdGlvbiB1cGRhdGVfc2xvdChzbG90LCBzbG90X2RlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgZGlydHksIGdldF9zbG90X2NoYW5nZXNfZm4sIGdldF9zbG90X2NvbnRleHRfZm4pIHtcbiAgICBjb25zdCBzbG90X2NoYW5nZXMgPSBnZXRfc2xvdF9jaGFuZ2VzKHNsb3RfZGVmaW5pdGlvbiwgJCRzY29wZSwgZGlydHksIGdldF9zbG90X2NoYW5nZXNfZm4pO1xuICAgIGlmIChzbG90X2NoYW5nZXMpIHtcbiAgICAgICAgY29uc3Qgc2xvdF9jb250ZXh0ID0gZ2V0X3Nsb3RfY29udGV4dChzbG90X2RlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgZ2V0X3Nsb3RfY29udGV4dF9mbik7XG4gICAgICAgIHNsb3QucChzbG90X2NvbnRleHQsIHNsb3RfY2hhbmdlcyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZXhjbHVkZV9pbnRlcm5hbF9wcm9wcyhwcm9wcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3QgayBpbiBwcm9wcylcbiAgICAgICAgaWYgKGtbMF0gIT09ICckJylcbiAgICAgICAgICAgIHJlc3VsdFtrXSA9IHByb3BzW2tdO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjb21wdXRlX3Jlc3RfcHJvcHMocHJvcHMsIGtleXMpIHtcbiAgICBjb25zdCByZXN0ID0ge307XG4gICAga2V5cyA9IG5ldyBTZXQoa2V5cyk7XG4gICAgZm9yIChjb25zdCBrIGluIHByb3BzKVxuICAgICAgICBpZiAoIWtleXMuaGFzKGspICYmIGtbMF0gIT09ICckJylcbiAgICAgICAgICAgIHJlc3Rba10gPSBwcm9wc1trXTtcbiAgICByZXR1cm4gcmVzdDtcbn1cbmZ1bmN0aW9uIG9uY2UoZm4pIHtcbiAgICBsZXQgcmFuID0gZmFsc2U7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIGlmIChyYW4pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHJhbiA9IHRydWU7XG4gICAgICAgIGZuLmNhbGwodGhpcywgLi4uYXJncyk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIG51bGxfdG9fZW1wdHkodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWU7XG59XG5mdW5jdGlvbiBzZXRfc3RvcmVfdmFsdWUoc3RvcmUsIHJldCwgdmFsdWUgPSByZXQpIHtcbiAgICBzdG9yZS5zZXQodmFsdWUpO1xuICAgIHJldHVybiByZXQ7XG59XG5jb25zdCBoYXNfcHJvcCA9IChvYmosIHByb3ApID0+IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xuZnVuY3Rpb24gYWN0aW9uX2Rlc3Ryb3llcihhY3Rpb25fcmVzdWx0KSB7XG4gICAgcmV0dXJuIGFjdGlvbl9yZXN1bHQgJiYgaXNfZnVuY3Rpb24oYWN0aW9uX3Jlc3VsdC5kZXN0cm95KSA/IGFjdGlvbl9yZXN1bHQuZGVzdHJveSA6IG5vb3A7XG59XG5cbmNvbnN0IGlzX2NsaWVudCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xubGV0IG5vdyA9IGlzX2NsaWVudFxuICAgID8gKCkgPT4gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpXG4gICAgOiAoKSA9PiBEYXRlLm5vdygpO1xubGV0IHJhZiA9IGlzX2NsaWVudCA/IGNiID0+IHJlcXVlc3RBbmltYXRpb25GcmFtZShjYikgOiBub29wO1xuLy8gdXNlZCBpbnRlcm5hbGx5IGZvciB0ZXN0aW5nXG5mdW5jdGlvbiBzZXRfbm93KGZuKSB7XG4gICAgbm93ID0gZm47XG59XG5mdW5jdGlvbiBzZXRfcmFmKGZuKSB7XG4gICAgcmFmID0gZm47XG59XG5cbmNvbnN0IHRhc2tzID0gbmV3IFNldCgpO1xuZnVuY3Rpb24gcnVuX3Rhc2tzKG5vdykge1xuICAgIHRhc2tzLmZvckVhY2godGFzayA9PiB7XG4gICAgICAgIGlmICghdGFzay5jKG5vdykpIHtcbiAgICAgICAgICAgIHRhc2tzLmRlbGV0ZSh0YXNrKTtcbiAgICAgICAgICAgIHRhc2suZigpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHRhc2tzLnNpemUgIT09IDApXG4gICAgICAgIHJhZihydW5fdGFza3MpO1xufVxuLyoqXG4gKiBGb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5IVxuICovXG5mdW5jdGlvbiBjbGVhcl9sb29wcygpIHtcbiAgICB0YXNrcy5jbGVhcigpO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHRhc2sgdGhhdCBydW5zIG9uIGVhY2ggcmFmIGZyYW1lXG4gKiB1bnRpbCBpdCByZXR1cm5zIGEgZmFsc3kgdmFsdWUgb3IgaXMgYWJvcnRlZFxuICovXG5mdW5jdGlvbiBsb29wKGNhbGxiYWNrKSB7XG4gICAgbGV0IHRhc2s7XG4gICAgaWYgKHRhc2tzLnNpemUgPT09IDApXG4gICAgICAgIHJhZihydW5fdGFza3MpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHByb21pc2U6IG5ldyBQcm9taXNlKGZ1bGZpbGwgPT4ge1xuICAgICAgICAgICAgdGFza3MuYWRkKHRhc2sgPSB7IGM6IGNhbGxiYWNrLCBmOiBmdWxmaWxsIH0pO1xuICAgICAgICB9KSxcbiAgICAgICAgYWJvcnQoKSB7XG4gICAgICAgICAgICB0YXNrcy5kZWxldGUodGFzayk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5mdW5jdGlvbiBhcHBlbmQodGFyZ2V0LCBub2RlKSB7XG4gICAgdGFyZ2V0LmFwcGVuZENoaWxkKG5vZGUpO1xufVxuZnVuY3Rpb24gaW5zZXJ0KHRhcmdldCwgbm9kZSwgYW5jaG9yKSB7XG4gICAgdGFyZ2V0Lmluc2VydEJlZm9yZShub2RlLCBhbmNob3IgfHwgbnVsbCk7XG59XG5mdW5jdGlvbiBkZXRhY2gobm9kZSkge1xuICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbn1cbmZ1bmN0aW9uIGRlc3Ryb3lfZWFjaChpdGVyYXRpb25zLCBkZXRhY2hpbmcpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJhdGlvbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKGl0ZXJhdGlvbnNbaV0pXG4gICAgICAgICAgICBpdGVyYXRpb25zW2ldLmQoZGV0YWNoaW5nKTtcbiAgICB9XG59XG5mdW5jdGlvbiBlbGVtZW50KG5hbWUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuYW1lKTtcbn1cbmZ1bmN0aW9uIGVsZW1lbnRfaXMobmFtZSwgaXMpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuYW1lLCB7IGlzIH0pO1xufVxuZnVuY3Rpb24gb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllcyhvYmosIGV4Y2x1ZGUpIHtcbiAgICBjb25zdCB0YXJnZXQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGsgaW4gb2JqKSB7XG4gICAgICAgIGlmIChoYXNfcHJvcChvYmosIGspXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAmJiBleGNsdWRlLmluZGV4T2YoaykgPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICB0YXJnZXRba10gPSBvYmpba107XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIHN2Z19lbGVtZW50KG5hbWUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsIG5hbWUpO1xufVxuZnVuY3Rpb24gdGV4dChkYXRhKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGRhdGEpO1xufVxuZnVuY3Rpb24gc3BhY2UoKSB7XG4gICAgcmV0dXJuIHRleHQoJyAnKTtcbn1cbmZ1bmN0aW9uIGVtcHR5KCkge1xuICAgIHJldHVybiB0ZXh0KCcnKTtcbn1cbmZ1bmN0aW9uIGxpc3Rlbihub2RlLCBldmVudCwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgcmV0dXJuICgpID0+IG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiBwcmV2ZW50X2RlZmF1bHQoZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIH07XG59XG5mdW5jdGlvbiBzdG9wX3Byb3BhZ2F0aW9uKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBldmVudCk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHNlbGYoZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gdGhpcylcbiAgICAgICAgICAgIGZuLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIH07XG59XG5mdW5jdGlvbiBhdHRyKG5vZGUsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbClcbiAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlKTtcbiAgICBlbHNlIGlmIChub2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGUpICE9PSB2YWx1ZSlcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlLCB2YWx1ZSk7XG59XG5mdW5jdGlvbiBzZXRfYXR0cmlidXRlcyhub2RlLCBhdHRyaWJ1dGVzKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IGRlc2NyaXB0b3JzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMobm9kZS5fX3Byb3RvX18pO1xuICAgIGZvciAoY29uc3Qga2V5IGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZXNba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleSA9PT0gJ3N0eWxlJykge1xuICAgICAgICAgICAgbm9kZS5zdHlsZS5jc3NUZXh0ID0gYXR0cmlidXRlc1trZXldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleSA9PT0gJ19fdmFsdWUnKSB7XG4gICAgICAgICAgICBub2RlLnZhbHVlID0gbm9kZVtrZXldID0gYXR0cmlidXRlc1trZXldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRlc2NyaXB0b3JzW2tleV0gJiYgZGVzY3JpcHRvcnNba2V5XS5zZXQpIHtcbiAgICAgICAgICAgIG5vZGVba2V5XSA9IGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGF0dHIobm9kZSwga2V5LCBhdHRyaWJ1dGVzW2tleV0pO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gc2V0X3N2Z19hdHRyaWJ1dGVzKG5vZGUsIGF0dHJpYnV0ZXMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIGF0dHIobm9kZSwga2V5LCBhdHRyaWJ1dGVzW2tleV0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNldF9jdXN0b21fZWxlbWVudF9kYXRhKG5vZGUsIHByb3AsIHZhbHVlKSB7XG4gICAgaWYgKHByb3AgaW4gbm9kZSkge1xuICAgICAgICBub2RlW3Byb3BdID0gdmFsdWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhdHRyKG5vZGUsIHByb3AsIHZhbHVlKTtcbiAgICB9XG59XG5mdW5jdGlvbiB4bGlua19hdHRyKG5vZGUsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICBub2RlLnNldEF0dHJpYnV0ZU5TKCdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJywgYXR0cmlidXRlLCB2YWx1ZSk7XG59XG5mdW5jdGlvbiBnZXRfYmluZGluZ19ncm91cF92YWx1ZShncm91cCwgX192YWx1ZSwgY2hlY2tlZCkge1xuICAgIGNvbnN0IHZhbHVlID0gbmV3IFNldCgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JvdXAubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKGdyb3VwW2ldLmNoZWNrZWQpXG4gICAgICAgICAgICB2YWx1ZS5hZGQoZ3JvdXBbaV0uX192YWx1ZSk7XG4gICAgfVxuICAgIGlmICghY2hlY2tlZCkge1xuICAgICAgICB2YWx1ZS5kZWxldGUoX192YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBBcnJheS5mcm9tKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHRvX251bWJlcih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gJycgPyB1bmRlZmluZWQgOiArdmFsdWU7XG59XG5mdW5jdGlvbiB0aW1lX3Jhbmdlc190b19hcnJheShyYW5nZXMpIHtcbiAgICBjb25zdCBhcnJheSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGFycmF5LnB1c2goeyBzdGFydDogcmFuZ2VzLnN0YXJ0KGkpLCBlbmQ6IHJhbmdlcy5lbmQoaSkgfSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbmZ1bmN0aW9uIGNoaWxkcmVuKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShlbGVtZW50LmNoaWxkTm9kZXMpO1xufVxuZnVuY3Rpb24gY2xhaW1fZWxlbWVudChub2RlcywgbmFtZSwgYXR0cmlidXRlcywgc3ZnKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIGlmIChub2RlLm5vZGVOYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgICBsZXQgaiA9IDA7XG4gICAgICAgICAgICBjb25zdCByZW1vdmUgPSBbXTtcbiAgICAgICAgICAgIHdoaWxlIChqIDwgbm9kZS5hdHRyaWJ1dGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IG5vZGUuYXR0cmlidXRlc1tqKytdO1xuICAgICAgICAgICAgICAgIGlmICghYXR0cmlidXRlc1thdHRyaWJ1dGUubmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlLnB1c2goYXR0cmlidXRlLm5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgcmVtb3ZlLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUocmVtb3ZlW2tdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBub2Rlcy5zcGxpY2UoaSwgMSlbMF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN2ZyA/IHN2Z19lbGVtZW50KG5hbWUpIDogZWxlbWVudChuYW1lKTtcbn1cbmZ1bmN0aW9uIGNsYWltX3RleHQobm9kZXMsIGRhdGEpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDMpIHtcbiAgICAgICAgICAgIG5vZGUuZGF0YSA9ICcnICsgZGF0YTtcbiAgICAgICAgICAgIHJldHVybiBub2Rlcy5zcGxpY2UoaSwgMSlbMF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRleHQoZGF0YSk7XG59XG5mdW5jdGlvbiBjbGFpbV9zcGFjZShub2Rlcykge1xuICAgIHJldHVybiBjbGFpbV90ZXh0KG5vZGVzLCAnICcpO1xufVxuZnVuY3Rpb24gc2V0X2RhdGEodGV4dCwgZGF0YSkge1xuICAgIGRhdGEgPSAnJyArIGRhdGE7XG4gICAgaWYgKHRleHQud2hvbGVUZXh0ICE9PSBkYXRhKVxuICAgICAgICB0ZXh0LmRhdGEgPSBkYXRhO1xufVxuZnVuY3Rpb24gc2V0X2lucHV0X3ZhbHVlKGlucHV0LCB2YWx1ZSkge1xuICAgIGlucHV0LnZhbHVlID0gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWU7XG59XG5mdW5jdGlvbiBzZXRfaW5wdXRfdHlwZShpbnB1dCwgdHlwZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGlucHV0LnR5cGUgPSB0eXBlO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgfVxufVxuZnVuY3Rpb24gc2V0X3N0eWxlKG5vZGUsIGtleSwgdmFsdWUsIGltcG9ydGFudCkge1xuICAgIG5vZGUuc3R5bGUuc2V0UHJvcGVydHkoa2V5LCB2YWx1ZSwgaW1wb3J0YW50ID8gJ2ltcG9ydGFudCcgOiAnJyk7XG59XG5mdW5jdGlvbiBzZWxlY3Rfb3B0aW9uKHNlbGVjdCwgdmFsdWUpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlbGVjdC5vcHRpb25zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbiA9IHNlbGVjdC5vcHRpb25zW2ldO1xuICAgICAgICBpZiAob3B0aW9uLl9fdmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gc2VsZWN0X29wdGlvbnMoc2VsZWN0LCB2YWx1ZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VsZWN0Lm9wdGlvbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9uID0gc2VsZWN0Lm9wdGlvbnNbaV07XG4gICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IH52YWx1ZS5pbmRleE9mKG9wdGlvbi5fX3ZhbHVlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZWxlY3RfdmFsdWUoc2VsZWN0KSB7XG4gICAgY29uc3Qgc2VsZWN0ZWRfb3B0aW9uID0gc2VsZWN0LnF1ZXJ5U2VsZWN0b3IoJzpjaGVja2VkJykgfHwgc2VsZWN0Lm9wdGlvbnNbMF07XG4gICAgcmV0dXJuIHNlbGVjdGVkX29wdGlvbiAmJiBzZWxlY3RlZF9vcHRpb24uX192YWx1ZTtcbn1cbmZ1bmN0aW9uIHNlbGVjdF9tdWx0aXBsZV92YWx1ZShzZWxlY3QpIHtcbiAgICByZXR1cm4gW10ubWFwLmNhbGwoc2VsZWN0LnF1ZXJ5U2VsZWN0b3JBbGwoJzpjaGVja2VkJyksIG9wdGlvbiA9PiBvcHRpb24uX192YWx1ZSk7XG59XG4vLyB1bmZvcnR1bmF0ZWx5IHRoaXMgY2FuJ3QgYmUgYSBjb25zdGFudCBhcyB0aGF0IHdvdWxkbid0IGJlIHRyZWUtc2hha2VhYmxlXG4vLyBzbyB3ZSBjYWNoZSB0aGUgcmVzdWx0IGluc3RlYWRcbmxldCBjcm9zc29yaWdpbjtcbmZ1bmN0aW9uIGlzX2Nyb3Nzb3JpZ2luKCkge1xuICAgIGlmIChjcm9zc29yaWdpbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNyb3Nzb3JpZ2luID0gZmFsc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnBhcmVudCkge1xuICAgICAgICAgICAgICAgIHZvaWQgd2luZG93LnBhcmVudC5kb2N1bWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNyb3Nzb3JpZ2luID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3Jvc3NvcmlnaW47XG59XG5mdW5jdGlvbiBhZGRfcmVzaXplX2xpc3RlbmVyKG5vZGUsIGZuKSB7XG4gICAgY29uc3QgY29tcHV0ZWRfc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICAgIGNvbnN0IHpfaW5kZXggPSAocGFyc2VJbnQoY29tcHV0ZWRfc3R5bGUuekluZGV4KSB8fCAwKSAtIDE7XG4gICAgaWYgKGNvbXB1dGVkX3N0eWxlLnBvc2l0aW9uID09PSAnc3RhdGljJykge1xuICAgICAgICBub2RlLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICB9XG4gICAgY29uc3QgaWZyYW1lID0gZWxlbWVudCgnaWZyYW1lJyk7XG4gICAgaWZyYW1lLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCBgZGlzcGxheTogYmxvY2s7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiAwOyBsZWZ0OiAwOyB3aWR0aDogMTAwJTsgaGVpZ2h0OiAxMDAlOyBgICtcbiAgICAgICAgYG92ZXJmbG93OiBoaWRkZW47IGJvcmRlcjogMDsgb3BhY2l0eTogMDsgcG9pbnRlci1ldmVudHM6IG5vbmU7IHotaW5kZXg6ICR7el9pbmRleH07YCk7XG4gICAgaWZyYW1lLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuICAgIGlmcmFtZS50YWJJbmRleCA9IC0xO1xuICAgIGNvbnN0IGNyb3Nzb3JpZ2luID0gaXNfY3Jvc3NvcmlnaW4oKTtcbiAgICBsZXQgdW5zdWJzY3JpYmU7XG4gICAgaWYgKGNyb3Nzb3JpZ2luKSB7XG4gICAgICAgIGlmcmFtZS5zcmMgPSBgZGF0YTp0ZXh0L2h0bWwsPHNjcmlwdD5vbnJlc2l6ZT1mdW5jdGlvbigpe3BhcmVudC5wb3N0TWVzc2FnZSgwLCcqJyl9PC9zY3JpcHQ+YDtcbiAgICAgICAgdW5zdWJzY3JpYmUgPSBsaXN0ZW4od2luZG93LCAnbWVzc2FnZScsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gaWZyYW1lLmNvbnRlbnRXaW5kb3cpXG4gICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZnJhbWUuc3JjID0gJ2Fib3V0OmJsYW5rJztcbiAgICAgICAgaWZyYW1lLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlID0gbGlzdGVuKGlmcmFtZS5jb250ZW50V2luZG93LCAncmVzaXplJywgZm4pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBhcHBlbmQobm9kZSwgaWZyYW1lKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpZiAoY3Jvc3NvcmlnaW4pIHtcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodW5zdWJzY3JpYmUgJiYgaWZyYW1lLmNvbnRlbnRXaW5kb3cpIHtcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZGV0YWNoKGlmcmFtZSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRvZ2dsZV9jbGFzcyhlbGVtZW50LCBuYW1lLCB0b2dnbGUpIHtcbiAgICBlbGVtZW50LmNsYXNzTGlzdFt0b2dnbGUgPyAnYWRkJyA6ICdyZW1vdmUnXShuYW1lKTtcbn1cbmZ1bmN0aW9uIGN1c3RvbV9ldmVudCh0eXBlLCBkZXRhaWwpIHtcbiAgICBjb25zdCBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XG4gICAgZS5pbml0Q3VzdG9tRXZlbnQodHlwZSwgZmFsc2UsIGZhbHNlLCBkZXRhaWwpO1xuICAgIHJldHVybiBlO1xufVxuZnVuY3Rpb24gcXVlcnlfc2VsZWN0b3JfYWxsKHNlbGVjdG9yLCBwYXJlbnQgPSBkb2N1bWVudC5ib2R5KSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20ocGFyZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKTtcbn1cbmNsYXNzIEh0bWxUYWcge1xuICAgIGNvbnN0cnVjdG9yKGFuY2hvciA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5hID0gYW5jaG9yO1xuICAgICAgICB0aGlzLmUgPSB0aGlzLm4gPSBudWxsO1xuICAgIH1cbiAgICBtKGh0bWwsIHRhcmdldCwgYW5jaG9yID0gbnVsbCkge1xuICAgICAgICBpZiAoIXRoaXMuZSkge1xuICAgICAgICAgICAgdGhpcy5lID0gZWxlbWVudCh0YXJnZXQubm9kZU5hbWUpO1xuICAgICAgICAgICAgdGhpcy50ID0gdGFyZ2V0O1xuICAgICAgICAgICAgdGhpcy5oKGh0bWwpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaShhbmNob3IpO1xuICAgIH1cbiAgICBoKGh0bWwpIHtcbiAgICAgICAgdGhpcy5lLmlubmVySFRNTCA9IGh0bWw7XG4gICAgICAgIHRoaXMubiA9IEFycmF5LmZyb20odGhpcy5lLmNoaWxkTm9kZXMpO1xuICAgIH1cbiAgICBpKGFuY2hvcikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgaW5zZXJ0KHRoaXMudCwgdGhpcy5uW2ldLCBhbmNob3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHAoaHRtbCkge1xuICAgICAgICB0aGlzLmQoKTtcbiAgICAgICAgdGhpcy5oKGh0bWwpO1xuICAgICAgICB0aGlzLmkodGhpcy5hKTtcbiAgICB9XG4gICAgZCgpIHtcbiAgICAgICAgdGhpcy5uLmZvckVhY2goZGV0YWNoKTtcbiAgICB9XG59XG5cbmNvbnN0IGFjdGl2ZV9kb2NzID0gbmV3IFNldCgpO1xubGV0IGFjdGl2ZSA9IDA7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZGFya3NreWFwcC9zdHJpbmctaGFzaC9ibG9iL21hc3Rlci9pbmRleC5qc1xuZnVuY3Rpb24gaGFzaChzdHIpIHtcbiAgICBsZXQgaGFzaCA9IDUzODE7XG4gICAgbGV0IGkgPSBzdHIubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pXG4gICAgICAgIGhhc2ggPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSBeIHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIHJldHVybiBoYXNoID4+PiAwO1xufVxuZnVuY3Rpb24gY3JlYXRlX3J1bGUobm9kZSwgYSwgYiwgZHVyYXRpb24sIGRlbGF5LCBlYXNlLCBmbiwgdWlkID0gMCkge1xuICAgIGNvbnN0IHN0ZXAgPSAxNi42NjYgLyBkdXJhdGlvbjtcbiAgICBsZXQga2V5ZnJhbWVzID0gJ3tcXG4nO1xuICAgIGZvciAobGV0IHAgPSAwOyBwIDw9IDE7IHAgKz0gc3RlcCkge1xuICAgICAgICBjb25zdCB0ID0gYSArIChiIC0gYSkgKiBlYXNlKHApO1xuICAgICAgICBrZXlmcmFtZXMgKz0gcCAqIDEwMCArIGAleyR7Zm4odCwgMSAtIHQpfX1cXG5gO1xuICAgIH1cbiAgICBjb25zdCBydWxlID0ga2V5ZnJhbWVzICsgYDEwMCUgeyR7Zm4oYiwgMSAtIGIpfX1cXG59YDtcbiAgICBjb25zdCBuYW1lID0gYF9fc3ZlbHRlXyR7aGFzaChydWxlKX1fJHt1aWR9YDtcbiAgICBjb25zdCBkb2MgPSBub2RlLm93bmVyRG9jdW1lbnQ7XG4gICAgYWN0aXZlX2RvY3MuYWRkKGRvYyk7XG4gICAgY29uc3Qgc3R5bGVzaGVldCA9IGRvYy5fX3N2ZWx0ZV9zdHlsZXNoZWV0IHx8IChkb2MuX19zdmVsdGVfc3R5bGVzaGVldCA9IGRvYy5oZWFkLmFwcGVuZENoaWxkKGVsZW1lbnQoJ3N0eWxlJykpLnNoZWV0KTtcbiAgICBjb25zdCBjdXJyZW50X3J1bGVzID0gZG9jLl9fc3ZlbHRlX3J1bGVzIHx8IChkb2MuX19zdmVsdGVfcnVsZXMgPSB7fSk7XG4gICAgaWYgKCFjdXJyZW50X3J1bGVzW25hbWVdKSB7XG4gICAgICAgIGN1cnJlbnRfcnVsZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgICBzdHlsZXNoZWV0Lmluc2VydFJ1bGUoYEBrZXlmcmFtZXMgJHtuYW1lfSAke3J1bGV9YCwgc3R5bGVzaGVldC5jc3NSdWxlcy5sZW5ndGgpO1xuICAgIH1cbiAgICBjb25zdCBhbmltYXRpb24gPSBub2RlLnN0eWxlLmFuaW1hdGlvbiB8fCAnJztcbiAgICBub2RlLnN0eWxlLmFuaW1hdGlvbiA9IGAke2FuaW1hdGlvbiA/IGAke2FuaW1hdGlvbn0sIGAgOiBgYH0ke25hbWV9ICR7ZHVyYXRpb259bXMgbGluZWFyICR7ZGVsYXl9bXMgMSBib3RoYDtcbiAgICBhY3RpdmUgKz0gMTtcbiAgICByZXR1cm4gbmFtZTtcbn1cbmZ1bmN0aW9uIGRlbGV0ZV9ydWxlKG5vZGUsIG5hbWUpIHtcbiAgICBjb25zdCBwcmV2aW91cyA9IChub2RlLnN0eWxlLmFuaW1hdGlvbiB8fCAnJykuc3BsaXQoJywgJyk7XG4gICAgY29uc3QgbmV4dCA9IHByZXZpb3VzLmZpbHRlcihuYW1lXG4gICAgICAgID8gYW5pbSA9PiBhbmltLmluZGV4T2YobmFtZSkgPCAwIC8vIHJlbW92ZSBzcGVjaWZpYyBhbmltYXRpb25cbiAgICAgICAgOiBhbmltID0+IGFuaW0uaW5kZXhPZignX19zdmVsdGUnKSA9PT0gLTEgLy8gcmVtb3ZlIGFsbCBTdmVsdGUgYW5pbWF0aW9uc1xuICAgICk7XG4gICAgY29uc3QgZGVsZXRlZCA9IHByZXZpb3VzLmxlbmd0aCAtIG5leHQubGVuZ3RoO1xuICAgIGlmIChkZWxldGVkKSB7XG4gICAgICAgIG5vZGUuc3R5bGUuYW5pbWF0aW9uID0gbmV4dC5qb2luKCcsICcpO1xuICAgICAgICBhY3RpdmUgLT0gZGVsZXRlZDtcbiAgICAgICAgaWYgKCFhY3RpdmUpXG4gICAgICAgICAgICBjbGVhcl9ydWxlcygpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNsZWFyX3J1bGVzKCkge1xuICAgIHJhZigoKSA9PiB7XG4gICAgICAgIGlmIChhY3RpdmUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGFjdGl2ZV9kb2NzLmZvckVhY2goZG9jID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN0eWxlc2hlZXQgPSBkb2MuX19zdmVsdGVfc3R5bGVzaGVldDtcbiAgICAgICAgICAgIGxldCBpID0gc3R5bGVzaGVldC5jc3NSdWxlcy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoaS0tKVxuICAgICAgICAgICAgICAgIHN0eWxlc2hlZXQuZGVsZXRlUnVsZShpKTtcbiAgICAgICAgICAgIGRvYy5fX3N2ZWx0ZV9ydWxlcyA9IHt9O1xuICAgICAgICB9KTtcbiAgICAgICAgYWN0aXZlX2RvY3MuY2xlYXIoKTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlX2FuaW1hdGlvbihub2RlLCBmcm9tLCBmbiwgcGFyYW1zKSB7XG4gICAgaWYgKCFmcm9tKVxuICAgICAgICByZXR1cm4gbm9vcDtcbiAgICBjb25zdCB0byA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgaWYgKGZyb20ubGVmdCA9PT0gdG8ubGVmdCAmJiBmcm9tLnJpZ2h0ID09PSB0by5yaWdodCAmJiBmcm9tLnRvcCA9PT0gdG8udG9wICYmIGZyb20uYm90dG9tID09PSB0by5ib3R0b20pXG4gICAgICAgIHJldHVybiBub29wO1xuICAgIGNvbnN0IHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDMwMCwgZWFzaW5nID0gaWRlbnRpdHksIFxuICAgIC8vIEB0cy1pZ25vcmUgdG9kbzogc2hvdWxkIHRoaXMgYmUgc2VwYXJhdGVkIGZyb20gZGVzdHJ1Y3R1cmluZz8gT3Igc3RhcnQvZW5kIGFkZGVkIHRvIHB1YmxpYyBhcGkgYW5kIGRvY3VtZW50YXRpb24/XG4gICAgc3RhcnQ6IHN0YXJ0X3RpbWUgPSBub3coKSArIGRlbGF5LCBcbiAgICAvLyBAdHMtaWdub3JlIHRvZG86XG4gICAgZW5kID0gc3RhcnRfdGltZSArIGR1cmF0aW9uLCB0aWNrID0gbm9vcCwgY3NzIH0gPSBmbihub2RlLCB7IGZyb20sIHRvIH0sIHBhcmFtcyk7XG4gICAgbGV0IHJ1bm5pbmcgPSB0cnVlO1xuICAgIGxldCBzdGFydGVkID0gZmFsc2U7XG4gICAgbGV0IG5hbWU7XG4gICAgZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgICAgIGlmIChjc3MpIHtcbiAgICAgICAgICAgIG5hbWUgPSBjcmVhdGVfcnVsZShub2RlLCAwLCAxLCBkdXJhdGlvbiwgZGVsYXksIGVhc2luZywgY3NzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRlbGF5KSB7XG4gICAgICAgICAgICBzdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgICBpZiAoY3NzKVxuICAgICAgICAgICAgZGVsZXRlX3J1bGUobm9kZSwgbmFtZSk7XG4gICAgICAgIHJ1bm5pbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgbG9vcChub3cgPT4ge1xuICAgICAgICBpZiAoIXN0YXJ0ZWQgJiYgbm93ID49IHN0YXJ0X3RpbWUpIHtcbiAgICAgICAgICAgIHN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydGVkICYmIG5vdyA+PSBlbmQpIHtcbiAgICAgICAgICAgIHRpY2soMSwgMCk7XG4gICAgICAgICAgICBzdG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFydW5uaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHAgPSBub3cgLSBzdGFydF90aW1lO1xuICAgICAgICAgICAgY29uc3QgdCA9IDAgKyAxICogZWFzaW5nKHAgLyBkdXJhdGlvbik7XG4gICAgICAgICAgICB0aWNrKHQsIDEgLSB0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgICBzdGFydCgpO1xuICAgIHRpY2soMCwgMSk7XG4gICAgcmV0dXJuIHN0b3A7XG59XG5mdW5jdGlvbiBmaXhfcG9zaXRpb24obm9kZSkge1xuICAgIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICBpZiAoc3R5bGUucG9zaXRpb24gIT09ICdhYnNvbHV0ZScgJiYgc3R5bGUucG9zaXRpb24gIT09ICdmaXhlZCcpIHtcbiAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBzdHlsZTtcbiAgICAgICAgY29uc3QgYSA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIG5vZGUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICBub2RlLnN0eWxlLndpZHRoID0gd2lkdGg7XG4gICAgICAgIG5vZGUuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICBhZGRfdHJhbnNmb3JtKG5vZGUsIGEpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFkZF90cmFuc2Zvcm0obm9kZSwgYSkge1xuICAgIGNvbnN0IGIgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGlmIChhLmxlZnQgIT09IGIubGVmdCB8fCBhLnRvcCAhPT0gYi50b3ApIHtcbiAgICAgICAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSBzdHlsZS50cmFuc2Zvcm0gPT09ICdub25lJyA/ICcnIDogc3R5bGUudHJhbnNmb3JtO1xuICAgICAgICBub2RlLnN0eWxlLnRyYW5zZm9ybSA9IGAke3RyYW5zZm9ybX0gdHJhbnNsYXRlKCR7YS5sZWZ0IC0gYi5sZWZ0fXB4LCAke2EudG9wIC0gYi50b3B9cHgpYDtcbiAgICB9XG59XG5cbmxldCBjdXJyZW50X2NvbXBvbmVudDtcbmZ1bmN0aW9uIHNldF9jdXJyZW50X2NvbXBvbmVudChjb21wb25lbnQpIHtcbiAgICBjdXJyZW50X2NvbXBvbmVudCA9IGNvbXBvbmVudDtcbn1cbmZ1bmN0aW9uIGdldF9jdXJyZW50X2NvbXBvbmVudCgpIHtcbiAgICBpZiAoIWN1cnJlbnRfY29tcG9uZW50KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZ1bmN0aW9uIGNhbGxlZCBvdXRzaWRlIGNvbXBvbmVudCBpbml0aWFsaXphdGlvbmApO1xuICAgIHJldHVybiBjdXJyZW50X2NvbXBvbmVudDtcbn1cbmZ1bmN0aW9uIGJlZm9yZVVwZGF0ZShmbikge1xuICAgIGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLmJlZm9yZV91cGRhdGUucHVzaChmbik7XG59XG5mdW5jdGlvbiBvbk1vdW50KGZuKSB7XG4gICAgZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQub25fbW91bnQucHVzaChmbik7XG59XG5mdW5jdGlvbiBhZnRlclVwZGF0ZShmbikge1xuICAgIGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLmFmdGVyX3VwZGF0ZS5wdXNoKGZuKTtcbn1cbmZ1bmN0aW9uIG9uRGVzdHJveShmbikge1xuICAgIGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLm9uX2Rlc3Ryb3kucHVzaChmbik7XG59XG5mdW5jdGlvbiBjcmVhdGVFdmVudERpc3BhdGNoZXIoKSB7XG4gICAgY29uc3QgY29tcG9uZW50ID0gZ2V0X2N1cnJlbnRfY29tcG9uZW50KCk7XG4gICAgcmV0dXJuICh0eXBlLCBkZXRhaWwpID0+IHtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tzID0gY29tcG9uZW50LiQkLmNhbGxiYWNrc1t0eXBlXTtcbiAgICAgICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgICAgICAgLy8gVE9ETyBhcmUgdGhlcmUgc2l0dWF0aW9ucyB3aGVyZSBldmVudHMgY291bGQgYmUgZGlzcGF0Y2hlZFxuICAgICAgICAgICAgLy8gaW4gYSBzZXJ2ZXIgKG5vbi1ET00pIGVudmlyb25tZW50P1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBjdXN0b21fZXZlbnQodHlwZSwgZGV0YWlsKTtcbiAgICAgICAgICAgIGNhbGxiYWNrcy5zbGljZSgpLmZvckVhY2goZm4gPT4ge1xuICAgICAgICAgICAgICAgIGZuLmNhbGwoY29tcG9uZW50LCBldmVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBzZXRDb250ZXh0KGtleSwgY29udGV4dCkge1xuICAgIGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLmNvbnRleHQuc2V0KGtleSwgY29udGV4dCk7XG59XG5mdW5jdGlvbiBnZXRDb250ZXh0KGtleSkge1xuICAgIHJldHVybiBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5jb250ZXh0LmdldChrZXkpO1xufVxuLy8gVE9ETyBmaWd1cmUgb3V0IGlmIHdlIHN0aWxsIHdhbnQgdG8gc3VwcG9ydFxuLy8gc2hvcnRoYW5kIGV2ZW50cywgb3IgaWYgd2Ugd2FudCB0byBpbXBsZW1lbnRcbi8vIGEgcmVhbCBidWJibGluZyBtZWNoYW5pc21cbmZ1bmN0aW9uIGJ1YmJsZShjb21wb25lbnQsIGV2ZW50KSB7XG4gICAgY29uc3QgY2FsbGJhY2tzID0gY29tcG9uZW50LiQkLmNhbGxiYWNrc1tldmVudC50eXBlXTtcbiAgICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgICAgIGNhbGxiYWNrcy5zbGljZSgpLmZvckVhY2goZm4gPT4gZm4oZXZlbnQpKTtcbiAgICB9XG59XG5cbmNvbnN0IGRpcnR5X2NvbXBvbmVudHMgPSBbXTtcbmNvbnN0IGludHJvcyA9IHsgZW5hYmxlZDogZmFsc2UgfTtcbmNvbnN0IGJpbmRpbmdfY2FsbGJhY2tzID0gW107XG5jb25zdCByZW5kZXJfY2FsbGJhY2tzID0gW107XG5jb25zdCBmbHVzaF9jYWxsYmFja3MgPSBbXTtcbmNvbnN0IHJlc29sdmVkX3Byb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbmxldCB1cGRhdGVfc2NoZWR1bGVkID0gZmFsc2U7XG5mdW5jdGlvbiBzY2hlZHVsZV91cGRhdGUoKSB7XG4gICAgaWYgKCF1cGRhdGVfc2NoZWR1bGVkKSB7XG4gICAgICAgIHVwZGF0ZV9zY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgICByZXNvbHZlZF9wcm9taXNlLnRoZW4oZmx1c2gpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRpY2soKSB7XG4gICAgc2NoZWR1bGVfdXBkYXRlKCk7XG4gICAgcmV0dXJuIHJlc29sdmVkX3Byb21pc2U7XG59XG5mdW5jdGlvbiBhZGRfcmVuZGVyX2NhbGxiYWNrKGZuKSB7XG4gICAgcmVuZGVyX2NhbGxiYWNrcy5wdXNoKGZuKTtcbn1cbmZ1bmN0aW9uIGFkZF9mbHVzaF9jYWxsYmFjayhmbikge1xuICAgIGZsdXNoX2NhbGxiYWNrcy5wdXNoKGZuKTtcbn1cbmxldCBmbHVzaGluZyA9IGZhbHNlO1xuY29uc3Qgc2Vlbl9jYWxsYmFja3MgPSBuZXcgU2V0KCk7XG5mdW5jdGlvbiBmbHVzaCgpIHtcbiAgICBpZiAoZmx1c2hpbmcpXG4gICAgICAgIHJldHVybjtcbiAgICBmbHVzaGluZyA9IHRydWU7XG4gICAgZG8ge1xuICAgICAgICAvLyBmaXJzdCwgY2FsbCBiZWZvcmVVcGRhdGUgZnVuY3Rpb25zXG4gICAgICAgIC8vIGFuZCB1cGRhdGUgY29tcG9uZW50c1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpcnR5X2NvbXBvbmVudHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IGRpcnR5X2NvbXBvbmVudHNbaV07XG4gICAgICAgICAgICBzZXRfY3VycmVudF9jb21wb25lbnQoY29tcG9uZW50KTtcbiAgICAgICAgICAgIHVwZGF0ZShjb21wb25lbnQuJCQpO1xuICAgICAgICB9XG4gICAgICAgIGRpcnR5X2NvbXBvbmVudHMubGVuZ3RoID0gMDtcbiAgICAgICAgd2hpbGUgKGJpbmRpbmdfY2FsbGJhY2tzLmxlbmd0aClcbiAgICAgICAgICAgIGJpbmRpbmdfY2FsbGJhY2tzLnBvcCgpKCk7XG4gICAgICAgIC8vIHRoZW4sIG9uY2UgY29tcG9uZW50cyBhcmUgdXBkYXRlZCwgY2FsbFxuICAgICAgICAvLyBhZnRlclVwZGF0ZSBmdW5jdGlvbnMuIFRoaXMgbWF5IGNhdXNlXG4gICAgICAgIC8vIHN1YnNlcXVlbnQgdXBkYXRlcy4uLlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbmRlcl9jYWxsYmFja3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gcmVuZGVyX2NhbGxiYWNrc1tpXTtcbiAgICAgICAgICAgIGlmICghc2Vlbl9jYWxsYmFja3MuaGFzKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgICAgIC8vIC4uLnNvIGd1YXJkIGFnYWluc3QgaW5maW5pdGUgbG9vcHNcbiAgICAgICAgICAgICAgICBzZWVuX2NhbGxiYWNrcy5hZGQoY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVuZGVyX2NhbGxiYWNrcy5sZW5ndGggPSAwO1xuICAgIH0gd2hpbGUgKGRpcnR5X2NvbXBvbmVudHMubGVuZ3RoKTtcbiAgICB3aGlsZSAoZmx1c2hfY2FsbGJhY2tzLmxlbmd0aCkge1xuICAgICAgICBmbHVzaF9jYWxsYmFja3MucG9wKCkoKTtcbiAgICB9XG4gICAgdXBkYXRlX3NjaGVkdWxlZCA9IGZhbHNlO1xuICAgIGZsdXNoaW5nID0gZmFsc2U7XG4gICAgc2Vlbl9jYWxsYmFja3MuY2xlYXIoKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZSgkJCkge1xuICAgIGlmICgkJC5mcmFnbWVudCAhPT0gbnVsbCkge1xuICAgICAgICAkJC51cGRhdGUoKTtcbiAgICAgICAgcnVuX2FsbCgkJC5iZWZvcmVfdXBkYXRlKTtcbiAgICAgICAgY29uc3QgZGlydHkgPSAkJC5kaXJ0eTtcbiAgICAgICAgJCQuZGlydHkgPSBbLTFdO1xuICAgICAgICAkJC5mcmFnbWVudCAmJiAkJC5mcmFnbWVudC5wKCQkLmN0eCwgZGlydHkpO1xuICAgICAgICAkJC5hZnRlcl91cGRhdGUuZm9yRWFjaChhZGRfcmVuZGVyX2NhbGxiYWNrKTtcbiAgICB9XG59XG5cbmxldCBwcm9taXNlO1xuZnVuY3Rpb24gd2FpdCgpIHtcbiAgICBpZiAoIXByb21pc2UpIHtcbiAgICAgICAgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICBwcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgcHJvbWlzZSA9IG51bGw7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cbmZ1bmN0aW9uIGRpc3BhdGNoKG5vZGUsIGRpcmVjdGlvbiwga2luZCkge1xuICAgIG5vZGUuZGlzcGF0Y2hFdmVudChjdXN0b21fZXZlbnQoYCR7ZGlyZWN0aW9uID8gJ2ludHJvJyA6ICdvdXRybyd9JHtraW5kfWApKTtcbn1cbmNvbnN0IG91dHJvaW5nID0gbmV3IFNldCgpO1xubGV0IG91dHJvcztcbmZ1bmN0aW9uIGdyb3VwX291dHJvcygpIHtcbiAgICBvdXRyb3MgPSB7XG4gICAgICAgIHI6IDAsXG4gICAgICAgIGM6IFtdLFxuICAgICAgICBwOiBvdXRyb3MgLy8gcGFyZW50IGdyb3VwXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNoZWNrX291dHJvcygpIHtcbiAgICBpZiAoIW91dHJvcy5yKSB7XG4gICAgICAgIHJ1bl9hbGwob3V0cm9zLmMpO1xuICAgIH1cbiAgICBvdXRyb3MgPSBvdXRyb3MucDtcbn1cbmZ1bmN0aW9uIHRyYW5zaXRpb25faW4oYmxvY2ssIGxvY2FsKSB7XG4gICAgaWYgKGJsb2NrICYmIGJsb2NrLmkpIHtcbiAgICAgICAgb3V0cm9pbmcuZGVsZXRlKGJsb2NrKTtcbiAgICAgICAgYmxvY2suaShsb2NhbCk7XG4gICAgfVxufVxuZnVuY3Rpb24gdHJhbnNpdGlvbl9vdXQoYmxvY2ssIGxvY2FsLCBkZXRhY2gsIGNhbGxiYWNrKSB7XG4gICAgaWYgKGJsb2NrICYmIGJsb2NrLm8pIHtcbiAgICAgICAgaWYgKG91dHJvaW5nLmhhcyhibG9jaykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIG91dHJvaW5nLmFkZChibG9jayk7XG4gICAgICAgIG91dHJvcy5jLnB1c2goKCkgPT4ge1xuICAgICAgICAgICAgb3V0cm9pbmcuZGVsZXRlKGJsb2NrKTtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGlmIChkZXRhY2gpXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrLmQoMSk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGJsb2NrLm8obG9jYWwpO1xuICAgIH1cbn1cbmNvbnN0IG51bGxfdHJhbnNpdGlvbiA9IHsgZHVyYXRpb246IDAgfTtcbmZ1bmN0aW9uIGNyZWF0ZV9pbl90cmFuc2l0aW9uKG5vZGUsIGZuLCBwYXJhbXMpIHtcbiAgICBsZXQgY29uZmlnID0gZm4obm9kZSwgcGFyYW1zKTtcbiAgICBsZXQgcnVubmluZyA9IGZhbHNlO1xuICAgIGxldCBhbmltYXRpb25fbmFtZTtcbiAgICBsZXQgdGFzaztcbiAgICBsZXQgdWlkID0gMDtcbiAgICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgICAgICBpZiAoYW5pbWF0aW9uX25hbWUpXG4gICAgICAgICAgICBkZWxldGVfcnVsZShub2RlLCBhbmltYXRpb25fbmFtZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdvKCkge1xuICAgICAgICBjb25zdCB7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSAzMDAsIGVhc2luZyA9IGlkZW50aXR5LCB0aWNrID0gbm9vcCwgY3NzIH0gPSBjb25maWcgfHwgbnVsbF90cmFuc2l0aW9uO1xuICAgICAgICBpZiAoY3NzKVxuICAgICAgICAgICAgYW5pbWF0aW9uX25hbWUgPSBjcmVhdGVfcnVsZShub2RlLCAwLCAxLCBkdXJhdGlvbiwgZGVsYXksIGVhc2luZywgY3NzLCB1aWQrKyk7XG4gICAgICAgIHRpY2soMCwgMSk7XG4gICAgICAgIGNvbnN0IHN0YXJ0X3RpbWUgPSBub3coKSArIGRlbGF5O1xuICAgICAgICBjb25zdCBlbmRfdGltZSA9IHN0YXJ0X3RpbWUgKyBkdXJhdGlvbjtcbiAgICAgICAgaWYgKHRhc2spXG4gICAgICAgICAgICB0YXNrLmFib3J0KCk7XG4gICAgICAgIHJ1bm5pbmcgPSB0cnVlO1xuICAgICAgICBhZGRfcmVuZGVyX2NhbGxiYWNrKCgpID0+IGRpc3BhdGNoKG5vZGUsIHRydWUsICdzdGFydCcpKTtcbiAgICAgICAgdGFzayA9IGxvb3Aobm93ID0+IHtcbiAgICAgICAgICAgIGlmIChydW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vdyA+PSBlbmRfdGltZSkge1xuICAgICAgICAgICAgICAgICAgICB0aWNrKDEsIDApO1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChub2RlLCB0cnVlLCAnZW5kJyk7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5vdyA+PSBzdGFydF90aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBlYXNpbmcoKG5vdyAtIHN0YXJ0X3RpbWUpIC8gZHVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB0aWNrKHQsIDEgLSB0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcnVubmluZztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxldCBzdGFydGVkID0gZmFsc2U7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQoKSB7XG4gICAgICAgICAgICBpZiAoc3RhcnRlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBkZWxldGVfcnVsZShub2RlKTtcbiAgICAgICAgICAgIGlmIChpc19mdW5jdGlvbihjb25maWcpKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnID0gY29uZmlnKCk7XG4gICAgICAgICAgICAgICAgd2FpdCgpLnRoZW4oZ28pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ28oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgICAgIHN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW5kKCkge1xuICAgICAgICAgICAgaWYgKHJ1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgcnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZV9vdXRfdHJhbnNpdGlvbihub2RlLCBmbiwgcGFyYW1zKSB7XG4gICAgbGV0IGNvbmZpZyA9IGZuKG5vZGUsIHBhcmFtcyk7XG4gICAgbGV0IHJ1bm5pbmcgPSB0cnVlO1xuICAgIGxldCBhbmltYXRpb25fbmFtZTtcbiAgICBjb25zdCBncm91cCA9IG91dHJvcztcbiAgICBncm91cC5yICs9IDE7XG4gICAgZnVuY3Rpb24gZ28oKSB7XG4gICAgICAgIGNvbnN0IHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDMwMCwgZWFzaW5nID0gaWRlbnRpdHksIHRpY2sgPSBub29wLCBjc3MgfSA9IGNvbmZpZyB8fCBudWxsX3RyYW5zaXRpb247XG4gICAgICAgIGlmIChjc3MpXG4gICAgICAgICAgICBhbmltYXRpb25fbmFtZSA9IGNyZWF0ZV9ydWxlKG5vZGUsIDEsIDAsIGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nLCBjc3MpO1xuICAgICAgICBjb25zdCBzdGFydF90aW1lID0gbm93KCkgKyBkZWxheTtcbiAgICAgICAgY29uc3QgZW5kX3RpbWUgPSBzdGFydF90aW1lICsgZHVyYXRpb247XG4gICAgICAgIGFkZF9yZW5kZXJfY2FsbGJhY2soKCkgPT4gZGlzcGF0Y2gobm9kZSwgZmFsc2UsICdzdGFydCcpKTtcbiAgICAgICAgbG9vcChub3cgPT4ge1xuICAgICAgICAgICAgaWYgKHJ1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICBpZiAobm93ID49IGVuZF90aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpY2soMCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKG5vZGUsIGZhbHNlLCAnZW5kJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghLS1ncm91cC5yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHdpbGwgcmVzdWx0IGluIGBlbmQoKWAgYmVpbmcgY2FsbGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc28gd2UgZG9uJ3QgbmVlZCB0byBjbGVhbiB1cCBoZXJlXG4gICAgICAgICAgICAgICAgICAgICAgICBydW5fYWxsKGdyb3VwLmMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5vdyA+PSBzdGFydF90aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBlYXNpbmcoKG5vdyAtIHN0YXJ0X3RpbWUpIC8gZHVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB0aWNrKDEgLSB0LCB0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcnVubmluZztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChpc19mdW5jdGlvbihjb25maWcpKSB7XG4gICAgICAgIHdhaXQoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGNvbmZpZyA9IGNvbmZpZygpO1xuICAgICAgICAgICAgZ28oKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnbygpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBlbmQocmVzZXQpIHtcbiAgICAgICAgICAgIGlmIChyZXNldCAmJiBjb25maWcudGljaykge1xuICAgICAgICAgICAgICAgIGNvbmZpZy50aWNrKDEsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJ1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICBpZiAoYW5pbWF0aW9uX25hbWUpXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZV9ydWxlKG5vZGUsIGFuaW1hdGlvbl9uYW1lKTtcbiAgICAgICAgICAgICAgICBydW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlX2JpZGlyZWN0aW9uYWxfdHJhbnNpdGlvbihub2RlLCBmbiwgcGFyYW1zLCBpbnRybykge1xuICAgIGxldCBjb25maWcgPSBmbihub2RlLCBwYXJhbXMpO1xuICAgIGxldCB0ID0gaW50cm8gPyAwIDogMTtcbiAgICBsZXQgcnVubmluZ19wcm9ncmFtID0gbnVsbDtcbiAgICBsZXQgcGVuZGluZ19wcm9ncmFtID0gbnVsbDtcbiAgICBsZXQgYW5pbWF0aW9uX25hbWUgPSBudWxsO1xuICAgIGZ1bmN0aW9uIGNsZWFyX2FuaW1hdGlvbigpIHtcbiAgICAgICAgaWYgKGFuaW1hdGlvbl9uYW1lKVxuICAgICAgICAgICAgZGVsZXRlX3J1bGUobm9kZSwgYW5pbWF0aW9uX25hbWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbml0KHByb2dyYW0sIGR1cmF0aW9uKSB7XG4gICAgICAgIGNvbnN0IGQgPSBwcm9ncmFtLmIgLSB0O1xuICAgICAgICBkdXJhdGlvbiAqPSBNYXRoLmFicyhkKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGE6IHQsXG4gICAgICAgICAgICBiOiBwcm9ncmFtLmIsXG4gICAgICAgICAgICBkLFxuICAgICAgICAgICAgZHVyYXRpb24sXG4gICAgICAgICAgICBzdGFydDogcHJvZ3JhbS5zdGFydCxcbiAgICAgICAgICAgIGVuZDogcHJvZ3JhbS5zdGFydCArIGR1cmF0aW9uLFxuICAgICAgICAgICAgZ3JvdXA6IHByb2dyYW0uZ3JvdXBcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ28oYikge1xuICAgICAgICBjb25zdCB7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSAzMDAsIGVhc2luZyA9IGlkZW50aXR5LCB0aWNrID0gbm9vcCwgY3NzIH0gPSBjb25maWcgfHwgbnVsbF90cmFuc2l0aW9uO1xuICAgICAgICBjb25zdCBwcm9ncmFtID0ge1xuICAgICAgICAgICAgc3RhcnQ6IG5vdygpICsgZGVsYXksXG4gICAgICAgICAgICBiXG4gICAgICAgIH07XG4gICAgICAgIGlmICghYikge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSB0b2RvOiBpbXByb3ZlIHR5cGluZ3NcbiAgICAgICAgICAgIHByb2dyYW0uZ3JvdXAgPSBvdXRyb3M7XG4gICAgICAgICAgICBvdXRyb3MuciArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChydW5uaW5nX3Byb2dyYW0pIHtcbiAgICAgICAgICAgIHBlbmRpbmdfcHJvZ3JhbSA9IHByb2dyYW07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBpZiB0aGlzIGlzIGFuIGludHJvLCBhbmQgdGhlcmUncyBhIGRlbGF5LCB3ZSBuZWVkIHRvIGRvXG4gICAgICAgICAgICAvLyBhbiBpbml0aWFsIHRpY2sgYW5kL29yIGFwcGx5IENTUyBhbmltYXRpb24gaW1tZWRpYXRlbHlcbiAgICAgICAgICAgIGlmIChjc3MpIHtcbiAgICAgICAgICAgICAgICBjbGVhcl9hbmltYXRpb24oKTtcbiAgICAgICAgICAgICAgICBhbmltYXRpb25fbmFtZSA9IGNyZWF0ZV9ydWxlKG5vZGUsIHQsIGIsIGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nLCBjc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGIpXG4gICAgICAgICAgICAgICAgdGljaygwLCAxKTtcbiAgICAgICAgICAgIHJ1bm5pbmdfcHJvZ3JhbSA9IGluaXQocHJvZ3JhbSwgZHVyYXRpb24pO1xuICAgICAgICAgICAgYWRkX3JlbmRlcl9jYWxsYmFjaygoKSA9PiBkaXNwYXRjaChub2RlLCBiLCAnc3RhcnQnKSk7XG4gICAgICAgICAgICBsb29wKG5vdyA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHBlbmRpbmdfcHJvZ3JhbSAmJiBub3cgPiBwZW5kaW5nX3Byb2dyYW0uc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcnVubmluZ19wcm9ncmFtID0gaW5pdChwZW5kaW5nX3Byb2dyYW0sIGR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZ19wcm9ncmFtID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2gobm9kZSwgcnVubmluZ19wcm9ncmFtLmIsICdzdGFydCcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3NzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhcl9hbmltYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbl9uYW1lID0gY3JlYXRlX3J1bGUobm9kZSwgdCwgcnVubmluZ19wcm9ncmFtLmIsIHJ1bm5pbmdfcHJvZ3JhbS5kdXJhdGlvbiwgMCwgZWFzaW5nLCBjb25maWcuY3NzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocnVubmluZ19wcm9ncmFtKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub3cgPj0gcnVubmluZ19wcm9ncmFtLmVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGljayh0ID0gcnVubmluZ19wcm9ncmFtLmIsIDEgLSB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKG5vZGUsIHJ1bm5pbmdfcHJvZ3JhbS5iLCAnZW5kJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBlbmRpbmdfcHJvZ3JhbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlJ3JlIGRvbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocnVubmluZ19wcm9ncmFtLmIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW50cm8g4oCUIHdlIGNhbiB0aWR5IHVwIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyX2FuaW1hdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3V0cm8g4oCUIG5lZWRzIHRvIGJlIGNvb3JkaW5hdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghLS1ydW5uaW5nX3Byb2dyYW0uZ3JvdXAucilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bl9hbGwocnVubmluZ19wcm9ncmFtLmdyb3VwLmMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5pbmdfcHJvZ3JhbSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobm93ID49IHJ1bm5pbmdfcHJvZ3JhbS5zdGFydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcCA9IG5vdyAtIHJ1bm5pbmdfcHJvZ3JhbS5zdGFydDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBydW5uaW5nX3Byb2dyYW0uYSArIHJ1bm5pbmdfcHJvZ3JhbS5kICogZWFzaW5nKHAgLyBydW5uaW5nX3Byb2dyYW0uZHVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGljayh0LCAxIC0gdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhKHJ1bm5pbmdfcHJvZ3JhbSB8fCBwZW5kaW5nX3Byb2dyYW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcnVuKGIpIHtcbiAgICAgICAgICAgIGlmIChpc19mdW5jdGlvbihjb25maWcpKSB7XG4gICAgICAgICAgICAgICAgd2FpdCgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZyA9IGNvbmZpZygpO1xuICAgICAgICAgICAgICAgICAgICBnbyhiKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdvKGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbmQoKSB7XG4gICAgICAgICAgICBjbGVhcl9hbmltYXRpb24oKTtcbiAgICAgICAgICAgIHJ1bm5pbmdfcHJvZ3JhbSA9IHBlbmRpbmdfcHJvZ3JhbSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5mdW5jdGlvbiBoYW5kbGVfcHJvbWlzZShwcm9taXNlLCBpbmZvKSB7XG4gICAgY29uc3QgdG9rZW4gPSBpbmZvLnRva2VuID0ge307XG4gICAgZnVuY3Rpb24gdXBkYXRlKHR5cGUsIGluZGV4LCBrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmIChpbmZvLnRva2VuICE9PSB0b2tlbilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaW5mby5yZXNvbHZlZCA9IHZhbHVlO1xuICAgICAgICBsZXQgY2hpbGRfY3R4ID0gaW5mby5jdHg7XG4gICAgICAgIGlmIChrZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2hpbGRfY3R4ID0gY2hpbGRfY3R4LnNsaWNlKCk7XG4gICAgICAgICAgICBjaGlsZF9jdHhba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJsb2NrID0gdHlwZSAmJiAoaW5mby5jdXJyZW50ID0gdHlwZSkoY2hpbGRfY3R4KTtcbiAgICAgICAgbGV0IG5lZWRzX2ZsdXNoID0gZmFsc2U7XG4gICAgICAgIGlmIChpbmZvLmJsb2NrKSB7XG4gICAgICAgICAgICBpZiAoaW5mby5ibG9ja3MpIHtcbiAgICAgICAgICAgICAgICBpbmZvLmJsb2Nrcy5mb3JFYWNoKChibG9jaywgaSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSAhPT0gaW5kZXggJiYgYmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwX291dHJvcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbl9vdXQoYmxvY2ssIDEsIDEsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmZvLmJsb2Nrc1tpXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrX291dHJvcygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbmZvLmJsb2NrLmQoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBibG9jay5jKCk7XG4gICAgICAgICAgICB0cmFuc2l0aW9uX2luKGJsb2NrLCAxKTtcbiAgICAgICAgICAgIGJsb2NrLm0oaW5mby5tb3VudCgpLCBpbmZvLmFuY2hvcik7XG4gICAgICAgICAgICBuZWVkc19mbHVzaCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaW5mby5ibG9jayA9IGJsb2NrO1xuICAgICAgICBpZiAoaW5mby5ibG9ja3MpXG4gICAgICAgICAgICBpbmZvLmJsb2Nrc1tpbmRleF0gPSBibG9jaztcbiAgICAgICAgaWYgKG5lZWRzX2ZsdXNoKSB7XG4gICAgICAgICAgICBmbHVzaCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpc19wcm9taXNlKHByb21pc2UpKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRfY29tcG9uZW50ID0gZ2V0X2N1cnJlbnRfY29tcG9uZW50KCk7XG4gICAgICAgIHByb21pc2UudGhlbih2YWx1ZSA9PiB7XG4gICAgICAgICAgICBzZXRfY3VycmVudF9jb21wb25lbnQoY3VycmVudF9jb21wb25lbnQpO1xuICAgICAgICAgICAgdXBkYXRlKGluZm8udGhlbiwgMSwgaW5mby52YWx1ZSwgdmFsdWUpO1xuICAgICAgICAgICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KG51bGwpO1xuICAgICAgICB9LCBlcnJvciA9PiB7XG4gICAgICAgICAgICBzZXRfY3VycmVudF9jb21wb25lbnQoY3VycmVudF9jb21wb25lbnQpO1xuICAgICAgICAgICAgdXBkYXRlKGluZm8uY2F0Y2gsIDIsIGluZm8uZXJyb3IsIGVycm9yKTtcbiAgICAgICAgICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChudWxsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGlmIHdlIHByZXZpb3VzbHkgaGFkIGEgdGhlbi9jYXRjaCBibG9jaywgZGVzdHJveSBpdFxuICAgICAgICBpZiAoaW5mby5jdXJyZW50ICE9PSBpbmZvLnBlbmRpbmcpIHtcbiAgICAgICAgICAgIHVwZGF0ZShpbmZvLnBlbmRpbmcsIDApO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChpbmZvLmN1cnJlbnQgIT09IGluZm8udGhlbikge1xuICAgICAgICAgICAgdXBkYXRlKGluZm8udGhlbiwgMSwgaW5mby52YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpbmZvLnJlc29sdmVkID0gcHJvbWlzZTtcbiAgICB9XG59XG5cbmNvbnN0IGdsb2JhbHMgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICA/IHdpbmRvd1xuICAgIDogdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnXG4gICAgICAgID8gZ2xvYmFsVGhpc1xuICAgICAgICA6IGdsb2JhbCk7XG5cbmZ1bmN0aW9uIGRlc3Ryb3lfYmxvY2soYmxvY2ssIGxvb2t1cCkge1xuICAgIGJsb2NrLmQoMSk7XG4gICAgbG9va3VwLmRlbGV0ZShibG9jay5rZXkpO1xufVxuZnVuY3Rpb24gb3V0cm9fYW5kX2Rlc3Ryb3lfYmxvY2soYmxvY2ssIGxvb2t1cCkge1xuICAgIHRyYW5zaXRpb25fb3V0KGJsb2NrLCAxLCAxLCAoKSA9PiB7XG4gICAgICAgIGxvb2t1cC5kZWxldGUoYmxvY2sua2V5KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGZpeF9hbmRfZGVzdHJveV9ibG9jayhibG9jaywgbG9va3VwKSB7XG4gICAgYmxvY2suZigpO1xuICAgIGRlc3Ryb3lfYmxvY2soYmxvY2ssIGxvb2t1cCk7XG59XG5mdW5jdGlvbiBmaXhfYW5kX291dHJvX2FuZF9kZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApIHtcbiAgICBibG9jay5mKCk7XG4gICAgb3V0cm9fYW5kX2Rlc3Ryb3lfYmxvY2soYmxvY2ssIGxvb2t1cCk7XG59XG5mdW5jdGlvbiB1cGRhdGVfa2V5ZWRfZWFjaChvbGRfYmxvY2tzLCBkaXJ0eSwgZ2V0X2tleSwgZHluYW1pYywgY3R4LCBsaXN0LCBsb29rdXAsIG5vZGUsIGRlc3Ryb3ksIGNyZWF0ZV9lYWNoX2Jsb2NrLCBuZXh0LCBnZXRfY29udGV4dCkge1xuICAgIGxldCBvID0gb2xkX2Jsb2Nrcy5sZW5ndGg7XG4gICAgbGV0IG4gPSBsaXN0Lmxlbmd0aDtcbiAgICBsZXQgaSA9IG87XG4gICAgY29uc3Qgb2xkX2luZGV4ZXMgPSB7fTtcbiAgICB3aGlsZSAoaS0tKVxuICAgICAgICBvbGRfaW5kZXhlc1tvbGRfYmxvY2tzW2ldLmtleV0gPSBpO1xuICAgIGNvbnN0IG5ld19ibG9ja3MgPSBbXTtcbiAgICBjb25zdCBuZXdfbG9va3VwID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGRlbHRhcyA9IG5ldyBNYXAoKTtcbiAgICBpID0gbjtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkX2N0eCA9IGdldF9jb250ZXh0KGN0eCwgbGlzdCwgaSk7XG4gICAgICAgIGNvbnN0IGtleSA9IGdldF9rZXkoY2hpbGRfY3R4KTtcbiAgICAgICAgbGV0IGJsb2NrID0gbG9va3VwLmdldChrZXkpO1xuICAgICAgICBpZiAoIWJsb2NrKSB7XG4gICAgICAgICAgICBibG9jayA9IGNyZWF0ZV9lYWNoX2Jsb2NrKGtleSwgY2hpbGRfY3R4KTtcbiAgICAgICAgICAgIGJsb2NrLmMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkeW5hbWljKSB7XG4gICAgICAgICAgICBibG9jay5wKGNoaWxkX2N0eCwgZGlydHkpO1xuICAgICAgICB9XG4gICAgICAgIG5ld19sb29rdXAuc2V0KGtleSwgbmV3X2Jsb2Nrc1tpXSA9IGJsb2NrKTtcbiAgICAgICAgaWYgKGtleSBpbiBvbGRfaW5kZXhlcylcbiAgICAgICAgICAgIGRlbHRhcy5zZXQoa2V5LCBNYXRoLmFicyhpIC0gb2xkX2luZGV4ZXNba2V5XSkpO1xuICAgIH1cbiAgICBjb25zdCB3aWxsX21vdmUgPSBuZXcgU2V0KCk7XG4gICAgY29uc3QgZGlkX21vdmUgPSBuZXcgU2V0KCk7XG4gICAgZnVuY3Rpb24gaW5zZXJ0KGJsb2NrKSB7XG4gICAgICAgIHRyYW5zaXRpb25faW4oYmxvY2ssIDEpO1xuICAgICAgICBibG9jay5tKG5vZGUsIG5leHQpO1xuICAgICAgICBsb29rdXAuc2V0KGJsb2NrLmtleSwgYmxvY2spO1xuICAgICAgICBuZXh0ID0gYmxvY2suZmlyc3Q7XG4gICAgICAgIG4tLTtcbiAgICB9XG4gICAgd2hpbGUgKG8gJiYgbikge1xuICAgICAgICBjb25zdCBuZXdfYmxvY2sgPSBuZXdfYmxvY2tzW24gLSAxXTtcbiAgICAgICAgY29uc3Qgb2xkX2Jsb2NrID0gb2xkX2Jsb2Nrc1tvIC0gMV07XG4gICAgICAgIGNvbnN0IG5ld19rZXkgPSBuZXdfYmxvY2sua2V5O1xuICAgICAgICBjb25zdCBvbGRfa2V5ID0gb2xkX2Jsb2NrLmtleTtcbiAgICAgICAgaWYgKG5ld19ibG9jayA9PT0gb2xkX2Jsb2NrKSB7XG4gICAgICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgICAgICAgICBuZXh0ID0gbmV3X2Jsb2NrLmZpcnN0O1xuICAgICAgICAgICAgby0tO1xuICAgICAgICAgICAgbi0tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFuZXdfbG9va3VwLmhhcyhvbGRfa2V5KSkge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIG9sZCBibG9ja1xuICAgICAgICAgICAgZGVzdHJveShvbGRfYmxvY2ssIGxvb2t1cCk7XG4gICAgICAgICAgICBvLS07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWxvb2t1cC5oYXMobmV3X2tleSkgfHwgd2lsbF9tb3ZlLmhhcyhuZXdfa2V5KSkge1xuICAgICAgICAgICAgaW5zZXJ0KG5ld19ibG9jayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGlkX21vdmUuaGFzKG9sZF9rZXkpKSB7XG4gICAgICAgICAgICBvLS07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGVsdGFzLmdldChuZXdfa2V5KSA+IGRlbHRhcy5nZXQob2xkX2tleSkpIHtcbiAgICAgICAgICAgIGRpZF9tb3ZlLmFkZChuZXdfa2V5KTtcbiAgICAgICAgICAgIGluc2VydChuZXdfYmxvY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2lsbF9tb3ZlLmFkZChvbGRfa2V5KTtcbiAgICAgICAgICAgIG8tLTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3aGlsZSAoby0tKSB7XG4gICAgICAgIGNvbnN0IG9sZF9ibG9jayA9IG9sZF9ibG9ja3Nbb107XG4gICAgICAgIGlmICghbmV3X2xvb2t1cC5oYXMob2xkX2Jsb2NrLmtleSkpXG4gICAgICAgICAgICBkZXN0cm95KG9sZF9ibG9jaywgbG9va3VwKTtcbiAgICB9XG4gICAgd2hpbGUgKG4pXG4gICAgICAgIGluc2VydChuZXdfYmxvY2tzW24gLSAxXSk7XG4gICAgcmV0dXJuIG5ld19ibG9ja3M7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZV9lYWNoX2tleXMoY3R4LCBsaXN0LCBnZXRfY29udGV4dCwgZ2V0X2tleSkge1xuICAgIGNvbnN0IGtleXMgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGdldF9rZXkoZ2V0X2NvbnRleHQoY3R4LCBsaXN0LCBpKSk7XG4gICAgICAgIGlmIChrZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBoYXZlIGR1cGxpY2F0ZSBrZXlzIGluIGEga2V5ZWQgZWFjaGApO1xuICAgICAgICB9XG4gICAgICAgIGtleXMuYWRkKGtleSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRfc3ByZWFkX3VwZGF0ZShsZXZlbHMsIHVwZGF0ZXMpIHtcbiAgICBjb25zdCB1cGRhdGUgPSB7fTtcbiAgICBjb25zdCB0b19udWxsX291dCA9IHt9O1xuICAgIGNvbnN0IGFjY291bnRlZF9mb3IgPSB7ICQkc2NvcGU6IDEgfTtcbiAgICBsZXQgaSA9IGxldmVscy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgICBjb25zdCBvID0gbGV2ZWxzW2ldO1xuICAgICAgICBjb25zdCBuID0gdXBkYXRlc1tpXTtcbiAgICAgICAgaWYgKG4pIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG8pIHtcbiAgICAgICAgICAgICAgICBpZiAoIShrZXkgaW4gbikpXG4gICAgICAgICAgICAgICAgICAgIHRvX251bGxfb3V0W2tleV0gPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbikge1xuICAgICAgICAgICAgICAgIGlmICghYWNjb3VudGVkX2ZvcltrZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVtrZXldID0gbltrZXldO1xuICAgICAgICAgICAgICAgICAgICBhY2NvdW50ZWRfZm9yW2tleV0gPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldmVsc1tpXSA9IG47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvKSB7XG4gICAgICAgICAgICAgICAgYWNjb3VudGVkX2ZvcltrZXldID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiB0b19udWxsX291dCkge1xuICAgICAgICBpZiAoIShrZXkgaW4gdXBkYXRlKSlcbiAgICAgICAgICAgIHVwZGF0ZVtrZXldID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gdXBkYXRlO1xufVxuZnVuY3Rpb24gZ2V0X3NwcmVhZF9vYmplY3Qoc3ByZWFkX3Byb3BzKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBzcHJlYWRfcHJvcHMgPT09ICdvYmplY3QnICYmIHNwcmVhZF9wcm9wcyAhPT0gbnVsbCA/IHNwcmVhZF9wcm9wcyA6IHt9O1xufVxuXG4vLyBzb3VyY2U6IGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2luZGljZXMuaHRtbFxuY29uc3QgYm9vbGVhbl9hdHRyaWJ1dGVzID0gbmV3IFNldChbXG4gICAgJ2FsbG93ZnVsbHNjcmVlbicsXG4gICAgJ2FsbG93cGF5bWVudHJlcXVlc3QnLFxuICAgICdhc3luYycsXG4gICAgJ2F1dG9mb2N1cycsXG4gICAgJ2F1dG9wbGF5JyxcbiAgICAnY2hlY2tlZCcsXG4gICAgJ2NvbnRyb2xzJyxcbiAgICAnZGVmYXVsdCcsXG4gICAgJ2RlZmVyJyxcbiAgICAnZGlzYWJsZWQnLFxuICAgICdmb3Jtbm92YWxpZGF0ZScsXG4gICAgJ2hpZGRlbicsXG4gICAgJ2lzbWFwJyxcbiAgICAnbG9vcCcsXG4gICAgJ211bHRpcGxlJyxcbiAgICAnbXV0ZWQnLFxuICAgICdub21vZHVsZScsXG4gICAgJ25vdmFsaWRhdGUnLFxuICAgICdvcGVuJyxcbiAgICAncGxheXNpbmxpbmUnLFxuICAgICdyZWFkb25seScsXG4gICAgJ3JlcXVpcmVkJyxcbiAgICAncmV2ZXJzZWQnLFxuICAgICdzZWxlY3RlZCdcbl0pO1xuXG5jb25zdCBpbnZhbGlkX2F0dHJpYnV0ZV9uYW1lX2NoYXJhY3RlciA9IC9bXFxzJ1wiPi89XFx1e0ZERDB9LVxcdXtGREVGfVxcdXtGRkZFfVxcdXtGRkZGfVxcdXsxRkZGRX1cXHV7MUZGRkZ9XFx1ezJGRkZFfVxcdXsyRkZGRn1cXHV7M0ZGRkV9XFx1ezNGRkZGfVxcdXs0RkZGRX1cXHV7NEZGRkZ9XFx1ezVGRkZFfVxcdXs1RkZGRn1cXHV7NkZGRkV9XFx1ezZGRkZGfVxcdXs3RkZGRX1cXHV7N0ZGRkZ9XFx1ezhGRkZFfVxcdXs4RkZGRn1cXHV7OUZGRkV9XFx1ezlGRkZGfVxcdXtBRkZGRX1cXHV7QUZGRkZ9XFx1e0JGRkZFfVxcdXtCRkZGRn1cXHV7Q0ZGRkV9XFx1e0NGRkZGfVxcdXtERkZGRX1cXHV7REZGRkZ9XFx1e0VGRkZFfVxcdXtFRkZGRn1cXHV7RkZGRkV9XFx1e0ZGRkZGfVxcdXsxMEZGRkV9XFx1ezEwRkZGRn1dL3U7XG4vLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNhdHRyaWJ1dGVzLTJcbi8vIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNub25jaGFyYWN0ZXJcbmZ1bmN0aW9uIHNwcmVhZChhcmdzLCBjbGFzc2VzX3RvX2FkZCkge1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBPYmplY3QuYXNzaWduKHt9LCAuLi5hcmdzKTtcbiAgICBpZiAoY2xhc3Nlc190b19hZGQpIHtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZXMuY2xhc3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgYXR0cmlidXRlcy5jbGFzcyA9IGNsYXNzZXNfdG9fYWRkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXR0cmlidXRlcy5jbGFzcyArPSAnICcgKyBjbGFzc2VzX3RvX2FkZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgc3RyID0gJyc7XG4gICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgICAgaWYgKGludmFsaWRfYXR0cmlidXRlX25hbWVfY2hhcmFjdGVyLnRlc3QobmFtZSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHZhbHVlID0gYXR0cmlidXRlc1tuYW1lXTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB0cnVlKVxuICAgICAgICAgICAgc3RyICs9IFwiIFwiICsgbmFtZTtcbiAgICAgICAgZWxzZSBpZiAoYm9vbGVhbl9hdHRyaWJ1dGVzLmhhcyhuYW1lLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUpXG4gICAgICAgICAgICAgICAgc3RyICs9IFwiIFwiICsgbmFtZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzdHIgKz0gYCAke25hbWV9PVwiJHtTdHJpbmcodmFsdWUpLnJlcGxhY2UoL1wiL2csICcmIzM0OycpLnJlcGxhY2UoLycvZywgJyYjMzk7Jyl9XCJgO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHN0cjtcbn1cbmNvbnN0IGVzY2FwZWQgPSB7XG4gICAgJ1wiJzogJyZxdW90OycsXG4gICAgXCInXCI6ICcmIzM5OycsXG4gICAgJyYnOiAnJmFtcDsnLFxuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnXG59O1xuZnVuY3Rpb24gZXNjYXBlKGh0bWwpIHtcbiAgICByZXR1cm4gU3RyaW5nKGh0bWwpLnJlcGxhY2UoL1tcIicmPD5dL2csIG1hdGNoID0+IGVzY2FwZWRbbWF0Y2hdKTtcbn1cbmZ1bmN0aW9uIGVhY2goaXRlbXMsIGZuKSB7XG4gICAgbGV0IHN0ciA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgc3RyICs9IGZuKGl0ZW1zW2ldLCBpKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn1cbmNvbnN0IG1pc3NpbmdfY29tcG9uZW50ID0ge1xuICAgICQkcmVuZGVyOiAoKSA9PiAnJ1xufTtcbmZ1bmN0aW9uIHZhbGlkYXRlX2NvbXBvbmVudChjb21wb25lbnQsIG5hbWUpIHtcbiAgICBpZiAoIWNvbXBvbmVudCB8fCAhY29tcG9uZW50LiQkcmVuZGVyKSB7XG4gICAgICAgIGlmIChuYW1lID09PSAnc3ZlbHRlOmNvbXBvbmVudCcpXG4gICAgICAgICAgICBuYW1lICs9ICcgdGhpcz17Li4ufSc7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgPCR7bmFtZX0+IGlzIG5vdCBhIHZhbGlkIFNTUiBjb21wb25lbnQuIFlvdSBtYXkgbmVlZCB0byByZXZpZXcgeW91ciBidWlsZCBjb25maWcgdG8gZW5zdXJlIHRoYXQgZGVwZW5kZW5jaWVzIGFyZSBjb21waWxlZCwgcmF0aGVyIHRoYW4gaW1wb3J0ZWQgYXMgcHJlLWNvbXBpbGVkIG1vZHVsZXNgKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbXBvbmVudDtcbn1cbmZ1bmN0aW9uIGRlYnVnKGZpbGUsIGxpbmUsIGNvbHVtbiwgdmFsdWVzKSB7XG4gICAgY29uc29sZS5sb2coYHtAZGVidWd9ICR7ZmlsZSA/IGZpbGUgKyAnICcgOiAnJ30oJHtsaW5lfToke2NvbHVtbn0pYCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgIGNvbnNvbGUubG9nKHZhbHVlcyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgIHJldHVybiAnJztcbn1cbmxldCBvbl9kZXN0cm95O1xuZnVuY3Rpb24gY3JlYXRlX3Nzcl9jb21wb25lbnQoZm4pIHtcbiAgICBmdW5jdGlvbiAkJHJlbmRlcihyZXN1bHQsIHByb3BzLCBiaW5kaW5ncywgc2xvdHMpIHtcbiAgICAgICAgY29uc3QgcGFyZW50X2NvbXBvbmVudCA9IGN1cnJlbnRfY29tcG9uZW50O1xuICAgICAgICBjb25zdCAkJCA9IHtcbiAgICAgICAgICAgIG9uX2Rlc3Ryb3ksXG4gICAgICAgICAgICBjb250ZXh0OiBuZXcgTWFwKHBhcmVudF9jb21wb25lbnQgPyBwYXJlbnRfY29tcG9uZW50LiQkLmNvbnRleHQgOiBbXSksXG4gICAgICAgICAgICAvLyB0aGVzZSB3aWxsIGJlIGltbWVkaWF0ZWx5IGRpc2NhcmRlZFxuICAgICAgICAgICAgb25fbW91bnQ6IFtdLFxuICAgICAgICAgICAgYmVmb3JlX3VwZGF0ZTogW10sXG4gICAgICAgICAgICBhZnRlcl91cGRhdGU6IFtdLFxuICAgICAgICAgICAgY2FsbGJhY2tzOiBibGFua19vYmplY3QoKVxuICAgICAgICB9O1xuICAgICAgICBzZXRfY3VycmVudF9jb21wb25lbnQoeyAkJCB9KTtcbiAgICAgICAgY29uc3QgaHRtbCA9IGZuKHJlc3VsdCwgcHJvcHMsIGJpbmRpbmdzLCBzbG90cyk7XG4gICAgICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChwYXJlbnRfY29tcG9uZW50KTtcbiAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHJlbmRlcjogKHByb3BzID0ge30sIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgb25fZGVzdHJveSA9IFtdO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geyB0aXRsZTogJycsIGhlYWQ6ICcnLCBjc3M6IG5ldyBTZXQoKSB9O1xuICAgICAgICAgICAgY29uc3QgaHRtbCA9ICQkcmVuZGVyKHJlc3VsdCwgcHJvcHMsIHt9LCBvcHRpb25zKTtcbiAgICAgICAgICAgIHJ1bl9hbGwob25fZGVzdHJveSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGh0bWwsXG4gICAgICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IEFycmF5LmZyb20ocmVzdWx0LmNzcykubWFwKGNzcyA9PiBjc3MuY29kZSkuam9pbignXFxuJyksXG4gICAgICAgICAgICAgICAgICAgIG1hcDogbnVsbCAvLyBUT0RPXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBoZWFkOiByZXN1bHQudGl0bGUgKyByZXN1bHQuaGVhZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgJCRyZW5kZXJcbiAgICB9O1xufVxuZnVuY3Rpb24gYWRkX2F0dHJpYnV0ZShuYW1lLCB2YWx1ZSwgYm9vbGVhbikge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IChib29sZWFuICYmICF2YWx1ZSkpXG4gICAgICAgIHJldHVybiAnJztcbiAgICByZXR1cm4gYCAke25hbWV9JHt2YWx1ZSA9PT0gdHJ1ZSA/ICcnIDogYD0ke3R5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyBKU09OLnN0cmluZ2lmeShlc2NhcGUodmFsdWUpKSA6IGBcIiR7dmFsdWV9XCJgfWB9YDtcbn1cbmZ1bmN0aW9uIGFkZF9jbGFzc2VzKGNsYXNzZXMpIHtcbiAgICByZXR1cm4gY2xhc3NlcyA/IGAgY2xhc3M9XCIke2NsYXNzZXN9XCJgIDogYGA7XG59XG5cbmZ1bmN0aW9uIGJpbmQoY29tcG9uZW50LCBuYW1lLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGluZGV4ID0gY29tcG9uZW50LiQkLnByb3BzW25hbWVdO1xuICAgIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbXBvbmVudC4kJC5ib3VuZFtpbmRleF0gPSBjYWxsYmFjaztcbiAgICAgICAgY2FsbGJhY2soY29tcG9uZW50LiQkLmN0eFtpbmRleF0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZV9jb21wb25lbnQoYmxvY2spIHtcbiAgICBibG9jayAmJiBibG9jay5jKCk7XG59XG5mdW5jdGlvbiBjbGFpbV9jb21wb25lbnQoYmxvY2ssIHBhcmVudF9ub2Rlcykge1xuICAgIGJsb2NrICYmIGJsb2NrLmwocGFyZW50X25vZGVzKTtcbn1cbmZ1bmN0aW9uIG1vdW50X2NvbXBvbmVudChjb21wb25lbnQsIHRhcmdldCwgYW5jaG9yKSB7XG4gICAgY29uc3QgeyBmcmFnbWVudCwgb25fbW91bnQsIG9uX2Rlc3Ryb3ksIGFmdGVyX3VwZGF0ZSB9ID0gY29tcG9uZW50LiQkO1xuICAgIGZyYWdtZW50ICYmIGZyYWdtZW50Lm0odGFyZ2V0LCBhbmNob3IpO1xuICAgIC8vIG9uTW91bnQgaGFwcGVucyBiZWZvcmUgdGhlIGluaXRpYWwgYWZ0ZXJVcGRhdGVcbiAgICBhZGRfcmVuZGVyX2NhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgY29uc3QgbmV3X29uX2Rlc3Ryb3kgPSBvbl9tb3VudC5tYXAocnVuKS5maWx0ZXIoaXNfZnVuY3Rpb24pO1xuICAgICAgICBpZiAob25fZGVzdHJveSkge1xuICAgICAgICAgICAgb25fZGVzdHJveS5wdXNoKC4uLm5ld19vbl9kZXN0cm95KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEVkZ2UgY2FzZSAtIGNvbXBvbmVudCB3YXMgZGVzdHJveWVkIGltbWVkaWF0ZWx5LFxuICAgICAgICAgICAgLy8gbW9zdCBsaWtlbHkgYXMgYSByZXN1bHQgb2YgYSBiaW5kaW5nIGluaXRpYWxpc2luZ1xuICAgICAgICAgICAgcnVuX2FsbChuZXdfb25fZGVzdHJveSk7XG4gICAgICAgIH1cbiAgICAgICAgY29tcG9uZW50LiQkLm9uX21vdW50ID0gW107XG4gICAgfSk7XG4gICAgYWZ0ZXJfdXBkYXRlLmZvckVhY2goYWRkX3JlbmRlcl9jYWxsYmFjayk7XG59XG5mdW5jdGlvbiBkZXN0cm95X2NvbXBvbmVudChjb21wb25lbnQsIGRldGFjaGluZykge1xuICAgIGNvbnN0ICQkID0gY29tcG9uZW50LiQkO1xuICAgIGlmICgkJC5mcmFnbWVudCAhPT0gbnVsbCkge1xuICAgICAgICBydW5fYWxsKCQkLm9uX2Rlc3Ryb3kpO1xuICAgICAgICAkJC5mcmFnbWVudCAmJiAkJC5mcmFnbWVudC5kKGRldGFjaGluZyk7XG4gICAgICAgIC8vIFRPRE8gbnVsbCBvdXQgb3RoZXIgcmVmcywgaW5jbHVkaW5nIGNvbXBvbmVudC4kJCAoYnV0IG5lZWQgdG9cbiAgICAgICAgLy8gcHJlc2VydmUgZmluYWwgc3RhdGU/KVxuICAgICAgICAkJC5vbl9kZXN0cm95ID0gJCQuZnJhZ21lbnQgPSBudWxsO1xuICAgICAgICAkJC5jdHggPSBbXTtcbiAgICB9XG59XG5mdW5jdGlvbiBtYWtlX2RpcnR5KGNvbXBvbmVudCwgaSkge1xuICAgIGlmIChjb21wb25lbnQuJCQuZGlydHlbMF0gPT09IC0xKSB7XG4gICAgICAgIGRpcnR5X2NvbXBvbmVudHMucHVzaChjb21wb25lbnQpO1xuICAgICAgICBzY2hlZHVsZV91cGRhdGUoKTtcbiAgICAgICAgY29tcG9uZW50LiQkLmRpcnR5LmZpbGwoMCk7XG4gICAgfVxuICAgIGNvbXBvbmVudC4kJC5kaXJ0eVsoaSAvIDMxKSB8IDBdIHw9ICgxIDw8IChpICUgMzEpKTtcbn1cbmZ1bmN0aW9uIGluaXQoY29tcG9uZW50LCBvcHRpb25zLCBpbnN0YW5jZSwgY3JlYXRlX2ZyYWdtZW50LCBub3RfZXF1YWwsIHByb3BzLCBkaXJ0eSA9IFstMV0pIHtcbiAgICBjb25zdCBwYXJlbnRfY29tcG9uZW50ID0gY3VycmVudF9jb21wb25lbnQ7XG4gICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KGNvbXBvbmVudCk7XG4gICAgY29uc3QgcHJvcF92YWx1ZXMgPSBvcHRpb25zLnByb3BzIHx8IHt9O1xuICAgIGNvbnN0ICQkID0gY29tcG9uZW50LiQkID0ge1xuICAgICAgICBmcmFnbWVudDogbnVsbCxcbiAgICAgICAgY3R4OiBudWxsLFxuICAgICAgICAvLyBzdGF0ZVxuICAgICAgICBwcm9wcyxcbiAgICAgICAgdXBkYXRlOiBub29wLFxuICAgICAgICBub3RfZXF1YWwsXG4gICAgICAgIGJvdW5kOiBibGFua19vYmplY3QoKSxcbiAgICAgICAgLy8gbGlmZWN5Y2xlXG4gICAgICAgIG9uX21vdW50OiBbXSxcbiAgICAgICAgb25fZGVzdHJveTogW10sXG4gICAgICAgIGJlZm9yZV91cGRhdGU6IFtdLFxuICAgICAgICBhZnRlcl91cGRhdGU6IFtdLFxuICAgICAgICBjb250ZXh0OiBuZXcgTWFwKHBhcmVudF9jb21wb25lbnQgPyBwYXJlbnRfY29tcG9uZW50LiQkLmNvbnRleHQgOiBbXSksXG4gICAgICAgIC8vIGV2ZXJ5dGhpbmcgZWxzZVxuICAgICAgICBjYWxsYmFja3M6IGJsYW5rX29iamVjdCgpLFxuICAgICAgICBkaXJ0eVxuICAgIH07XG4gICAgbGV0IHJlYWR5ID0gZmFsc2U7XG4gICAgJCQuY3R4ID0gaW5zdGFuY2VcbiAgICAgICAgPyBpbnN0YW5jZShjb21wb25lbnQsIHByb3BfdmFsdWVzLCAoaSwgcmV0LCAuLi5yZXN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHJlc3QubGVuZ3RoID8gcmVzdFswXSA6IHJldDtcbiAgICAgICAgICAgIGlmICgkJC5jdHggJiYgbm90X2VxdWFsKCQkLmN0eFtpXSwgJCQuY3R4W2ldID0gdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCQkLmJvdW5kW2ldKVxuICAgICAgICAgICAgICAgICAgICAkJC5ib3VuZFtpXSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlYWR5KVxuICAgICAgICAgICAgICAgICAgICBtYWtlX2RpcnR5KGNvbXBvbmVudCwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9KVxuICAgICAgICA6IFtdO1xuICAgICQkLnVwZGF0ZSgpO1xuICAgIHJlYWR5ID0gdHJ1ZTtcbiAgICBydW5fYWxsKCQkLmJlZm9yZV91cGRhdGUpO1xuICAgIC8vIGBmYWxzZWAgYXMgYSBzcGVjaWFsIGNhc2Ugb2Ygbm8gRE9NIGNvbXBvbmVudFxuICAgICQkLmZyYWdtZW50ID0gY3JlYXRlX2ZyYWdtZW50ID8gY3JlYXRlX2ZyYWdtZW50KCQkLmN0eCkgOiBmYWxzZTtcbiAgICBpZiAob3B0aW9ucy50YXJnZXQpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuaHlkcmF0ZSkge1xuICAgICAgICAgICAgY29uc3Qgbm9kZXMgPSBjaGlsZHJlbihvcHRpb25zLnRhcmdldCk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgJCQuZnJhZ21lbnQgJiYgJCQuZnJhZ21lbnQubChub2Rlcyk7XG4gICAgICAgICAgICBub2Rlcy5mb3JFYWNoKGRldGFjaCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgJCQuZnJhZ21lbnQgJiYgJCQuZnJhZ21lbnQuYygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmludHJvKVxuICAgICAgICAgICAgdHJhbnNpdGlvbl9pbihjb21wb25lbnQuJCQuZnJhZ21lbnQpO1xuICAgICAgICBtb3VudF9jb21wb25lbnQoY29tcG9uZW50LCBvcHRpb25zLnRhcmdldCwgb3B0aW9ucy5hbmNob3IpO1xuICAgICAgICBmbHVzaCgpO1xuICAgIH1cbiAgICBzZXRfY3VycmVudF9jb21wb25lbnQocGFyZW50X2NvbXBvbmVudCk7XG59XG5sZXQgU3ZlbHRlRWxlbWVudDtcbmlmICh0eXBlb2YgSFRNTEVsZW1lbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBTdmVsdGVFbGVtZW50ID0gY2xhc3MgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgICAgIHRoaXMuYXR0YWNoU2hhZG93KHsgbW9kZTogJ29wZW4nIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSB0b2RvOiBpbXByb3ZlIHR5cGluZ3NcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMuJCQuc2xvdHRlZCkge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgdG9kbzogaW1wcm92ZSB0eXBpbmdzXG4gICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRDaGlsZCh0aGlzLiQkLnNsb3R0ZWRba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKGF0dHIsIF9vbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXNbYXR0cl0gPSBuZXdWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICAkZGVzdHJveSgpIHtcbiAgICAgICAgICAgIGRlc3Ryb3lfY29tcG9uZW50KHRoaXMsIDEpO1xuICAgICAgICAgICAgdGhpcy4kZGVzdHJveSA9IG5vb3A7XG4gICAgICAgIH1cbiAgICAgICAgJG9uKHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAvLyBUT0RPIHNob3VsZCB0aGlzIGRlbGVnYXRlIHRvIGFkZEV2ZW50TGlzdGVuZXI/XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFja3MgPSAodGhpcy4kJC5jYWxsYmFja3NbdHlwZV0gfHwgKHRoaXMuJCQuY2FsbGJhY2tzW3R5cGVdID0gW10pKTtcbiAgICAgICAgICAgIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBjYWxsYmFja3MuaW5kZXhPZihjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgICRzZXQoKSB7XG4gICAgICAgICAgICAvLyBvdmVycmlkZGVuIGJ5IGluc3RhbmNlLCBpZiBpdCBoYXMgcHJvcHNcbiAgICAgICAgfVxuICAgIH07XG59XG5jbGFzcyBTdmVsdGVDb21wb25lbnQge1xuICAgICRkZXN0cm95KCkge1xuICAgICAgICBkZXN0cm95X2NvbXBvbmVudCh0aGlzLCAxKTtcbiAgICAgICAgdGhpcy4kZGVzdHJveSA9IG5vb3A7XG4gICAgfVxuICAgICRvbih0eXBlLCBjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBjYWxsYmFja3MgPSAodGhpcy4kJC5jYWxsYmFja3NbdHlwZV0gfHwgKHRoaXMuJCQuY2FsbGJhY2tzW3R5cGVdID0gW10pKTtcbiAgICAgICAgY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBjYWxsYmFja3MuaW5kZXhPZihjYWxsYmFjayk7XG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAkc2V0KCkge1xuICAgICAgICAvLyBvdmVycmlkZGVuIGJ5IGluc3RhbmNlLCBpZiBpdCBoYXMgcHJvcHNcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoX2Rldih0eXBlLCBkZXRhaWwpIHtcbiAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KGN1c3RvbV9ldmVudCh0eXBlLCBPYmplY3QuYXNzaWduKHsgdmVyc2lvbjogJzMuMjQuMCcgfSwgZGV0YWlsKSkpO1xufVxuZnVuY3Rpb24gYXBwZW5kX2Rldih0YXJnZXQsIG5vZGUpIHtcbiAgICBkaXNwYXRjaF9kZXYoXCJTdmVsdGVET01JbnNlcnRcIiwgeyB0YXJnZXQsIG5vZGUgfSk7XG4gICAgYXBwZW5kKHRhcmdldCwgbm9kZSk7XG59XG5mdW5jdGlvbiBpbnNlcnRfZGV2KHRhcmdldCwgbm9kZSwgYW5jaG9yKSB7XG4gICAgZGlzcGF0Y2hfZGV2KFwiU3ZlbHRlRE9NSW5zZXJ0XCIsIHsgdGFyZ2V0LCBub2RlLCBhbmNob3IgfSk7XG4gICAgaW5zZXJ0KHRhcmdldCwgbm9kZSwgYW5jaG9yKTtcbn1cbmZ1bmN0aW9uIGRldGFjaF9kZXYobm9kZSkge1xuICAgIGRpc3BhdGNoX2RldihcIlN2ZWx0ZURPTVJlbW92ZVwiLCB7IG5vZGUgfSk7XG4gICAgZGV0YWNoKG5vZGUpO1xufVxuZnVuY3Rpb24gZGV0YWNoX2JldHdlZW5fZGV2KGJlZm9yZSwgYWZ0ZXIpIHtcbiAgICB3aGlsZSAoYmVmb3JlLm5leHRTaWJsaW5nICYmIGJlZm9yZS5uZXh0U2libGluZyAhPT0gYWZ0ZXIpIHtcbiAgICAgICAgZGV0YWNoX2RldihiZWZvcmUubmV4dFNpYmxpbmcpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRldGFjaF9iZWZvcmVfZGV2KGFmdGVyKSB7XG4gICAgd2hpbGUgKGFmdGVyLnByZXZpb3VzU2libGluZykge1xuICAgICAgICBkZXRhY2hfZGV2KGFmdGVyLnByZXZpb3VzU2libGluZyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZGV0YWNoX2FmdGVyX2RldihiZWZvcmUpIHtcbiAgICB3aGlsZSAoYmVmb3JlLm5leHRTaWJsaW5nKSB7XG4gICAgICAgIGRldGFjaF9kZXYoYmVmb3JlLm5leHRTaWJsaW5nKTtcbiAgICB9XG59XG5mdW5jdGlvbiBsaXN0ZW5fZGV2KG5vZGUsIGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zLCBoYXNfcHJldmVudF9kZWZhdWx0LCBoYXNfc3RvcF9wcm9wYWdhdGlvbikge1xuICAgIGNvbnN0IG1vZGlmaWVycyA9IG9wdGlvbnMgPT09IHRydWUgPyBbXCJjYXB0dXJlXCJdIDogb3B0aW9ucyA/IEFycmF5LmZyb20oT2JqZWN0LmtleXMob3B0aW9ucykpIDogW107XG4gICAgaWYgKGhhc19wcmV2ZW50X2RlZmF1bHQpXG4gICAgICAgIG1vZGlmaWVycy5wdXNoKCdwcmV2ZW50RGVmYXVsdCcpO1xuICAgIGlmIChoYXNfc3RvcF9wcm9wYWdhdGlvbilcbiAgICAgICAgbW9kaWZpZXJzLnB1c2goJ3N0b3BQcm9wYWdhdGlvbicpO1xuICAgIGRpc3BhdGNoX2RldihcIlN2ZWx0ZURPTUFkZEV2ZW50TGlzdGVuZXJcIiwgeyBub2RlLCBldmVudCwgaGFuZGxlciwgbW9kaWZpZXJzIH0pO1xuICAgIGNvbnN0IGRpc3Bvc2UgPSBsaXN0ZW4obm9kZSwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGRpc3BhdGNoX2RldihcIlN2ZWx0ZURPTVJlbW92ZUV2ZW50TGlzdGVuZXJcIiwgeyBub2RlLCBldmVudCwgaGFuZGxlciwgbW9kaWZpZXJzIH0pO1xuICAgICAgICBkaXNwb3NlKCk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGF0dHJfZGV2KG5vZGUsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICBhdHRyKG5vZGUsIGF0dHJpYnV0ZSwgdmFsdWUpO1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKVxuICAgICAgICBkaXNwYXRjaF9kZXYoXCJTdmVsdGVET01SZW1vdmVBdHRyaWJ1dGVcIiwgeyBub2RlLCBhdHRyaWJ1dGUgfSk7XG4gICAgZWxzZVxuICAgICAgICBkaXNwYXRjaF9kZXYoXCJTdmVsdGVET01TZXRBdHRyaWJ1dGVcIiwgeyBub2RlLCBhdHRyaWJ1dGUsIHZhbHVlIH0pO1xufVxuZnVuY3Rpb24gcHJvcF9kZXYobm9kZSwgcHJvcGVydHksIHZhbHVlKSB7XG4gICAgbm9kZVtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICBkaXNwYXRjaF9kZXYoXCJTdmVsdGVET01TZXRQcm9wZXJ0eVwiLCB7IG5vZGUsIHByb3BlcnR5LCB2YWx1ZSB9KTtcbn1cbmZ1bmN0aW9uIGRhdGFzZXRfZGV2KG5vZGUsIHByb3BlcnR5LCB2YWx1ZSkge1xuICAgIG5vZGUuZGF0YXNldFtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICBkaXNwYXRjaF9kZXYoXCJTdmVsdGVET01TZXREYXRhc2V0XCIsIHsgbm9kZSwgcHJvcGVydHksIHZhbHVlIH0pO1xufVxuZnVuY3Rpb24gc2V0X2RhdGFfZGV2KHRleHQsIGRhdGEpIHtcbiAgICBkYXRhID0gJycgKyBkYXRhO1xuICAgIGlmICh0ZXh0Lndob2xlVGV4dCA9PT0gZGF0YSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGRpc3BhdGNoX2RldihcIlN2ZWx0ZURPTVNldERhdGFcIiwgeyBub2RlOiB0ZXh0LCBkYXRhIH0pO1xuICAgIHRleHQuZGF0YSA9IGRhdGE7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZV9lYWNoX2FyZ3VtZW50KGFyZykge1xuICAgIGlmICh0eXBlb2YgYXJnICE9PSAnc3RyaW5nJyAmJiAhKGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiAnbGVuZ3RoJyBpbiBhcmcpKSB7XG4gICAgICAgIGxldCBtc2cgPSAneyNlYWNofSBvbmx5IGl0ZXJhdGVzIG92ZXIgYXJyYXktbGlrZSBvYmplY3RzLic7XG4gICAgICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIGFyZyAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gYXJnKSB7XG4gICAgICAgICAgICBtc2cgKz0gJyBZb3UgY2FuIHVzZSBhIHNwcmVhZCB0byBjb252ZXJ0IHRoaXMgaXRlcmFibGUgaW50byBhbiBhcnJheS4nO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlX3Nsb3RzKG5hbWUsIHNsb3QsIGtleXMpIHtcbiAgICBmb3IgKGNvbnN0IHNsb3Rfa2V5IG9mIE9iamVjdC5rZXlzKHNsb3QpKSB7XG4gICAgICAgIGlmICghfmtleXMuaW5kZXhPZihzbG90X2tleSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgPCR7bmFtZX0+IHJlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgc2xvdCBcIiR7c2xvdF9rZXl9XCIuYCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBTdmVsdGVDb21wb25lbnREZXYgZXh0ZW5kcyBTdmVsdGVDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zIHx8ICghb3B0aW9ucy50YXJnZXQgJiYgIW9wdGlvbnMuJCRpbmxpbmUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCd0YXJnZXQnIGlzIGEgcmVxdWlyZWQgb3B0aW9uYCk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoKTtcbiAgICB9XG4gICAgJGRlc3Ryb3koKSB7XG4gICAgICAgIHN1cGVyLiRkZXN0cm95KCk7XG4gICAgICAgIHRoaXMuJGRlc3Ryb3kgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYENvbXBvbmVudCB3YXMgYWxyZWFkeSBkZXN0cm95ZWRgKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgICAgIH07XG4gICAgfVxuICAgICRjYXB0dXJlX3N0YXRlKCkgeyB9XG4gICAgJGluamVjdF9zdGF0ZSgpIHsgfVxufVxuZnVuY3Rpb24gbG9vcF9ndWFyZCh0aW1lb3V0KSB7XG4gICAgY29uc3Qgc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlmIChEYXRlLm5vdygpIC0gc3RhcnQgPiB0aW1lb3V0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluZmluaXRlIGxvb3AgZGV0ZWN0ZWRgKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmV4cG9ydCB7IEh0bWxUYWcsIFN2ZWx0ZUNvbXBvbmVudCwgU3ZlbHRlQ29tcG9uZW50RGV2LCBTdmVsdGVFbGVtZW50LCBhY3Rpb25fZGVzdHJveWVyLCBhZGRfYXR0cmlidXRlLCBhZGRfY2xhc3NlcywgYWRkX2ZsdXNoX2NhbGxiYWNrLCBhZGRfbG9jYXRpb24sIGFkZF9yZW5kZXJfY2FsbGJhY2ssIGFkZF9yZXNpemVfbGlzdGVuZXIsIGFkZF90cmFuc2Zvcm0sIGFmdGVyVXBkYXRlLCBhcHBlbmQsIGFwcGVuZF9kZXYsIGFzc2lnbiwgYXR0ciwgYXR0cl9kZXYsIGJlZm9yZVVwZGF0ZSwgYmluZCwgYmluZGluZ19jYWxsYmFja3MsIGJsYW5rX29iamVjdCwgYnViYmxlLCBjaGVja19vdXRyb3MsIGNoaWxkcmVuLCBjbGFpbV9jb21wb25lbnQsIGNsYWltX2VsZW1lbnQsIGNsYWltX3NwYWNlLCBjbGFpbV90ZXh0LCBjbGVhcl9sb29wcywgY29tcG9uZW50X3N1YnNjcmliZSwgY29tcHV0ZV9yZXN0X3Byb3BzLCBjcmVhdGVFdmVudERpc3BhdGNoZXIsIGNyZWF0ZV9hbmltYXRpb24sIGNyZWF0ZV9iaWRpcmVjdGlvbmFsX3RyYW5zaXRpb24sIGNyZWF0ZV9jb21wb25lbnQsIGNyZWF0ZV9pbl90cmFuc2l0aW9uLCBjcmVhdGVfb3V0X3RyYW5zaXRpb24sIGNyZWF0ZV9zbG90LCBjcmVhdGVfc3NyX2NvbXBvbmVudCwgY3VycmVudF9jb21wb25lbnQsIGN1c3RvbV9ldmVudCwgZGF0YXNldF9kZXYsIGRlYnVnLCBkZXN0cm95X2Jsb2NrLCBkZXN0cm95X2NvbXBvbmVudCwgZGVzdHJveV9lYWNoLCBkZXRhY2gsIGRldGFjaF9hZnRlcl9kZXYsIGRldGFjaF9iZWZvcmVfZGV2LCBkZXRhY2hfYmV0d2Vlbl9kZXYsIGRldGFjaF9kZXYsIGRpcnR5X2NvbXBvbmVudHMsIGRpc3BhdGNoX2RldiwgZWFjaCwgZWxlbWVudCwgZWxlbWVudF9pcywgZW1wdHksIGVzY2FwZSwgZXNjYXBlZCwgZXhjbHVkZV9pbnRlcm5hbF9wcm9wcywgZml4X2FuZF9kZXN0cm95X2Jsb2NrLCBmaXhfYW5kX291dHJvX2FuZF9kZXN0cm95X2Jsb2NrLCBmaXhfcG9zaXRpb24sIGZsdXNoLCBnZXRDb250ZXh0LCBnZXRfYmluZGluZ19ncm91cF92YWx1ZSwgZ2V0X2N1cnJlbnRfY29tcG9uZW50LCBnZXRfc2xvdF9jaGFuZ2VzLCBnZXRfc2xvdF9jb250ZXh0LCBnZXRfc3ByZWFkX29iamVjdCwgZ2V0X3NwcmVhZF91cGRhdGUsIGdldF9zdG9yZV92YWx1ZSwgZ2xvYmFscywgZ3JvdXBfb3V0cm9zLCBoYW5kbGVfcHJvbWlzZSwgaGFzX3Byb3AsIGlkZW50aXR5LCBpbml0LCBpbnNlcnQsIGluc2VydF9kZXYsIGludHJvcywgaW52YWxpZF9hdHRyaWJ1dGVfbmFtZV9jaGFyYWN0ZXIsIGlzX2NsaWVudCwgaXNfY3Jvc3NvcmlnaW4sIGlzX2Z1bmN0aW9uLCBpc19wcm9taXNlLCBsaXN0ZW4sIGxpc3Rlbl9kZXYsIGxvb3AsIGxvb3BfZ3VhcmQsIG1pc3NpbmdfY29tcG9uZW50LCBtb3VudF9jb21wb25lbnQsIG5vb3AsIG5vdF9lcXVhbCwgbm93LCBudWxsX3RvX2VtcHR5LCBvYmplY3Rfd2l0aG91dF9wcm9wZXJ0aWVzLCBvbkRlc3Ryb3ksIG9uTW91bnQsIG9uY2UsIG91dHJvX2FuZF9kZXN0cm95X2Jsb2NrLCBwcmV2ZW50X2RlZmF1bHQsIHByb3BfZGV2LCBxdWVyeV9zZWxlY3Rvcl9hbGwsIHJhZiwgcnVuLCBydW5fYWxsLCBzYWZlX25vdF9lcXVhbCwgc2NoZWR1bGVfdXBkYXRlLCBzZWxlY3RfbXVsdGlwbGVfdmFsdWUsIHNlbGVjdF9vcHRpb24sIHNlbGVjdF9vcHRpb25zLCBzZWxlY3RfdmFsdWUsIHNlbGYsIHNldENvbnRleHQsIHNldF9hdHRyaWJ1dGVzLCBzZXRfY3VycmVudF9jb21wb25lbnQsIHNldF9jdXN0b21fZWxlbWVudF9kYXRhLCBzZXRfZGF0YSwgc2V0X2RhdGFfZGV2LCBzZXRfaW5wdXRfdHlwZSwgc2V0X2lucHV0X3ZhbHVlLCBzZXRfbm93LCBzZXRfcmFmLCBzZXRfc3RvcmVfdmFsdWUsIHNldF9zdHlsZSwgc2V0X3N2Z19hdHRyaWJ1dGVzLCBzcGFjZSwgc3ByZWFkLCBzdG9wX3Byb3BhZ2F0aW9uLCBzdWJzY3JpYmUsIHN2Z19lbGVtZW50LCB0ZXh0LCB0aWNrLCB0aW1lX3Jhbmdlc190b19hcnJheSwgdG9fbnVtYmVyLCB0b2dnbGVfY2xhc3MsIHRyYW5zaXRpb25faW4sIHRyYW5zaXRpb25fb3V0LCB1cGRhdGVfa2V5ZWRfZWFjaCwgdXBkYXRlX3Nsb3QsIHZhbGlkYXRlX2NvbXBvbmVudCwgdmFsaWRhdGVfZWFjaF9hcmd1bWVudCwgdmFsaWRhdGVfZWFjaF9rZXlzLCB2YWxpZGF0ZV9zbG90cywgdmFsaWRhdGVfc3RvcmUsIHhsaW5rX2F0dHIgfTtcbiIsImltcG9ydCB7IG5vb3AsIHNhZmVfbm90X2VxdWFsLCBzdWJzY3JpYmUsIHJ1bl9hbGwsIGlzX2Z1bmN0aW9uIH0gZnJvbSAnLi4vaW50ZXJuYWwnO1xuZXhwb3J0IHsgZ2V0X3N0b3JlX3ZhbHVlIGFzIGdldCB9IGZyb20gJy4uL2ludGVybmFsJztcblxuY29uc3Qgc3Vic2NyaWJlcl9xdWV1ZSA9IFtdO1xuLyoqXG4gKiBDcmVhdGVzIGEgYFJlYWRhYmxlYCBzdG9yZSB0aGF0IGFsbG93cyByZWFkaW5nIGJ5IHN1YnNjcmlwdGlvbi5cbiAqIEBwYXJhbSB2YWx1ZSBpbml0aWFsIHZhbHVlXG4gKiBAcGFyYW0ge1N0YXJ0U3RvcE5vdGlmaWVyfXN0YXJ0IHN0YXJ0IGFuZCBzdG9wIG5vdGlmaWNhdGlvbnMgZm9yIHN1YnNjcmlwdGlvbnNcbiAqL1xuZnVuY3Rpb24gcmVhZGFibGUodmFsdWUsIHN0YXJ0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3Vic2NyaWJlOiB3cml0YWJsZSh2YWx1ZSwgc3RhcnQpLnN1YnNjcmliZSxcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGUgYSBgV3JpdGFibGVgIHN0b3JlIHRoYXQgYWxsb3dzIGJvdGggdXBkYXRpbmcgYW5kIHJlYWRpbmcgYnkgc3Vic2NyaXB0aW9uLlxuICogQHBhcmFtIHsqPX12YWx1ZSBpbml0aWFsIHZhbHVlXG4gKiBAcGFyYW0ge1N0YXJ0U3RvcE5vdGlmaWVyPX1zdGFydCBzdGFydCBhbmQgc3RvcCBub3RpZmljYXRpb25zIGZvciBzdWJzY3JpcHRpb25zXG4gKi9cbmZ1bmN0aW9uIHdyaXRhYmxlKHZhbHVlLCBzdGFydCA9IG5vb3ApIHtcbiAgICBsZXQgc3RvcDtcbiAgICBjb25zdCBzdWJzY3JpYmVycyA9IFtdO1xuICAgIGZ1bmN0aW9uIHNldChuZXdfdmFsdWUpIHtcbiAgICAgICAgaWYgKHNhZmVfbm90X2VxdWFsKHZhbHVlLCBuZXdfdmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG5ld192YWx1ZTtcbiAgICAgICAgICAgIGlmIChzdG9wKSB7IC8vIHN0b3JlIGlzIHJlYWR5XG4gICAgICAgICAgICAgICAgY29uc3QgcnVuX3F1ZXVlID0gIXN1YnNjcmliZXJfcXVldWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3Vic2NyaWJlcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcyA9IHN1YnNjcmliZXJzW2ldO1xuICAgICAgICAgICAgICAgICAgICBzWzFdKCk7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXJfcXVldWUucHVzaChzLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChydW5fcXVldWUpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdWJzY3JpYmVyX3F1ZXVlLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyX3F1ZXVlW2ldWzBdKHN1YnNjcmliZXJfcXVldWVbaSArIDFdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyX3F1ZXVlLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZShmbikge1xuICAgICAgICBzZXQoZm4odmFsdWUpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3Vic2NyaWJlKHJ1biwgaW52YWxpZGF0ZSA9IG5vb3ApIHtcbiAgICAgICAgY29uc3Qgc3Vic2NyaWJlciA9IFtydW4sIGludmFsaWRhdGVdO1xuICAgICAgICBzdWJzY3JpYmVycy5wdXNoKHN1YnNjcmliZXIpO1xuICAgICAgICBpZiAoc3Vic2NyaWJlcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBzdG9wID0gc3RhcnQoc2V0KSB8fCBub29wO1xuICAgICAgICB9XG4gICAgICAgIHJ1bih2YWx1ZSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHN1YnNjcmliZXJzLmluZGV4T2Yoc3Vic2NyaWJlcik7XG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdWJzY3JpYmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBzdG9wKCk7XG4gICAgICAgICAgICAgICAgc3RvcCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7IHNldCwgdXBkYXRlLCBzdWJzY3JpYmUgfTtcbn1cbmZ1bmN0aW9uIGRlcml2ZWQoc3RvcmVzLCBmbiwgaW5pdGlhbF92YWx1ZSkge1xuICAgIGNvbnN0IHNpbmdsZSA9ICFBcnJheS5pc0FycmF5KHN0b3Jlcyk7XG4gICAgY29uc3Qgc3RvcmVzX2FycmF5ID0gc2luZ2xlXG4gICAgICAgID8gW3N0b3Jlc11cbiAgICAgICAgOiBzdG9yZXM7XG4gICAgY29uc3QgYXV0byA9IGZuLmxlbmd0aCA8IDI7XG4gICAgcmV0dXJuIHJlYWRhYmxlKGluaXRpYWxfdmFsdWUsIChzZXQpID0+IHtcbiAgICAgICAgbGV0IGluaXRlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICAgICAgbGV0IHBlbmRpbmcgPSAwO1xuICAgICAgICBsZXQgY2xlYW51cCA9IG5vb3A7XG4gICAgICAgIGNvbnN0IHN5bmMgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAocGVuZGluZykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGZuKHNpbmdsZSA/IHZhbHVlc1swXSA6IHZhbHVlcywgc2V0KTtcbiAgICAgICAgICAgIGlmIChhdXRvKSB7XG4gICAgICAgICAgICAgICAgc2V0KHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjbGVhbnVwID0gaXNfZnVuY3Rpb24ocmVzdWx0KSA/IHJlc3VsdCA6IG5vb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHVuc3Vic2NyaWJlcnMgPSBzdG9yZXNfYXJyYXkubWFwKChzdG9yZSwgaSkgPT4gc3Vic2NyaWJlKHN0b3JlLCAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHZhbHVlc1tpXSA9IHZhbHVlO1xuICAgICAgICAgICAgcGVuZGluZyAmPSB+KDEgPDwgaSk7XG4gICAgICAgICAgICBpZiAoaW5pdGVkKSB7XG4gICAgICAgICAgICAgICAgc3luYygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAoKSA9PiB7XG4gICAgICAgICAgICBwZW5kaW5nIHw9ICgxIDw8IGkpO1xuICAgICAgICB9KSk7XG4gICAgICAgIGluaXRlZCA9IHRydWU7XG4gICAgICAgIHN5bmMoKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICAgICAgICBydW5fYWxsKHVuc3Vic2NyaWJlcnMpO1xuICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICB9O1xuICAgIH0pO1xufVxuXG5leHBvcnQgeyBkZXJpdmVkLCByZWFkYWJsZSwgd3JpdGFibGUgfTtcbiIsImltcG9ydCB7IHdyaXRhYmxlIH0gZnJvbSAnc3ZlbHRlL3N0b3JlJztcblxuZXhwb3J0IGNvbnN0IENPTlRFWFRfS0VZID0ge307XG5cbmV4cG9ydCBjb25zdCBwcmVsb2FkID0gKCkgPT4gKHt9KTsiLCI8c2NyaXB0PlxuICBleHBvcnQgbGV0IHNpemUgPSAnMWVtJztcblxuICAkOiBmb3JhbXR0ZWRTaXplID0gTnVtYmVyLmlzRmluaXRlKCtzaXplKSA/IGAke3NpemV9cHhgIDogdHlwZW9mIHNpemUgPT09ICdzdHJpbmcnID8gc2l6ZSA6IG51bGxcbjwvc2NyaXB0PlxuXG48ZGl2IGNsYXNzPVwib3ZlcmZsb3ctaGlkZGVuXCI+XG4gIDxiciBzdHlsZT17YG1hcmdpbi10b3A6ICR7Zm9yYW10dGVkU2l6ZX1gfSBjbGFzcz17JCRwcm9wcy5jbGFzc30vPlxuPC9kaXY+XG5cbjxzdHlsZT5cbiAgOmdsb2JhbChicikge1xuICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgIGhlaWdodDogMDtcbiAgICBjb250ZW50OiBcIlxcMDBhMFwiO1xuICAgIGJveC1zaXppbmc6IGNvbnRlbnQtYm94O1xuICB9XG5cbiAgOmdsb2JhbChici50aW55KSB7XG4gICAgbWFyZ2luLXRvcDogY2FsYygxZW0gKiAwLjI5KTsgLyogNHB4ICovXG4gIH1cblxuICA6Z2xvYmFsKGJyLnNtYWxsKSB7XG4gICAgbWFyZ2luLXRvcDogY2FsYygxZW0gKiAwLjU3KTsgLyogOHB4ICovXG4gIH1cblxuICA6Z2xvYmFsKGJyLm1lZGl1bSksXG4gIDpnbG9iYWwoYnIpIHtcbiAgICBtYXJnaW4tdG9wOiBjYWxjKDFlbSAqIDEuMTQpOyAvKiAxNnB4ICovXG4gIH1cblxuICA6Z2xvYmFsKGJyLmJpZykge1xuICAgIG1hcmdpbi10b3A6IGNhbGMoMWVtICogMi4yOCk7IC8qIDMycHggKi9cbiAgfVxuPC9zdHlsZT5cbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG5leHBvcnQgZGVmYXVsdCBpc0FycmF5O1xuIiwiLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuZXhwb3J0IGRlZmF1bHQgZnJlZUdsb2JhbDtcbiIsImltcG9ydCBmcmVlR2xvYmFsIGZyb20gJy4vX2ZyZWVHbG9iYWwuanMnO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbmV4cG9ydCBkZWZhdWx0IHJvb3Q7XG4iLCJpbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cbmV4cG9ydCBkZWZhdWx0IFN5bWJvbDtcbiIsImltcG9ydCBTeW1ib2wgZnJvbSAnLi9fU3ltYm9sLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXRSYXdUYWc7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgb2JqZWN0VG9TdHJpbmc7XG4iLCJpbXBvcnQgU3ltYm9sIGZyb20gJy4vX1N5bWJvbC5qcyc7XG5pbXBvcnQgZ2V0UmF3VGFnIGZyb20gJy4vX2dldFJhd1RhZy5qcyc7XG5pbXBvcnQgb2JqZWN0VG9TdHJpbmcgZnJvbSAnLi9fb2JqZWN0VG9TdHJpbmcuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUdldFRhZztcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc09iamVjdExpa2U7XG4iLCJpbXBvcnQgYmFzZUdldFRhZyBmcm9tICcuL19iYXNlR2V0VGFnLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzU3ltYm9sO1xuIiwiaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcbmltcG9ydCBpc1N5bWJvbCBmcm9tICcuL2lzU3ltYm9sLmpzJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlSXNEZWVwUHJvcCA9IC9cXC58XFxbKD86W15bXFxdXSp8KFtcIiddKSg/Oig/IVxcMSlbXlxcXFxdfFxcXFwuKSo/XFwxKVxcXS8sXG4gICAgcmVJc1BsYWluUHJvcCA9IC9eXFx3KiQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSBhbmQgbm90IGEgcHJvcGVydHkgcGF0aC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5KHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nIHx8XG4gICAgICB2YWx1ZSA9PSBudWxsIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiByZUlzUGxhaW5Qcm9wLnRlc3QodmFsdWUpIHx8ICFyZUlzRGVlcFByb3AudGVzdCh2YWx1ZSkgfHxcbiAgICAob2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgaW4gT2JqZWN0KG9iamVjdCkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0tleTtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc09iamVjdDtcbiIsImltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0Z1bmN0aW9uO1xuIiwiaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbnZhciBjb3JlSnNEYXRhID0gcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbmV4cG9ydCBkZWZhdWx0IGNvcmVKc0RhdGE7XG4iLCJpbXBvcnQgY29yZUpzRGF0YSBmcm9tICcuL19jb3JlSnNEYXRhLmpzJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG59KCkpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNNYXNrZWQ7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAqL1xuZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHRvU291cmNlO1xuIiwiaW1wb3J0IGlzRnVuY3Rpb24gZnJvbSAnLi9pc0Z1bmN0aW9uLmpzJztcbmltcG9ydCBpc01hc2tlZCBmcm9tICcuL19pc01hc2tlZC5qcyc7XG5pbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdC5qcyc7XG5pbXBvcnQgdG9Tb3VyY2UgZnJvbSAnLi9fdG9Tb3VyY2UuanMnO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb24odmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSXNOYXRpdmU7XG4iLCIvKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0VmFsdWU7XG4iLCJpbXBvcnQgYmFzZUlzTmF0aXZlIGZyb20gJy4vX2Jhc2VJc05hdGl2ZS5qcyc7XG5pbXBvcnQgZ2V0VmFsdWUgZnJvbSAnLi9fZ2V0VmFsdWUuanMnO1xuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXROYXRpdmU7XG4iLCJpbXBvcnQgZ2V0TmF0aXZlIGZyb20gJy4vX2dldE5hdGl2ZS5qcyc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbmV4cG9ydCBkZWZhdWx0IG5hdGl2ZUNyZWF0ZTtcbiIsImltcG9ydCBuYXRpdmVDcmVhdGUgZnJvbSAnLi9fbmF0aXZlQ3JlYXRlLmpzJztcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIEhhc2hcbiAqL1xuZnVuY3Rpb24gaGFzaENsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlID8gbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGhhc2hDbGVhcjtcbiIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGhhc2hEZWxldGU7XG4iLCJpbXBvcnQgbmF0aXZlQ3JlYXRlIGZyb20gJy4vX25hdGl2ZUNyZWF0ZS5qcyc7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaGFzaEdldDtcbiIsImltcG9ydCBuYXRpdmVDcmVhdGUgZnJvbSAnLi9fbmF0aXZlQ3JlYXRlLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHJldHVybiBuYXRpdmVDcmVhdGUgPyAoZGF0YVtrZXldICE9PSB1bmRlZmluZWQpIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBoYXNoSGFzO1xuIiwiaW1wb3J0IG5hdGl2ZUNyZWF0ZSBmcm9tICcuL19uYXRpdmVDcmVhdGUuanMnO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxuZXhwb3J0IGRlZmF1bHQgaGFzaFNldDtcbiIsImltcG9ydCBoYXNoQ2xlYXIgZnJvbSAnLi9faGFzaENsZWFyLmpzJztcbmltcG9ydCBoYXNoRGVsZXRlIGZyb20gJy4vX2hhc2hEZWxldGUuanMnO1xuaW1wb3J0IGhhc2hHZXQgZnJvbSAnLi9faGFzaEdldC5qcyc7XG5pbXBvcnQgaGFzaEhhcyBmcm9tICcuL19oYXNoSGFzLmpzJztcbmltcG9ydCBoYXNoU2V0IGZyb20gJy4vX2hhc2hTZXQuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbkhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbkhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XG5IYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxuZXhwb3J0IGRlZmF1bHQgSGFzaDtcbiIsIi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbGlzdENhY2hlQ2xlYXI7XG4iLCIvKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZXE7XG4iLCJpbXBvcnQgZXEgZnJvbSAnLi9lcS5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFzc29jSW5kZXhPZjtcbiIsImltcG9ydCBhc3NvY0luZGV4T2YgZnJvbSAnLi9fYXNzb2NJbmRleE9mLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgZGF0YS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gIH1cbiAgLS10aGlzLnNpemU7XG4gIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBsaXN0Q2FjaGVEZWxldGU7XG4iLCJpbXBvcnQgYXNzb2NJbmRleE9mIGZyb20gJy4vX2Fzc29jSW5kZXhPZi5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGxpc3RDYWNoZUdldDtcbiIsImltcG9ydCBhc3NvY0luZGV4T2YgZnJvbSAnLi9fYXNzb2NJbmRleE9mLmpzJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGxpc3RDYWNoZUhhcztcbiIsImltcG9ydCBhc3NvY0luZGV4T2YgZnJvbSAnLi9fYXNzb2NJbmRleE9mLmpzJztcblxuLyoqXG4gKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICArK3RoaXMuc2l6ZTtcbiAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG5leHBvcnQgZGVmYXVsdCBsaXN0Q2FjaGVTZXQ7XG4iLCJpbXBvcnQgbGlzdENhY2hlQ2xlYXIgZnJvbSAnLi9fbGlzdENhY2hlQ2xlYXIuanMnO1xuaW1wb3J0IGxpc3RDYWNoZURlbGV0ZSBmcm9tICcuL19saXN0Q2FjaGVEZWxldGUuanMnO1xuaW1wb3J0IGxpc3RDYWNoZUdldCBmcm9tICcuL19saXN0Q2FjaGVHZXQuanMnO1xuaW1wb3J0IGxpc3RDYWNoZUhhcyBmcm9tICcuL19saXN0Q2FjaGVIYXMuanMnO1xuaW1wb3J0IGxpc3RDYWNoZVNldCBmcm9tICcuL19saXN0Q2FjaGVTZXQuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbkxpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbmV4cG9ydCBkZWZhdWx0IExpc3RDYWNoZTtcbiIsImltcG9ydCBnZXROYXRpdmUgZnJvbSAnLi9fZ2V0TmF0aXZlLmpzJztcbmltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdNYXAnKTtcblxuZXhwb3J0IGRlZmF1bHQgTWFwO1xuIiwiaW1wb3J0IEhhc2ggZnJvbSAnLi9fSGFzaC5qcyc7XG5pbXBvcnQgTGlzdENhY2hlIGZyb20gJy4vX0xpc3RDYWNoZS5qcyc7XG5pbXBvcnQgTWFwIGZyb20gJy4vX01hcC5qcyc7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuc2l6ZSA9IDA7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWFwQ2FjaGVDbGVhcjtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNLZXlhYmxlO1xuIiwiaW1wb3J0IGlzS2V5YWJsZSBmcm9tICcuL19pc0tleWFibGUuanMnO1xuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldE1hcERhdGE7XG4iLCJpbXBvcnQgZ2V0TWFwRGF0YSBmcm9tICcuL19nZXRNYXBEYXRhLmpzJztcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1hcENhY2hlRGVsZXRlO1xuIiwiaW1wb3J0IGdldE1hcERhdGEgZnJvbSAnLi9fZ2V0TWFwRGF0YS5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWFwQ2FjaGVHZXQ7XG4iLCJpbXBvcnQgZ2V0TWFwRGF0YSBmcm9tICcuL19nZXRNYXBEYXRhLmpzJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWFwQ2FjaGVIYXM7XG4iLCJpbXBvcnQgZ2V0TWFwRGF0YSBmcm9tICcuL19nZXRNYXBEYXRhLmpzJztcblxuLyoqXG4gKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLFxuICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplICs9IGRhdGEuc2l6ZSA9PSBzaXplID8gMCA6IDE7XG4gIHJldHVybiB0aGlzO1xufVxuXG5leHBvcnQgZGVmYXVsdCBtYXBDYWNoZVNldDtcbiIsImltcG9ydCBtYXBDYWNoZUNsZWFyIGZyb20gJy4vX21hcENhY2hlQ2xlYXIuanMnO1xuaW1wb3J0IG1hcENhY2hlRGVsZXRlIGZyb20gJy4vX21hcENhY2hlRGVsZXRlLmpzJztcbmltcG9ydCBtYXBDYWNoZUdldCBmcm9tICcuL19tYXBDYWNoZUdldC5qcyc7XG5pbXBvcnQgbWFwQ2FjaGVIYXMgZnJvbSAnLi9fbWFwQ2FjaGVIYXMuanMnO1xuaW1wb3J0IG1hcENhY2hlU2V0IGZyb20gJy4vX21hcENhY2hlU2V0LmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbmV4cG9ydCBkZWZhdWx0IE1hcENhY2hlO1xuIiwiaW1wb3J0IE1hcENhY2hlIGZyb20gJy4vX01hcENhY2hlLmpzJztcblxuLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBtZW1vaXplcyB0aGUgcmVzdWx0IG9mIGBmdW5jYC4gSWYgYHJlc29sdmVyYCBpc1xuICogcHJvdmlkZWQsIGl0IGRldGVybWluZXMgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0IGJhc2VkIG9uIHRoZVxuICogYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGFyZ3VtZW50XG4gKiBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24gaXMgdXNlZCBhcyB0aGUgbWFwIGNhY2hlIGtleS4gVGhlIGBmdW5jYFxuICogaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKlxuICogKipOb3RlOioqIFRoZSBjYWNoZSBpcyBleHBvc2VkIGFzIHRoZSBgY2FjaGVgIHByb3BlcnR5IG9uIHRoZSBtZW1vaXplZFxuICogZnVuY3Rpb24uIEl0cyBjcmVhdGlvbiBtYXkgYmUgY3VzdG9taXplZCBieSByZXBsYWNpbmcgdGhlIGBfLm1lbW9pemUuQ2FjaGVgXG4gKiBjb25zdHJ1Y3RvciB3aXRoIG9uZSB3aG9zZSBpbnN0YW5jZXMgaW1wbGVtZW50IHRoZVxuICogW2BNYXBgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1tYXAtcHJvdG90eXBlLW9iamVjdClcbiAqIG1ldGhvZCBpbnRlcmZhY2Ugb2YgYGNsZWFyYCwgYGRlbGV0ZWAsIGBnZXRgLCBgaGFzYCwgYW5kIGBzZXRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVyXSBUaGUgZnVuY3Rpb24gdG8gcmVzb2x2ZSB0aGUgY2FjaGUga2V5LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdjJzogMywgJ2QnOiA0IH07XG4gKlxuICogdmFyIHZhbHVlcyA9IF8ubWVtb2l6ZShfLnZhbHVlcyk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIHZhbHVlcyhvdGhlcik7XG4gKiAvLyA9PiBbMywgNF1cbiAqXG4gKiBvYmplY3QuYSA9IDI7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIC8vIE1vZGlmeSB0aGUgcmVzdWx0IGNhY2hlLlxuICogdmFsdWVzLmNhY2hlLnNldChvYmplY3QsIFsnYScsICdiJ10pO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddXG4gKlxuICogLy8gUmVwbGFjZSBgXy5tZW1vaXplLkNhY2hlYC5cbiAqIF8ubWVtb2l6ZS5DYWNoZSA9IFdlYWtNYXA7XG4gKi9cbmZ1bmN0aW9uIG1lbW9pemUoZnVuYywgcmVzb2x2ZXIpIHtcbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicgfHwgKHJlc29sdmVyICE9IG51bGwgJiYgdHlwZW9mIHJlc29sdmVyICE9ICdmdW5jdGlvbicpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBrZXkgPSByZXNvbHZlciA/IHJlc29sdmVyLmFwcGx5KHRoaXMsIGFyZ3MpIDogYXJnc1swXSxcbiAgICAgICAgY2FjaGUgPSBtZW1vaXplZC5jYWNoZTtcblxuICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICBtZW1vaXplZC5jYWNoZSA9IGNhY2hlLnNldChrZXksIHJlc3VsdCkgfHwgY2FjaGU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgbWVtb2l6ZWQuY2FjaGUgPSBuZXcgKG1lbW9pemUuQ2FjaGUgfHwgTWFwQ2FjaGUpO1xuICByZXR1cm4gbWVtb2l6ZWQ7XG59XG5cbi8vIEV4cG9zZSBgTWFwQ2FjaGVgLlxubWVtb2l6ZS5DYWNoZSA9IE1hcENhY2hlO1xuXG5leHBvcnQgZGVmYXVsdCBtZW1vaXplO1xuIiwiaW1wb3J0IG1lbW9pemUgZnJvbSAnLi9tZW1vaXplLmpzJztcblxuLyoqIFVzZWQgYXMgdGhlIG1heGltdW0gbWVtb2l6ZSBjYWNoZSBzaXplLiAqL1xudmFyIE1BWF9NRU1PSVpFX1NJWkUgPSA1MDA7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1lbW9pemVgIHdoaWNoIGNsZWFycyB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24nc1xuICogY2FjaGUgd2hlbiBpdCBleGNlZWRzIGBNQVhfTUVNT0laRV9TSVpFYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1lbW9pemVDYXBwZWQoZnVuYykge1xuICB2YXIgcmVzdWx0ID0gbWVtb2l6ZShmdW5jLCBmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoY2FjaGUuc2l6ZSA9PT0gTUFYX01FTU9JWkVfU0laRSkge1xuICAgICAgY2FjaGUuY2xlYXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIGtleTtcbiAgfSk7XG5cbiAgdmFyIGNhY2hlID0gcmVzdWx0LmNhY2hlO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBtZW1vaXplQ2FwcGVkO1xuIiwiaW1wb3J0IG1lbW9pemVDYXBwZWQgZnJvbSAnLi9fbWVtb2l6ZUNhcHBlZC5qcyc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZVByb3BOYW1lID0gL1teLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCQpKS9nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG52YXIgc3RyaW5nVG9QYXRoID0gbWVtb2l6ZUNhcHBlZChmdW5jdGlvbihzdHJpbmcpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoMCkgPT09IDQ2IC8qIC4gKi8pIHtcbiAgICByZXN1bHQucHVzaCgnJyk7XG4gIH1cbiAgc3RyaW5nLnJlcGxhY2UocmVQcm9wTmFtZSwgZnVuY3Rpb24obWF0Y2gsIG51bWJlciwgcXVvdGUsIHN1YlN0cmluZykge1xuICAgIHJlc3VsdC5wdXNoKHF1b3RlID8gc3ViU3RyaW5nLnJlcGxhY2UocmVFc2NhcGVDaGFyLCAnJDEnKSA6IChudW1iZXIgfHwgbWF0Y2gpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgc3RyaW5nVG9QYXRoO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TWFwKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXJyYXlNYXA7XG4iLCJpbXBvcnQgU3ltYm9sIGZyb20gJy4vX1N5bWJvbC5qcyc7XG5pbXBvcnQgYXJyYXlNYXAgZnJvbSAnLi9fYXJyYXlNYXAuanMnO1xuaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcbmltcG9ydCBpc1N5bWJvbCBmcm9tICcuL2lzU3ltYm9sLmpzJztcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFRvU3RyaW5nID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by50b1N0cmluZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1N0cmluZ2Agd2hpY2ggZG9lc24ndCBjb252ZXJ0IG51bGxpc2hcbiAqIHZhbHVlcyB0byBlbXB0eSBzdHJpbmdzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBiYXNlVG9TdHJpbmcodmFsdWUpIHtcbiAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAvLyBSZWN1cnNpdmVseSBjb252ZXJ0IHZhbHVlcyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIHJldHVybiBhcnJheU1hcCh2YWx1ZSwgYmFzZVRvU3RyaW5nKSArICcnO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3ltYm9sVG9TdHJpbmcgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVRvU3RyaW5nO1xuIiwiaW1wb3J0IGJhc2VUb1N0cmluZyBmcm9tICcuL19iYXNlVG9TdHJpbmcuanMnO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXG4gKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9TdHJpbmcobnVsbCk7XG4gKiAvLyA9PiAnJ1xuICpcbiAqIF8udG9TdHJpbmcoLTApO1xuICogLy8gPT4gJy0wJ1xuICpcbiAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcbiAqIC8vID0+ICcxLDIsMydcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHRvU3RyaW5nO1xuIiwiaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcbmltcG9ydCBpc0tleSBmcm9tICcuL19pc0tleS5qcyc7XG5pbXBvcnQgc3RyaW5nVG9QYXRoIGZyb20gJy4vX3N0cmluZ1RvUGF0aC5qcyc7XG5pbXBvcnQgdG9TdHJpbmcgZnJvbSAnLi90b1N0cmluZy5qcyc7XG5cbi8qKlxuICogQ2FzdHMgYHZhbHVlYCB0byBhIHBhdGggYXJyYXkgaWYgaXQncyBub3Qgb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG5mdW5jdGlvbiBjYXN0UGF0aCh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gaXNLZXkodmFsdWUsIG9iamVjdCkgPyBbdmFsdWVdIDogc3RyaW5nVG9QYXRoKHRvU3RyaW5nKHZhbHVlKSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNhc3RQYXRoO1xuIiwiaW1wb3J0IGlzU3ltYm9sIGZyb20gJy4vaXNTeW1ib2wuanMnO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcga2V5IGlmIGl0J3Mgbm90IGEgc3RyaW5nIG9yIHN5bWJvbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtzdHJpbmd8c3ltYm9sfSBSZXR1cm5zIHRoZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIHRvS2V5KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdG9LZXk7XG4iLCJpbXBvcnQgY2FzdFBhdGggZnJvbSAnLi9fY2FzdFBhdGguanMnO1xuaW1wb3J0IHRvS2V5IGZyb20gJy4vX3RvS2V5LmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5nZXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVmYXVsdCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXQob2JqZWN0LCBwYXRoKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IDAsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICB3aGlsZSAob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICBvYmplY3QgPSBvYmplY3RbdG9LZXkocGF0aFtpbmRleCsrXSldO1xuICB9XG4gIHJldHVybiAoaW5kZXggJiYgaW5kZXggPT0gbGVuZ3RoKSA/IG9iamVjdCA6IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUdldDtcbiIsImltcG9ydCBiYXNlR2V0IGZyb20gJy4vX2Jhc2VHZXQuanMnO1xuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC4gSWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzXG4gKiBgdW5kZWZpbmVkYCwgdGhlIGBkZWZhdWx0VmFsdWVgIGlzIHJldHVybmVkIGluIGl0cyBwbGFjZS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuNy4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgcmV0dXJuZWQgZm9yIGB1bmRlZmluZWRgIHJlc29sdmVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAqXG4gKiBfLmdldChvYmplY3QsICdhWzBdLmIuYycpO1xuICogLy8gPT4gM1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgWydhJywgJzAnLCAnYicsICdjJ10pO1xuICogLy8gPT4gM1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2EuYi5jJywgJ2RlZmF1bHQnKTtcbiAqIC8vID0+ICdkZWZhdWx0J1xuICovXG5mdW5jdGlvbiBnZXQob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0VmFsdWUgOiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldDtcbiIsImltcG9ydCBnZXROYXRpdmUgZnJvbSAnLi9fZ2V0TmF0aXZlLmpzJztcblxudmFyIGRlZmluZVByb3BlcnR5ID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHZhciBmdW5jID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2RlZmluZVByb3BlcnR5Jyk7XG4gICAgZnVuYyh7fSwgJycsIHt9KTtcbiAgICByZXR1cm4gZnVuYztcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbmV4cG9ydCBkZWZhdWx0IGRlZmluZVByb3BlcnR5O1xuIiwiaW1wb3J0IGRlZmluZVByb3BlcnR5IGZyb20gJy4vX2RlZmluZVByb3BlcnR5LmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYXNzaWduVmFsdWVgIGFuZCBgYXNzaWduTWVyZ2VWYWx1ZWAgd2l0aG91dFxuICogdmFsdWUgY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSA9PSAnX19wcm90b19fJyAmJiBkZWZpbmVQcm9wZXJ0eSkge1xuICAgIGRlZmluZVByb3BlcnR5KG9iamVjdCwga2V5LCB7XG4gICAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAgICdlbnVtZXJhYmxlJzogdHJ1ZSxcbiAgICAgICd2YWx1ZSc6IHZhbHVlLFxuICAgICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUFzc2lnblZhbHVlO1xuIiwiaW1wb3J0IGJhc2VBc3NpZ25WYWx1ZSBmcm9tICcuL19iYXNlQXNzaWduVmFsdWUuanMnO1xuaW1wb3J0IGVxIGZyb20gJy4vZXEuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEFzc2lnbnMgYHZhbHVlYCB0byBga2V5YCBvZiBgb2JqZWN0YCBpZiB0aGUgZXhpc3RpbmcgdmFsdWUgaXMgbm90IGVxdWl2YWxlbnRcbiAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldO1xuICBpZiAoIShoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBlcShvYmpWYWx1ZSwgdmFsdWUpKSB8fFxuICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBhc3NpZ25WYWx1ZTtcbiIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuXG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlID09ICdudW1iZXInIHx8XG4gICAgICAodHlwZSAhPSAnc3ltYm9sJyAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkpICYmXG4gICAgICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNJbmRleDtcbiIsImltcG9ydCBhc3NpZ25WYWx1ZSBmcm9tICcuL19hc3NpZ25WYWx1ZS5qcyc7XG5pbXBvcnQgY2FzdFBhdGggZnJvbSAnLi9fY2FzdFBhdGguanMnO1xuaW1wb3J0IGlzSW5kZXggZnJvbSAnLi9faXNJbmRleC5qcyc7XG5pbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdC5qcyc7XG5pbXBvcnQgdG9LZXkgZnJvbSAnLi9fdG9LZXkuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNldGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgcGF0aCBjcmVhdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VTZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSwgY3VzdG9taXplcikge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICBsYXN0SW5kZXggPSBsZW5ndGggLSAxLFxuICAgICAgbmVzdGVkID0gb2JqZWN0O1xuXG4gIHdoaWxlIChuZXN0ZWQgIT0gbnVsbCAmJiArK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKSxcbiAgICAgICAgbmV3VmFsdWUgPSB2YWx1ZTtcblxuICAgIGlmIChpbmRleCAhPSBsYXN0SW5kZXgpIHtcbiAgICAgIHZhciBvYmpWYWx1ZSA9IG5lc3RlZFtrZXldO1xuICAgICAgbmV3VmFsdWUgPSBjdXN0b21pemVyID8gY3VzdG9taXplcihvYmpWYWx1ZSwga2V5LCBuZXN0ZWQpIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBpc09iamVjdChvYmpWYWx1ZSlcbiAgICAgICAgICA/IG9ialZhbHVlXG4gICAgICAgICAgOiAoaXNJbmRleChwYXRoW2luZGV4ICsgMV0pID8gW10gOiB7fSk7XG4gICAgICB9XG4gICAgfVxuICAgIGFzc2lnblZhbHVlKG5lc3RlZCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgbmVzdGVkID0gbmVzdGVkW2tleV07XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVNldDtcbiIsImltcG9ydCBiYXNlU2V0IGZyb20gJy4vX2Jhc2VTZXQuanMnO1xuXG4vKipcbiAqIFNldHMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC4gSWYgYSBwb3J0aW9uIG9mIGBwYXRoYCBkb2Vzbid0IGV4aXN0LFxuICogaXQncyBjcmVhdGVkLiBBcnJheXMgYXJlIGNyZWF0ZWQgZm9yIG1pc3NpbmcgaW5kZXggcHJvcGVydGllcyB3aGlsZSBvYmplY3RzXG4gKiBhcmUgY3JlYXRlZCBmb3IgYWxsIG90aGVyIG1pc3NpbmcgcHJvcGVydGllcy4gVXNlIGBfLnNldFdpdGhgIHRvIGN1c3RvbWl6ZVxuICogYHBhdGhgIGNyZWF0aW9uLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy43LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAqXG4gKiBfLnNldChvYmplY3QsICdhWzBdLmIuYycsIDQpO1xuICogY29uc29sZS5sb2cob2JqZWN0LmFbMF0uYi5jKTtcbiAqIC8vID0+IDRcbiAqXG4gKiBfLnNldChvYmplY3QsIFsneCcsICcwJywgJ3knLCAneiddLCA1KTtcbiAqIGNvbnNvbGUubG9nKG9iamVjdC54WzBdLnkueik7XG4gKiAvLyA9PiA1XG4gKi9cbmZ1bmN0aW9uIHNldChvYmplY3QsIHBhdGgsIHZhbHVlKSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IGJhc2VTZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHNldDtcbiIsImltcG9ydCBMaXN0Q2FjaGUgZnJvbSAnLi9fTGlzdENhY2hlLmpzJztcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBTdGFja1xuICovXG5mdW5jdGlvbiBzdGFja0NsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3RhY2tDbGVhcjtcbiIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXShrZXkpO1xuXG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3RhY2tEZWxldGU7XG4iLCIvKipcbiAqIEdldHMgdGhlIHN0YWNrIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzdGFja0dldChrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGtleSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0YWNrR2V0O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3RhY2tIYXM7XG4iLCJpbXBvcnQgTGlzdENhY2hlIGZyb20gJy4vX0xpc3RDYWNoZS5qcyc7XG5pbXBvcnQgTWFwIGZyb20gJy4vX01hcC5qcyc7XG5pbXBvcnQgTWFwQ2FjaGUgZnJvbSAnLi9fTWFwQ2FjaGUuanMnO1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKipcbiAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xuICAgIGlmICghTWFwIHx8IChwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkpIHtcbiAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIHRoaXMuc2l6ZSA9ICsrZGF0YS5zaXplO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgfVxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gdGhpcztcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3RhY2tTZXQ7XG4iLCJpbXBvcnQgTGlzdENhY2hlIGZyb20gJy4vX0xpc3RDYWNoZS5qcyc7XG5pbXBvcnQgc3RhY2tDbGVhciBmcm9tICcuL19zdGFja0NsZWFyLmpzJztcbmltcG9ydCBzdGFja0RlbGV0ZSBmcm9tICcuL19zdGFja0RlbGV0ZS5qcyc7XG5pbXBvcnQgc3RhY2tHZXQgZnJvbSAnLi9fc3RhY2tHZXQuanMnO1xuaW1wb3J0IHN0YWNrSGFzIGZyb20gJy4vX3N0YWNrSGFzLmpzJztcbmltcG9ydCBzdGFja1NldCBmcm9tICcuL19zdGFja1NldC5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFN0YWNrKGVudHJpZXMpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxuU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcblN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcblN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcblN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcblN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcblxuZXhwb3J0IGRlZmF1bHQgU3RhY2s7XG4iLCIvKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogQWRkcyBgdmFsdWVgIHRvIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgYWRkXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBhbGlhcyBwdXNoXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjYWNoZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUFkZCh2YWx1ZSkge1xuICB0aGlzLl9fZGF0YV9fLnNldCh2YWx1ZSwgSEFTSF9VTkRFRklORUQpO1xuICByZXR1cm4gdGhpcztcbn1cblxuZXhwb3J0IGRlZmF1bHQgc2V0Q2FjaGVBZGQ7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlSGFzKHZhbHVlKSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyh2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHNldENhY2hlSGFzO1xuIiwiaW1wb3J0IE1hcENhY2hlIGZyb20gJy4vX01hcENhY2hlLmpzJztcbmltcG9ydCBzZXRDYWNoZUFkZCBmcm9tICcuL19zZXRDYWNoZUFkZC5qcyc7XG5pbXBvcnQgc2V0Q2FjaGVIYXMgZnJvbSAnLi9fc2V0Q2FjaGVIYXMuanMnO1xuXG4vKipcbiAqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGNhY2hlIG9iamVjdCB0byBzdG9yZSB1bmlxdWUgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFNldENhY2hlKHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcyA9PSBudWxsID8gMCA6IHZhbHVlcy5sZW5ndGg7XG5cbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB0aGlzLmFkZCh2YWx1ZXNbaW5kZXhdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU2V0Q2FjaGVgLlxuU2V0Q2FjaGUucHJvdG90eXBlLmFkZCA9IFNldENhY2hlLnByb3RvdHlwZS5wdXNoID0gc2V0Q2FjaGVBZGQ7XG5TZXRDYWNoZS5wcm90b3R5cGUuaGFzID0gc2V0Q2FjaGVIYXM7XG5cbmV4cG9ydCBkZWZhdWx0IFNldENhY2hlO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc29tZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5U29tZShhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXJyYXlTb21lO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYSBgY2FjaGVgIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBjYWNoZSBUaGUgY2FjaGUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gY2FjaGVIYXMoY2FjaGUsIGtleSkge1xuICByZXR1cm4gY2FjaGUuaGFzKGtleSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNhY2hlSGFzO1xuIiwiaW1wb3J0IFNldENhY2hlIGZyb20gJy4vX1NldENhY2hlLmpzJztcbmltcG9ydCBhcnJheVNvbWUgZnJvbSAnLi9fYXJyYXlTb21lLmpzJztcbmltcG9ydCBjYWNoZUhhcyBmcm9tICcuL19jYWNoZUhhcy5qcyc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGFycmF5cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtBcnJheX0gb3RoZXIgVGhlIG90aGVyIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBhcnJheWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJyYXlzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQXJyYXlzKGFycmF5LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuXG4gIGlmIChhcnJMZW5ndGggIT0gb3RoTGVuZ3RoICYmICEoaXNQYXJ0aWFsICYmIG90aExlbmd0aCA+IGFyckxlbmd0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChhcnJheSk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IHRydWUsXG4gICAgICBzZWVuID0gKGJpdG1hc2sgJiBDT01QQVJFX1VOT1JERVJFRF9GTEFHKSA/IG5ldyBTZXRDYWNoZSA6IHVuZGVmaW5lZDtcblxuICBzdGFjay5zZXQoYXJyYXksIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBhcnJheSk7XG5cbiAgLy8gSWdub3JlIG5vbi1pbmRleCBwcm9wZXJ0aWVzLlxuICB3aGlsZSAoKytpbmRleCA8IGFyckxlbmd0aCkge1xuICAgIHZhciBhcnJWYWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltpbmRleF07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgYXJyVmFsdWUsIGluZGV4LCBvdGhlciwgYXJyYXksIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIoYXJyVmFsdWUsIG90aFZhbHVlLCBpbmRleCwgYXJyYXksIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIGlmIChjb21wYXJlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoY29tcGFyZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmIChzZWVuKSB7XG4gICAgICBpZiAoIWFycmF5U29tZShvdGhlciwgZnVuY3Rpb24ob3RoVmFsdWUsIG90aEluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIWNhY2hlSGFzKHNlZW4sIG90aEluZGV4KSAmJlxuICAgICAgICAgICAgICAgIChhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKSkge1xuICAgICAgICAgICAgICByZXR1cm4gc2Vlbi5wdXNoKG90aEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSkge1xuICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghKFxuICAgICAgICAgIGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fFxuICAgICAgICAgICAgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShhcnJheSk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGVxdWFsQXJyYXlzO1xuIiwiaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFVpbnQ4QXJyYXkgPSByb290LlVpbnQ4QXJyYXk7XG5cbmV4cG9ydCBkZWZhdWx0IFVpbnQ4QXJyYXk7XG4iLCIvKipcbiAqIENvbnZlcnRzIGBtYXBgIHRvIGl0cyBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gKi9cbmZ1bmN0aW9uIG1hcFRvQXJyYXkobWFwKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobWFwLnNpemUpO1xuXG4gIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSBba2V5LCB2YWx1ZV07XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBtYXBUb0FycmF5O1xuIiwiLyoqXG4gKiBDb252ZXJ0cyBgc2V0YCB0byBhbiBhcnJheSBvZiBpdHMgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBzZXRUb0FycmF5KHNldCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc2V0VG9BcnJheTtcbiIsImltcG9ydCBTeW1ib2wgZnJvbSAnLi9fU3ltYm9sLmpzJztcbmltcG9ydCBVaW50OEFycmF5IGZyb20gJy4vX1VpbnQ4QXJyYXkuanMnO1xuaW1wb3J0IGVxIGZyb20gJy4vZXEuanMnO1xuaW1wb3J0IGVxdWFsQXJyYXlzIGZyb20gJy4vX2VxdWFsQXJyYXlzLmpzJztcbmltcG9ydCBtYXBUb0FycmF5IGZyb20gJy4vX21hcFRvQXJyYXkuanMnO1xuaW1wb3J0IHNldFRvQXJyYXkgZnJvbSAnLi9fc2V0VG9BcnJheS5qcyc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGNvbXBhcmluZyBvYmplY3RzIG9mXG4gKiB0aGUgc2FtZSBgdG9TdHJpbmdUYWdgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY29tcGFyaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3RzIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCB0YWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgIChvYmplY3QuYnl0ZU9mZnNldCAhPSBvdGhlci5ieXRlT2Zmc2V0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBvYmplY3QuYnVmZmVyO1xuICAgICAgb3RoZXIgPSBvdGhlci5idWZmZXI7XG5cbiAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgICFlcXVhbEZ1bmMobmV3IFVpbnQ4QXJyYXkob2JqZWN0KSwgbmV3IFVpbnQ4QXJyYXkob3RoZXIpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAvLyBDb2VyY2UgYm9vbGVhbnMgdG8gYDFgIG9yIGAwYCBhbmQgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzLlxuICAgICAgLy8gSW52YWxpZCBkYXRlcyBhcmUgY29lcmNlZCB0byBgTmFOYC5cbiAgICAgIHJldHVybiBlcSgrb2JqZWN0LCArb3RoZXIpO1xuXG4gICAgY2FzZSBlcnJvclRhZzpcbiAgICAgIHJldHVybiBvYmplY3QubmFtZSA9PSBvdGhlci5uYW1lICYmIG9iamVjdC5tZXNzYWdlID09IG90aGVyLm1lc3NhZ2U7XG5cbiAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIC8vIENvZXJjZSByZWdleGVzIHRvIHN0cmluZ3MgYW5kIHRyZWF0IHN0cmluZ3MsIHByaW1pdGl2ZXMgYW5kIG9iamVjdHMsXG4gICAgICAvLyBhcyBlcXVhbC4gU2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1yZWdleHAucHJvdG90eXBlLnRvc3RyaW5nXG4gICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgcmV0dXJuIG9iamVjdCA9PSAob3RoZXIgKyAnJyk7XG5cbiAgICBjYXNlIG1hcFRhZzpcbiAgICAgIHZhciBjb252ZXJ0ID0gbWFwVG9BcnJheTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRztcbiAgICAgIGNvbnZlcnQgfHwgKGNvbnZlcnQgPSBzZXRUb0FycmF5KTtcblxuICAgICAgaWYgKG9iamVjdC5zaXplICE9IG90aGVyLnNpemUgJiYgIWlzUGFydGlhbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gICAgICB9XG4gICAgICBiaXRtYXNrIHw9IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUc7XG5cbiAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgdmFyIHJlc3VsdCA9IGVxdWFsQXJyYXlzKGNvbnZlcnQob2JqZWN0KSwgY29udmVydChvdGhlciksIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICBpZiAoc3ltYm9sVmFsdWVPZikge1xuICAgICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZi5jYWxsKG9iamVjdCkgPT0gc3ltYm9sVmFsdWVPZi5jYWxsKG90aGVyKTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGVxdWFsQnlUYWc7XG4iLCIvKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFycmF5UHVzaDtcbiIsImltcG9ydCBhcnJheVB1c2ggZnJvbSAnLi9fYXJyYXlQdXNoLmpzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldEFsbEtleXNgIGFuZCBgZ2V0QWxsS2V5c0luYCB3aGljaCB1c2VzXG4gKiBga2V5c0Z1bmNgIGFuZCBgc3ltYm9sc0Z1bmNgIHRvIGdldCB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzeW1ib2xzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzRnVuYywgc3ltYm9sc0Z1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXNGdW5jKG9iamVjdCk7XG4gIHJldHVybiBpc0FycmF5KG9iamVjdCkgPyByZXN1bHQgOiBhcnJheVB1c2gocmVzdWx0LCBzeW1ib2xzRnVuYyhvYmplY3QpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUdldEFsbEtleXM7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5maWx0ZXJgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlGaWx0ZXIoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFycmF5RmlsdGVyO1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGVtcHR5IGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZW1wdHkgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBhcnJheXMgPSBfLnRpbWVzKDIsIF8uc3R1YkFycmF5KTtcbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXMpO1xuICogLy8gPT4gW1tdLCBbXV1cbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXNbMF0gPT09IGFycmF5c1sxXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBzdHViQXJyYXkoKSB7XG4gIHJldHVybiBbXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3R1YkFycmF5O1xuIiwiaW1wb3J0IGFycmF5RmlsdGVyIGZyb20gJy4vX2FycmF5RmlsdGVyLmpzJztcbmltcG9ydCBzdHViQXJyYXkgZnJvbSAnLi9zdHViQXJyYXkuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICovXG52YXIgZ2V0U3ltYm9scyA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgcmV0dXJuIGFycmF5RmlsdGVyKG5hdGl2ZUdldFN5bWJvbHMob2JqZWN0KSwgZnVuY3Rpb24oc3ltYm9sKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCBzeW1ib2wpO1xuICB9KTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGdldFN5bWJvbHM7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlVGltZXM7XG4iLCJpbXBvcnQgYmFzZUdldFRhZyBmcm9tICcuL19iYXNlR2V0VGFnLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJndW1lbnRzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBhcmdzVGFnO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSXNBcmd1bWVudHM7XG4iLCJpbXBvcnQgYmFzZUlzQXJndW1lbnRzIGZyb20gJy4vX2Jhc2VJc0FyZ3VtZW50cy5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID8gYmFzZUlzQXJndW1lbnRzIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGlzQXJndW1lbnRzO1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTtcbiAqIC8vID0+IFtmYWxzZSwgZmFsc2VdXG4gKi9cbmZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzdHViRmFsc2U7XG4iLCJpbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcbmltcG9ydCBzdHViRmFsc2UgZnJvbSAnLi9zdHViRmFsc2UuanMnO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbmV4cG9ydCBkZWZhdWx0IGlzQnVmZmVyO1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0xlbmd0aDtcbiIsImltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IGlzTGVuZ3RoIGZyb20gJy4vaXNMZW5ndGguanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG50eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG50eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG50eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG50eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUlzVHlwZWRBcnJheTtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVVuYXJ5O1xuIiwiaW1wb3J0IGZyZWVHbG9iYWwgZnJvbSAnLi9fZnJlZUdsb2JhbC5qcyc7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBwcm9jZXNzYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzICYmIGZyZWVHbG9iYWwucHJvY2VzcztcblxuLyoqIFVzZWQgdG8gYWNjZXNzIGZhc3RlciBOb2RlLmpzIGhlbHBlcnMuICovXG52YXIgbm9kZVV0aWwgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgLy8gVXNlIGB1dGlsLnR5cGVzYCBmb3IgTm9kZS5qcyAxMCsuXG4gICAgdmFyIHR5cGVzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlKCd1dGlsJykudHlwZXM7XG5cbiAgICBpZiAodHlwZXMpIHtcbiAgICAgIHJldHVybiB0eXBlcztcbiAgICB9XG5cbiAgICAvLyBMZWdhY3kgYHByb2Nlc3MuYmluZGluZygndXRpbCcpYCBmb3IgTm9kZS5qcyA8IDEwLlxuICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbmV4cG9ydCBkZWZhdWx0IG5vZGVVdGlsO1xuIiwiaW1wb3J0IGJhc2VJc1R5cGVkQXJyYXkgZnJvbSAnLi9fYmFzZUlzVHlwZWRBcnJheS5qcyc7XG5pbXBvcnQgYmFzZVVuYXJ5IGZyb20gJy4vX2Jhc2VVbmFyeS5qcyc7XG5pbXBvcnQgbm9kZVV0aWwgZnJvbSAnLi9fbm9kZVV0aWwuanMnO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxuZXhwb3J0IGRlZmF1bHQgaXNUeXBlZEFycmF5O1xuIiwiaW1wb3J0IGJhc2VUaW1lcyBmcm9tICcuL19iYXNlVGltZXMuanMnO1xuaW1wb3J0IGlzQXJndW1lbnRzIGZyb20gJy4vaXNBcmd1bWVudHMuanMnO1xuaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcbmltcG9ydCBpc0J1ZmZlciBmcm9tICcuL2lzQnVmZmVyLmpzJztcbmltcG9ydCBpc0luZGV4IGZyb20gJy4vX2lzSW5kZXguanMnO1xuaW1wb3J0IGlzVHlwZWRBcnJheSBmcm9tICcuL2lzVHlwZWRBcnJheS5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKSxcbiAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzKHZhbHVlKSxcbiAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLFxuICAgICAgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheSh2YWx1ZSksXG4gICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsXG4gICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoXG4gICAgICAgICAgIC8vIFNhZmFyaSA5IGhhcyBlbnVtZXJhYmxlIGBhcmd1bWVudHMubGVuZ3RoYCBpbiBzdHJpY3QgbW9kZS5cbiAgICAgICAgICAga2V5ID09ICdsZW5ndGgnIHx8XG4gICAgICAgICAgIC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuICAgICAgICAgICAoaXNCdWZmICYmIChrZXkgPT0gJ29mZnNldCcgfHwga2V5ID09ICdwYXJlbnQnKSkgfHxcbiAgICAgICAgICAgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgICAgICAgICAoaXNUeXBlICYmIChrZXkgPT0gJ2J1ZmZlcicgfHwga2V5ID09ICdieXRlTGVuZ3RoJyB8fCBrZXkgPT0gJ2J5dGVPZmZzZXQnKSkgfHxcbiAgICAgICAgICAgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKVxuICAgICAgICApKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXJyYXlMaWtlS2V5cztcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNQcm90b3R5cGU7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgb3ZlckFyZztcbiIsImltcG9ydCBvdmVyQXJnIGZyb20gJy4vX292ZXJBcmcuanMnO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCk7XG5cbmV4cG9ydCBkZWZhdWx0IG5hdGl2ZUtleXM7XG4iLCJpbXBvcnQgaXNQcm90b3R5cGUgZnJvbSAnLi9faXNQcm90b3R5cGUuanMnO1xuaW1wb3J0IG5hdGl2ZUtleXMgZnJvbSAnLi9fbmF0aXZlS2V5cy5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUtleXM7XG4iLCJpbXBvcnQgaXNGdW5jdGlvbiBmcm9tICcuL2lzRnVuY3Rpb24uanMnO1xuaW1wb3J0IGlzTGVuZ3RoIGZyb20gJy4vaXNMZW5ndGguanMnO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNBcnJheUxpa2U7XG4iLCJpbXBvcnQgYXJyYXlMaWtlS2V5cyBmcm9tICcuL19hcnJheUxpa2VLZXlzLmpzJztcbmltcG9ydCBiYXNlS2V5cyBmcm9tICcuL19iYXNlS2V5cy5qcyc7XG5pbXBvcnQgaXNBcnJheUxpa2UgZnJvbSAnLi9pc0FycmF5TGlrZS5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL1xuZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBrZXlzO1xuIiwiaW1wb3J0IGJhc2VHZXRBbGxLZXlzIGZyb20gJy4vX2Jhc2VHZXRBbGxLZXlzLmpzJztcbmltcG9ydCBnZXRTeW1ib2xzIGZyb20gJy4vX2dldFN5bWJvbHMuanMnO1xuaW1wb3J0IGtleXMgZnJvbSAnLi9rZXlzLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzKG9iamVjdCkge1xuICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzLCBnZXRTeW1ib2xzKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0QWxsS2V5cztcbiIsImltcG9ydCBnZXRBbGxLZXlzIGZyb20gJy4vX2dldEFsbEtleXMuanMnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDE7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBvYmpQcm9wcyA9IGdldEFsbEtleXMob2JqZWN0KSxcbiAgICAgIG9iakxlbmd0aCA9IG9ialByb3BzLmxlbmd0aCxcbiAgICAgIG90aFByb3BzID0gZ2V0QWxsS2V5cyhvdGhlciksXG4gICAgICBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XG5cbiAgaWYgKG9iakxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIWlzUGFydGlhbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaW5kZXggPSBvYmpMZW5ndGg7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICBpZiAoIShpc1BhcnRpYWwgPyBrZXkgaW4gb3RoZXIgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBrZXkpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIG9iamVjdCk7XG5cbiAgdmFyIHNraXBDdG9yID0gaXNQYXJ0aWFsO1xuICB3aGlsZSAoKytpbmRleCA8IG9iakxlbmd0aCkge1xuICAgIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIG9ialZhbHVlLCBrZXksIG90aGVyLCBvYmplY3QsIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlLCBrZXksIG9iamVjdCwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKCEoY29tcGFyZWQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gKG9ialZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMob2JqVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpXG4gICAgICAgICAgOiBjb21wYXJlZFxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBza2lwQ3RvciB8fCAoc2tpcEN0b3IgPSBrZXkgPT0gJ2NvbnN0cnVjdG9yJyk7XG4gIH1cbiAgaWYgKHJlc3VsdCAmJiAhc2tpcEN0b3IpIHtcbiAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXG4gICAgaWYgKG9iakN0b3IgIT0gb3RoQ3RvciAmJlxuICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgISh0eXBlb2Ygb2JqQ3RvciA9PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmXG4gICAgICAgICAgdHlwZW9mIG90aEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZXF1YWxPYmplY3RzO1xuIiwiaW1wb3J0IGdldE5hdGl2ZSBmcm9tICcuL19nZXROYXRpdmUuanMnO1xuaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBEYXRhVmlldyA9IGdldE5hdGl2ZShyb290LCAnRGF0YVZpZXcnKTtcblxuZXhwb3J0IGRlZmF1bHQgRGF0YVZpZXc7XG4iLCJpbXBvcnQgZ2V0TmF0aXZlIGZyb20gJy4vX2dldE5hdGl2ZS5qcyc7XG5pbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFByb21pc2UgPSBnZXROYXRpdmUocm9vdCwgJ1Byb21pc2UnKTtcblxuZXhwb3J0IGRlZmF1bHQgUHJvbWlzZTtcbiIsImltcG9ydCBnZXROYXRpdmUgZnJvbSAnLi9fZ2V0TmF0aXZlLmpzJztcbmltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgU2V0ID0gZ2V0TmF0aXZlKHJvb3QsICdTZXQnKTtcblxuZXhwb3J0IGRlZmF1bHQgU2V0O1xuIiwiaW1wb3J0IGdldE5hdGl2ZSBmcm9tICcuL19nZXROYXRpdmUuanMnO1xuaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBXZWFrTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdXZWFrTWFwJyk7XG5cbmV4cG9ydCBkZWZhdWx0IFdlYWtNYXA7XG4iLCJpbXBvcnQgRGF0YVZpZXcgZnJvbSAnLi9fRGF0YVZpZXcuanMnO1xuaW1wb3J0IE1hcCBmcm9tICcuL19NYXAuanMnO1xuaW1wb3J0IFByb21pc2UgZnJvbSAnLi9fUHJvbWlzZS5qcyc7XG5pbXBvcnQgU2V0IGZyb20gJy4vX1NldC5qcyc7XG5pbXBvcnQgV2Vha01hcCBmcm9tICcuL19XZWFrTWFwLmpzJztcbmltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IHRvU291cmNlIGZyb20gJy4vX3RvU291cmNlLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHByb21pc2VUYWcgPSAnW29iamVjdCBQcm9taXNlXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1hcHMsIHNldHMsIGFuZCB3ZWFrbWFwcy4gKi9cbnZhciBkYXRhVmlld0N0b3JTdHJpbmcgPSB0b1NvdXJjZShEYXRhVmlldyksXG4gICAgbWFwQ3RvclN0cmluZyA9IHRvU291cmNlKE1hcCksXG4gICAgcHJvbWlzZUN0b3JTdHJpbmcgPSB0b1NvdXJjZShQcm9taXNlKSxcbiAgICBzZXRDdG9yU3RyaW5nID0gdG9Tb3VyY2UoU2V0KSxcbiAgICB3ZWFrTWFwQ3RvclN0cmluZyA9IHRvU291cmNlKFdlYWtNYXApO1xuXG4vKipcbiAqIEdldHMgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG52YXIgZ2V0VGFnID0gYmFzZUdldFRhZztcblxuLy8gRmFsbGJhY2sgZm9yIGRhdGEgdmlld3MsIG1hcHMsIHNldHMsIGFuZCB3ZWFrIG1hcHMgaW4gSUUgMTEgYW5kIHByb21pc2VzIGluIE5vZGUuanMgPCA2LlxuaWYgKChEYXRhVmlldyAmJiBnZXRUYWcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSkpICE9IGRhdGFWaWV3VGFnKSB8fFxuICAgIChNYXAgJiYgZ2V0VGFnKG5ldyBNYXApICE9IG1hcFRhZykgfHxcbiAgICAoUHJvbWlzZSAmJiBnZXRUYWcoUHJvbWlzZS5yZXNvbHZlKCkpICE9IHByb21pc2VUYWcpIHx8XG4gICAgKFNldCAmJiBnZXRUYWcobmV3IFNldCkgIT0gc2V0VGFnKSB8fFxuICAgIChXZWFrTWFwICYmIGdldFRhZyhuZXcgV2Vha01hcCkgIT0gd2Vha01hcFRhZykpIHtcbiAgZ2V0VGFnID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gYmFzZUdldFRhZyh2YWx1ZSksXG4gICAgICAgIEN0b3IgPSByZXN1bHQgPT0gb2JqZWN0VGFnID8gdmFsdWUuY29uc3RydWN0b3IgOiB1bmRlZmluZWQsXG4gICAgICAgIGN0b3JTdHJpbmcgPSBDdG9yID8gdG9Tb3VyY2UoQ3RvcikgOiAnJztcblxuICAgIGlmIChjdG9yU3RyaW5nKSB7XG4gICAgICBzd2l0Y2ggKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgY2FzZSBkYXRhVmlld0N0b3JTdHJpbmc6IHJldHVybiBkYXRhVmlld1RhZztcbiAgICAgICAgY2FzZSBtYXBDdG9yU3RyaW5nOiByZXR1cm4gbWFwVGFnO1xuICAgICAgICBjYXNlIHByb21pc2VDdG9yU3RyaW5nOiByZXR1cm4gcHJvbWlzZVRhZztcbiAgICAgICAgY2FzZSBzZXRDdG9yU3RyaW5nOiByZXR1cm4gc2V0VGFnO1xuICAgICAgICBjYXNlIHdlYWtNYXBDdG9yU3RyaW5nOiByZXR1cm4gd2Vha01hcFRhZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0VGFnO1xuIiwiaW1wb3J0IFN0YWNrIGZyb20gJy4vX1N0YWNrLmpzJztcbmltcG9ydCBlcXVhbEFycmF5cyBmcm9tICcuL19lcXVhbEFycmF5cy5qcyc7XG5pbXBvcnQgZXF1YWxCeVRhZyBmcm9tICcuL19lcXVhbEJ5VGFnLmpzJztcbmltcG9ydCBlcXVhbE9iamVjdHMgZnJvbSAnLi9fZXF1YWxPYmplY3RzLmpzJztcbmltcG9ydCBnZXRUYWcgZnJvbSAnLi9fZ2V0VGFnLmpzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5pbXBvcnQgaXNCdWZmZXIgZnJvbSAnLi9pc0J1ZmZlci5qcyc7XG5pbXBvcnQgaXNUeXBlZEFycmF5IGZyb20gJy4vaXNUeXBlZEFycmF5LmpzJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gKiBkZWVwIGNvbXBhcmlzb25zIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gKiByZWZlcmVuY2VzIHRvIGJlIGNvbXBhcmVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbERlZXAob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgb2JqSXNBcnIgPSBpc0FycmF5KG9iamVjdCksXG4gICAgICBvdGhJc0FyciA9IGlzQXJyYXkob3RoZXIpLFxuICAgICAgb2JqVGFnID0gb2JqSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvYmplY3QpLFxuICAgICAgb3RoVGFnID0gb3RoSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvdGhlcik7XG5cbiAgb2JqVGFnID0gb2JqVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvYmpUYWc7XG4gIG90aFRhZyA9IG90aFRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb3RoVGFnO1xuXG4gIHZhciBvYmpJc09iaiA9IG9ialRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBvdGhJc09iaiA9IG90aFRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBpc1NhbWVUYWcgPSBvYmpUYWcgPT0gb3RoVGFnO1xuXG4gIGlmIChpc1NhbWVUYWcgJiYgaXNCdWZmZXIob2JqZWN0KSkge1xuICAgIGlmICghaXNCdWZmZXIob3RoZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG9iaklzQXJyID0gdHJ1ZTtcbiAgICBvYmpJc09iaiA9IGZhbHNlO1xuICB9XG4gIGlmIChpc1NhbWVUYWcgJiYgIW9iaklzT2JqKSB7XG4gICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICByZXR1cm4gKG9iaklzQXJyIHx8IGlzVHlwZWRBcnJheShvYmplY3QpKVxuICAgICAgPyBlcXVhbEFycmF5cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKVxuICAgICAgOiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIG9ialRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gIH1cbiAgaWYgKCEoYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHKSkge1xuICAgIHZhciBvYmpJc1dyYXBwZWQgPSBvYmpJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ19fd3JhcHBlZF9fJyksXG4gICAgICAgIG90aElzV3JhcHBlZCA9IG90aElzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsICdfX3dyYXBwZWRfXycpO1xuXG4gICAgaWYgKG9iaklzV3JhcHBlZCB8fCBvdGhJc1dyYXBwZWQpIHtcbiAgICAgIHZhciBvYmpVbndyYXBwZWQgPSBvYmpJc1dyYXBwZWQgPyBvYmplY3QudmFsdWUoKSA6IG9iamVjdCxcbiAgICAgICAgICBvdGhVbndyYXBwZWQgPSBvdGhJc1dyYXBwZWQgPyBvdGhlci52YWx1ZSgpIDogb3RoZXI7XG5cbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICByZXR1cm4gZXF1YWxGdW5jKG9ialVud3JhcHBlZCwgb3RoVW53cmFwcGVkLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgfVxuICB9XG4gIGlmICghaXNTYW1lVGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gIHJldHVybiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VJc0VxdWFsRGVlcDtcbiIsImltcG9ydCBiYXNlSXNFcXVhbERlZXAgZnJvbSAnLi9fYmFzZUlzRXF1YWxEZWVwLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRXF1YWxgIHdoaWNoIHN1cHBvcnRzIHBhcnRpYWwgY29tcGFyaXNvbnNcbiAqIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtib29sZWFufSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICogIDEgLSBVbm9yZGVyZWQgY29tcGFyaXNvblxuICogIDIgLSBQYXJ0aWFsIGNvbXBhcmlzb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgdmFsdWVgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIGlmICh2YWx1ZSA9PT0gb3RoZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCB8fCBvdGhlciA9PSBudWxsIHx8ICghaXNPYmplY3RMaWtlKHZhbHVlKSAmJiAhaXNPYmplY3RMaWtlKG90aGVyKSkpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcjtcbiAgfVxuICByZXR1cm4gYmFzZUlzRXF1YWxEZWVwKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgYmFzZUlzRXF1YWwsIHN0YWNrKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUlzRXF1YWw7XG4iLCJpbXBvcnQgU3RhY2sgZnJvbSAnLi9fU3RhY2suanMnO1xuaW1wb3J0IGJhc2VJc0VxdWFsIGZyb20gJy4vX2Jhc2VJc0VxdWFsLmpzJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWF0Y2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtBcnJheX0gbWF0Y2hEYXRhIFRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSwgY3VzdG9taXplcikge1xuICB2YXIgaW5kZXggPSBtYXRjaERhdGEubGVuZ3RoLFxuICAgICAgbGVuZ3RoID0gaW5kZXgsXG4gICAgICBub0N1c3RvbWl6ZXIgPSAhY3VzdG9taXplcjtcblxuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gIWxlbmd0aDtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgaWYgKChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSlcbiAgICAgICAgICA/IGRhdGFbMV0gIT09IG9iamVjdFtkYXRhWzBdXVxuICAgICAgICAgIDogIShkYXRhWzBdIGluIG9iamVjdClcbiAgICAgICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgdmFyIGtleSA9IGRhdGFbMF0sXG4gICAgICAgIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIHNyY1ZhbHVlID0gZGF0YVsxXTtcblxuICAgIGlmIChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSkge1xuICAgICAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzdGFjayA9IG5ldyBTdGFjaztcbiAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spO1xuICAgICAgfVxuICAgICAgaWYgKCEocmVzdWx0ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcsIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICAgICAgOiByZXN1bHRcbiAgICAgICAgICApKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VJc01hdGNoO1xuIiwiaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaWYgc3VpdGFibGUgZm9yIHN0cmljdFxuICogIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlICYmICFpc09iamVjdCh2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzU3RyaWN0Q29tcGFyYWJsZTtcbiIsImltcG9ydCBpc1N0cmljdENvbXBhcmFibGUgZnJvbSAnLi9faXNTdHJpY3RDb21wYXJhYmxlLmpzJztcbmltcG9ydCBrZXlzIGZyb20gJy4va2V5cy5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3Mgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbWF0Y2ggZGF0YSBvZiBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gZ2V0TWF0Y2hEYXRhKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0ga2V5cyhvYmplY3QpLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICB2YXIga2V5ID0gcmVzdWx0W2xlbmd0aF0sXG4gICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICByZXN1bHRbbGVuZ3RoXSA9IFtrZXksIHZhbHVlLCBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXRNYXRjaERhdGE7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgbWF0Y2hlc1Byb3BlcnR5YCBmb3Igc291cmNlIHZhbHVlcyBzdWl0YWJsZVxuICogZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKGtleSwgc3JjVmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0W2tleV0gPT09IHNyY1ZhbHVlICYmXG4gICAgICAoc3JjVmFsdWUgIT09IHVuZGVmaW5lZCB8fCAoa2V5IGluIE9iamVjdChvYmplY3QpKSk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlO1xuIiwiaW1wb3J0IGJhc2VJc01hdGNoIGZyb20gJy4vX2Jhc2VJc01hdGNoLmpzJztcbmltcG9ydCBnZXRNYXRjaERhdGEgZnJvbSAnLi9fZ2V0TWF0Y2hEYXRhLmpzJztcbmltcG9ydCBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSBmcm9tICcuL19tYXRjaGVzU3RyaWN0Q29tcGFyYWJsZS5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc2Agd2hpY2ggZG9lc24ndCBjbG9uZSBgc291cmNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzKHNvdXJjZSkge1xuICB2YXIgbWF0Y2hEYXRhID0gZ2V0TWF0Y2hEYXRhKHNvdXJjZSk7XG4gIGlmIChtYXRjaERhdGEubGVuZ3RoID09IDEgJiYgbWF0Y2hEYXRhWzBdWzJdKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKG1hdGNoRGF0YVswXVswXSwgbWF0Y2hEYXRhWzBdWzFdKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PT0gc291cmNlIHx8IGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlTWF0Y2hlcztcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaGFzSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30ga2V5IFRoZSBrZXkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VIYXNJbihvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYga2V5IGluIE9iamVjdChvYmplY3QpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSGFzSW47XG4iLCJpbXBvcnQgY2FzdFBhdGggZnJvbSAnLi9fY2FzdFBhdGguanMnO1xuaW1wb3J0IGlzQXJndW1lbnRzIGZyb20gJy4vaXNBcmd1bWVudHMuanMnO1xuaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcbmltcG9ydCBpc0luZGV4IGZyb20gJy4vX2lzSW5kZXguanMnO1xuaW1wb3J0IGlzTGVuZ3RoIGZyb20gJy4vaXNMZW5ndGguanMnO1xuaW1wb3J0IHRvS2V5IGZyb20gJy4vX3RvS2V5LmpzJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGV4aXN0cyBvbiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYXNGdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjayBwcm9wZXJ0aWVzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzUGF0aChvYmplY3QsIHBhdGgsIGhhc0Z1bmMpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKTtcbiAgICBpZiAoIShyZXN1bHQgPSBvYmplY3QgIT0gbnVsbCAmJiBoYXNGdW5jKG9iamVjdCwga2V5KSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBvYmplY3QgPSBvYmplY3Rba2V5XTtcbiAgfVxuICBpZiAocmVzdWx0IHx8ICsraW5kZXggIT0gbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBsZW5ndGggPSBvYmplY3QgPT0gbnVsbCA/IDAgOiBvYmplY3QubGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJiBpc0luZGV4KGtleSwgbGVuZ3RoKSAmJlxuICAgIChpc0FycmF5KG9iamVjdCkgfHwgaXNBcmd1bWVudHMob2JqZWN0KSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGhhc1BhdGg7XG4iLCJpbXBvcnQgYmFzZUhhc0luIGZyb20gJy4vX2Jhc2VIYXNJbi5qcyc7XG5pbXBvcnQgaGFzUGF0aCBmcm9tICcuL19oYXNQYXRoLmpzJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IG9yIGluaGVyaXRlZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhLmInKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdiJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBoYXNJbihvYmplY3QsIHBhdGgpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzSW4pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBoYXNJbjtcbiIsImltcG9ydCBiYXNlSXNFcXVhbCBmcm9tICcuL19iYXNlSXNFcXVhbC5qcyc7XG5pbXBvcnQgZ2V0IGZyb20gJy4vZ2V0LmpzJztcbmltcG9ydCBoYXNJbiBmcm9tICcuL2hhc0luLmpzJztcbmltcG9ydCBpc0tleSBmcm9tICcuL19pc0tleS5qcyc7XG5pbXBvcnQgaXNTdHJpY3RDb21wYXJhYmxlIGZyb20gJy4vX2lzU3RyaWN0Q29tcGFyYWJsZS5qcyc7XG5pbXBvcnQgbWF0Y2hlc1N0cmljdENvbXBhcmFibGUgZnJvbSAnLi9fbWF0Y2hlc1N0cmljdENvbXBhcmFibGUuanMnO1xuaW1wb3J0IHRvS2V5IGZyb20gJy4vX3RvS2V5LmpzJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNQcm9wZXJ0eWAgd2hpY2ggZG9lc24ndCBjbG9uZSBgc3JjVmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlTWF0Y2hlc1Byb3BlcnR5KHBhdGgsIHNyY1ZhbHVlKSB7XG4gIGlmIChpc0tleShwYXRoKSAmJiBpc1N0cmljdENvbXBhcmFibGUoc3JjVmFsdWUpKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKHRvS2V5KHBhdGgpLCBzcmNWYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBvYmpWYWx1ZSA9IGdldChvYmplY3QsIHBhdGgpO1xuICAgIHJldHVybiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiBvYmpWYWx1ZSA9PT0gc3JjVmFsdWUpXG4gICAgICA/IGhhc0luKG9iamVjdCwgcGF0aClcbiAgICAgIDogYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlTWF0Y2hlc1Byb3BlcnR5O1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpdCByZWNlaXZlcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqXG4gKiBjb25zb2xlLmxvZyhfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaWRlbnRpdHk7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlUHJvcGVydHk7XG4iLCJpbXBvcnQgYmFzZUdldCBmcm9tICcuL19iYXNlR2V0LmpzJztcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VQcm9wZXJ0eWAgd2hpY2ggc3VwcG9ydHMgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VQcm9wZXJ0eURlZXA7XG4iLCJpbXBvcnQgYmFzZVByb3BlcnR5IGZyb20gJy4vX2Jhc2VQcm9wZXJ0eS5qcyc7XG5pbXBvcnQgYmFzZVByb3BlcnR5RGVlcCBmcm9tICcuL19iYXNlUHJvcGVydHlEZWVwLmpzJztcbmltcG9ydCBpc0tleSBmcm9tICcuL19pc0tleS5qcyc7XG5pbXBvcnQgdG9LZXkgZnJvbSAnLi9fdG9LZXkuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBhIGdpdmVuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IFtcbiAqICAgeyAnYSc6IHsgJ2InOiAyIH0gfSxcbiAqICAgeyAnYSc6IHsgJ2InOiAxIH0gfVxuICogXTtcbiAqXG4gKiBfLm1hcChvYmplY3RzLCBfLnByb3BlcnR5KCdhLmInKSk7XG4gKiAvLyA9PiBbMiwgMV1cbiAqXG4gKiBfLm1hcChfLnNvcnRCeShvYmplY3RzLCBfLnByb3BlcnR5KFsnYScsICdiJ10pKSwgJ2EuYicpO1xuICogLy8gPT4gWzEsIDJdXG4gKi9cbmZ1bmN0aW9uIHByb3BlcnR5KHBhdGgpIHtcbiAgcmV0dXJuIGlzS2V5KHBhdGgpID8gYmFzZVByb3BlcnR5KHRvS2V5KHBhdGgpKSA6IGJhc2VQcm9wZXJ0eURlZXAocGF0aCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHByb3BlcnR5O1xuIiwiaW1wb3J0IGJhc2VNYXRjaGVzIGZyb20gJy4vX2Jhc2VNYXRjaGVzLmpzJztcbmltcG9ydCBiYXNlTWF0Y2hlc1Byb3BlcnR5IGZyb20gJy4vX2Jhc2VNYXRjaGVzUHJvcGVydHkuanMnO1xuaW1wb3J0IGlkZW50aXR5IGZyb20gJy4vaWRlbnRpdHkuanMnO1xuaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcbmltcG9ydCBwcm9wZXJ0eSBmcm9tICcuL3Byb3BlcnR5LmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pdGVyYXRlZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gW3ZhbHVlPV8uaWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGFuIGl0ZXJhdGVlLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBpdGVyYXRlZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUl0ZXJhdGVlKHZhbHVlKSB7XG4gIC8vIERvbid0IHN0b3JlIHRoZSBgdHlwZW9mYCByZXN1bHQgaW4gYSB2YXJpYWJsZSB0byBhdm9pZCBhIEpJVCBidWcgaW4gU2FmYXJpIDkuXG4gIC8vIFNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTU2MDM0IGZvciBtb3JlIGRldGFpbHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBpZGVudGl0eTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpXG4gICAgICA/IGJhc2VNYXRjaGVzUHJvcGVydHkodmFsdWVbMF0sIHZhbHVlWzFdKVxuICAgICAgOiBiYXNlTWF0Y2hlcyh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHByb3BlcnR5KHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUl0ZXJhdGVlO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgYmFzZSBmdW5jdGlvbiBmb3IgbWV0aG9kcyBsaWtlIGBfLmZvckluYCBhbmQgYF8uZm9yT3duYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVCYXNlRm9yKGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSwga2V5c0Z1bmMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgaXRlcmFibGUgPSBPYmplY3Qob2JqZWN0KSxcbiAgICAgICAgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpLFxuICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wc1tmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XTtcbiAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZUJhc2VGb3I7XG4iLCJpbXBvcnQgY3JlYXRlQmFzZUZvciBmcm9tICcuL19jcmVhdGVCYXNlRm9yLmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYmFzZUZvck93bmAgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgb2JqZWN0YFxuICogcHJvcGVydGllcyByZXR1cm5lZCBieSBga2V5c0Z1bmNgIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuXG4gKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbnZhciBiYXNlRm9yID0gY3JlYXRlQmFzZUZvcigpO1xuXG5leHBvcnQgZGVmYXVsdCBiYXNlRm9yO1xuIiwiaW1wb3J0IGJhc2VGb3IgZnJvbSAnLi9fYmFzZUZvci5qcyc7XG5pbXBvcnQga2V5cyBmcm9tICcuL2tleXMuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvck93bmAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGb3JPd24ob2JqZWN0LCBpdGVyYXRlZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3Iob2JqZWN0LCBpdGVyYXRlZSwga2V5cyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VGb3JPd247XG4iLCJpbXBvcnQgaXNBcnJheUxpa2UgZnJvbSAnLi9pc0FycmF5TGlrZS5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBiYXNlRWFjaGAgb3IgYGJhc2VFYWNoUmlnaHRgIGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGEgY29sbGVjdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUVhY2goZWFjaEZ1bmMsIGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9XG4gICAgaWYgKCFpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKTtcbiAgICB9XG4gICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuICAgICAgICBpbmRleCA9IGZyb21SaWdodCA/IGxlbmd0aCA6IC0xLFxuICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChjb2xsZWN0aW9uKTtcblxuICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVbaW5kZXhdLCBpbmRleCwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZUJhc2VFYWNoO1xuIiwiaW1wb3J0IGJhc2VGb3JPd24gZnJvbSAnLi9fYmFzZUZvck93bi5qcyc7XG5pbXBvcnQgY3JlYXRlQmFzZUVhY2ggZnJvbSAnLi9fY3JlYXRlQmFzZUVhY2guanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckVhY2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICovXG52YXIgYmFzZUVhY2ggPSBjcmVhdGVCYXNlRWFjaChiYXNlRm9yT3duKTtcblxuZXhwb3J0IGRlZmF1bHQgYmFzZUVhY2g7XG4iLCJpbXBvcnQgYmFzZUVhY2ggZnJvbSAnLi9fYmFzZUVhY2guanMnO1xuaW1wb3J0IGlzQXJyYXlMaWtlIGZyb20gJy4vaXNBcnJheUxpa2UuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hcGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlTWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gaXNBcnJheUxpa2UoY29sbGVjdGlvbikgPyBBcnJheShjb2xsZWN0aW9uLmxlbmd0aCkgOiBbXTtcblxuICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gaXRlcmF0ZWUodmFsdWUsIGtleSwgY29sbGVjdGlvbik7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlTWFwO1xuIiwiaW1wb3J0IGFycmF5TWFwIGZyb20gJy4vX2FycmF5TWFwLmpzJztcbmltcG9ydCBiYXNlSXRlcmF0ZWUgZnJvbSAnLi9fYmFzZUl0ZXJhdGVlLmpzJztcbmltcG9ydCBiYXNlTWFwIGZyb20gJy4vX2Jhc2VNYXAuanMnO1xuaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHZhbHVlcyBieSBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAgdGhydVxuICogYGl0ZXJhdGVlYC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gKiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gKlxuICogTWFueSBsb2Rhc2ggbWV0aG9kcyBhcmUgZ3VhcmRlZCB0byB3b3JrIGFzIGl0ZXJhdGVlcyBmb3IgbWV0aG9kcyBsaWtlXG4gKiBgXy5ldmVyeWAsIGBfLmZpbHRlcmAsIGBfLm1hcGAsIGBfLm1hcFZhbHVlc2AsIGBfLnJlamVjdGAsIGFuZCBgXy5zb21lYC5cbiAqXG4gKiBUaGUgZ3VhcmRlZCBtZXRob2RzIGFyZTpcbiAqIGBhcnlgLCBgY2h1bmtgLCBgY3VycnlgLCBgY3VycnlSaWdodGAsIGBkcm9wYCwgYGRyb3BSaWdodGAsIGBldmVyeWAsXG4gKiBgZmlsbGAsIGBpbnZlcnRgLCBgcGFyc2VJbnRgLCBgcmFuZG9tYCwgYHJhbmdlYCwgYHJhbmdlUmlnaHRgLCBgcmVwZWF0YCxcbiAqIGBzYW1wbGVTaXplYCwgYHNsaWNlYCwgYHNvbWVgLCBgc29ydEJ5YCwgYHNwbGl0YCwgYHRha2VgLCBgdGFrZVJpZ2h0YCxcbiAqIGB0ZW1wbGF0ZWAsIGB0cmltYCwgYHRyaW1FbmRgLCBgdHJpbVN0YXJ0YCwgYW5kIGB3b3Jkc2BcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gKiAgIHJldHVybiBuICogbjtcbiAqIH1cbiAqXG4gKiBfLm1hcChbNCwgOF0sIHNxdWFyZSk7XG4gKiAvLyA9PiBbMTYsIDY0XVxuICpcbiAqIF8ubWFwKHsgJ2EnOiA0LCAnYic6IDggfSwgc3F1YXJlKTtcbiAqIC8vID0+IFsxNiwgNjRdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogdmFyIHVzZXJzID0gW1xuICogICB7ICd1c2VyJzogJ2Jhcm5leScgfSxcbiAqICAgeyAndXNlcic6ICdmcmVkJyB9XG4gKiBdO1xuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5tYXAodXNlcnMsICd1c2VyJyk7XG4gKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAqL1xuZnVuY3Rpb24gbWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5TWFwIDogYmFzZU1hcDtcbiAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgYmFzZUl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1hcDtcbiIsImltcG9ydCBiYXNlSXRlcmF0ZWUgZnJvbSAnLi9fYmFzZUl0ZXJhdGVlLmpzJztcbmltcG9ydCBpc0FycmF5TGlrZSBmcm9tICcuL2lzQXJyYXlMaWtlLmpzJztcbmltcG9ydCBrZXlzIGZyb20gJy4va2V5cy5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBfLmZpbmRgIG9yIGBfLmZpbmRMYXN0YCBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZmluZEluZGV4RnVuYyBUaGUgZnVuY3Rpb24gdG8gZmluZCB0aGUgY29sbGVjdGlvbiBpbmRleC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZpbmQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUZpbmQoZmluZEluZGV4RnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgcHJlZGljYXRlLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgaXRlcmFibGUgPSBPYmplY3QoY29sbGVjdGlvbik7XG4gICAgaWYgKCFpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgICAgdmFyIGl0ZXJhdGVlID0gYmFzZUl0ZXJhdGVlKHByZWRpY2F0ZSwgMyk7XG4gICAgICBjb2xsZWN0aW9uID0ga2V5cyhjb2xsZWN0aW9uKTtcbiAgICAgIHByZWRpY2F0ZSA9IGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSk7IH07XG4gICAgfVxuICAgIHZhciBpbmRleCA9IGZpbmRJbmRleEZ1bmMoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBmcm9tSW5kZXgpO1xuICAgIHJldHVybiBpbmRleCA+IC0xID8gaXRlcmFibGVbaXRlcmF0ZWUgPyBjb2xsZWN0aW9uW2luZGV4XSA6IGluZGV4XSA6IHVuZGVmaW5lZDtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlRmluZDtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmluZEluZGV4YCBhbmQgYF8uZmluZExhc3RJbmRleGAgd2l0aG91dFxuICogc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBiYXNlRmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCwgZnJvbVJpZ2h0KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBpbmRleCA9IGZyb21JbmRleCArIChmcm9tUmlnaHQgPyAxIDogLTEpO1xuXG4gIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlRmluZEluZGV4O1xuIiwiaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuaW1wb3J0IGlzU3ltYm9sIGZyb20gJy4vaXNTeW1ib2wuanMnO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBOQU4gPSAwIC8gMDtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZS4gKi9cbnZhciByZVRyaW0gPSAvXlxccyt8XFxzKyQvZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJhZCBzaWduZWQgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmFkSGV4ID0gL15bLStdMHhbMC05YS1mXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiaW5hcnkgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmluYXJ5ID0gL14wYlswMV0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb2N0YWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzT2N0YWwgPSAvXjBvWzAtN10rJC9pO1xuXG4vKiogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgd2l0aG91dCBhIGRlcGVuZGVuY3kgb24gYHJvb3RgLiAqL1xudmFyIGZyZWVQYXJzZUludCA9IHBhcnNlSW50O1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9OdW1iZXIoMy4yKTtcbiAqIC8vID0+IDMuMlxuICpcbiAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiA1ZS0zMjRcbiAqXG4gKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcbiAqIC8vID0+IEluZmluaXR5XG4gKlxuICogXy50b051bWJlcignMy4yJyk7XG4gKiAvLyA9PiAzLjJcbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIE5BTjtcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgIHZhbHVlID0gaXNPYmplY3Qob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICB9XG4gIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZVRyaW0sICcnKTtcbiAgdmFyIGlzQmluYXJ5ID0gcmVJc0JpbmFyeS50ZXN0KHZhbHVlKTtcbiAgcmV0dXJuIChpc0JpbmFyeSB8fCByZUlzT2N0YWwudGVzdCh2YWx1ZSkpXG4gICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXG4gICAgOiAocmVJc0JhZEhleC50ZXN0KHZhbHVlKSA/IE5BTiA6ICt2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHRvTnVtYmVyO1xuIiwiaW1wb3J0IHRvTnVtYmVyIGZyb20gJy4vdG9OdW1iZXIuanMnO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwLFxuICAgIE1BWF9JTlRFR0VSID0gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDg7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIGZpbml0ZSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEyLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b0Zpbml0ZSgzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b0Zpbml0ZShOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9GaW5pdGUoSW5maW5pdHkpO1xuICogLy8gPT4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAqXG4gKiBfLnRvRmluaXRlKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b0Zpbml0ZSh2YWx1ZSkge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiAwO1xuICB9XG4gIHZhbHVlID0gdG9OdW1iZXIodmFsdWUpO1xuICBpZiAodmFsdWUgPT09IElORklOSVRZIHx8IHZhbHVlID09PSAtSU5GSU5JVFkpIHtcbiAgICB2YXIgc2lnbiA9ICh2YWx1ZSA8IDAgPyAtMSA6IDEpO1xuICAgIHJldHVybiBzaWduICogTUFYX0lOVEVHRVI7XG4gIH1cbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA/IHZhbHVlIDogMDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdG9GaW5pdGU7XG4iLCJpbXBvcnQgdG9GaW5pdGUgZnJvbSAnLi90b0Zpbml0ZS5qcyc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhbiBpbnRlZ2VyLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvSW50ZWdlcmBdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2ludGVnZXIpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9JbnRlZ2VyKDMuMik7XG4gKiAvLyA9PiAzXG4gKlxuICogXy50b0ludGVnZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiAwXG4gKlxuICogXy50b0ludGVnZXIoSW5maW5pdHkpO1xuICogLy8gPT4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAqXG4gKiBfLnRvSW50ZWdlcignMy4yJyk7XG4gKiAvLyA9PiAzXG4gKi9cbmZ1bmN0aW9uIHRvSW50ZWdlcih2YWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gdG9GaW5pdGUodmFsdWUpLFxuICAgICAgcmVtYWluZGVyID0gcmVzdWx0ICUgMTtcblxuICByZXR1cm4gcmVzdWx0ID09PSByZXN1bHQgPyAocmVtYWluZGVyID8gcmVzdWx0IC0gcmVtYWluZGVyIDogcmVzdWx0KSA6IDA7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHRvSW50ZWdlcjtcbiIsImltcG9ydCBiYXNlRmluZEluZGV4IGZyb20gJy4vX2Jhc2VGaW5kSW5kZXguanMnO1xuaW1wb3J0IGJhc2VJdGVyYXRlZSBmcm9tICcuL19iYXNlSXRlcmF0ZWUuanMnO1xuaW1wb3J0IHRvSW50ZWdlciBmcm9tICcuL3RvSW50ZWdlci5qcyc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdFxuICogZWxlbWVudCBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgaW5zdGVhZCBvZiB0aGUgZWxlbWVudCBpdHNlbGYuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAxLjEuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGAtMWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciB1c2VycyA9IFtcbiAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogdHJ1ZSB9XG4gKiBdO1xuICpcbiAqIF8uZmluZEluZGV4KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLnVzZXIgPT0gJ2Jhcm5leSc7IH0pO1xuICogLy8gPT4gMFxuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbmRJbmRleCh1c2VycywgeyAndXNlcic6ICdmcmVkJywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICogLy8gPT4gMVxuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmluZEluZGV4KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gKiAvLyA9PiAwXG4gKlxuICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbmRJbmRleCh1c2VycywgJ2FjdGl2ZScpO1xuICogLy8gPT4gMlxuICovXG5mdW5jdGlvbiBmaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgdmFyIGluZGV4ID0gZnJvbUluZGV4ID09IG51bGwgPyAwIDogdG9JbnRlZ2VyKGZyb21JbmRleCk7XG4gIGlmIChpbmRleCA8IDApIHtcbiAgICBpbmRleCA9IG5hdGl2ZU1heChsZW5ndGggKyBpbmRleCwgMCk7XG4gIH1cbiAgcmV0dXJuIGJhc2VGaW5kSW5kZXgoYXJyYXksIGJhc2VJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCBpbmRleCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZpbmRJbmRleDtcbiIsImltcG9ydCBjcmVhdGVGaW5kIGZyb20gJy4vX2NyZWF0ZUZpbmQuanMnO1xuaW1wb3J0IGZpbmRJbmRleCBmcm9tICcuL2ZpbmRJbmRleC5qcyc7XG5cbi8qKlxuICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAsIHJldHVybmluZyB0aGUgZmlyc3QgZWxlbWVudFxuICogYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0aHJlZVxuICogYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF0Y2hlZCBlbGVtZW50LCBlbHNlIGB1bmRlZmluZWRgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgdXNlcnMgPSBbXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfSxcbiAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEsICAnYWN0aXZlJzogdHJ1ZSB9XG4gKiBdO1xuICpcbiAqIF8uZmluZCh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby5hZ2UgPCA0MDsgfSk7XG4gKiAvLyA9PiBvYmplY3QgZm9yICdiYXJuZXknXG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmluZCh1c2VycywgeyAnYWdlJzogMSwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gKiAvLyA9PiBvYmplY3QgZm9yICdwZWJibGVzJ1xuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmluZCh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICogLy8gPT4gb2JqZWN0IGZvciAnZnJlZCdcbiAqXG4gKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmluZCh1c2VycywgJ2FjdGl2ZScpO1xuICogLy8gPT4gb2JqZWN0IGZvciAnYmFybmV5J1xuICovXG52YXIgZmluZCA9IGNyZWF0ZUZpbmQoZmluZEluZGV4KTtcblxuZXhwb3J0IGRlZmF1bHQgZmluZDtcbiIsImltcG9ydCBiYXNlS2V5cyBmcm9tICcuL19iYXNlS2V5cy5qcyc7XG5pbXBvcnQgZ2V0VGFnIGZyb20gJy4vX2dldFRhZy5qcyc7XG5pbXBvcnQgaXNBcmd1bWVudHMgZnJvbSAnLi9pc0FyZ3VtZW50cy5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuaW1wb3J0IGlzQXJyYXlMaWtlIGZyb20gJy4vaXNBcnJheUxpa2UuanMnO1xuaW1wb3J0IGlzQnVmZmVyIGZyb20gJy4vaXNCdWZmZXIuanMnO1xuaW1wb3J0IGlzUHJvdG90eXBlIGZyb20gJy4vX2lzUHJvdG90eXBlLmpzJztcbmltcG9ydCBpc1R5cGVkQXJyYXkgZnJvbSAnLi9pc1R5cGVkQXJyYXkuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gZW1wdHkgb2JqZWN0LCBjb2xsZWN0aW9uLCBtYXAsIG9yIHNldC5cbiAqXG4gKiBPYmplY3RzIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBubyBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWRcbiAqIHByb3BlcnRpZXMuXG4gKlxuICogQXJyYXktbGlrZSB2YWx1ZXMgc3VjaCBhcyBgYXJndW1lbnRzYCBvYmplY3RzLCBhcnJheXMsIGJ1ZmZlcnMsIHN0cmluZ3MsIG9yXG4gKiBqUXVlcnktbGlrZSBjb2xsZWN0aW9ucyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgYSBgbGVuZ3RoYCBvZiBgMGAuXG4gKiBTaW1pbGFybHksIG1hcHMgYW5kIHNldHMgYXJlIGNvbnNpZGVyZWQgZW1wdHkgaWYgdGhleSBoYXZlIGEgYHNpemVgIG9mIGAwYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBlbXB0eSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRW1wdHkobnVsbCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0VtcHR5KHRydWUpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNFbXB0eSgxKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRW1wdHkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0VtcHR5KHsgJ2EnOiAxIH0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNFbXB0eSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkgJiZcbiAgICAgIChpc0FycmF5KHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlLnNwbGljZSA9PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgIGlzQnVmZmVyKHZhbHVlKSB8fCBpc1R5cGVkQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSkpIHtcbiAgICByZXR1cm4gIXZhbHVlLmxlbmd0aDtcbiAgfVxuICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKTtcbiAgaWYgKHRhZyA9PSBtYXBUYWcgfHwgdGFnID09IHNldFRhZykge1xuICAgIHJldHVybiAhdmFsdWUuc2l6ZTtcbiAgfVxuICBpZiAoaXNQcm90b3R5cGUodmFsdWUpKSB7XG4gICAgcmV0dXJuICFiYXNlS2V5cyh2YWx1ZSkubGVuZ3RoO1xuICB9XG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0VtcHR5O1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZm9yRWFjaGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RWFjaChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkgPT09IGZhbHNlKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheUVhY2g7XG4iLCJpbXBvcnQgYXNzaWduVmFsdWUgZnJvbSAnLi9fYXNzaWduVmFsdWUuanMnO1xuaW1wb3J0IGJhc2VBc3NpZ25WYWx1ZSBmcm9tICcuL19iYXNlQXNzaWduVmFsdWUuanMnO1xuXG4vKipcbiAqIENvcGllcyBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMgdG8gY29weS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvcGllZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5T2JqZWN0KHNvdXJjZSwgcHJvcHMsIG9iamVjdCwgY3VzdG9taXplcikge1xuICB2YXIgaXNOZXcgPSAhb2JqZWN0O1xuICBvYmplY3QgfHwgKG9iamVjdCA9IHt9KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG5cbiAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICA/IGN1c3RvbWl6ZXIob2JqZWN0W2tleV0sIHNvdXJjZVtrZXldLCBrZXksIG9iamVjdCwgc291cmNlKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbmV3VmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gICAgaWYgKGlzTmV3KSB7XG4gICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY29weU9iamVjdDtcbiIsImltcG9ydCBjb3B5T2JqZWN0IGZyb20gJy4vX2NvcHlPYmplY3QuanMnO1xuaW1wb3J0IGtleXMgZnJvbSAnLi9rZXlzLmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xuICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ24ob2JqZWN0LCBzb3VyY2UpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBjb3B5T2JqZWN0KHNvdXJjZSwga2V5cyhzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlQXNzaWduO1xuIiwiLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2VcbiAqIFtgT2JqZWN0LmtleXNgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGV4Y2VwdCB0aGF0IGl0IGluY2x1ZGVzIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIG5hdGl2ZUtleXNJbihvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAob2JqZWN0ICE9IG51bGwpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG5hdGl2ZUtleXNJbjtcbiIsImltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0LmpzJztcbmltcG9ydCBpc1Byb3RvdHlwZSBmcm9tICcuL19pc1Byb3RvdHlwZS5qcyc7XG5pbXBvcnQgbmF0aXZlS2V5c0luIGZyb20gJy4vX25hdGl2ZUtleXNJbi5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c0luYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzSW4ob2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzSW4ob2JqZWN0KTtcbiAgfVxuICB2YXIgaXNQcm90byA9IGlzUHJvdG90eXBlKG9iamVjdCksXG4gICAgICByZXN1bHQgPSBbXTtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKCEoa2V5ID09ICdjb25zdHJ1Y3RvcicgJiYgKGlzUHJvdG8gfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VLZXlzSW47XG4iLCJpbXBvcnQgYXJyYXlMaWtlS2V5cyBmcm9tICcuL19hcnJheUxpa2VLZXlzLmpzJztcbmltcG9ydCBiYXNlS2V5c0luIGZyb20gJy4vX2Jhc2VLZXlzSW4uanMnO1xuaW1wb3J0IGlzQXJyYXlMaWtlIGZyb20gJy4vaXNBcnJheUxpa2UuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzSW4obmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYicsICdjJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqL1xuZnVuY3Rpb24ga2V5c0luKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0LCB0cnVlKSA6IGJhc2VLZXlzSW4ob2JqZWN0KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQga2V5c0luO1xuIiwiaW1wb3J0IGNvcHlPYmplY3QgZnJvbSAnLi9fY29weU9iamVjdC5qcyc7XG5pbXBvcnQga2V5c0luIGZyb20gJy4va2V5c0luLmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25JbmAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzXG4gKiBvciBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnbkluKG9iamVjdCwgc291cmNlKSB7XG4gIHJldHVybiBvYmplY3QgJiYgY29weU9iamVjdChzb3VyY2UsIGtleXNJbihzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlQXNzaWduSW47XG4iLCJpbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgYWxsb2NVbnNhZmUgPSBCdWZmZXIgPyBCdWZmZXIuYWxsb2NVbnNhZmUgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mICBgYnVmZmVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBUaGUgYnVmZmVyIHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQnVmZmVyKGJ1ZmZlciwgaXNEZWVwKSB7XG4gIGlmIChpc0RlZXApIHtcbiAgICByZXR1cm4gYnVmZmVyLnNsaWNlKCk7XG4gIH1cbiAgdmFyIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBhbGxvY1Vuc2FmZSA/IGFsbG9jVW5zYWZlKGxlbmd0aCkgOiBuZXcgYnVmZmVyLmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgYnVmZmVyLmNvcHkocmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xvbmVCdWZmZXI7XG4iLCIvKipcbiAqIENvcGllcyB0aGUgdmFsdWVzIG9mIGBzb3VyY2VgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheT1bXV0gVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIHRvLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlBcnJheShzb3VyY2UsIGFycmF5KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcblxuICBhcnJheSB8fCAoYXJyYXkgPSBBcnJheShsZW5ndGgpKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtpbmRleF0gPSBzb3VyY2VbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY29weUFycmF5O1xuIiwiaW1wb3J0IGNvcHlPYmplY3QgZnJvbSAnLi9fY29weU9iamVjdC5qcyc7XG5pbXBvcnQgZ2V0U3ltYm9scyBmcm9tICcuL19nZXRTeW1ib2xzLmpzJztcblxuLyoqXG4gKiBDb3BpZXMgb3duIHN5bWJvbHMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgZnJvbS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyB0by5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlTeW1ib2xzKHNvdXJjZSwgb2JqZWN0KSB7XG4gIHJldHVybiBjb3B5T2JqZWN0KHNvdXJjZSwgZ2V0U3ltYm9scyhzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjb3B5U3ltYm9scztcbiIsImltcG9ydCBvdmVyQXJnIGZyb20gJy4vX292ZXJBcmcuanMnO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBnZXRQcm90b3R5cGUgPSBvdmVyQXJnKE9iamVjdC5nZXRQcm90b3R5cGVPZiwgT2JqZWN0KTtcblxuZXhwb3J0IGRlZmF1bHQgZ2V0UHJvdG90eXBlO1xuIiwiaW1wb3J0IGFycmF5UHVzaCBmcm9tICcuL19hcnJheVB1c2guanMnO1xuaW1wb3J0IGdldFByb3RvdHlwZSBmcm9tICcuL19nZXRQcm90b3R5cGUuanMnO1xuaW1wb3J0IGdldFN5bWJvbHMgZnJvbSAnLi9fZ2V0U3ltYm9scy5qcyc7XG5pbXBvcnQgc3R1YkFycmF5IGZyb20gJy4vc3R1YkFycmF5LmpzJztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICovXG52YXIgZ2V0U3ltYm9sc0luID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB3aGlsZSAob2JqZWN0KSB7XG4gICAgYXJyYXlQdXNoKHJlc3VsdCwgZ2V0U3ltYm9scyhvYmplY3QpKTtcbiAgICBvYmplY3QgPSBnZXRQcm90b3R5cGUob2JqZWN0KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZ2V0U3ltYm9sc0luO1xuIiwiaW1wb3J0IGNvcHlPYmplY3QgZnJvbSAnLi9fY29weU9iamVjdC5qcyc7XG5pbXBvcnQgZ2V0U3ltYm9sc0luIGZyb20gJy4vX2dldFN5bWJvbHNJbi5qcyc7XG5cbi8qKlxuICogQ29waWVzIG93biBhbmQgaW5oZXJpdGVkIHN5bWJvbHMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgZnJvbS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyB0by5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlTeW1ib2xzSW4oc291cmNlLCBvYmplY3QpIHtcbiAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzSW4oc291cmNlKSwgb2JqZWN0KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY29weVN5bWJvbHNJbjtcbiIsImltcG9ydCBiYXNlR2V0QWxsS2V5cyBmcm9tICcuL19iYXNlR2V0QWxsS2V5cy5qcyc7XG5pbXBvcnQgZ2V0U3ltYm9sc0luIGZyb20gJy4vX2dldFN5bWJvbHNJbi5qcyc7XG5pbXBvcnQga2V5c0luIGZyb20gJy4va2V5c0luLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzSW4ob2JqZWN0KSB7XG4gIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNJbiwgZ2V0U3ltYm9sc0luKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0QWxsS2V5c0luO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBhcnJheSBjbG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNsb25lLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lQXJyYXkoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IG5ldyBhcnJheS5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gIC8vIEFkZCBwcm9wZXJ0aWVzIGFzc2lnbmVkIGJ5IGBSZWdFeHAjZXhlY2AuXG4gIGlmIChsZW5ndGggJiYgdHlwZW9mIGFycmF5WzBdID09ICdzdHJpbmcnICYmIGhhc093blByb3BlcnR5LmNhbGwoYXJyYXksICdpbmRleCcpKSB7XG4gICAgcmVzdWx0LmluZGV4ID0gYXJyYXkuaW5kZXg7XG4gICAgcmVzdWx0LmlucHV0ID0gYXJyYXkuaW5wdXQ7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaW5pdENsb25lQXJyYXk7XG4iLCJpbXBvcnQgVWludDhBcnJheSBmcm9tICcuL19VaW50OEFycmF5LmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGFycmF5QnVmZmVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYXJyYXlCdWZmZXIgVGhlIGFycmF5IGJ1ZmZlciB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGFycmF5IGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY2xvbmVBcnJheUJ1ZmZlcihhcnJheUJ1ZmZlcikge1xuICB2YXIgcmVzdWx0ID0gbmV3IGFycmF5QnVmZmVyLmNvbnN0cnVjdG9yKGFycmF5QnVmZmVyLmJ5dGVMZW5ndGgpO1xuICBuZXcgVWludDhBcnJheShyZXN1bHQpLnNldChuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcikpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbG9uZUFycmF5QnVmZmVyO1xuIiwiaW1wb3J0IGNsb25lQXJyYXlCdWZmZXIgZnJvbSAnLi9fY2xvbmVBcnJheUJ1ZmZlci5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBkYXRhVmlld2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhVmlldyBUaGUgZGF0YSB2aWV3IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBkYXRhIHZpZXcuXG4gKi9cbmZ1bmN0aW9uIGNsb25lRGF0YVZpZXcoZGF0YVZpZXcsIGlzRGVlcCkge1xuICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcihkYXRhVmlldy5idWZmZXIpIDogZGF0YVZpZXcuYnVmZmVyO1xuICByZXR1cm4gbmV3IGRhdGFWaWV3LmNvbnN0cnVjdG9yKGJ1ZmZlciwgZGF0YVZpZXcuYnl0ZU9mZnNldCwgZGF0YVZpZXcuYnl0ZUxlbmd0aCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsb25lRGF0YVZpZXc7XG4iLCIvKiogVXNlZCB0byBtYXRjaCBgUmVnRXhwYCBmbGFncyBmcm9tIHRoZWlyIGNvZXJjZWQgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUZsYWdzID0gL1xcdyokLztcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHJlZ2V4cGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWdleHAgVGhlIHJlZ2V4cCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCByZWdleHAuXG4gKi9cbmZ1bmN0aW9uIGNsb25lUmVnRXhwKHJlZ2V4cCkge1xuICB2YXIgcmVzdWx0ID0gbmV3IHJlZ2V4cC5jb25zdHJ1Y3RvcihyZWdleHAuc291cmNlLCByZUZsYWdzLmV4ZWMocmVnZXhwKSk7XG4gIHJlc3VsdC5sYXN0SW5kZXggPSByZWdleHAubGFzdEluZGV4O1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbG9uZVJlZ0V4cDtcbiIsImltcG9ydCBTeW1ib2wgZnJvbSAnLi9fU3ltYm9sLmpzJztcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoZSBgc3ltYm9sYCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzeW1ib2wgVGhlIHN5bWJvbCBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgc3ltYm9sIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gY2xvbmVTeW1ib2woc3ltYm9sKSB7XG4gIHJldHVybiBzeW1ib2xWYWx1ZU9mID8gT2JqZWN0KHN5bWJvbFZhbHVlT2YuY2FsbChzeW1ib2wpKSA6IHt9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbG9uZVN5bWJvbDtcbiIsImltcG9ydCBjbG9uZUFycmF5QnVmZmVyIGZyb20gJy4vX2Nsb25lQXJyYXlCdWZmZXIuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgdHlwZWRBcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlZEFycmF5IFRoZSB0eXBlZCBhcnJheSB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgdHlwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNsb25lVHlwZWRBcnJheSh0eXBlZEFycmF5LCBpc0RlZXApIHtcbiAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIodHlwZWRBcnJheS5idWZmZXIpIDogdHlwZWRBcnJheS5idWZmZXI7XG4gIHJldHVybiBuZXcgdHlwZWRBcnJheS5jb25zdHJ1Y3RvcihidWZmZXIsIHR5cGVkQXJyYXkuYnl0ZU9mZnNldCwgdHlwZWRBcnJheS5sZW5ndGgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbG9uZVR5cGVkQXJyYXk7XG4iLCJpbXBvcnQgY2xvbmVBcnJheUJ1ZmZlciBmcm9tICcuL19jbG9uZUFycmF5QnVmZmVyLmpzJztcbmltcG9ydCBjbG9uZURhdGFWaWV3IGZyb20gJy4vX2Nsb25lRGF0YVZpZXcuanMnO1xuaW1wb3J0IGNsb25lUmVnRXhwIGZyb20gJy4vX2Nsb25lUmVnRXhwLmpzJztcbmltcG9ydCBjbG9uZVN5bWJvbCBmcm9tICcuL19jbG9uZVN5bWJvbC5qcyc7XG5pbXBvcnQgY2xvbmVUeXBlZEFycmF5IGZyb20gJy4vX2Nsb25lVHlwZWRBcnJheS5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZSBiYXNlZCBvbiBpdHMgYHRvU3RyaW5nVGFnYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNsb25pbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBNYXBgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIGBTZXRgLCBvciBgU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVCeVRhZyhvYmplY3QsIHRhZywgaXNEZWVwKSB7XG4gIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICByZXR1cm4gY2xvbmVBcnJheUJ1ZmZlcihvYmplY3QpO1xuXG4gICAgY2FzZSBib29sVGFnOlxuICAgIGNhc2UgZGF0ZVRhZzpcbiAgICAgIHJldHVybiBuZXcgQ3Rvcigrb2JqZWN0KTtcblxuICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICByZXR1cm4gY2xvbmVEYXRhVmlldyhvYmplY3QsIGlzRGVlcCk7XG5cbiAgICBjYXNlIGZsb2F0MzJUYWc6IGNhc2UgZmxvYXQ2NFRhZzpcbiAgICBjYXNlIGludDhUYWc6IGNhc2UgaW50MTZUYWc6IGNhc2UgaW50MzJUYWc6XG4gICAgY2FzZSB1aW50OFRhZzogY2FzZSB1aW50OENsYW1wZWRUYWc6IGNhc2UgdWludDE2VGFnOiBjYXNlIHVpbnQzMlRhZzpcbiAgICAgIHJldHVybiBjbG9uZVR5cGVkQXJyYXkob2JqZWN0LCBpc0RlZXApO1xuXG4gICAgY2FzZSBtYXBUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3I7XG5cbiAgICBjYXNlIG51bWJlclRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIHJldHVybiBuZXcgQ3RvcihvYmplY3QpO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgICByZXR1cm4gY2xvbmVSZWdFeHAob2JqZWN0KTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yO1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICByZXR1cm4gY2xvbmVTeW1ib2wob2JqZWN0KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBpbml0Q2xvbmVCeVRhZztcbiIsImltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0LmpzJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXNzaWduaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xudmFyIGJhc2VDcmVhdGUgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIG9iamVjdCgpIHt9XG4gIHJldHVybiBmdW5jdGlvbihwcm90bykge1xuICAgIGlmICghaXNPYmplY3QocHJvdG8pKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGlmIChvYmplY3RDcmVhdGUpIHtcbiAgICAgIHJldHVybiBvYmplY3RDcmVhdGUocHJvdG8pO1xuICAgIH1cbiAgICBvYmplY3QucHJvdG90eXBlID0gcHJvdG87XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBvYmplY3Q7XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufSgpKTtcblxuZXhwb3J0IGRlZmF1bHQgYmFzZUNyZWF0ZTtcbiIsImltcG9ydCBiYXNlQ3JlYXRlIGZyb20gJy4vX2Jhc2VDcmVhdGUuanMnO1xuaW1wb3J0IGdldFByb3RvdHlwZSBmcm9tICcuL19nZXRQcm90b3R5cGUuanMnO1xuaW1wb3J0IGlzUHJvdG90eXBlIGZyb20gJy4vX2lzUHJvdG90eXBlLmpzJztcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVPYmplY3Qob2JqZWN0KSB7XG4gIHJldHVybiAodHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmICFpc1Byb3RvdHlwZShvYmplY3QpKVxuICAgID8gYmFzZUNyZWF0ZShnZXRQcm90b3R5cGUob2JqZWN0KSlcbiAgICA6IHt9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBpbml0Q2xvbmVPYmplY3Q7XG4iLCJpbXBvcnQgZ2V0VGFnIGZyb20gJy4vX2dldFRhZy5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWFwYCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG1hcCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNNYXAodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgZ2V0VGFnKHZhbHVlKSA9PSBtYXBUYWc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VJc01hcDtcbiIsImltcG9ydCBiYXNlSXNNYXAgZnJvbSAnLi9fYmFzZUlzTWFwLmpzJztcbmltcG9ydCBiYXNlVW5hcnkgZnJvbSAnLi9fYmFzZVVuYXJ5LmpzJztcbmltcG9ydCBub2RlVXRpbCBmcm9tICcuL19ub2RlVXRpbC5qcyc7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzTWFwID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNNYXA7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBNYXBgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG1hcCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTWFwKG5ldyBNYXApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNNYXAobmV3IFdlYWtNYXApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzTWFwID0gbm9kZUlzTWFwID8gYmFzZVVuYXJ5KG5vZGVJc01hcCkgOiBiYXNlSXNNYXA7XG5cbmV4cG9ydCBkZWZhdWx0IGlzTWFwO1xuIiwiaW1wb3J0IGdldFRhZyBmcm9tICcuL19nZXRUYWcuanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzZXRUYWcgPSAnW29iamVjdCBTZXRdJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1NldGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzZXQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzU2V0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gc2V0VGFnO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSXNTZXQ7XG4iLCJpbXBvcnQgYmFzZUlzU2V0IGZyb20gJy4vX2Jhc2VJc1NldC5qcyc7XG5pbXBvcnQgYmFzZVVuYXJ5IGZyb20gJy4vX2Jhc2VVbmFyeS5qcyc7XG5pbXBvcnQgbm9kZVV0aWwgZnJvbSAnLi9fbm9kZVV0aWwuanMnO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1NldCA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzU2V0O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU2V0YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzZXQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1NldChuZXcgU2V0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU2V0KG5ldyBXZWFrU2V0KTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1NldCA9IG5vZGVJc1NldCA/IGJhc2VVbmFyeShub2RlSXNTZXQpIDogYmFzZUlzU2V0O1xuXG5leHBvcnQgZGVmYXVsdCBpc1NldDtcbiIsImltcG9ydCBTdGFjayBmcm9tICcuL19TdGFjay5qcyc7XG5pbXBvcnQgYXJyYXlFYWNoIGZyb20gJy4vX2FycmF5RWFjaC5qcyc7XG5pbXBvcnQgYXNzaWduVmFsdWUgZnJvbSAnLi9fYXNzaWduVmFsdWUuanMnO1xuaW1wb3J0IGJhc2VBc3NpZ24gZnJvbSAnLi9fYmFzZUFzc2lnbi5qcyc7XG5pbXBvcnQgYmFzZUFzc2lnbkluIGZyb20gJy4vX2Jhc2VBc3NpZ25Jbi5qcyc7XG5pbXBvcnQgY2xvbmVCdWZmZXIgZnJvbSAnLi9fY2xvbmVCdWZmZXIuanMnO1xuaW1wb3J0IGNvcHlBcnJheSBmcm9tICcuL19jb3B5QXJyYXkuanMnO1xuaW1wb3J0IGNvcHlTeW1ib2xzIGZyb20gJy4vX2NvcHlTeW1ib2xzLmpzJztcbmltcG9ydCBjb3B5U3ltYm9sc0luIGZyb20gJy4vX2NvcHlTeW1ib2xzSW4uanMnO1xuaW1wb3J0IGdldEFsbEtleXMgZnJvbSAnLi9fZ2V0QWxsS2V5cy5qcyc7XG5pbXBvcnQgZ2V0QWxsS2V5c0luIGZyb20gJy4vX2dldEFsbEtleXNJbi5qcyc7XG5pbXBvcnQgZ2V0VGFnIGZyb20gJy4vX2dldFRhZy5qcyc7XG5pbXBvcnQgaW5pdENsb25lQXJyYXkgZnJvbSAnLi9faW5pdENsb25lQXJyYXkuanMnO1xuaW1wb3J0IGluaXRDbG9uZUJ5VGFnIGZyb20gJy4vX2luaXRDbG9uZUJ5VGFnLmpzJztcbmltcG9ydCBpbml0Q2xvbmVPYmplY3QgZnJvbSAnLi9faW5pdENsb25lT2JqZWN0LmpzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5pbXBvcnQgaXNCdWZmZXIgZnJvbSAnLi9pc0J1ZmZlci5qcyc7XG5pbXBvcnQgaXNNYXAgZnJvbSAnLi9pc01hcC5qcyc7XG5pbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdC5qcyc7XG5pbXBvcnQgaXNTZXQgZnJvbSAnLi9pc1NldC5qcyc7XG5pbXBvcnQga2V5cyBmcm9tICcuL2tleXMuanMnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xudmFyIENMT05FX0RFRVBfRkxBRyA9IDEsXG4gICAgQ0xPTkVfRkxBVF9GTEFHID0gMixcbiAgICBDTE9ORV9TWU1CT0xTX0ZMQUcgPSA0O1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIHN1cHBvcnRlZCBieSBgXy5jbG9uZWAuICovXG52YXIgY2xvbmVhYmxlVGFncyA9IHt9O1xuY2xvbmVhYmxlVGFnc1thcmdzVGFnXSA9IGNsb25lYWJsZVRhZ3NbYXJyYXlUYWddID1cbmNsb25lYWJsZVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gY2xvbmVhYmxlVGFnc1tkYXRhVmlld1RhZ10gPVxuY2xvbmVhYmxlVGFnc1tib29sVGFnXSA9IGNsb25lYWJsZVRhZ3NbZGF0ZVRhZ10gPVxuY2xvbmVhYmxlVGFnc1tmbG9hdDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbZmxvYXQ2NFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbaW50MTZUYWddID1cbmNsb25lYWJsZVRhZ3NbaW50MzJUYWddID0gY2xvbmVhYmxlVGFnc1ttYXBUYWddID1cbmNsb25lYWJsZVRhZ3NbbnVtYmVyVGFnXSA9IGNsb25lYWJsZVRhZ3Nbb2JqZWN0VGFnXSA9XG5jbG9uZWFibGVUYWdzW3JlZ2V4cFRhZ10gPSBjbG9uZWFibGVUYWdzW3NldFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tzdHJpbmdUYWddID0gY2xvbmVhYmxlVGFnc1tzeW1ib2xUYWddID1cbmNsb25lYWJsZVRhZ3NbdWludDhUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50OENsYW1wZWRUYWddID1cbmNsb25lYWJsZVRhZ3NbdWludDE2VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG5jbG9uZWFibGVUYWdzW2Vycm9yVGFnXSA9IGNsb25lYWJsZVRhZ3NbZnVuY1RhZ10gPVxuY2xvbmVhYmxlVGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNsb25lYCBhbmQgYF8uY2xvbmVEZWVwYCB3aGljaCB0cmFja3NcbiAqIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAqICAxIC0gRGVlcCBjbG9uZVxuICogIDIgLSBGbGF0dGVuIGluaGVyaXRlZCBwcm9wZXJ0aWVzXG4gKiAgNCAtIENsb25lIHN5bWJvbHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2tleV0gVGhlIGtleSBvZiBgdmFsdWVgLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBwYXJlbnQgb2JqZWN0IG9mIGB2YWx1ZWAuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIG9iamVjdHMgYW5kIHRoZWlyIGNsb25lIGNvdW50ZXJwYXJ0cy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VDbG9uZSh2YWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCBvYmplY3QsIHN0YWNrKSB7XG4gIHZhciByZXN1bHQsXG4gICAgICBpc0RlZXAgPSBiaXRtYXNrICYgQ0xPTkVfREVFUF9GTEFHLFxuICAgICAgaXNGbGF0ID0gYml0bWFzayAmIENMT05FX0ZMQVRfRkxBRyxcbiAgICAgIGlzRnVsbCA9IGJpdG1hc2sgJiBDTE9ORV9TWU1CT0xTX0ZMQUc7XG5cbiAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICByZXN1bHQgPSBvYmplY3QgPyBjdXN0b21pemVyKHZhbHVlLCBrZXksIG9iamVjdCwgc3RhY2spIDogY3VzdG9taXplcih2YWx1ZSk7XG4gIH1cbiAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKTtcbiAgaWYgKGlzQXJyKSB7XG4gICAgcmVzdWx0ID0gaW5pdENsb25lQXJyYXkodmFsdWUpO1xuICAgIGlmICghaXNEZWVwKSB7XG4gICAgICByZXR1cm4gY29weUFycmF5KHZhbHVlLCByZXN1bHQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKSxcbiAgICAgICAgaXNGdW5jID0gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcblxuICAgIGlmIChpc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjbG9uZUJ1ZmZlcih2YWx1ZSwgaXNEZWVwKTtcbiAgICB9XG4gICAgaWYgKHRhZyA9PSBvYmplY3RUYWcgfHwgdGFnID09IGFyZ3NUYWcgfHwgKGlzRnVuYyAmJiAhb2JqZWN0KSkge1xuICAgICAgcmVzdWx0ID0gKGlzRmxhdCB8fCBpc0Z1bmMpID8ge30gOiBpbml0Q2xvbmVPYmplY3QodmFsdWUpO1xuICAgICAgaWYgKCFpc0RlZXApIHtcbiAgICAgICAgcmV0dXJuIGlzRmxhdFxuICAgICAgICAgID8gY29weVN5bWJvbHNJbih2YWx1ZSwgYmFzZUFzc2lnbkluKHJlc3VsdCwgdmFsdWUpKVxuICAgICAgICAgIDogY29weVN5bWJvbHModmFsdWUsIGJhc2VBc3NpZ24ocmVzdWx0LCB2YWx1ZSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWNsb25lYWJsZVRhZ3NbdGFnXSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0ID8gdmFsdWUgOiB7fTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGluaXRDbG9uZUJ5VGFnKHZhbHVlLCB0YWcsIGlzRGVlcCk7XG4gICAgfVxuICB9XG4gIC8vIENoZWNrIGZvciBjaXJjdWxhciByZWZlcmVuY2VzIGFuZCByZXR1cm4gaXRzIGNvcnJlc3BvbmRpbmcgY2xvbmUuXG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KHZhbHVlKTtcbiAgaWYgKHN0YWNrZWQpIHtcbiAgICByZXR1cm4gc3RhY2tlZDtcbiAgfVxuICBzdGFjay5zZXQodmFsdWUsIHJlc3VsdCk7XG5cbiAgaWYgKGlzU2V0KHZhbHVlKSkge1xuICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24oc3ViVmFsdWUpIHtcbiAgICAgIHJlc3VsdC5hZGQoYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdWJWYWx1ZSwgdmFsdWUsIHN0YWNrKSk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoaXNNYXAodmFsdWUpKSB7XG4gICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbihzdWJWYWx1ZSwga2V5KSB7XG4gICAgICByZXN1bHQuc2V0KGtleSwgYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFjaykpO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIGtleXNGdW5jID0gaXNGdWxsXG4gICAgPyAoaXNGbGF0ID8gZ2V0QWxsS2V5c0luIDogZ2V0QWxsS2V5cylcbiAgICA6IChpc0ZsYXQgPyBrZXlzSW4gOiBrZXlzKTtcblxuICB2YXIgcHJvcHMgPSBpc0FyciA/IHVuZGVmaW5lZCA6IGtleXNGdW5jKHZhbHVlKTtcbiAgYXJyYXlFYWNoKHByb3BzIHx8IHZhbHVlLCBmdW5jdGlvbihzdWJWYWx1ZSwga2V5KSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICBrZXkgPSBzdWJWYWx1ZTtcbiAgICAgIHN1YlZhbHVlID0gdmFsdWVba2V5XTtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgcG9wdWxhdGUgY2xvbmUgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBhc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFjaykpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUNsb25lO1xuIiwiaW1wb3J0IGJhc2VDbG9uZSBmcm9tICcuL19iYXNlQ2xvbmUuanMnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xudmFyIENMT05FX0RFRVBfRkxBRyA9IDEsXG4gICAgQ0xPTkVfU1lNQk9MU19GTEFHID0gNDtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmNsb25lYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBjbG9uZXMgYHZhbHVlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDEuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmVjdXJzaXZlbHkgY2xvbmUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZGVlcCBjbG9uZWQgdmFsdWUuXG4gKiBAc2VlIF8uY2xvbmVcbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBbeyAnYSc6IDEgfSwgeyAnYic6IDIgfV07XG4gKlxuICogdmFyIGRlZXAgPSBfLmNsb25lRGVlcChvYmplY3RzKTtcbiAqIGNvbnNvbGUubG9nKGRlZXBbMF0gPT09IG9iamVjdHNbMF0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gY2xvbmVEZWVwKHZhbHVlKSB7XG4gIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIENMT05FX0RFRVBfRkxBRyB8IENMT05FX1NZTUJPTFNfRkxBRyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsb25lRGVlcDtcbiIsImZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH0gZWxzZSB7IHJldHVybiBBcnJheS5mcm9tKGFycik7IH0gfVxuXG4vLyBPbGRlciBicm93c2VycyBkb24ndCBzdXBwb3J0IGV2ZW50IG9wdGlvbnMsIGZlYXR1cmUgZGV0ZWN0IGl0LlxuXG4vLyBBZG9wdGVkIGFuZCBtb2RpZmllZCBzb2x1dGlvbiBmcm9tIEJvaGRhbiBEaWR1a2ggKDIwMTcpXG4vLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80MTU5NDk5Ny9pb3MtMTAtc2FmYXJpLXByZXZlbnQtc2Nyb2xsaW5nLWJlaGluZC1hLWZpeGVkLW92ZXJsYXktYW5kLW1haW50YWluLXNjcm9sbC1wb3NpXG5cbnZhciBoYXNQYXNzaXZlRXZlbnRzID0gZmFsc2U7XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgdmFyIHBhc3NpdmVUZXN0T3B0aW9ucyA9IHtcbiAgICBnZXQgcGFzc2l2ZSgpIHtcbiAgICAgIGhhc1Bhc3NpdmVFdmVudHMgPSB0cnVlO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH07XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0UGFzc2l2ZScsIG51bGwsIHBhc3NpdmVUZXN0T3B0aW9ucyk7XG4gIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0ZXN0UGFzc2l2ZScsIG51bGwsIHBhc3NpdmVUZXN0T3B0aW9ucyk7XG59XG5cbnZhciBpc0lvc0RldmljZSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5uYXZpZ2F0b3IgJiYgd2luZG93Lm5hdmlnYXRvci5wbGF0Zm9ybSAmJiAoL2lQKGFkfGhvbmV8b2QpLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IucGxhdGZvcm0pIHx8IHdpbmRvdy5uYXZpZ2F0b3IucGxhdGZvcm0gPT09ICdNYWNJbnRlbCcgJiYgd2luZG93Lm5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDEpO1xuXG5cbnZhciBsb2NrcyA9IFtdO1xudmFyIGRvY3VtZW50TGlzdGVuZXJBZGRlZCA9IGZhbHNlO1xudmFyIGluaXRpYWxDbGllbnRZID0gLTE7XG52YXIgcHJldmlvdXNCb2R5T3ZlcmZsb3dTZXR0aW5nID0gdm9pZCAwO1xudmFyIHByZXZpb3VzQm9keVBhZGRpbmdSaWdodCA9IHZvaWQgMDtcblxuLy8gcmV0dXJucyB0cnVlIGlmIGBlbGAgc2hvdWxkIGJlIGFsbG93ZWQgdG8gcmVjZWl2ZSB0b3VjaG1vdmUgZXZlbnRzLlxudmFyIGFsbG93VG91Y2hNb3ZlID0gZnVuY3Rpb24gYWxsb3dUb3VjaE1vdmUoZWwpIHtcbiAgcmV0dXJuIGxvY2tzLnNvbWUoZnVuY3Rpb24gKGxvY2spIHtcbiAgICBpZiAobG9jay5vcHRpb25zLmFsbG93VG91Y2hNb3ZlICYmIGxvY2sub3B0aW9ucy5hbGxvd1RvdWNoTW92ZShlbCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSk7XG59O1xuXG52YXIgcHJldmVudERlZmF1bHQgPSBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChyYXdFdmVudCkge1xuICB2YXIgZSA9IHJhd0V2ZW50IHx8IHdpbmRvdy5ldmVudDtcblxuICAvLyBGb3IgdGhlIGNhc2Ugd2hlcmVieSBjb25zdW1lcnMgYWRkcyBhIHRvdWNobW92ZSBldmVudCBsaXN0ZW5lciB0byBkb2N1bWVudC5cbiAgLy8gUmVjYWxsIHRoYXQgd2UgZG8gZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgcHJldmVudERlZmF1bHQsIHsgcGFzc2l2ZTogZmFsc2UgfSlcbiAgLy8gaW4gZGlzYWJsZUJvZHlTY3JvbGwgLSBzbyBpZiB3ZSBwcm92aWRlIHRoaXMgb3Bwb3J0dW5pdHkgdG8gYWxsb3dUb3VjaE1vdmUsIHRoZW5cbiAgLy8gdGhlIHRvdWNobW92ZSBldmVudCBvbiBkb2N1bWVudCB3aWxsIGJyZWFrLlxuICBpZiAoYWxsb3dUb3VjaE1vdmUoZS50YXJnZXQpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBEbyBub3QgcHJldmVudCBpZiB0aGUgZXZlbnQgaGFzIG1vcmUgdGhhbiBvbmUgdG91Y2ggKHVzdWFsbHkgbWVhbmluZyB0aGlzIGlzIGEgbXVsdGkgdG91Y2ggZ2VzdHVyZSBsaWtlIHBpbmNoIHRvIHpvb20pLlxuICBpZiAoZS50b3VjaGVzLmxlbmd0aCA+IDEpIHJldHVybiB0cnVlO1xuXG4gIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxudmFyIHNldE92ZXJmbG93SGlkZGVuID0gZnVuY3Rpb24gc2V0T3ZlcmZsb3dIaWRkZW4ob3B0aW9ucykge1xuICAvLyBTZXR0aW5nIG92ZXJmbG93IG9uIGJvZHkvZG9jdW1lbnRFbGVtZW50IHN5bmNocm9ub3VzbHkgaW4gRGVza3RvcCBTYWZhcmkgc2xvd3MgZG93blxuICAvLyB0aGUgcmVzcG9uc2l2ZW5lc3MgZm9yIHNvbWUgcmVhc29uLiBTZXR0aW5nIHdpdGhpbiBhIHNldFRpbWVvdXQgZml4ZXMgdGhpcy5cbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgLy8gSWYgcHJldmlvdXNCb2R5UGFkZGluZ1JpZ2h0IGlzIGFscmVhZHkgc2V0LCBkb24ndCBzZXQgaXQgYWdhaW4uXG4gICAgaWYgKHByZXZpb3VzQm9keVBhZGRpbmdSaWdodCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgX3Jlc2VydmVTY3JvbGxCYXJHYXAgPSAhIW9wdGlvbnMgJiYgb3B0aW9ucy5yZXNlcnZlU2Nyb2xsQmFyR2FwID09PSB0cnVlO1xuICAgICAgdmFyIHNjcm9sbEJhckdhcCA9IHdpbmRvdy5pbm5lcldpZHRoIC0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xuXG4gICAgICBpZiAoX3Jlc2VydmVTY3JvbGxCYXJHYXAgJiYgc2Nyb2xsQmFyR2FwID4gMCkge1xuICAgICAgICBwcmV2aW91c0JvZHlQYWRkaW5nUmlnaHQgPSBkb2N1bWVudC5ib2R5LnN0eWxlLnBhZGRpbmdSaWdodDtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5wYWRkaW5nUmlnaHQgPSBzY3JvbGxCYXJHYXAgKyAncHgnO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHByZXZpb3VzQm9keU92ZXJmbG93U2V0dGluZyBpcyBhbHJlYWR5IHNldCwgZG9uJ3Qgc2V0IGl0IGFnYWluLlxuICAgIGlmIChwcmV2aW91c0JvZHlPdmVyZmxvd1NldHRpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcHJldmlvdXNCb2R5T3ZlcmZsb3dTZXR0aW5nID0gZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdztcbiAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICB9XG4gIH0pO1xufTtcblxudmFyIHJlc3RvcmVPdmVyZmxvd1NldHRpbmcgPSBmdW5jdGlvbiByZXN0b3JlT3ZlcmZsb3dTZXR0aW5nKCkge1xuICAvLyBTZXR0aW5nIG92ZXJmbG93IG9uIGJvZHkvZG9jdW1lbnRFbGVtZW50IHN5bmNocm9ub3VzbHkgaW4gRGVza3RvcCBTYWZhcmkgc2xvd3MgZG93blxuICAvLyB0aGUgcmVzcG9uc2l2ZW5lc3MgZm9yIHNvbWUgcmVhc29uLiBTZXR0aW5nIHdpdGhpbiBhIHNldFRpbWVvdXQgZml4ZXMgdGhpcy5cbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHByZXZpb3VzQm9keVBhZGRpbmdSaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLnBhZGRpbmdSaWdodCA9IHByZXZpb3VzQm9keVBhZGRpbmdSaWdodDtcblxuICAgICAgLy8gUmVzdG9yZSBwcmV2aW91c0JvZHlQYWRkaW5nUmlnaHQgdG8gdW5kZWZpbmVkIHNvIHNldE92ZXJmbG93SGlkZGVuIGtub3dzIGl0XG4gICAgICAvLyBjYW4gYmUgc2V0IGFnYWluLlxuICAgICAgcHJldmlvdXNCb2R5UGFkZGluZ1JpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmIChwcmV2aW91c0JvZHlPdmVyZmxvd1NldHRpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdyA9IHByZXZpb3VzQm9keU92ZXJmbG93U2V0dGluZztcblxuICAgICAgLy8gUmVzdG9yZSBwcmV2aW91c0JvZHlPdmVyZmxvd1NldHRpbmcgdG8gdW5kZWZpbmVkXG4gICAgICAvLyBzbyBzZXRPdmVyZmxvd0hpZGRlbiBrbm93cyBpdCBjYW4gYmUgc2V0IGFnYWluLlxuICAgICAgcHJldmlvdXNCb2R5T3ZlcmZsb3dTZXR0aW5nID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudC9zY3JvbGxIZWlnaHQjUHJvYmxlbXNfYW5kX3NvbHV0aW9uc1xudmFyIGlzVGFyZ2V0RWxlbWVudFRvdGFsbHlTY3JvbGxlZCA9IGZ1bmN0aW9uIGlzVGFyZ2V0RWxlbWVudFRvdGFsbHlTY3JvbGxlZCh0YXJnZXRFbGVtZW50KSB7XG4gIHJldHVybiB0YXJnZXRFbGVtZW50ID8gdGFyZ2V0RWxlbWVudC5zY3JvbGxIZWlnaHQgLSB0YXJnZXRFbGVtZW50LnNjcm9sbFRvcCA8PSB0YXJnZXRFbGVtZW50LmNsaWVudEhlaWdodCA6IGZhbHNlO1xufTtcblxudmFyIGhhbmRsZVNjcm9sbCA9IGZ1bmN0aW9uIGhhbmRsZVNjcm9sbChldmVudCwgdGFyZ2V0RWxlbWVudCkge1xuICB2YXIgY2xpZW50WSA9IGV2ZW50LnRhcmdldFRvdWNoZXNbMF0uY2xpZW50WSAtIGluaXRpYWxDbGllbnRZO1xuXG4gIGlmIChhbGxvd1RvdWNoTW92ZShldmVudC50YXJnZXQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHRhcmdldEVsZW1lbnQgJiYgdGFyZ2V0RWxlbWVudC5zY3JvbGxUb3AgPT09IDAgJiYgY2xpZW50WSA+IDApIHtcbiAgICAvLyBlbGVtZW50IGlzIGF0IHRoZSB0b3Agb2YgaXRzIHNjcm9sbC5cbiAgICByZXR1cm4gcHJldmVudERlZmF1bHQoZXZlbnQpO1xuICB9XG5cbiAgaWYgKGlzVGFyZ2V0RWxlbWVudFRvdGFsbHlTY3JvbGxlZCh0YXJnZXRFbGVtZW50KSAmJiBjbGllbnRZIDwgMCkge1xuICAgIC8vIGVsZW1lbnQgaXMgYXQgdGhlIGJvdHRvbSBvZiBpdHMgc2Nyb2xsLlxuICAgIHJldHVybiBwcmV2ZW50RGVmYXVsdChldmVudCk7XG4gIH1cblxuICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5leHBvcnQgdmFyIGRpc2FibGVCb2R5U2Nyb2xsID0gZnVuY3Rpb24gZGlzYWJsZUJvZHlTY3JvbGwodGFyZ2V0RWxlbWVudCwgb3B0aW9ucykge1xuICBpZiAoaXNJb3NEZXZpY2UpIHtcbiAgICAvLyB0YXJnZXRFbGVtZW50IG11c3QgYmUgcHJvdmlkZWQsIGFuZCBkaXNhYmxlQm9keVNjcm9sbCBtdXN0IG5vdCBoYXZlIGJlZW5cbiAgICAvLyBjYWxsZWQgb24gdGhpcyB0YXJnZXRFbGVtZW50IGJlZm9yZS5cbiAgICBpZiAoIXRhcmdldEVsZW1lbnQpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLmVycm9yKCdkaXNhYmxlQm9keVNjcm9sbCB1bnN1Y2Nlc3NmdWwgLSB0YXJnZXRFbGVtZW50IG11c3QgYmUgcHJvdmlkZWQgd2hlbiBjYWxsaW5nIGRpc2FibGVCb2R5U2Nyb2xsIG9uIElPUyBkZXZpY2VzLicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0YXJnZXRFbGVtZW50ICYmICFsb2Nrcy5zb21lKGZ1bmN0aW9uIChsb2NrKSB7XG4gICAgICByZXR1cm4gbG9jay50YXJnZXRFbGVtZW50ID09PSB0YXJnZXRFbGVtZW50O1xuICAgIH0pKSB7XG4gICAgICB2YXIgbG9jayA9IHtcbiAgICAgICAgdGFyZ2V0RWxlbWVudDogdGFyZ2V0RWxlbWVudCxcbiAgICAgICAgb3B0aW9uczogb3B0aW9ucyB8fCB7fVxuICAgICAgfTtcblxuICAgICAgbG9ja3MgPSBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGxvY2tzKSwgW2xvY2tdKTtcblxuICAgICAgdGFyZ2V0RWxlbWVudC5vbnRvdWNoc3RhcnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LnRhcmdldFRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgLy8gZGV0ZWN0IHNpbmdsZSB0b3VjaC5cbiAgICAgICAgICBpbml0aWFsQ2xpZW50WSA9IGV2ZW50LnRhcmdldFRvdWNoZXNbMF0uY2xpZW50WTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHRhcmdldEVsZW1lbnQub250b3VjaG1vdmUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LnRhcmdldFRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgLy8gZGV0ZWN0IHNpbmdsZSB0b3VjaC5cbiAgICAgICAgICBoYW5kbGVTY3JvbGwoZXZlbnQsIHRhcmdldEVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBpZiAoIWRvY3VtZW50TGlzdGVuZXJBZGRlZCkge1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBwcmV2ZW50RGVmYXVsdCwgaGFzUGFzc2l2ZUV2ZW50cyA/IHsgcGFzc2l2ZTogZmFsc2UgfSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIGRvY3VtZW50TGlzdGVuZXJBZGRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNldE92ZXJmbG93SGlkZGVuKG9wdGlvbnMpO1xuICAgIHZhciBfbG9jayA9IHtcbiAgICAgIHRhcmdldEVsZW1lbnQ6IHRhcmdldEVsZW1lbnQsXG4gICAgICBvcHRpb25zOiBvcHRpb25zIHx8IHt9XG4gICAgfTtcblxuICAgIGxvY2tzID0gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShsb2NrcyksIFtfbG9ja10pO1xuICB9XG59O1xuXG5leHBvcnQgdmFyIGNsZWFyQWxsQm9keVNjcm9sbExvY2tzID0gZnVuY3Rpb24gY2xlYXJBbGxCb2R5U2Nyb2xsTG9ja3MoKSB7XG4gIGlmIChpc0lvc0RldmljZSkge1xuICAgIC8vIENsZWFyIGFsbCBsb2NrcyBvbnRvdWNoc3RhcnQvb250b3VjaG1vdmUgaGFuZGxlcnMsIGFuZCB0aGUgcmVmZXJlbmNlcy5cbiAgICBsb2Nrcy5mb3JFYWNoKGZ1bmN0aW9uIChsb2NrKSB7XG4gICAgICBsb2NrLnRhcmdldEVsZW1lbnQub250b3VjaHN0YXJ0ID0gbnVsbDtcbiAgICAgIGxvY2sudGFyZ2V0RWxlbWVudC5vbnRvdWNobW92ZSA9IG51bGw7XG4gICAgfSk7XG5cbiAgICBpZiAoZG9jdW1lbnRMaXN0ZW5lckFkZGVkKSB7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBwcmV2ZW50RGVmYXVsdCwgaGFzUGFzc2l2ZUV2ZW50cyA/IHsgcGFzc2l2ZTogZmFsc2UgfSA6IHVuZGVmaW5lZCk7XG4gICAgICBkb2N1bWVudExpc3RlbmVyQWRkZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBsb2NrcyA9IFtdO1xuXG4gICAgLy8gUmVzZXQgaW5pdGlhbCBjbGllbnRZLlxuICAgIGluaXRpYWxDbGllbnRZID0gLTE7XG4gIH0gZWxzZSB7XG4gICAgcmVzdG9yZU92ZXJmbG93U2V0dGluZygpO1xuICAgIGxvY2tzID0gW107XG4gIH1cbn07XG5cbmV4cG9ydCB2YXIgZW5hYmxlQm9keVNjcm9sbCA9IGZ1bmN0aW9uIGVuYWJsZUJvZHlTY3JvbGwodGFyZ2V0RWxlbWVudCkge1xuICBpZiAoaXNJb3NEZXZpY2UpIHtcbiAgICBpZiAoIXRhcmdldEVsZW1lbnQpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLmVycm9yKCdlbmFibGVCb2R5U2Nyb2xsIHVuc3VjY2Vzc2Z1bCAtIHRhcmdldEVsZW1lbnQgbXVzdCBiZSBwcm92aWRlZCB3aGVuIGNhbGxpbmcgZW5hYmxlQm9keVNjcm9sbCBvbiBJT1MgZGV2aWNlcy4nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0YXJnZXRFbGVtZW50Lm9udG91Y2hzdGFydCA9IG51bGw7XG4gICAgdGFyZ2V0RWxlbWVudC5vbnRvdWNobW92ZSA9IG51bGw7XG5cbiAgICBsb2NrcyA9IGxvY2tzLmZpbHRlcihmdW5jdGlvbiAobG9jaykge1xuICAgICAgcmV0dXJuIGxvY2sudGFyZ2V0RWxlbWVudCAhPT0gdGFyZ2V0RWxlbWVudDtcbiAgICB9KTtcblxuICAgIGlmIChkb2N1bWVudExpc3RlbmVyQWRkZWQgJiYgbG9ja3MubGVuZ3RoID09PSAwKSB7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBwcmV2ZW50RGVmYXVsdCwgaGFzUGFzc2l2ZUV2ZW50cyA/IHsgcGFzc2l2ZTogZmFsc2UgfSA6IHVuZGVmaW5lZCk7XG5cbiAgICAgIGRvY3VtZW50TGlzdGVuZXJBZGRlZCA9IGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsb2NrcyA9IGxvY2tzLmZpbHRlcihmdW5jdGlvbiAobG9jaykge1xuICAgICAgcmV0dXJuIGxvY2sudGFyZ2V0RWxlbWVudCAhPT0gdGFyZ2V0RWxlbWVudDtcbiAgICB9KTtcbiAgICBpZiAoIWxvY2tzLmxlbmd0aCkge1xuICAgICAgcmVzdG9yZU92ZXJmbG93U2V0dGluZygpO1xuICAgIH1cbiAgfVxufTtcblxuIiwiaW1wb3J0IHsgZGlzYWJsZUJvZHlTY3JvbGwsIGVuYWJsZUJvZHlTY3JvbGwgfSBmcm9tICdib2R5LXNjcm9sbC1sb2NrJztcblxuY29uc3QgRFVSQVRJT04gPSA1MDBcbmxldCBzY3JvbGxcbmxldCBzY3JvbGxDaGVja0ludGVydmFsXG5mdW5jdGlvbiBwcmV2ZW50SW5lcnRpYWxTY3JvbGwoZSkge1xuICAgIGlmIChlICYmIGUudG91Y2hlcy5sZW5ndGggIT09IDEpIHJldHVyblxuXG4gICAgZnVuY3Rpb24gc2Nyb2xsVG8odG9wKSB7XG4gICAgICAgIC8vIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgPSBzY3JvbGxcbiAgICAgICAgd2luZG93LnNjcm9sbFRvKHtcbiAgICAgICAgICAgIHRvcCxcbiAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICBiZWhhdmlvcjogJ3Ntb290aCdcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVjdXJzaXZlKCkge1xuICAgICAgICBpZiAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCAhPT0gc2Nyb2xsKSB7XG4gICAgICAgICAgICBzY3JvbGxUbyhzY3JvbGwpXG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmVjdXJzaXZlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdGltZSA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgICAgICAgICBmdW5jdGlvbiBzdG9wU2Nyb2xsKCkge1xuICAgICAgICAgICAgICAgIGlmIChwZXJmb3JtYW5jZS5ub3coKSAtIHRpbWUgPCBEVVJBVElPTikge1xuICAgICAgICAgICAgICAgICAgICBzY3JvbGxUbyhzY3JvbGwpXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShzdG9wU2Nyb2xsKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3BTY3JvbGwoKVxuICAgICAgICB9XG4gICAgfVxuICAgIHJlY3Vyc2l2ZSgpXG59XG5cbi8qKlxuICogXG4gKiBAYXR0ciBib2R5LXNjcm9sbC1sb2NrLWlnbm9yZSAtIHRvIGlnbm9yIGxvY2suXG4gKiBcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lclxuICogQHBhcmFtIHt7XG4gKiAgZXh0cmFMb2NrPzogYm9vbGVhbiAoZmFsc2UpXG4gKiB9fSBjb25maWdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpc2FibGVTY3JvbGwoY29udGFpbmVyLCBjb25maWcgPSB7fSkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoJ2JvZHktc2Nyb2xsLWxvY2snKVxuXG4gICAgICAgIGlmIChjb25maWcuZXh0cmFMb2NrKSB7XG4gICAgICAgICAgICBzY3JvbGwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wXG4gICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQub250b3VjaHN0YXJ0ID0gKCkgPT4gc2Nyb2xsID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcFxuICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm9udG91Y2htb3ZlID0gcHJldmVudEluZXJ0aWFsU2Nyb2xsXG4gICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQub250b3VjaGVuZCA9IHByZXZlbnRJbmVydGlhbFNjcm9sbFxuICAgICAgICAgICAgc2Nyb2xsQ2hlY2tJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCAhPT0gc2Nyb2xsKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZlbnRJbmVydGlhbFNjcm9sbCgpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgRFVSQVRJT04pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkaXNhYmxlQm9keVNjcm9sbChjb250YWluZXIsIHtcbiAgICAgICAgYWxsb3dUb3VjaE1vdmU6IGVsID0+IHtcbiAgICAgICAgICAgIHdoaWxlIChlbCAmJiBlbCAhPT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICAgICAgICAgIGlmIChlbC5nZXRBdHRyaWJ1dGUoJ2JvZHktc2Nyb2xsLWxvY2staWdub3JlJykgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsID0gZWwucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZW5hYmxlU2Nyb2xsKGNvbnRhaW5lciwgY29uZmlnID0ge30pIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKCdib2R5LXNjcm9sbC1sb2NrJylcblxuICAgICAgICBpZiAoY29uZmlnLmV4dHJhTG9jaykge1xuICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm9udG91Y2hzdGFydCA9IG51bGxcbiAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5vbnRvdWNobW92ZSA9IG51bGxcbiAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5vbnRvdWNoZW5kID0gbnVsbFxuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChzY3JvbGxDaGVja0ludGVydmFsKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZW5hYmxlQm9keVNjcm9sbChjb250YWluZXIpXG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXVpZHY0KCkge1xuICAgIHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgbGV0IHIgPSBNYXRoLnJhbmRvbSgpICogMTYgfCAwLCB2ID0gYyA9PSAneCcgPyByIDogKHIgJiAweDMgfCAweDgpO1xuICAgICAgICByZXR1cm4gdi50b1N0cmluZygxNik7XG4gICAgfSk7XG59IFxuIiwiZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gKG1zLCBpc0Vycm9yKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHNldFRpbWVvdXQoaXNFcnJvciA/IHJlaiA6IHJlcywgbXMpKVxufVxuIiwiLyoqXG4gKlxuICogQGZ1bmN0aW9uIHNhZmVHZXRcbiAqXG4gKiBAZGVzY3JpcHRpb24gU2FmZSBnZXR0aW5nIG9mIGFuIGFueSB2YWx1ZSBvZiBhIG5lc3RlZCBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSBleHByZXNzaW9uRm4ge2Z1bmN0aW9ufSAtIFRoZSBmdW5jdGlvbiB3aXRoIGFuIGV4cHJlc3Npb24gd2hpY2ggcmV0dXJucyByZXN1bHQgb2YgdGhlIHNhZmUgZ2V0dGluZy5cbiAqIEBwYXJhbSBkZWZhdWx0VmFsdWUge2FueX0gLSBUaGUgZGVmYXVsdCB2YWx1ZSB3aGVuIHJlc3VsdCBpcyB1bmRlZmluZWQuXG4gKiBAcGFyYW0gaXNEZWZhdWx0VHlwZWQge2Jvb2xlYW59IC0gV2hldGVyIGlzIHRoZSByZXN1bHQgZnJvbSBhbiBleHByZXNzaW9uIG11c3QgYmUgdGhlIHNhbWUgdHlwZSBhcyB0aGUgZGVmYXVsdCB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZXNcbiAqIC8vIFNvbWUgZGF0YS5cbiAqIGNvbnN0IHZlcnkgPSB7XG4gKiAgbmVzdGVkOiB7XG4gKiAgIG9iamVjdDogW3tcbiAqICAgICB3aXRoOiB7XG4gKiAgICAgICBhcnJheXM6ICdzdHVmZidcbiAqICAgICB9XG4gKiAgIH1dXG4gKiAgfVxuICogfVxuICpcbiAqIC8vIEdldHRpbmcuXG4gKiAxLiBzYWZlR2V0KCgpID0+IHZlcnkubmVzdGVkLm9iamVjdFswXS53aXRoLmFycmF5cyk7XG4gKiAyLiBzYWZlR2V0KCgpID0+IHZlcnkubmVzdGVkLm9iamVjdFswXS53aXRoLmFycmF5cywgeyBkZWZhdWx0OiAndmFsdWUnIH0pO1xuICogMy4gc2FmZUdldCgoKSA9PiB2ZXJ5Lm5lc3RlZC5vYmplY3RbMF0ud2l0aC5hcnJheXMsIHsgZGVmYXVsdDogJ3ZhbHVlJyB9LCB0cnVlKTtcbiAqXG4gKiAvLyBSZXR1cm4uXG4gKiAxLiAnc3R1ZmYnXG4gKiAyLiAnc3R1ZmYnXG4gKiAzLiB7IGRlZmF1bHQ6ICd2YWx1ZScgfVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzYWZlR2V0KGV4cHJlc3Npb25GbiwgZGVmYXVsdFZhbHVlLCBpc0RlZmF1bHRUeXBlZCA9IGZhbHNlKSB7XG4gIC8vIENoZWNrIHdoZXRoZXIgYSBhbmQgYiBoYXZlIHRoZSBzYW1lIHR5cGUuICh1dGlsKVxuICBmdW5jdGlvbiBpc1NhbWVUeXBlKGEsIGIpIHtcbiAgICBjb25zdCBydWxlcyA9IFtcbiAgICAgIChhLCBiKSA9PiB0eXBlb2YgYSA9PT0gdHlwZW9mIGIsXG4gICAgICAoYSwgYikgPT4gKCthID09PSBhKSA9PT0gKCtiID09PSBiKSwgICAgICAgICAgICAgIC8vIHdoZXRoZXIgb25lIGlzIE5hTlxuICAgICAgKGEsIGIpID0+IChhID09PSBudWxsKSA9PT0gKGIgPT09IG51bGwpLCAgICAgICAgICAvLyBudWxsIGlzIG9iamVjdCB0eXBlIHRvb1xuICAgICAgKGEsIGIpID0+IEFycmF5LmlzQXJyYXkoYSkgPT09IEFycmF5LmlzQXJyYXkoYiksICAvLyBhcnJheSBpcyBvYmplY3QgdHlwZSB0b29cbiAgICBdXG4gICAgcmV0dXJuICFydWxlcy5zb21lKHJ1bGVGbiA9PiAhcnVsZUZuKGEsIGIpKVxuICB9XG4gIC8vIENvcmUgb2Ygc2FmZSBnZXR0aW5nLiBFeGVjdXRpbmcgYSBmdW5jdGlvbi4gRGVmYXVsdCB2YWx1ZXMuXG4gIGZ1bmN0aW9uIGdldChleHByZXNzaW9uRm4sIGRlZmF1bHRWYWx1ZSwgaXNEZWZhdWx0VHlwZWQpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gZXhwcmVzc2lvbkZuLmNhbGwodGhpcylcbiAgICAgIGlmIChpc0RlZmF1bHRUeXBlZCkge1xuICAgICAgICByZXR1cm4gaXNTYW1lVHlwZShyZXN1bHQsIGRlZmF1bHRWYWx1ZSkgPyByZXN1bHQgOiBkZWZhdWx0VmFsdWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdFxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBkZWZhdWx0VmFsdWVcbiAgICB9XG4gIH1cbiAgLy8gU2FmZSBnZXR0aW5nIG9mIHRoZSBleHByZXNzaW9uRm4uXG4gIGlmICh0eXBlb2YgZXhwcmVzc2lvbkZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGdldChleHByZXNzaW9uRm4sIGRlZmF1bHRWYWx1ZSwgaXNEZWZhdWx0VHlwZWQpXG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS53YXJuKCdZb3UgbmVlZCB0byB1c2UgYSBmdW5jdGlvbiBhcyB0aGUgZmlyc3QgYXJndW1lbnQuJylcbiAgfVxuICByZXR1cm4gZGVmYXVsdFZhbHVlXG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB3YWl0VW50aWwoZm4sIHsgdGltZW91dCA9IDUwMDAsIGludGVydmFsID0gNTAwIH0gPSB7fSkge1xuICBsZXQgdGltZXIgPSBudWxsXG4gIGxldCBpbnRlcnZhbFRpbWVyID0gbnVsbFxuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlcywgcmVqKSB7XG4gICAgdGltZXIgPSBzZXRUaW1lb3V0KHJlaiwgdGltZW91dCwgbmV3IEVycm9yKCdFcnJvcjogVGltZW91dCcpKVxuICAgIGludGVydmFsVGltZXIgPSBzZXRJbnRlcnZhbChhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBmbigpXG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcilcbiAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbFRpbWVyKVxuICAgICAgICByZXMocmVzdWx0KVxuICAgICAgfSBjYXRjaCAoX2UpIHt9XG4gICAgfSwgaW50ZXJ2YWwpXG4gIH0pXG59XG4iLCIvKiFcbiAgQ29weXJpZ2h0IChjKSAyMDE3IEplZCBXYXRzb24uXG4gIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZSAoTUlUKSwgc2VlXG4gIGh0dHA6Ly9qZWR3YXRzb24uZ2l0aHViLmlvL2NsYXNzbmFtZXNcbiovXG4vKiBnbG9iYWwgZGVmaW5lICovXG5cbihmdW5jdGlvbiAoKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgaGFzT3duID0ge30uaGFzT3duUHJvcGVydHk7XG5cblx0ZnVuY3Rpb24gY2xhc3NOYW1lcyAoKSB7XG5cdFx0dmFyIGNsYXNzZXMgPSBbXTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgYXJnID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0aWYgKCFhcmcpIGNvbnRpbnVlO1xuXG5cdFx0XHR2YXIgYXJnVHlwZSA9IHR5cGVvZiBhcmc7XG5cblx0XHRcdGlmIChhcmdUeXBlID09PSAnc3RyaW5nJyB8fCBhcmdUeXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHRjbGFzc2VzLnB1c2goYXJnKTtcblx0XHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmcpICYmIGFyZy5sZW5ndGgpIHtcblx0XHRcdFx0dmFyIGlubmVyID0gY2xhc3NOYW1lcy5hcHBseShudWxsLCBhcmcpO1xuXHRcdFx0XHRpZiAoaW5uZXIpIHtcblx0XHRcdFx0XHRjbGFzc2VzLnB1c2goaW5uZXIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKGFyZ1R5cGUgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdGZvciAodmFyIGtleSBpbiBhcmcpIHtcblx0XHRcdFx0XHRpZiAoaGFzT3duLmNhbGwoYXJnLCBrZXkpICYmIGFyZ1trZXldKSB7XG5cdFx0XHRcdFx0XHRjbGFzc2VzLnB1c2goa2V5KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gY2xhc3Nlcy5qb2luKCcgJyk7XG5cdH1cblxuXHRpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcblx0XHRjbGFzc05hbWVzLmRlZmF1bHQgPSBjbGFzc05hbWVzO1xuXHRcdG1vZHVsZS5leHBvcnRzID0gY2xhc3NOYW1lcztcblx0fSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkZWZpbmUuYW1kID09PSAnb2JqZWN0JyAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gcmVnaXN0ZXIgYXMgJ2NsYXNzbmFtZXMnLCBjb25zaXN0ZW50IHdpdGggbnBtIHBhY2thZ2UgbmFtZVxuXHRcdGRlZmluZSgnY2xhc3NuYW1lcycsIFtdLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gY2xhc3NOYW1lcztcblx0XHR9KTtcblx0fSBlbHNlIHtcblx0XHR3aW5kb3cuY2xhc3NOYW1lcyA9IGNsYXNzTmFtZXM7XG5cdH1cbn0oKSk7XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0b0NTU1N0cmluZyhzdHlsZXMgPSB7fSkge1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMoc3R5bGVzKVxuICAgIC5maWx0ZXIoKFtfcHJvcE5hbWUsIHByb3BWYWx1ZV0pID0+IHByb3BWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BWYWx1ZSAhPT0gbnVsbClcbiAgICAucmVkdWNlKChzdHlsZVN0cmluZywgW3Byb3BOYW1lLCBwcm9wVmFsdWVdKSA9PiB7XG4gICAgICBwcm9wTmFtZSA9IHByb3BOYW1lLnJlcGxhY2UoL1tBLVpdL2csIG1hdGNoID0+IGAtJHttYXRjaC50b0xvd2VyQ2FzZSgpfWApXG4gICAgICByZXR1cm4gYCR7c3R5bGVTdHJpbmd9JHtwcm9wTmFtZX06JHtwcm9wVmFsdWV9O2BcbiAgICB9LCAnJylcbn0iLCJcblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRTY3JvbGxQZXJjZW50KGNvbnRhaW5lciwgY2hpbGQpIHtcbiAgICBjb25zdCBwID0gY29udGFpbmVyXG4gICAgY29uc3QgYyA9IGNoaWxkXG4gICAgY29uc3Qgc3QgPSAnc2Nyb2xsVG9wJ1xuICAgIGNvbnN0IHNsID0gJ3Njcm9sbExlZnQnXG4gICAgY29uc3Qgc2ggPSAnc2Nyb2xsSGVpZ2h0J1xuICAgIGNvbnN0IHN3ID0gJ3Njcm9sbFdpZHRoJ1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6ICAocFtzbF0gfHwgY1tzbF0pIC8gKCgocFtzd10gfHwgY1tzd10pIC0gcC5jbGllbnRXaWR0aCkgfHwgMSkgKiAxMDAsXG4gICAgICAgIHk6ICAocFtzdF0gfHwgY1tzdF0pIC8gKCgocFtzaF0gfHwgY1tzaF0pIC0gcC5jbGllbnRIZWlnaHQpIHx8IDEpICogMTAwLFxuICAgICAgICBwLFxuICAgICAgICBjLFxuICAgICAgICBzdCxcbiAgICAgICAgc2wsXG4gICAgICAgIHNoLFxuICAgICAgICBzdyxcbiAgICB9XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmb3JtYXRUZXh0VG9CdWxsZXRzKHRleHQpIHtcbiAgICBjb25zdCBsaW5lcyA9IHR5cGVvZiB0ZXh0ID09PSAnc3RyaW5nJyA/IHRleHQuc3BsaXQoL1tcXG5cXHJdL2dtKSA6IFtdXG4gICAgY29uc3QgcGxhaW5UZXh0TGluZXMgPSBsaW5lcy5tYXAobGluZSA9PiBsaW5lLnJlcGxhY2UoL14o4oCiXFxzKykvZywgJycpKVxuICAgIGNvbnN0IGZpbHRlcmVkTGluZXMgPSBwbGFpblRleHRMaW5lcy5maWx0ZXIobGluZSA9PiBsaW5lICE9PSAn4oCiJylcbiAgICBjb25zdCBmb3JtYXR0ZWRMaW5lcyA9IGZpbHRlcmVkTGluZXMubWFwKGxpbmUgPT4gYOKAoiAke2xpbmV9YClcbiAgICByZXR1cm4gZm9ybWF0dGVkTGluZXMuam9pbignXFxuJylcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRpc2FibGVEb3VibGVUYXBab29tKGVsZW1lbnRzKSB7XG4gICAgW10uY29uY2F0KGVsZW1lbnRzIHx8IFtdKS5mb3JFYWNoKChlbCkgPT4ge1xuICAgICAgICBsZXQgbGFzdFRvdWNoRW5kID0gMDtcblx0XHRlbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRjb25zdCBub3cgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuXHRcdFx0aWYgKG5vdyAtIGxhc3RUb3VjaEVuZCA8PSAzMDApIHtcblx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdH1cblx0XHRcdGxhc3RUb3VjaEVuZCA9IG5vdztcblx0XHR9LCBmYWxzZSk7XG4gICAgfSlcbn0iLCJcblxuXG5pbXBvcnQgZ2V0U2Nyb2xsUGVyY2VudCBmcm9tICcuL2dldFNjcm9sbFBlcmNlbnQnXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHN0b3BQcm9wYWdhdGlvbkluUmFuZ2VzKGVsLCByYW5nZXMgPSB7IHg6IFswLCAxMDBdLCB5OiBbMCwgMTAwXSB9LCBvbkNoYW5nZSkge1xuICAgIGVsLm9udG91Y2hzdGFydCA9IGNvbnRyb2xsU2Nyb2xsXG4gICAgZWwub250b3VjaG1vdmUgPSBjb250cm9sbFNjcm9sbFxuICAgIGVsLm9udG91Y2hlbmQgPSBjb250cm9sbFNjcm9sbFxuICAgIFxuICAgIGZ1bmN0aW9uIGNvbnRyb2xsU2Nyb2xsKGUpIHtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gZ2V0U2Nyb2xsUGVyY2VudChlbCwgZWwuY2hpbGRyZW5bMF0pXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHBhcmFtcy54ID49IHJhbmdlcy54WzBdICYmIHBhcmFtcy54IDw9IHJhbmdlcy54WzFdICYmXG4gICAgICAgICAgICBwYXJhbXMueSA+PSByYW5nZXMueVswXSAmJiBwYXJhbXMueSA8PSByYW5nZXMueVsxXVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9uQ2hhbmdlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gb25DaGFuZ2UoeyAuLi5wYXJhbXMsIGUgfSlcbiAgICAgICAgfVxuICAgIH1cbn0iLCJleHBvcnQgZGVmYXVsdCB7XG4gIEJBQ0tFTkRfVVJMOiAnbW9jaycsIC8vICcvQ2hhcml0aWZ5LycsIC8vIGNoYXJpdGlmeS1hcHBsaWNhdGlvbi5wYWdlLmxpbmsvP2xpbms9aHR0cHM6Ly9jaGFyaXRpZnktYXBwbGljYXRpb24uZmlyZWJhc2Vpby5jb20mYXBuPXBhY2thZ2VfbmFtZVxuXG4gIE1BUEJPWF9LRVk6ICdtYXBib3gnLFxufVxuIiwiPHNjcmlwdD5cbiAgZXhwb3J0IGxldCB0aXRsZSA9IG51bGw7XG4gIGV4cG9ydCBsZXQgdmlld0JveDtcbjwvc2NyaXB0PlxuXG48c3R5bGU+XG4gIHN2ZyB7XG4gICAgc3Ryb2tlOiBjdXJyZW50Q29sb3I7XG4gICAgZmlsbDogY3VycmVudENvbG9yO1xuICAgIHN0cm9rZS13aWR0aDogMDtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBoZWlnaHQ6IGF1dG87XG4gICAgbWF4LWhlaWdodDogMTAwJTtcbiAgfSAgXG48L3N0eWxlPlxuXG48c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB7dmlld0JveH0+XG4gIHsjaWYgdGl0bGV9XG4gICAgPHRpdGxlPnt0aXRsZX08L3RpdGxlPlxuICB7L2lmfVxuICA8c2xvdCAvPlxuPC9zdmc+XG4iLCI8c2NyaXB0PlxuICAgICAgICBpbXBvcnQgSWNvbkJhc2UgZnJvbSAnLi4vY29tcG9uZW50cy9JY29uQmFzZS5zdmVsdGUnO1xuICAgICAgICA8L3NjcmlwdD5cbiAgICAgICAgPEljb25CYXNlIHZpZXdCb3g9XCIwIDAgNTEyIDUxMlwiIHsuLi4kJHByb3BzfT5cbiAgICAgICAgICA8cGF0aCBkPVwiTTI1NiA4QzExOC45NDEgOCA4IDExOC45MTkgOCAyNTZjMCAxMzcuMDU5IDExMC45MTkgMjQ4IDI0OCAyNDggNDguMTU0IDAgOTUuMzQyLTE0LjE0IDEzNS40MDgtNDAuMjIzIDEyLjAwNS03LjgxNSAxNC42MjUtMjQuMjg4IDUuNTUyLTM1LjM3MmwtMTAuMTc3LTEyLjQzM2MtNy42NzEtOS4zNzEtMjEuMTc5LTExLjY2Ny0zMS4zNzMtNS4xMjlDMzI1LjkyIDQyOS43NTcgMjkxLjMxNCA0NDAgMjU2IDQ0MGMtMTAxLjQ1OCAwLTE4NC04Mi41NDItMTg0LTE4NFMxNTQuNTQyIDcyIDI1NiA3MmMxMDAuMTM5IDAgMTg0IDU3LjYxOSAxODQgMTYwIDAgMzguNzg2LTIxLjA5MyA3OS43NDItNTguMTcgODMuNjkzLTE3LjM0OS0uNDU0LTE2LjkxLTEyLjg1Ny0xMy40NzYtMzAuMDI0bDIzLjQzMy0xMjEuMTFDMzk0LjY1MyAxNDkuNzUgMzgzLjMwOCAxMzYgMzY4LjIyNSAxMzZoLTQ0Ljk4MWExMy41MTggMTMuNTE4IDAgMCAwLTEzLjQzMiAxMS45OTNsLS4wMS4wOTJjLTE0LjY5Ny0xNy45MDEtNDAuNDQ4LTIxLjc3NS01OS45NzEtMjEuNzc1LTc0LjU4IDAtMTM3LjgzMSA2Mi4yMzQtMTM3LjgzMSAxNTEuNDYgMCA2NS4zMDMgMzYuNzg1IDEwNS44NyA5NiAxMDUuODcgMjYuOTg0IDAgNTcuMzY5LTE1LjYzNyA3NC45OTEtMzguMzMzIDkuNTIyIDM0LjEwNCA0MC42MTMgMzQuMTAzIDcwLjcxIDM0LjEwM0M0NjIuNjA5IDM3OS40MSA1MDQgMzA3Ljc5OCA1MDQgMjMyIDUwNCA5NS42NTMgMzk0LjAyMyA4IDI1NiA4em0tMjEuNjggMzA0LjQzYy0yMi4yNDkgMC0zNi4wNy0xNS42MjMtMzYuMDctNDAuNzcxIDAtNDQuOTkzIDMwLjc3OS03Mi43MjkgNTguNjMtNzIuNzI5IDIyLjI5MiAwIDM1LjYwMSAxNS4yNDEgMzUuNjAxIDQwLjc3IDAgNDUuMDYxLTMzLjg3NSA3Mi43My01OC4xNjEgNzIuNzN6XCIgLz5cbiAgICAgICAgPC9JY29uQmFzZT5cbiAgICAgICIsIjxzY3JpcHQ+XG4gICAgICAgIGltcG9ydCBJY29uQmFzZSBmcm9tICcuLi9jb21wb25lbnRzL0ljb25CYXNlLnN2ZWx0ZSc7XG4gICAgICAgIDwvc2NyaXB0PlxuICAgICAgICA8SWNvbkJhc2Ugdmlld0JveD1cIjAgMCA1MTIgNTEyXCIgey4uLiQkcHJvcHN9PlxuICAgICAgICAgIDxwYXRoIGQ9XCJNMjgzLjIxMSA1MTJjNzguOTYyIDAgMTUxLjA3OS0zNS45MjUgMTk4Ljg1Ny05NC43OTIgNy4wNjgtOC43MDgtLjYzOS0yMS40My0xMS41NjItMTkuMzUtMTI0LjIwMyAyMy42NTQtMjM4LjI2Mi03MS41NzYtMjM4LjI2Mi0xOTYuOTU0IDAtNzIuMjIyIDM4LjY2Mi0xMzguNjM1IDEwMS40OTgtMTc0LjM5NCA5LjY4Ni01LjUxMiA3LjI1LTIwLjE5Ny0zLjc1Ni0yMi4yM0EyNTguMTU2IDI1OC4xNTYgMCAwIDAgMjgzLjIxMSAwYy0xNDEuMzA5IDAtMjU2IDExNC41MTEtMjU2IDI1NiAwIDE0MS4zMDkgMTE0LjUxMSAyNTYgMjU2IDI1NnpcIiAvPlxuICAgICAgICA8L0ljb25CYXNlPlxuICAgICAgIiwiPHNjcmlwdD5cbiAgICAgICAgaW1wb3J0IEljb25CYXNlIGZyb20gJy4uL2NvbXBvbmVudHMvSWNvbkJhc2Uuc3ZlbHRlJztcbiAgICAgICAgPC9zY3JpcHQ+XG4gICAgICAgIDxJY29uQmFzZSB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgey4uLiQkcHJvcHN9PlxuICAgICAgICAgIDxwYXRoIGQ9XCJNMy45IDEyYzAtMS43MSAxLjM5LTMuMSAzLjEtMy4xaDRWN0g3Yy0yLjc2IDAtNSAyLjI0LTUgNXMyLjI0IDUgNSA1aDR2LTEuOUg3Yy0xLjcxIDAtMy4xLTEuMzktMy4xLTMuMXpNOCAxM2g4di0ySDh2MnptOS02aC00djEuOWg0YzEuNzEgMCAzLjEgMS4zOSAzLjEgMy4xcy0xLjM5IDMuMS0zLjEgMy4xaC00VjE3aDRjMi43NiAwIDUtMi4yNCA1LTVzLTIuMjQtNS01LTV6XCIgLz5cbiAgICAgICAgPC9JY29uQmFzZT5cbiAgICAgICIsIjxzY3JpcHQ+XG4gICAgICAgIGltcG9ydCBJY29uQmFzZSBmcm9tICcuLi9jb21wb25lbnRzL0ljb25CYXNlLnN2ZWx0ZSc7XG4gICAgICAgIDwvc2NyaXB0PlxuICAgICAgICA8SWNvbkJhc2Ugdmlld0JveD1cIjAgMCA1MTIgNTEyXCIgey4uLiQkcHJvcHN9PlxuICAgICAgICAgIDxwYXRoIGQ9XCJNMjkyLjU2MyA2NS42NTZ2NDBoODUuMTU2bC04MS42NTggODIuNjU2LTEyLjkzNyAxMy4xMjVjLTkuMDU0LTYuNzY1LTE4LjkzNi0xMi40MTItMjkuNDA2LTE2Ljc1LTE2LjQ3OC02LjgyNS0zNC4yMy0xMC4zNDMtNTIuMDY0LTEwLjM0My0xNy44MzUgMC0zNS41NTMgMy41Mi01Mi4wMyAxMC4zNDQtMTYuNDggNi44MjQtMzEuNTE0IDE2Ljg1OC00NC4xMjYgMjkuNDY4LTEyLjYxMyAxMi42MTItMjIuNjQzIDI3LjY0Ny0yOS40NyA0NC4xMjUtNi44MjUgMTYuNDgtMTAuMzczIDM0LjIyOC0xMC4zNzQgNTIuMDY0IDAgMTcuODM2IDMuNTIgMzUuNTUzIDEwLjM0NCA1Mi4wMyA2LjgyNSAxNi40OCAxNi44ODggMzEuNTE0IDI5LjUgNDQuMTI2IDEyLjYxMiAxMi42MTIgMjcuNjQ3IDIyLjY0MyA0NC4xMjUgMjkuNDcgMTYuNDc4IDYuODI0IDM0LjE5NSAxMC4zNzQgNTIuMDMgMTAuMzc0IDE3LjgzNyAwIDM1LjU4Ni0zLjU1IDUyLjA2NC0xMC4zNzUgMTYuNDc3LTYuODI3IDMxLjUxMi0xNi44NTcgNDQuMTI0LTI5LjQ3IDEyLjYxLTEyLjYxMiAyMi42NDQtMjcuNjQ3IDI5LjQ3LTQ0LjEyNSA2LjgyMy0xNi40NzggMTAuMzQzLTM0LjE5NiAxMC4zNDItNTIuMDMgMC0xNy44MzYtMy41MTgtMzUuNTg3LTEwLjM0NC01Mi4wNjQtNC4xODMtMTAuMDk4LTkuNTgzLTE5LjY0Ni0xNi4wMy0yOC40MzZsMTMuMjE4LTEzLjQwNiA4MS44NDQtODIuODc1djg1Ljg3NWg0MFY2NS42NTZIMjkyLjU2MnptLTkwLjkwNyAxNDguNjg4YzEyLjUzMyAwIDI1LjE3IDIuNTE2IDM2Ljc1IDcuMzEyIDExLjU4IDQuNzk3IDIyLjI2MyAxMS45NSAzMS4xMjUgMjAuODEzIDguODYzIDguODYgMTYuMDE3IDE5LjU0NSAyMC44MTQgMzEuMTI0IDQuNzk2IDExLjU4IDcuMzEyIDI0LjIxNyA3LjMxMiAzNi43NSAwIDEyLjUzMy0yLjUxNyAyNS4xNC03LjMxMiAzNi43Mi00Ljc5NiAxMS41NzctMTEuOTIgMjIuMjkyLTIwLjc4IDMxLjE1NS04Ljg2NCA4Ljg2Mi0xOS41NzggMTYuMDE0LTMxLjE1OCAyMC44MS0xMS41OCA0Ljc5OC0yNC4yMTYgNy4zMTMtMzYuNzUgNy4zMTQtMTIuNTMzIDAtMjUuMTQtMi41MTYtMzYuNzItNy4zMTMtMTEuNTc4LTQuNzk1LTIyLjI5Mi0xMS45NS0zMS4xNTUtMjAuODEtOC44Ni04Ljg2NC0xNi4wMTUtMTkuNTc4LTIwLjgxLTMxLjE1OC00Ljc5OC0xMS41OC03LjMxNC0yNC4xODUtNy4zMTQtMzYuNzE4IDAtMTIuNTM0IDIuNTE2LTI1LjE3IDcuMzEzLTM2Ljc1bC4wOTMtLjIyYzQuNzk2LTExLjQ5NCAxMS45MS0yMi4xMyAyMC43MTgtMzAuOTM3IDguODA4LTguODA1IDE5LjQ0NC0xNS44OTIgMzAuOTQtMjAuNjg3bC4yMTgtLjA5NGMxMS41OC00Ljc5NSAyNC4xODUtNy4zMTMgMzYuNzE4LTcuMzEyelwiIC8+XG4gICAgICAgIDwvSWNvbkJhc2U+XG4gICAgICAiLCI8c2NyaXB0PlxuICAgICAgICBpbXBvcnQgSWNvbkJhc2UgZnJvbSAnLi4vY29tcG9uZW50cy9JY29uQmFzZS5zdmVsdGUnO1xuICAgICAgICA8L3NjcmlwdD5cbiAgICAgICAgPEljb25CYXNlIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiB7Li4uJCRwcm9wc30+XG4gICAgICAgICAgPHBhdGggZD1cIk0zIDE3LjI1VjIxaDMuNzVMMTcuODEgOS45NGwtMy43NS0zLjc1TDMgMTcuMjV6TTIwLjcxIDcuMDRjLjM5LS4zOS4zOS0xLjAyIDAtMS40MWwtMi4zNC0yLjM0Yy0uMzktLjM5LTEuMDItLjM5LTEuNDEgMGwtMS44MyAxLjgzIDMuNzUgMy43NSAxLjgzLTEuODN6XCIgLz5cbiAgICAgICAgPC9JY29uQmFzZT5cbiAgICAgICIsIjxzY3JpcHQ+XG4gICAgICAgIGltcG9ydCBJY29uQmFzZSBmcm9tICcuLi9jb21wb25lbnRzL0ljb25CYXNlLnN2ZWx0ZSc7XG4gICAgICAgIDwvc2NyaXB0PlxuICAgICAgICA8SWNvbkJhc2Ugdmlld0JveD1cIjAgMCA1MTIgNTEyXCIgey4uLiQkcHJvcHN9PlxuICAgICAgICAgIDxwYXRoIGQ9XCJNNDYyLjMgNjIuNkM0MDcuNSAxNS45IDMyNiAyNC4zIDI3NS43IDc2LjJMMjU2IDk2LjVsLTE5LjctMjAuM0MxODYuMSAyNC4zIDEwNC41IDE1LjkgNDkuNyA2Mi42Yy02Mi44IDUzLjYtNjYuMSAxNDkuOC05LjkgMjA3LjlsMTkzLjUgMTk5LjhjMTIuNSAxMi45IDMyLjggMTIuOSA0NS4zIDBsMTkzLjUtMTk5LjhjNTYuMy01OC4xIDUzLTE1NC4zLTkuOC0yMDcuOXpcIiAvPlxuICAgICAgICA8L0ljb25CYXNlPlxuICAgICAgIiwiPHNjcmlwdD5cbiAgICAgICAgaW1wb3J0IEljb25CYXNlIGZyb20gJy4uL2NvbXBvbmVudHMvSWNvbkJhc2Uuc3ZlbHRlJztcbiAgICAgICAgPC9zY3JpcHQ+XG4gICAgICAgIDxJY29uQmFzZSB2aWV3Qm94PVwiMCAwIDUxMiA1MTJcIiB7Li4uJCRwcm9wc30+XG4gICAgICAgICAgPHBhdGggZD1cIk00NDQgNDkuOUM0MzEuMyAzOC4yIDM3OS45LjkgMjY1LjMuNGMwIDAtMTM1LjEtOC4xLTIwMC45IDUyLjNDMjcuOCA4OS4zIDE0LjkgMTQzIDEzLjUgMjA5LjVjLTEuNCA2Ni41LTMuMSAxOTEuMSAxMTcgMjI0LjloLjFsLS4xIDUxLjZzLS44IDIwLjkgMTMgMjUuMWMxNi42IDUuMiAyNi40LTEwLjcgNDIuMy0yNy44IDguNy05LjQgMjAuNy0yMy4yIDI5LjgtMzMuNyA4Mi4yIDYuOSAxNDUuMy04LjkgMTUyLjUtMTEuMiAxNi42LTUuNCAxMTAuNS0xNy40IDEyNS43LTE0MiAxNS44LTEyOC42LTcuNi0yMDkuOC00OS44LTI0Ni41ek00NTcuOSAyODdjLTEyLjkgMTA0LTg5IDExMC42LTEwMyAxMTUuMS02IDEuOS02MS41IDE1LjctMTMxLjIgMTEuMiAwIDAtNTIgNjIuNy02OC4yIDc5LTUuMyA1LjMtMTEuMSA0LjgtMTEtNS43IDAtNi45LjQtODUuNy40LTg1LjctLjEgMC0uMSAwIDAgMC0xMDEuOC0yOC4yLTk1LjgtMTM0LjMtOTQuNy0xODkuOCAxLjEtNTUuNSAxMS42LTEwMSA0Mi42LTEzMS42IDU1LjctNTAuNSAxNzAuNC00MyAxNzAuNC00MyA5Ni45LjQgMTQzLjMgMjkuNiAxNTQuMSAzOS40IDM1LjcgMzAuNiA1My45IDEwMy44IDQwLjYgMjExLjF6bS0xMzktODAuOGMuNCA4LjYtMTIuNSA5LjItMTIuOS42LTEuMS0yMi0xMS40LTMyLjctMzIuNi0zMy45LTguNi0uNS03LjgtMTMuNC43LTEyLjkgMjcuOSAxLjUgNDMuNCAxNy41IDQ0LjggNDYuMnptMjAuMyAxMS4zYzEtNDIuNC0yNS41LTc1LjYtNzUuOC03OS4zLTguNS0uNi03LjYtMTMuNS45LTEyLjkgNTggNC4yIDg4LjkgNDQuMSA4Ny44IDkyLjUtLjEgOC42LTEzLjEgOC4yLTEyLjktLjN6bTQ3IDEzLjRjLjEgOC42LTEyLjkgOC43LTEyLjkuMS0uNi04MS41LTU0LjktMTI1LjktMTIwLjgtMTI2LjQtOC41LS4xLTguNS0xMi45IDAtMTIuOSA3My43LjUgMTMzIDUxLjQgMTMzLjcgMTM5LjJ6TTM3NC45IDMyOXYuMmMtMTAuOCAxOS0zMSA0MC01MS44IDMzLjNsLS4yLS4zYy0yMS4xLTUuOS03MC44LTMxLjUtMTAyLjItNTYuNS0xNi4yLTEyLjgtMzEtMjcuOS00Mi40LTQyLjQtMTAuMy0xMi45LTIwLjctMjguMi0zMC44LTQ2LjYtMjEuMy0zOC41LTI2LTU1LjctMjYtNTUuNy02LjctMjAuOCAxNC4yLTQxIDMzLjMtNTEuOGguMmM5LjItNC44IDE4LTMuMiAyMy45IDMuOSAwIDAgMTIuNCAxNC44IDE3LjcgMjIuMSA1IDYuOCAxMS43IDE3LjcgMTUuMiAyMy44IDYuMSAxMC45IDIuMyAyMi0zLjcgMjYuNmwtMTIgOS42Yy02LjEgNC45LTUuMyAxNC01LjMgMTRzMTcuOCA2Ny4zIDg0LjMgODQuM2MwIDAgOS4xLjggMTQtNS4zbDkuNi0xMmM0LjYtNiAxNS43LTkuOCAyNi42LTMuNyAxNC43IDguMyAzMy40IDIxLjIgNDUuOCAzMi45IDcgNS43IDguNiAxNC40IDMuOCAyMy42elwiIC8+XG4gICAgICAgIDwvSWNvbkJhc2U+XG4gICAgICAiLCI8c2NyaXB0PlxuICAgICAgICBpbXBvcnQgSWNvbkJhc2UgZnJvbSAnLi4vY29tcG9uZW50cy9JY29uQmFzZS5zdmVsdGUnO1xuICAgICAgICA8L3NjcmlwdD5cbiAgICAgICAgPEljb25CYXNlIHZpZXdCb3g9XCIwIDAgNTEyIDUxMlwiIHsuLi4kJHByb3BzfT5cbiAgICAgICAgICA8cGF0aCBkPVwiTTUwMy42OTEgMTg5LjgzNkwzMjcuNjg3IDM3Ljg1MUMzMTIuMjgxIDI0LjU0NiAyODggMzUuMzQ3IDI4OCA1Ni4wMTV2ODAuMDUzQzEyNy4zNzEgMTM3LjkwNyAwIDE3MC4xIDAgMzIyLjMyNmMwIDYxLjQ0MSAzOS41ODEgMTIyLjMwOSA4My4zMzMgMTU0LjEzMiAxMy42NTMgOS45MzEgMzMuMTExLTIuNTMzIDI4LjA3Ny0xOC42MzFDNjYuMDY2IDMxMi44MTQgMTMyLjkxNyAyNzQuMzE2IDI4OCAyNzIuMDg1VjM2MGMwIDIwLjcgMjQuMyAzMS40NTMgMzkuNjg3IDE4LjE2NGwxNzYuMDA0LTE1MmMxMS4wNzEtOS41NjIgMTEuMDg2LTI2Ljc1MyAwLTM2LjMyOHpcIiAvPlxuICAgICAgICA8L0ljb25CYXNlPlxuICAgICAgIiwiPHNjcmlwdD5cbiAgICAgICAgaW1wb3J0IEljb25CYXNlIGZyb20gJy4uL2NvbXBvbmVudHMvSWNvbkJhc2Uuc3ZlbHRlJztcbiAgICAgICAgPC9zY3JpcHQ+XG4gICAgICAgIDxJY29uQmFzZSB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgey4uLiQkcHJvcHN9PlxuICAgICAgICAgIDxwYXRoIGQ9XCJNOSAxNi4xN0w0LjgzIDEybC0xLjQyIDEuNDFMOSAxOSAyMSA3bC0xLjQxLTEuNDF6XCIgLz5cbiAgICAgICAgPC9JY29uQmFzZT5cbiAgICAgICIsIjxzY3JpcHQ+XG4gICAgICAgIGltcG9ydCBJY29uQmFzZSBmcm9tICcuLi9jb21wb25lbnRzL0ljb25CYXNlLnN2ZWx0ZSc7XG4gICAgICAgIDwvc2NyaXB0PlxuICAgICAgICA8SWNvbkJhc2Ugdmlld0JveD1cIjAgMCA1MTIgNTEyXCIgey4uLiQkcHJvcHN9PlxuICAgICAgICAgIDxwYXRoIGQ9XCJNMjU2IDI1LjQzOGMtMTcuODQgMC0zNS41ODIgMy41NDctNTIuMDYzIDEwLjM3NS0xNi40OCA2LjgyNy0zMS41MTIgMTYuODUzLTQ0LjEyNSAyOS40NjgtMTIuNjEyIDEyLjYxNy0yMi42NDUgMjcuNjc1LTI5LjQ2OCA0NC4xNTdDMTIzLjUyIDEyNS45MiAxMTkuOTk0IDE0My42NiAxMjAgMTYxLjVjLjAwNSAxNy44MzIgMy41NDcgMzUuNTU4IDEwLjM3NSA1Mi4wMyA2LjgyOCAxNi40NzQgMTYuODU4IDMxLjQ4OCAyOS40NyA0NC4wOTUgMTIuNjEgMTIuNjA3IDI3LjY1IDIyLjY0NiA0NC4xMjQgMjkuNDdsLjIxOC4wOTJjMTAuMDMyIDQuMTM1IDIwLjUyIDcuMDIgMzEuMjE4IDguNjU3bC4xMjUgMTguOTA2LjMxNCA0OS4xODhIMTY1Ljk3djQwaDcwLjEyNGwuMzc1IDYyLjg3NS4xMjQgMjAgNDAtLjI1LS4xMjUtMjAtLjM3Ni02Mi42MjVoNjkuOTM3di00MGgtNzAuMTg2bC0uMzEzLTQ5LjQzOC0uMTI0LTE4LjQ3YzExLjE4OC0xLjYxIDIyLjE1NC00LjYgMzIuNjI1LTguOTM2IDE2LjQ3Ni02LjgyMyAzMS41MTUtMTYuODYyIDQ0LjEyNi0yOS40NyAxMi42MS0xMi42MDYgMjIuNjQtMjcuNjIgMjkuNDctNDQuMDkzIDYuODI3LTE2LjQ3MiAxMC4zNy0zNC4xOTggMTAuMzc0LTUyLjAzLjAwNS0xNy44NC0zLjUyLTM1LjU4LTEwLjM0NC01Mi4wNjMtNi44MjMtMTYuNDgyLTE2Ljg1Ni0zMS41NC0yOS40Ny00NC4xNTYtMTIuNjEtMTIuNjE0LTI3LjY0My0yMi42NC00NC4xMjMtMjkuNDY4LTE2LjQ4LTYuODI3LTM0LjIyNC0xMC4zNzQtNTIuMDYzLTEwLjM3NHptMCA0MGMxMi41MzYgMCAyNS4xNyAyLjUxNCAzNi43NSA3LjMxMiAxMS41OCA0Ljc5OCAyMi4yOTQgMTEuOTQ3IDMxLjE1NiAyMC44MTMgOC44NjMgOC44NjUgMTUuOTg3IDE5LjU3MyAyMC43OCAzMS4xNTYgNC43OTYgMTEuNTggNy4zMTggMjQuMjEzIDcuMzE0IDM2Ljc1LS4wMDQgMTIuNTMtMi41MTUgMjUuMTczLTcuMzEzIDM2Ljc1LTQuNzk3IDExLjU3NS0xMS45NSAyMi4yNjQtMjAuODEyIDMxLjEyNC04Ljg2MiA4Ljg2LTE5LjU4IDE2LjAxOC0zMS4xNTYgMjAuODEyLTExLjU4IDQuNzk1LTI0LjE5IDcuMjgtMzYuNzIgNy4yOC0xMi41My4wMDItMjUuMTQtMi40ODUtMzYuNzItNy4yOC0xMS41NzYtNC43OTQtMjIuMjkzLTExLjk1My0zMS4xNTUtMjAuODEyLTguODYyLTguODYtMTYuMDE1LTE5LjU1LTIwLjgxMy0zMS4xMjUtNC43OTctMTEuNTc3LTcuMzA4LTI0LjIyLTcuMzEyLTM2Ljc1LS4wMDQtMTIuNTM3IDIuNTE4LTI1LjE3IDcuMzEzLTM2Ljc1IDQuNzk0LTExLjU4NCAxMS45MTgtMjIuMjkyIDIwLjc4LTMxLjE1NyA4Ljg2My04Ljg2NiAxOS41NzYtMTYuMDE1IDMxLjE1Ny0yMC44MTMgMTEuNTgtNC43OTggMjQuMjE0LTcuMzEzIDM2Ljc1LTcuMzEzelwiIC8+XG4gICAgICAgIDwvSWNvbkJhc2U+XG4gICAgICAiLCI8c2NyaXB0PlxuICAgICAgICBpbXBvcnQgSWNvbkJhc2UgZnJvbSAnLi4vY29tcG9uZW50cy9JY29uQmFzZS5zdmVsdGUnO1xuICAgICAgICA8L3NjcmlwdD5cbiAgICAgICAgPEljb25CYXNlIHZpZXdCb3g9XCIwIDAgNTEyIDUxMlwiIHsuLi4kJHByb3BzfT5cbiAgICAgICAgICA8cGF0aCBkPVwiTTQ4IDQ0OGw0MTYtMTkyTDQ4IDY0djE0OS4zMzNMMzQ2IDI1NiA0OCAyOTguNjY3elwiIC8+XG4gICAgICAgIDwvSWNvbkJhc2U+XG4gICAgICAiLCI8c2NyaXB0PlxuICAgICAgICBpbXBvcnQgSWNvbkJhc2UgZnJvbSAnLi4vY29tcG9uZW50cy9JY29uQmFzZS5zdmVsdGUnO1xuICAgICAgICA8L3NjcmlwdD5cbiAgICAgICAgPEljb25CYXNlIHZpZXdCb3g9XCIwIDAgMTYgMTZcIiB7Li4uJCRwcm9wc30+XG4gICAgICAgICAgPHBhdGggZD1cIk0xNS43IDEzLjNsLTMuODEtMy44M0E1LjkzIDUuOTMgMCAwIDAgMTMgNmMwLTMuMzEtMi42OS02LTYtNlMxIDIuNjkgMSA2czIuNjkgNiA2IDZjMS4zIDAgMi40OC0uNDEgMy40Ny0xLjExbDMuODMgMy44MWMuMTkuMi40NS4zLjcuMy4yNSAwIC41Mi0uMDkuNy0uM2EuOTk2Ljk5NiAwIDAgMCAwLTEuNDF2LjAxek03IDEwLjdjLTIuNTkgMC00LjctMi4xMS00LjctNC43IDAtMi41OSAyLjExLTQuNyA0LjctNC43IDIuNTkgMCA0LjcgMi4xMSA0LjcgNC43IDAgMi41OS0yLjExIDQuNy00LjcgNC43elwiIC8+XG4gICAgICAgIDwvSWNvbkJhc2U+XG4gICAgICAiLCI8c2NyaXB0PlxuICAgICAgICBpbXBvcnQgSWNvbkJhc2UgZnJvbSAnLi4vY29tcG9uZW50cy9JY29uQmFzZS5zdmVsdGUnO1xuICAgICAgICA8L3NjcmlwdD5cbiAgICAgICAgPEljb25CYXNlIHZpZXdCb3g9XCIwIDAgNTEyIDUxMlwiIHsuLi4kJHByb3BzfT5cbiAgICAgICAgICA8cGF0aCBkPVwiTTQwNSAxMzYuNzk4TDM3NS4yMDIgMTA3IDI1NiAyMjYuMjAyIDEzNi43OTggMTA3IDEwNyAxMzYuNzk4IDIyNi4yMDIgMjU2IDEwNyAzNzUuMjAyIDEzNi43OTggNDA1IDI1NiAyODUuNzk4IDM3NS4yMDIgNDA1IDQwNSAzNzUuMjAyIDI4NS43OTggMjU2elwiIC8+XG4gICAgICAgIDwvSWNvbkJhc2U+XG4gICAgICAiLCI8c2NyaXB0PlxuICAgICAgICBpbXBvcnQgSWNvbkJhc2UgZnJvbSAnLi4vY29tcG9uZW50cy9JY29uQmFzZS5zdmVsdGUnO1xuICAgICAgICA8L3NjcmlwdD5cbiAgICAgICAgPEljb25CYXNlIHZpZXdCb3g9XCIwIDAgNTEyIDUxMlwiIHsuLi4kJHByb3BzfT5cbiAgICAgICAgICA8cGF0aCBkPVwiTTQ5Ny4zOSAzNjEuOGwtMTEyLTQ4YTI0IDI0IDAgMCAwLTI4IDYuOWwtNDkuNiA2MC42QTM3MC42NiAzNzAuNjYgMCAwIDEgMTMwLjYgMjA0LjExbDYwLjYtNDkuNmEyMy45NCAyMy45NCAwIDAgMCA2LjktMjhsLTQ4LTExMkEyNC4xNiAyNC4xNiAwIDAgMCAxMjIuNi42MWwtMTA0IDI0QTI0IDI0IDAgMCAwIDAgNDhjMCAyNTYuNSAyMDcuOSA0NjQgNDY0IDQ2NGEyNCAyNCAwIDAgMCAyMy40LTE4LjZsMjQtMTA0YTI0LjI5IDI0LjI5IDAgMCAwLTE0LjAxLTI3LjZ6XCIgLz5cbiAgICAgICAgPC9JY29uQmFzZT5cbiAgICAgICIsIjxzY3JpcHQ+XG4gICAgICAgIGltcG9ydCBJY29uQmFzZSBmcm9tICcuLi9jb21wb25lbnRzL0ljb25CYXNlLnN2ZWx0ZSc7XG4gICAgICAgIDwvc2NyaXB0PlxuICAgICAgICA8SWNvbkJhc2Ugdmlld0JveD1cIjAgMCAzMjAgNTEyXCIgey4uLiQkcHJvcHN9PlxuICAgICAgICAgIDxwYXRoIGQ9XCJNMjc5LjE0IDI4OGwxNC4yMi05Mi42NmgtODguOTF2LTYwLjEzYzAtMjUuMzUgMTIuNDItNTAuMDYgNTIuMjQtNTAuMDZoNDAuNDJWNi4yNlMyNjAuNDMgMCAyMjUuMzYgMGMtNzMuMjIgMC0xMjEuMDggNDQuMzgtMTIxLjA4IDEyNC43MnY3MC42MkgyMi44OVYyODhoODEuMzl2MjI0aDEwMC4xN1YyODh6XCIgLz5cbiAgICAgICAgPC9JY29uQmFzZT5cbiAgICAgICIsIjxzY3JpcHQ+XG4gICAgICAgIGltcG9ydCBJY29uQmFzZSBmcm9tICcuLi9jb21wb25lbnRzL0ljb25CYXNlLnN2ZWx0ZSc7XG4gICAgICAgIDwvc2NyaXB0PlxuICAgICAgICA8SWNvbkJhc2Ugdmlld0JveD1cIjAgMCA0NDggNTEyXCIgey4uLiQkcHJvcHN9PlxuICAgICAgICAgIDxwYXRoIGQ9XCJNNDAwIDMySDQ4QzIxLjUgMzIgMCA1My41IDAgODB2MzUyYzAgMjYuNSAyMS41IDQ4IDQ4IDQ4aDM1MmMyNi41IDAgNDgtMjEuNSA0OC00OFY4MGMwLTI2LjUtMjEuNS00OC00OC00OHptLTYgNDAwSDU0Yy0zLjMgMC02LTIuNy02LTZWODZjMC0zLjMgMi43LTYgNi02aDM0MGMzLjMgMCA2IDIuNyA2IDZ2MzQwYzAgMy4zLTIuNyA2LTYgNnpcIiAvPlxuICAgICAgICA8L0ljb25CYXNlPlxuICAgICAgIiwiPHNjcmlwdD5cbiAgICAgICAgaW1wb3J0IEljb25CYXNlIGZyb20gJy4uL2NvbXBvbmVudHMvSWNvbkJhc2Uuc3ZlbHRlJztcbiAgICAgICAgPC9zY3JpcHQ+XG4gICAgICAgIDxJY29uQmFzZSB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgey4uLiQkcHJvcHN9PlxuICAgICAgICAgIDxwYXRoIGQ9XCJNMTkuMDY0IDEwLjEwOWwxLjE3OS0yLjM4N2MuMDc0LS4xNDkuMDY4LS4zMjctLjAxNS0uNDcxLS4wODMtLjE0NS0uMjM0LS4yMzgtLjQwMS0uMjQ5bC0yLjY1Ni0uMTcyLS4xNzItMi42NTZjLS4wMTEtLjE2Ny0uMTA0LS4zMTctLjI0OS0uNDAxLS4xNDUtLjA4NC0uMzIyLS4wOS0uNDcyLS4wMTVsLTIuMzg1IDEuMTgtMS40NzctMi4yMTVjLS4xODYtLjI3OC0uNjQ2LS4yNzgtLjgzMiAwbC0xLjQ3NyAyLjIxNS0yLjM4NS0xLjE4Yy0uMTUxLS4wNzUtLjMyNy0uMDY5LS40NzIuMDE1LS4xNDUuMDgzLS4yMzguMjM0LS4yNDkuNDAxbC0uMTcxIDIuNjU2LTIuNjU3LjE3MWMtLjE2Ny4wMTEtLjMxOC4xMDQtLjQwMS4yNDktLjA4NC4xNDUtLjA4OS4zMjItLjAxNS40NzJsMS4xNzkgMi4zODYtMi4yMTQgMS40NzdjLS4xMzkuMDkzLS4yMjMuMjQ5LS4yMjMuNDE2cy4wODMuMzIzLjIyMy40MTZsMi4yMTUgMS40NzctMS4xOCAyLjM4NmMtLjA3NC4xNS0uMDY4LjMyNy4wMTUuNDcyLjA4My4xNDQuMjM0LjIzOC40MDEuMjQ4bDIuNjU2LjE3MS4xNzEgMi42NTdjLjAxMS4xNjcuMTA0LjMxNy4yNDkuNDAxLjE0NC4wODMuMzIuMDg4LjQ3Mi4wMTVsMi4zODYtMS4xNzkgMS40NzcgMi4yMTRjLjA5My4xMzkuMjQ5LjIyMy40MTYuMjIzcy4zMjMtLjA4My40MTYtLjIyM2wxLjQ3Ny0yLjIxNCAyLjM4NiAxLjE3OWMuMTUuMDczLjMyNy4wNjguNDcyLS4wMTVzLjIzOC0uMjM0LjI0OS0uNDAxbC4xNzEtMi42NTYgMi42NTYtLjE3MmMuMTY3LS4wMTEuMzE3LS4xMDQuNDAxLS4yNDkuMDgzLS4xNDUuMDg5LS4zMjIuMDE1LS40NzJsLTEuMTc5LTIuMzg1IDIuMjE0LTEuNDc4Yy4xMzktLjA5My4yMjMtLjI0OS4yMjMtLjQxNnMtLjA4My0uMzIzLS4yMjMtLjQxNmwtMi4yMTQtMS40NzV6XCIgLz5cbiAgICAgICAgPC9JY29uQmFzZT5cbiAgICAgICIsIjxzY3JpcHQ+XG4gICAgICAgIGltcG9ydCBJY29uQmFzZSBmcm9tICcuLi9jb21wb25lbnRzL0ljb25CYXNlLnN2ZWx0ZSc7XG4gICAgICAgIDwvc2NyaXB0PlxuICAgICAgICA8SWNvbkJhc2Ugdmlld0JveD1cIjAgMCAyODggNTEyXCIgey4uLiQkcHJvcHN9PlxuICAgICAgICAgIDxwYXRoIGQ9XCJNMjA5LjIgMjMzLjRsLTEwOC0zMS42Qzg4LjcgMTk4LjIgODAgMTg2LjUgODAgMTczLjVjMC0xNi4zIDEzLjItMjkuNSAyOS41LTI5LjVoNjYuM2MxMi4yIDAgMjQuMiAzLjcgMzQuMiAxMC41IDYuMSA0LjEgMTQuMyAzLjEgMTkuNS0ybDM0LjgtMzRjNy4xLTYuOSA2LjEtMTguNC0xLjgtMjQuNUMyMzggNzQuOCAyMDcuNCA2NC4xIDE3NiA2NFYxNmMwLTguOC03LjItMTYtMTYtMTZoLTMyYy04LjggMC0xNiA3LjItMTYgMTZ2NDhoLTIuNUM0NS44IDY0LTUuNCAxMTguNy41IDE4My42YzQuMiA0Ni4xIDM5LjQgODMuNiA4My44IDk2LjZsMTAyLjUgMzBjMTIuNSAzLjcgMjEuMiAxNS4zIDIxLjIgMjguMyAwIDE2LjMtMTMuMiAyOS41LTI5LjUgMjkuNWgtNjYuM0MxMDAgMzY4IDg4IDM2NC4zIDc4IDM1Ny41Yy02LjEtNC4xLTE0LjMtMy4xLTE5LjUgMmwtMzQuOCAzNGMtNy4xIDYuOS02LjEgMTguNCAxLjggMjQuNSAyNC41IDE5LjIgNTUuMSAyOS45IDg2LjUgMzB2NDhjMCA4LjggNy4yIDE2IDE2IDE2aDMyYzguOCAwIDE2LTcuMiAxNi0xNnYtNDguMmM0Ni42LS45IDkwLjMtMjguNiAxMDUuNy03Mi43IDIxLjUtNjEuNi0xNC42LTEyNC44LTcyLjUtMTQxLjd6XCIgLz5cbiAgICAgICAgPC9JY29uQmFzZT5cbiAgICAgICIsIjxzY3JpcHQ+XG4gICAgICAgIGltcG9ydCBJY29uQmFzZSBmcm9tICcuLi9jb21wb25lbnRzL0ljb25CYXNlLnN2ZWx0ZSc7XG4gICAgICAgIDwvc2NyaXB0PlxuICAgICAgICA8SWNvbkJhc2Ugdmlld0JveD1cIjAgMCA0NDggNTEyXCIgey4uLiQkcHJvcHN9PlxuICAgICAgICAgIDxwYXRoIGQ9XCJNMCA0NjRjMCAyNi41IDIxLjUgNDggNDggNDhoMzUyYzI2LjUgMCA0OC0yMS41IDQ4LTQ4VjE5MkgwdjI3MnptMzIwLTE5NmMwLTYuNiA1LjQtMTIgMTItMTJoNDBjNi42IDAgMTIgNS40IDEyIDEydjQwYzAgNi42LTUuNCAxMi0xMiAxMmgtNDBjLTYuNiAwLTEyLTUuNC0xMi0xMnYtNDB6bTAgMTI4YzAtNi42IDUuNC0xMiAxMi0xMmg0MGM2LjYgMCAxMiA1LjQgMTIgMTJ2NDBjMCA2LjYtNS40IDEyLTEyIDEyaC00MGMtNi42IDAtMTItNS40LTEyLTEydi00MHpNMTkyIDI2OGMwLTYuNiA1LjQtMTIgMTItMTJoNDBjNi42IDAgMTIgNS40IDEyIDEydjQwYzAgNi42LTUuNCAxMi0xMiAxMmgtNDBjLTYuNiAwLTEyLTUuNC0xMi0xMnYtNDB6bTAgMTI4YzAtNi42IDUuNC0xMiAxMi0xMmg0MGM2LjYgMCAxMiA1LjQgMTIgMTJ2NDBjMCA2LjYtNS40IDEyLTEyIDEyaC00MGMtNi42IDAtMTItNS40LTEyLTEydi00MHpNNjQgMjY4YzAtNi42IDUuNC0xMiAxMi0xMmg0MGM2LjYgMCAxMiA1LjQgMTIgMTJ2NDBjMCA2LjYtNS40IDEyLTEyIDEySDc2Yy02LjYgMC0xMi01LjQtMTItMTJ2LTQwem0wIDEyOGMwLTYuNiA1LjQtMTIgMTItMTJoNDBjNi42IDAgMTIgNS40IDEyIDEydjQwYzAgNi42LTUuNCAxMi0xMiAxMkg3NmMtNi42IDAtMTItNS40LTEyLTEydi00MHpNNDAwIDY0aC00OFYxNmMwLTguOC03LjItMTYtMTYtMTZoLTMyYy04LjggMC0xNiA3LjItMTYgMTZ2NDhIMTYwVjE2YzAtOC44LTcuMi0xNi0xNi0xNmgtMzJjLTguOCAwLTE2IDcuMi0xNiAxNnY0OEg0OEMyMS41IDY0IDAgODUuNSAwIDExMnY0OGg0NDh2LTQ4YzAtMjYuNS0yMS41LTQ4LTQ4LTQ4elwiIC8+XG4gICAgICAgIDwvSWNvbkJhc2U+XG4gICAgICAiLCI8c2NyaXB0PlxuICAgICAgICBpbXBvcnQgSWNvbkJhc2UgZnJvbSAnLi4vY29tcG9uZW50cy9JY29uQmFzZS5zdmVsdGUnO1xuICAgICAgICA8L3NjcmlwdD5cbiAgICAgICAgPEljb25CYXNlIHZpZXdCb3g9XCIwIDAgNDQ4IDUxMlwiIHsuLi4kJHByb3BzfT5cbiAgICAgICAgICA8cGF0aCBkPVwiTTQwMCA0ODBINDhjLTI2LjUxIDAtNDgtMjEuNDktNDgtNDhWODBjMC0yNi41MSAyMS40OS00OCA0OC00OGgzNTJjMjYuNTEgMCA0OCAyMS40OSA0OCA0OHYzNTJjMCAyNi41MS0yMS40OSA0OC00OCA0OHptLTIwNC42ODYtOTguMDU5bDE4NC0xODRjNi4yNDgtNi4yNDggNi4yNDgtMTYuMzc5IDAtMjIuNjI3bC0yMi42MjctMjIuNjI3Yy02LjI0OC02LjI0OC0xNi4zNzktNi4yNDktMjIuNjI4IDBMMTg0IDMwMi43NDVsLTcwLjA1OS03MC4wNTljLTYuMjQ4LTYuMjQ4LTE2LjM3OS02LjI0OC0yMi42MjggMGwtMjIuNjI3IDIyLjYyN2MtNi4yNDggNi4yNDgtNi4yNDggMTYuMzc5IDAgMjIuNjI3bDEwNCAxMDRjNi4yNDkgNi4yNSAxNi4zNzkgNi4yNSAyMi42MjguMDAxelwiIC8+XG4gICAgICAgIDwvSWNvbkJhc2U+XG4gICAgICAiLCI8c2NyaXB0PlxuICAgICAgICBpbXBvcnQgSWNvbkJhc2UgZnJvbSAnLi4vY29tcG9uZW50cy9JY29uQmFzZS5zdmVsdGUnO1xuICAgICAgICA8L3NjcmlwdD5cbiAgICAgICAgPEljb25CYXNlIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiB7Li4uJCRwcm9wc30+XG4gICAgICAgICAgPHBhdGggZD1cIk0xOS4zNSAxMC4wNEMxOC42NyA2LjU5IDE1LjY0IDQgMTIgNCA5LjExIDQgNi42IDUuNjQgNS4zNSA4LjA0IDIuMzQgOC4zNiAwIDEwLjkxIDAgMTRjMCAzLjMxIDIuNjkgNiA2IDZoMTNjMi43NiAwIDUtMi4yNCA1LTUgMC0yLjY0LTIuMDUtNC43OC00LjY1LTQuOTZ6TTE0IDEzdjRoLTR2LTRIN2w1LTUgNSA1aC0zelwiIC8+XG4gICAgICAgIDwvSWNvbkJhc2U+XG4gICAgICAiLCI8c2NyaXB0PlxuICAgICAgICBpbXBvcnQgSWNvbkJhc2UgZnJvbSAnLi4vY29tcG9uZW50cy9JY29uQmFzZS5zdmVsdGUnO1xuICAgICAgICA8L3NjcmlwdD5cbiAgICAgICAgPEljb25CYXNlIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiB7Li4uJCRwcm9wc30+XG4gICAgICAgICAgPHBhdGggZD1cIk0xMiA0LjVDNyA0LjUgMi43MyA3LjYxIDEgMTJjMS43MyA0LjM5IDYgNy41IDExIDcuNXM5LjI3LTMuMTEgMTEtNy41Yy0xLjczLTQuMzktNi03LjUtMTEtNy41ek0xMiAxN2MtMi43NiAwLTUtMi4yNC01LTVzMi4yNC01IDUtNSA1IDIuMjQgNSA1LTIuMjQgNS01IDV6bTAtOGMtMS42NiAwLTMgMS4zNC0zIDNzMS4zNCAzIDMgMyAzLTEuMzQgMy0zLTEuMzQtMy0zLTN6XCIgLz5cbiAgICAgICAgPC9JY29uQmFzZT5cbiAgICAgICIsIjxzY3JpcHQ+XG4gICAgICAgIGltcG9ydCBJY29uQmFzZSBmcm9tICcuLi9jb21wb25lbnRzL0ljb25CYXNlLnN2ZWx0ZSc7XG4gICAgICAgIDwvc2NyaXB0PlxuICAgICAgICA8SWNvbkJhc2Ugdmlld0JveD1cIjAgMCAzODQgNTEyXCIgey4uLiQkcHJvcHN9PlxuICAgICAgICAgIDxwYXRoIGQ9XCJNMTcyLjI2OCA1MDEuNjdDMjYuOTcgMjkxLjAzMSAwIDI2OS40MTMgMCAxOTIgMCA4NS45NjEgODUuOTYxIDAgMTkyIDBzMTkyIDg1Ljk2MSAxOTIgMTkyYzAgNzcuNDEzLTI2Ljk3IDk5LjAzMS0xNzIuMjY4IDMwOS42Ny05LjUzNSAxMy43NzQtMjkuOTMgMTMuNzczLTM5LjQ2NCAwek0xOTIgMjcyYzQ0LjE4MyAwIDgwLTM1LjgxNyA4MC04MHMtMzUuODE3LTgwLTgwLTgwLTgwIDM1LjgxNy04MCA4MCAzNS44MTcgODAgODAgODB6XCIgLz5cbiAgICAgICAgPC9JY29uQmFzZT5cbiAgICAgICIsIjxzY3JpcHQ+XG4gICAgICAgIGltcG9ydCBJY29uQmFzZSBmcm9tICcuLi9jb21wb25lbnRzL0ljb25CYXNlLnN2ZWx0ZSc7XG4gICAgICAgIDwvc2NyaXB0PlxuICAgICAgICA8SWNvbkJhc2Ugdmlld0JveD1cIjAgMCA0NDggNTEyXCIgey4uLiQkcHJvcHN9PlxuICAgICAgICAgIDxwYXRoIGQ9XCJNNDQ2LjcgOTguNmwtNjcuNiAzMTguOGMtNS4xIDIyLjUtMTguNCAyOC4xLTM3LjMgMTcuNWwtMTAzLTc1LjktNDkuNyA0Ny44Yy01LjUgNS41LTEwLjEgMTAuMS0yMC43IDEwLjFsNy40LTEwNC45IDE5MC45LTE3Mi41YzguMy03LjQtMS44LTExLjUtMTIuOS00LjFMMTE3LjggMjg0IDE2LjIgMjUyLjJjLTIyLjEtNi45LTIyLjUtMjIuMSA0LjYtMzIuN0w0MTguMiA2Ni40YzE4LjQtNi45IDM0LjUgNC4xIDI4LjUgMzIuMnpcIiAvPlxuICAgICAgICA8L0ljb25CYXNlPlxuICAgICAgIiwiPHNjcmlwdD5cbiAgICAgICAgaW1wb3J0IEljb25CYXNlIGZyb20gJy4uL2NvbXBvbmVudHMvSWNvbkJhc2Uuc3ZlbHRlJztcbiAgICAgICAgPC9zY3JpcHQ+XG4gICAgICAgIDxJY29uQmFzZSB2aWV3Qm94PVwiMCAwIDI1NiA1MTJcIiB7Li4uJCRwcm9wc30+XG4gICAgICAgICAgPHBhdGggZD1cIk04OCAxNjYuMDU5VjQ2OGMwIDYuNjI3IDUuMzczIDEyIDEyIDEyaDU2YzYuNjI3IDAgMTItNS4zNzMgMTItMTJWMTY2LjA1OWg0Ni4wNTljMjEuMzgyIDAgMzIuMDktMjUuODUxIDE2Ljk3MS00MC45NzFsLTg2LjA1OS04Ni4wNTljLTkuMzczLTkuMzczLTI0LjU2OS05LjM3My0zMy45NDEgMGwtODYuMDU5IDg2LjA1OWMtMTUuMTE5IDE1LjExOS00LjQxMSA0MC45NzEgMTYuOTcxIDQwLjk3MUg4OHpcIiAvPlxuICAgICAgICA8L0ljb25CYXNlPlxuICAgICAgIiwiPHNjcmlwdD5cbiAgICAgICAgaW1wb3J0IEljb25CYXNlIGZyb20gJy4uL2NvbXBvbmVudHMvSWNvbkJhc2Uuc3ZlbHRlJztcbiAgICAgICAgPC9zY3JpcHQ+XG4gICAgICAgIDxJY29uQmFzZSB2aWV3Qm94PVwiMCAwIDI1NiA1MTJcIiB7Li4uJCRwcm9wc30+XG4gICAgICAgICAgPHBhdGggZD1cIk0xNjggMzQ1Ljk0MVY0NGMwLTYuNjI3LTUuMzczLTEyLTEyLTEyaC01NmMtNi42MjcgMC0xMiA1LjM3My0xMiAxMnYzMDEuOTQxSDQxLjk0MWMtMjEuMzgyIDAtMzIuMDkgMjUuODUxLTE2Ljk3MSA0MC45NzFsODYuMDU5IDg2LjA1OWM5LjM3MyA5LjM3MyAyNC41NjkgOS4zNzMgMzMuOTQxIDBsODYuMDU5LTg2LjA1OWMxNS4xMTktMTUuMTE5IDQuNDExLTQwLjk3MS0xNi45NzEtNDAuOTcxSDE2OHpcIiAvPlxuICAgICAgICA8L0ljb25CYXNlPlxuICAgICAgIiwiPHNjcmlwdD5cbiAgICAgICAgaW1wb3J0IEljb25CYXNlIGZyb20gJy4uL2NvbXBvbmVudHMvSWNvbkJhc2Uuc3ZlbHRlJztcbiAgICAgICAgPC9zY3JpcHQ+XG4gICAgICAgIDxJY29uQmFzZSB2aWV3Qm94PVwiMCAwIDQ0OCA1MTJcIiB7Li4uJCRwcm9wc30+XG4gICAgICAgICAgPHBhdGggZD1cIk0xMzQuMDU5IDI5Nkg0MzZjNi42MjcgMCAxMi01LjM3MyAxMi0xMnYtNTZjMC02LjYyNy01LjM3My0xMi0xMi0xMkgxMzQuMDU5di00Ni4wNTljMC0yMS4zODItMjUuODUxLTMyLjA5LTQwLjk3MS0xNi45NzFMNy4wMjkgMjM5LjAyOWMtOS4zNzMgOS4zNzMtOS4zNzMgMjQuNTY5IDAgMzMuOTQxbDg2LjA1OSA4Ni4wNTljMTUuMTE5IDE1LjExOSA0MC45NzEgNC40MTEgNDAuOTcxLTE2Ljk3MVYyOTZ6XCIgLz5cbiAgICAgICAgPC9JY29uQmFzZT5cbiAgICAgICIsIjxzY3JpcHQ+XG4gICAgICAgIGltcG9ydCBJY29uQmFzZSBmcm9tICcuLi9jb21wb25lbnRzL0ljb25CYXNlLnN2ZWx0ZSc7XG4gICAgICAgIDwvc2NyaXB0PlxuICAgICAgICA8SWNvbkJhc2Ugdmlld0JveD1cIjAgMCA0NDggNTEyXCIgey4uLiQkcHJvcHN9PlxuICAgICAgICAgIDxwYXRoIGQ9XCJNMzEzLjk0MSAyMTZIMTJjLTYuNjI3IDAtMTIgNS4zNzMtMTIgMTJ2NTZjMCA2LjYyNyA1LjM3MyAxMiAxMiAxMmgzMDEuOTQxdjQ2LjA1OWMwIDIxLjM4MiAyNS44NTEgMzIuMDkgNDAuOTcxIDE2Ljk3MWw4Ni4wNTktODYuMDU5YzkuMzczLTkuMzczIDkuMzczLTI0LjU2OSAwLTMzLjk0MWwtODYuMDU5LTg2LjA1OWMtMTUuMTE5LTE1LjExOS00MC45NzEtNC40MTEtNDAuOTcxIDE2Ljk3MVYyMTZ6XCIgLz5cbiAgICAgICAgPC9JY29uQmFzZT5cbiAgICAgICIsIjxzY3JpcHQ+XG4gICAgICAgIGltcG9ydCBJY29uQmFzZSBmcm9tICcuLi9jb21wb25lbnRzL0ljb25CYXNlLnN2ZWx0ZSc7XG4gICAgICAgIDwvc2NyaXB0PlxuICAgICAgICA8SWNvbkJhc2Ugdmlld0JveD1cIjAgMCAyNCAyNFwiIHsuLi4kJHByb3BzfT5cbiAgICAgICAgICA8cGF0aCBkPVwiTTcuNDEgMTUuNDFMMTIgMTAuODNsNC41OSA0LjU4TDE4IDE0bC02LTYtNiA2elwiIC8+XG4gICAgICAgIDwvSWNvbkJhc2U+XG4gICAgICAiLCI8c2NyaXB0PlxuICAgICAgICBpbXBvcnQgSWNvbkJhc2UgZnJvbSAnLi4vY29tcG9uZW50cy9JY29uQmFzZS5zdmVsdGUnO1xuICAgICAgICA8L3NjcmlwdD5cbiAgICAgICAgPEljb25CYXNlIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiB7Li4uJCRwcm9wc30+XG4gICAgICAgICAgPHBhdGggZD1cIk0xNS40MSAxNi4wOWwtNC41OC00LjU5IDQuNTgtNC41OUwxNCA1LjVsLTYgNiA2IDZ6XCIgLz5cbiAgICAgICAgPC9JY29uQmFzZT5cbiAgICAgICIsIjxzY3JpcHQ+XG4gICAgICAgIGltcG9ydCBJY29uQmFzZSBmcm9tICcuLi9jb21wb25lbnRzL0ljb25CYXNlLnN2ZWx0ZSc7XG4gICAgICAgIDwvc2NyaXB0PlxuICAgICAgICA8SWNvbkJhc2Ugdmlld0JveD1cIjAgMCAyNCAyNFwiIHsuLi4kJHByb3BzfT5cbiAgICAgICAgICA8cGF0aCBkPVwiTTcuNDEgNy44NEwxMiAxMi40Mmw0LjU5LTQuNThMMTggOS4yNWwtNiA2LTYtNnpcIiAvPlxuICAgICAgICA8L0ljb25CYXNlPlxuICAgICAgIiwiPHNjcmlwdD5cbiAgICAgICAgaW1wb3J0IEljb25CYXNlIGZyb20gJy4uL2NvbXBvbmVudHMvSWNvbkJhc2Uuc3ZlbHRlJztcbiAgICAgICAgPC9zY3JpcHQ+XG4gICAgICAgIDxJY29uQmFzZSB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgey4uLiQkcHJvcHN9PlxuICAgICAgICAgIDxwYXRoIGQ9XCJNOC41OSAxNi4zNGw0LjU4LTQuNTktNC41OC00LjU5TDEwIDUuNzVsNiA2LTYgNnpcIiAvPlxuICAgICAgICA8L0ljb25CYXNlPlxuICAgICAgIiwiPHNjcmlwdD5cbiAgICAgICAgaW1wb3J0IEljb25CYXNlIGZyb20gJy4uL2NvbXBvbmVudHMvSWNvbkJhc2Uuc3ZlbHRlJztcbiAgICAgICAgPC9zY3JpcHQ+XG4gICAgICAgIDxJY29uQmFzZSB2aWV3Qm94PVwiMCAwIDUxMiA1MTJcIiB7Li4uJCRwcm9wc30+XG4gICAgICAgICAgPHBhdGggZD1cIk0yNTYgNDhDMTQxLjEgNDggNDggMTQxLjEgNDggMjU2czkzLjEgMjA4IDIwOCAyMDggMjA4LTkzLjEgMjA4LTIwOFMzNzAuOSA0OCAyNTYgNDh6bTEwNi41IDE1MC41TDIyOC44IDMzMi44aC0uMWMtMS43IDEuNy02LjMgNS41LTExLjYgNS41LTMuOCAwLTguMS0yLjEtMTEuNy01LjdsLTU2LTU2Yy0xLjYtMS42LTEuNi00LjEgMC01LjdsMTcuOC0xNy44Yy44LS44IDEuOC0xLjIgMi44LTEuMiAxIDAgMiAuNCAyLjggMS4ybDQ0LjQgNDQuNCAxMjItMTIyLjljLjgtLjggMS44LTEuMiAyLjgtMS4yIDEuMSAwIDIuMS40IDIuOCAxLjJsMTcuNSAxOC4xYzEuOCAxLjcgMS44IDQuMi4yIDUuOHpcIiAvPlxuICAgICAgICA8L0ljb25CYXNlPlxuICAgICAgIiwiPHNjcmlwdD5cbiAgICAgICAgaW1wb3J0IEljb25CYXNlIGZyb20gJy4uL2NvbXBvbmVudHMvSWNvbkJhc2Uuc3ZlbHRlJztcbiAgICAgICAgPC9zY3JpcHQ+XG4gICAgICAgIDxJY29uQmFzZSB2aWV3Qm94PVwiMCAwIDUxMiA1MTJcIiB7Li4uJCRwcm9wc30+XG4gICAgICAgICAgPHBhdGggZD1cIk0zMzEuMyAzMDguN0wyNzguNiAyNTZsNTIuNy01Mi43YzYuMi02LjIgNi4yLTE2LjQgMC0yMi42LTYuMi02LjItMTYuNC02LjItMjIuNiAwTDI1NiAyMzMuNGwtNTIuNy01Mi43Yy02LjItNi4yLTE1LjYtNy4xLTIyLjYgMC03LjEgNy4xLTYgMTYuNiAwIDIyLjZsNTIuNyA1Mi43LTUyLjcgNTIuN2MtNi43IDYuNy02LjQgMTYuMyAwIDIyLjYgNi40IDYuNCAxNi40IDYuMiAyMi42IDBsNTIuNy01Mi43IDUyLjcgNTIuN2M2LjIgNi4yIDE2LjQgNi4yIDIyLjYgMCA2LjMtNi4yIDYuMy0xNi40IDAtMjIuNnpcIiAvPlxuPHBhdGggZD1cIk0yNTYgNzZjNDguMSAwIDkzLjMgMTguNyAxMjcuMyA1Mi43UzQzNiAyMDcuOSA0MzYgMjU2cy0xOC43IDkzLjMtNTIuNyAxMjcuM1MzMDQuMSA0MzYgMjU2IDQzNmMtNDguMSAwLTkzLjMtMTguNy0xMjcuMy01Mi43Uzc2IDMwNC4xIDc2IDI1NnMxOC43LTkzLjMgNTIuNy0xMjcuM1MyMDcuOSA3NiAyNTYgNzZtMC0yOEMxNDEuMSA0OCA0OCAxNDEuMSA0OCAyNTZzOTMuMSAyMDggMjA4IDIwOCAyMDgtOTMuMSAyMDgtMjA4UzM3MC45IDQ4IDI1NiA0OHpcIiAvPlxuICAgICAgICA8L0ljb25CYXNlPlxuICAgICAgIiwiaW1wb3J0IEZhQXQgZnJvbSAnc3ZlbHRlLWljb25zL2ZhL0ZhQXQuc3ZlbHRlJ1xuaW1wb3J0IEZhTW9vbiBmcm9tICdzdmVsdGUtaWNvbnMvZmEvRmFNb29uLnN2ZWx0ZSdcbmltcG9ydCBNZExpbmsgZnJvbSAnc3ZlbHRlLWljb25zL21kL01kTGluay5zdmVsdGUnXG5pbXBvcnQgR2lNYWxlIGZyb20gJ3N2ZWx0ZS1pY29ucy9naS9HaU1hbGUuc3ZlbHRlJ1xuaW1wb3J0IE1kRWRpdCBmcm9tICdzdmVsdGUtaWNvbnMvbWQvTWRFZGl0LnN2ZWx0ZSdcbmltcG9ydCBGYUhlYXJ0IGZyb20gJ3N2ZWx0ZS1pY29ucy9mYS9GYUhlYXJ0LnN2ZWx0ZSdcbmltcG9ydCBGYVZpYmVyIGZyb20gJ3N2ZWx0ZS1pY29ucy9mYS9GYVZpYmVyLnN2ZWx0ZSdcbmltcG9ydCBGYVNoYXJlIGZyb20gJ3N2ZWx0ZS1pY29ucy9mYS9GYVNoYXJlLnN2ZWx0ZSdcbmltcG9ydCBNZENoZWNrIGZyb20gJ3N2ZWx0ZS1pY29ucy9tZC9NZENoZWNrLnN2ZWx0ZSdcbmltcG9ydCBHaUZlbWFsZSBmcm9tICdzdmVsdGUtaWNvbnMvZ2kvR2lGZW1hbGUuc3ZlbHRlJ1xuaW1wb3J0IElvTWRTZW5kIGZyb20gJ3N2ZWx0ZS1pY29ucy9pby9Jb01kU2VuZC5zdmVsdGUnXG5pbXBvcnQgR29TZWFyY2ggZnJvbSAnc3ZlbHRlLWljb25zL2dvL0dvU2VhcmNoLnN2ZWx0ZSdcbmltcG9ydCBJb01kQ2xvc2UgZnJvbSAnc3ZlbHRlLWljb25zL2lvL0lvTWRDbG9zZS5zdmVsdGUnXG5pbXBvcnQgRmFQaG9uZUFsdCBmcm9tICdzdmVsdGUtaWNvbnMvZmEvRmFQaG9uZUFsdC5zdmVsdGUnXG5pbXBvcnQgRmFGYWNlYm9va0YgZnJvbSAnc3ZlbHRlLWljb25zL2ZhL0ZhRmFjZWJvb2tGLnN2ZWx0ZSdcbmltcG9ydCBGYVJlZ1NxdWFyZSBmcm9tICdzdmVsdGUtaWNvbnMvZmEvRmFSZWdTcXVhcmUuc3ZlbHRlJ1xuaW1wb3J0IFRpU3RhcmJ1cnN0IGZyb20gJ3N2ZWx0ZS1pY29ucy90aS9UaVN0YXJidXJzdC5zdmVsdGUnXG5pbXBvcnQgRmFEb2xsYXJTaWduIGZyb20gJ3N2ZWx0ZS1pY29ucy9mYS9GYURvbGxhclNpZ24uc3ZlbHRlJ1xuaW1wb3J0IEZhQ2FsZW5kYXJBbHQgZnJvbSAnc3ZlbHRlLWljb25zL2ZhL0ZhQ2FsZW5kYXJBbHQuc3ZlbHRlJ1xuaW1wb3J0IEZhQ2hlY2tTcXVhcmUgZnJvbSAnc3ZlbHRlLWljb25zL2ZhL0ZhQ2hlY2tTcXVhcmUuc3ZlbHRlJ1xuaW1wb3J0IE1kQ2xvdWRVcGxvYWQgZnJvbSAnc3ZlbHRlLWljb25zL21kL01kQ2xvdWRVcGxvYWQuc3ZlbHRlJ1xuaW1wb3J0IE1kUmVtb3ZlUmVkRXllIGZyb20gJ3N2ZWx0ZS1pY29ucy9tZC9NZFJlbW92ZVJlZEV5ZS5zdmVsdGUnXG5pbXBvcnQgRmFNYXBNYXJrZXJBbHQgZnJvbSAnc3ZlbHRlLWljb25zL2ZhL0ZhTWFwTWFya2VyQWx0LnN2ZWx0ZSdcbmltcG9ydCBGYVRlbGVncmFtUGxhbmUgZnJvbSAnc3ZlbHRlLWljb25zL2ZhL0ZhVGVsZWdyYW1QbGFuZS5zdmVsdGUnXG5pbXBvcnQgRmFMb25nQXJyb3dBbHRVcCBmcm9tICdzdmVsdGUtaWNvbnMvZmEvRmFMb25nQXJyb3dBbHRVcC5zdmVsdGUnXG5pbXBvcnQgRmFMb25nQXJyb3dBbHREb3duIGZyb20gJ3N2ZWx0ZS1pY29ucy9mYS9GYUxvbmdBcnJvd0FsdERvd24uc3ZlbHRlJ1xuaW1wb3J0IEZhTG9uZ0Fycm93QWx0TGVmdCBmcm9tICdzdmVsdGUtaWNvbnMvZmEvRmFMb25nQXJyb3dBbHRMZWZ0LnN2ZWx0ZSdcbmltcG9ydCBGYUxvbmdBcnJvd0FsdFJpZ2h0IGZyb20gJ3N2ZWx0ZS1pY29ucy9mYS9GYUxvbmdBcnJvd0FsdFJpZ2h0LnN2ZWx0ZSdcbmltcG9ydCBNZEtleWJvYXJkQXJyb3dVcCBmcm9tICdzdmVsdGUtaWNvbnMvbWQvTWRLZXlib2FyZEFycm93VXAuc3ZlbHRlJ1xuaW1wb3J0IE1kS2V5Ym9hcmRBcnJvd0xlZnQgZnJvbSAnc3ZlbHRlLWljb25zL21kL01kS2V5Ym9hcmRBcnJvd0xlZnQuc3ZlbHRlJ1xuaW1wb3J0IE1kS2V5Ym9hcmRBcnJvd0Rvd24gZnJvbSAnc3ZlbHRlLWljb25zL21kL01kS2V5Ym9hcmRBcnJvd0Rvd24uc3ZlbHRlJ1xuaW1wb3J0IE1kS2V5Ym9hcmRBcnJvd1JpZ2h0IGZyb20gJ3N2ZWx0ZS1pY29ucy9tZC9NZEtleWJvYXJkQXJyb3dSaWdodC5zdmVsdGUnXG5pbXBvcnQgSW9Jb3NDaGVja21hcmtDaXJjbGUgZnJvbSAnc3ZlbHRlLWljb25zL2lvL0lvSW9zQ2hlY2ttYXJrQ2lyY2xlLnN2ZWx0ZSdcbmltcG9ydCBJb0lvc0Nsb3NlQ2lyY2xlT3V0bGluZSBmcm9tICdzdmVsdGUtaWNvbnMvaW8vSW9Jb3NDbG9zZUNpcmNsZU91dGxpbmUuc3ZlbHRlJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgZW1haWw6IEZhQXQsXG4gICAgZWRpdDogTWRFZGl0LFxuICAgIGxpbms6IE1kTGluayxcbiAgICBtb29uOiBGYU1vb24sXG4gICAgbWFsZTogR2lNYWxlLFxuICAgIHNlbmQ6IElvTWRTZW5kLFxuICAgIHNoYXJlOiBGYVNoYXJlLFxuICAgIGhlYXJ0OiBGYUhlYXJ0LFxuICAgIHZpYmVyOiBGYVZpYmVyLFxuICAgIGNsb3NlOiBJb01kQ2xvc2UsXG4gICAgYm94OiBGYVJlZ1NxdWFyZSxcbiAgICBzZWFyY2g6IEdvU2VhcmNoLFxuICAgIGZlbWFsZTogR2lGZW1hbGUsXG4gICAgcGhvbmU6IEZhUGhvbmVBbHQsXG4gICAgY29pbjogRmFEb2xsYXJTaWduLFxuICAgIGV5ZTogTWRSZW1vdmVSZWRFeWUsXG4gICAgcG9seWdvbjogVGlTdGFyYnVyc3QsXG4gICAgZmFjZWJvb2s6IEZhRmFjZWJvb2tGLFxuICAgIHVwbG9hZDogTWRDbG91ZFVwbG9hZCxcbiAgICAnY2hlY2stZmxhZyc6IE1kQ2hlY2ssXG4gICAgY2FsZW5kYXI6IEZhQ2FsZW5kYXJBbHQsXG4gICAgbG9jYXRpb246IEZhTWFwTWFya2VyQWx0LFxuICAgIHRlbGVncmFtOiBGYVRlbGVncmFtUGxhbmUsXG4gICAgJ2JveC1jaGVja2VkJzogRmFDaGVja1NxdWFyZSxcbiAgICAnYXJyb3ctdXAnOiBGYUxvbmdBcnJvd0FsdFVwLFxuICAgICdhcnJvdy1sZWZ0JzogRmFMb25nQXJyb3dBbHRMZWZ0LFxuICAgICdhcnJvdy1kb3duJzogRmFMb25nQXJyb3dBbHREb3duLFxuICAgICdhcnJvdy1yaWdodCc6IEZhTG9uZ0Fycm93QWx0UmlnaHQsXG4gICAgJ2NhcmV0LXVwJzogTWRLZXlib2FyZEFycm93VXAsXG4gICAgJ2NhcmV0LWxlZnQnOiBNZEtleWJvYXJkQXJyb3dMZWZ0LFxuICAgICdjYXJldC1kb3duJzogTWRLZXlib2FyZEFycm93RG93bixcbiAgICAnY2FyZXQtcmlnaHQnOiBNZEtleWJvYXJkQXJyb3dSaWdodCxcbiAgICAnY2hlY2tlZC1jaXJjbGUnOiBJb0lvc0NoZWNrbWFya0NpcmNsZSxcbiAgICAnY2FuY2VsLWNpcmNsZSc6IElvSW9zQ2xvc2VDaXJjbGVPdXRsaW5lLFxufVxuIiwiXG4vKipcbiAqXG4gKiBAZGVzY3JpcHRpb24gQVBJIFVSTHMgYnVpbGRlcnMuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBVU0VSOiAoaWQpID0+IGB1c2VyLmpzb25gLFxuICAgIFVTRVJTOiAoKSA9PiBgdXNlcnMuanNvbmAsXG5cbiAgICBSRUNFTlQ6IChpZCkgPT4gYHJlY2VudC5qc29uYCxcbiAgICBSRUNFTlRTOiAoKSA9PiBgcmVjZW50cy5qc29uYCxcblxuICAgIENPTU1FTlQ6IChpZCkgPT4gYGNvbW1lbnQuanNvbmAsXG4gICAgQ09NTUVOVFM6ICgpID0+IGBjb21tZW50cy5qc29uYCxcblxuICAgIEZVTkQ6IChpZCkgPT4gYGZ1bmQuanNvbmAsXG4gICAgRlVORFM6ICgpID0+IGBmdW5kcy5qc29uYCxcblxuICAgIE9SR0FOSVpBVElPTjogKGlkKSA9PiBgb3JnYW5pemF0aW9uLmpzb25gLFxuICAgIE9SR0FOSVpBVElPTlM6ICgpID0+IGBvcmdhbml6YXRpb25zLmpzb25gLFxuXG4gICAgSU1BR0VTX1VQTE9BRDogKCkgPT4gYC9pbWFnZXMvdXBsb2FkYCxcbn1cbi8vIGV4cG9ydCBkZWZhdWx0IHtcbi8vICAgICBVU0VSOiAoaWQpID0+IGBhcGl1c2Vycy8ke2lkIHx8ICc6aWQnfWAsXG4vLyAgICAgVVNFUlM6ICgpID0+IGBhcGl1c2Vyc2AsXG4vL1xuLy8gICAgIFJFQ0VOVDogKGlkKSA9PiBgYXBpcmVjZW50cy8ke2lkIHx8ICc6aWQnfWAsXG4vLyAgICAgUkVDRU5UUzogKCkgPT4gYGFwaXJlY2VudHNgLFxuLy9cbi8vICAgICBDT01NRU5UOiAoaWQpID0+IGBhcGljb21tZW50cy8ke2lkIHx8ICc6aWQnfWAsXG4vLyAgICAgQ09NTUVOVFM6ICgpID0+IGBhcGljb21tZW50c2AsXG4vL1xuLy8gICAgIEZVTkQ6IChpZCkgPT4gYGFwaWZ1bmRzLyR7aWQgfHwgJzppZCd9YCxcbi8vICAgICBGVU5EUzogKCkgPT4gYGFwaWZ1bmRzYCxcbi8vXG4vLyAgICAgT1JHQU5JWkFUSU9OOiAoaWQpID0+IGBhcGlvcmdhbml6YXRpb25zLyR7aWQgfHwgJzppZCd9YCxcbi8vICAgICBPUkdBTklaQVRJT05TOiAoKSA9PiBgYXBpb3JnYW5pemF0aW9uc2AsXG4vLyB9XG4iLCJleHBvcnQgY29uc3QgdmFjY2luYXRpb25zID0gW1xuICAgIHtcbiAgICAgICAgdGV4dDogJ9CS0ZbQtCDQutC70ZbRidGW0LInLFxuICAgICAgICB2YWx1ZTogJ2Zyb20tZnVuZ2knXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHRleHQ6ICfQktGW0LQg0YHQutCw0LfRgycsXG4gICAgICAgIHZhbHVlOiAnZnJvbS1yYWJpZXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHRleHQ6ICfQktGW0LQg0L/QsNGA0LDQs9GA0LjQv9GDJyxcbiAgICAgICAgdmFsdWU6ICdmcm9tLXBhcmFpbmZsdWVuemEnXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHRleHQ6ICfQktGW0LQg0YfRg9C80Lgg0LxcXCfRj9GB0L7Rl9C00L3QuNGFJyxcbiAgICAgICAgdmFsdWU6ICdmcm9tLWNhcm5pdm9yb3VzLXBsYWd1ZSdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgdGV4dDogJ9CS0ZbQtCDQv9Cw0YDQstC+0LLRltGA0L7QtycsXG4gICAgICAgIHZhbHVlOiAnZnJvbS1wYXJ2b3ZpcnVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgICB0ZXh0OiAn0JLRltC0INCw0LTQtdC90L7QstGW0YDQvtC3JyxcbiAgICAgICAgdmFsdWU6ICdmcm9tLWFkZW5vdmlydXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHRleHQ6ICfQktGW0LQg0LvQtdC/0YLQvtGB0L/RltGA0L7QtycsXG4gICAgICAgIHZhbHVlOiAnZnJvbS1sZXB0b3NwaXJvc2lzJ1xuICAgIH0sXG5dIiwiPHNjcmlwdD5cbiAgICAvKipcbiAgICAgKiBAaW5mbyBzZWUgbW9yZSBpY29uczogaHR0cHM6Ly93d3cuc3ZlbHRlLWljb25zLmdpYmRpZy5jb20vXG4gICAgICovXG4gICAgaW1wb3J0IHsgY2xhc3NuYW1lcywgdG9DU1NTdHJpbmcgfSBmcm9tICdAdXRpbHMnXG4gICAgaW1wb3J0IHsgaWNvbnMgfSBmcm9tICdAY29uZmlnJ1xuXG5cbiAgICBleHBvcnQgbGV0IHR5cGVcbiAgICBleHBvcnQgbGV0IGlzID0gbnVsbCAvLyBwcmltYXJ5fGluZm98ZGFuZ2VyfGxpZ2h0fGRhcmtcbiAgICBleHBvcnQgbGV0IHNpemUgPSBudWxsIC8vIHNtYWxsfG1lZGl1bXxiaWdcbiAgICBleHBvcnQgbGV0IHJvdGF0ZSA9IDBcbiAgICBleHBvcnQgbGV0IHN0eWxlID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCBpZCA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgdGl0bGUgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IGFyaWFMYWJlbCA9IHVuZGVmaW5lZFxuXG4gICAgbGV0IHRpdGxlUHJvcCA9IHRpdGxlIHx8IGFyaWFMYWJlbFxuICAgIGxldCBhcmlhTGFiZWxQcm9wID0gYXJpYUxhYmVsIHx8IHRpdGxlXG4gICAgbGV0IHN0eWxlUHJvcCA9IHRvQ1NTU3RyaW5nKHsgdHJhbnNmb3JtOiAhIXJvdGF0ZSA/IGByb3RhdGVaKCR7cm90YXRlfWRlZylgIDogbnVsbCwgLi4uc3R5bGUgfSlcblxuICAgICQ6IGNsYXNzUHJvcCA9IGNsYXNzbmFtZXMoJ2ljbycsIGlzLCBzaXplLCAkJHByb3BzLmNsYXNzKVxuPC9zY3JpcHQ+XG5cbjxpIHtpZH0gdGl0bGU9e3RpdGxlUHJvcH0gc3R5bGU9e3N0eWxlUHJvcH0gY2xhc3M9e2NsYXNzUHJvcH0+XG4gICAgPHN2ZWx0ZTpjb21wb25lbnQgdGhpcz17aWNvbnNbdHlwZV19Lz5cbjwvaT5cblxuPHN0eWxlPlxuICAgIC5pY28ge1xuICAgICAgICBmbGV4LWdyb3c6IDE7XG4gICAgICAgIGFsaWduLXNlbGY6IHN0cmV0Y2g7XG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1mbGV4O1xuICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xuICAgIH1cblxuICAgIC5pY286bm90KC5jdXN0b20pIHtcbiAgICAgICAgY29sb3I6IHJnYmEodmFyKC0tdGhlbWUtc3ZnLWZpbGwpKTtcbiAgICB9XG5cbiAgICAvKiAtLS0tLS0tLS0tLS09PT09PT09PT0oIFNpemUgKT09PT09PT09PS0tLS0tLS0tLS0tLSAqL1xuICAgIC50aW55IHtcbiAgICAgICAgd2lkdGg6IDEzcHg7XG4gICAgICAgIGhlaWdodDogMTNweDtcbiAgICAgICAgZmxleDogbm9uZTtcbiAgICAgICAgYWxpZ24tc2VsZjogYXV0bztcbiAgICB9XG5cbiAgICAuc21hbGwge1xuICAgICAgICB3aWR0aDogMThweDtcbiAgICAgICAgaGVpZ2h0OiAxOHB4O1xuICAgICAgICBmbGV4OiBub25lO1xuICAgICAgICBhbGlnbi1zZWxmOiBhdXRvO1xuICAgIH1cblxuICAgIC5tZWRpdW0ge1xuICAgICAgICB3aWR0aDogMjRweDtcbiAgICAgICAgaGVpZ2h0OiAyNHB4O1xuICAgICAgICBmbGV4OiBub25lO1xuICAgICAgICBhbGlnbi1zZWxmOiBhdXRvO1xuICAgIH1cblxuICAgIC5iaWcge1xuICAgICAgICB3aWR0aDogMzBweDtcbiAgICAgICAgaGVpZ2h0OiAzMHB4O1xuICAgICAgICBmbGV4OiBub25lO1xuICAgICAgICBhbGlnbi1zZWxmOiBhdXRvO1xuICAgIH1cblxuICAgIC5sYXJnZSB7XG4gICAgICAgIHdpZHRoOiA0MHB4O1xuICAgICAgICBoZWlnaHQ6IDQwcHg7XG4gICAgICAgIGZsZXg6IG5vbmU7XG4gICAgICAgIGFsaWduLXNlbGY6IGF1dG87XG4gICAgfVxuXG4gICAgLyogLS0tLS0tLS0tLS0tPT09PT09PT09KCBDb2xvciApPT09PT09PT09LS0tLS0tLS0tLS0tICovXG4gICAgLmljby5wcmltYXJ5IHtcbiAgICAgICAgY29sb3I6IHJnYih2YXIoLS1jb2xvci1zdWNjZXNzKSk7XG4gICAgfVxuXG4gICAgLmljby5kYW5nZXIge1xuICAgICAgICBjb2xvcjogcmdiKHZhcigtLWNvbG9yLWRhbmdlcikpO1xuICAgIH1cblxuICAgIC5pY28uaW5mbyB7XG4gICAgICAgIGNvbG9yOiByZ2IodmFyKC0tY29sb3ItaW5mbykpO1xuICAgIH1cblxuICAgIC5pY28ubGlnaHQge1xuICAgICAgICBjb2xvcjogcmdiKHZhcigtLWNvbG9yLXdoaXRlKSk7XG4gICAgfVxuXG4gICAgLmljby5kYXJrIHtcbiAgICAgICAgY29sb3I6IHJnYih2YXIoLS1jb2xvci1ibGFjaykpO1xuICAgIH1cbjwvc3R5bGU+XG4iLCI8c2NyaXB0PlxuICAgIGV4cG9ydCBsZXQgbmFtZSA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgaWQgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IHRpdGxlID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCBhcmlhTGFiZWwgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IG1ldGhvZCA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgYXV0b2NvbXBsZXRlID0gdW5kZWZpbmVkXG5cbiAgICBsZXQgdGl0bGVQcm9wID0gdGl0bGUgfHwgYXJpYUxhYmVsXG4gICAgbGV0IGFyaWFMYWJlbFByb3AgPSBhcmlhTGFiZWwgfHwgdGl0bGVcbjwvc2NyaXB0PlxuXG48Zm9ybVxuICAgICAgICB7aWR9XG4gICAgICAgIHtuYW1lfVxuICAgICAgICB7bWV0aG9kfVxuICAgICAgICB7YXV0b2NvbXBsZXRlfVxuICAgICAgICB0aXRsZT17dGl0bGVQcm9wfVxuICAgICAgICBjbGFzcz17JCRwcm9wcy5jbGFzc31cbiAgICAgICAgYXJpYS1sYWJlbD17YXJpYUxhYmVsUHJvcH1cbiAgICAgICAgb246c3VibWl0fHByZXZlbnREZWZhdWx0XG4+XG4gICAgPHNsb3Q+PC9zbG90PlxuPC9mb3JtPlxuXG48c3R5bGU+XG5cbjwvc3R5bGU+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IGNsYXNzbmFtZXMgfSBmcm9tICdAdXRpbHMnXG5cbiAgICAkOiBjbGFzc1Byb3AgPSBjbGFzc25hbWVzKCdjYXJkJywgJCRwcm9wcy5jbGFzcylcbjwvc2NyaXB0PlxuXG48c2VjdGlvbiBjbGFzcz17Y2xhc3NQcm9wfSBzdHlsZT17JCRwcm9wcy5zdHlsZX0+XG4gICAgPHNsb3Q+PC9zbG90PlxuPC9zZWN0aW9uPlxuXG48c3R5bGU+XG4gICAgLmNhcmQge1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVooMCk7XG4gICAgICAgIGJveC1zaGFkb3c6IHZhcigtLXNoYWRvdy1zZWNvbmRhcnkpO1xuICAgICAgICBib3JkZXItcmFkaXVzOiB2YXIoLS1ib3JkZXItcmFkaXVzLWJpZyk7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEodmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeSkpO1xuICAgIH1cbjwvc3R5bGU+XG4iLCJleHBvcnQgeyBpZGVudGl0eSBhcyBsaW5lYXIgfSBmcm9tICcuLi9pbnRlcm5hbCc7XG5cbi8qXG5BZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL21hdHRkZXNsXG5EaXN0cmlidXRlZCB1bmRlciBNSVQgTGljZW5zZSBodHRwczovL2dpdGh1Yi5jb20vbWF0dGRlc2wvZWFzZXMvYmxvYi9tYXN0ZXIvTElDRU5TRS5tZFxuKi9cbmZ1bmN0aW9uIGJhY2tJbk91dCh0KSB7XG4gICAgY29uc3QgcyA9IDEuNzAxNTggKiAxLjUyNTtcbiAgICBpZiAoKHQgKj0gMikgPCAxKVxuICAgICAgICByZXR1cm4gMC41ICogKHQgKiB0ICogKChzICsgMSkgKiB0IC0gcykpO1xuICAgIHJldHVybiAwLjUgKiAoKHQgLT0gMikgKiB0ICogKChzICsgMSkgKiB0ICsgcykgKyAyKTtcbn1cbmZ1bmN0aW9uIGJhY2tJbih0KSB7XG4gICAgY29uc3QgcyA9IDEuNzAxNTg7XG4gICAgcmV0dXJuIHQgKiB0ICogKChzICsgMSkgKiB0IC0gcyk7XG59XG5mdW5jdGlvbiBiYWNrT3V0KHQpIHtcbiAgICBjb25zdCBzID0gMS43MDE1ODtcbiAgICByZXR1cm4gLS10ICogdCAqICgocyArIDEpICogdCArIHMpICsgMTtcbn1cbmZ1bmN0aW9uIGJvdW5jZU91dCh0KSB7XG4gICAgY29uc3QgYSA9IDQuMCAvIDExLjA7XG4gICAgY29uc3QgYiA9IDguMCAvIDExLjA7XG4gICAgY29uc3QgYyA9IDkuMCAvIDEwLjA7XG4gICAgY29uc3QgY2EgPSA0MzU2LjAgLyAzNjEuMDtcbiAgICBjb25zdCBjYiA9IDM1NDQyLjAgLyAxODA1LjA7XG4gICAgY29uc3QgY2MgPSAxNjA2MS4wIC8gMTgwNS4wO1xuICAgIGNvbnN0IHQyID0gdCAqIHQ7XG4gICAgcmV0dXJuIHQgPCBhXG4gICAgICAgID8gNy41NjI1ICogdDJcbiAgICAgICAgOiB0IDwgYlxuICAgICAgICAgICAgPyA5LjA3NSAqIHQyIC0gOS45ICogdCArIDMuNFxuICAgICAgICAgICAgOiB0IDwgY1xuICAgICAgICAgICAgICAgID8gY2EgKiB0MiAtIGNiICogdCArIGNjXG4gICAgICAgICAgICAgICAgOiAxMC44ICogdCAqIHQgLSAyMC41MiAqIHQgKyAxMC43Mjtcbn1cbmZ1bmN0aW9uIGJvdW5jZUluT3V0KHQpIHtcbiAgICByZXR1cm4gdCA8IDAuNVxuICAgICAgICA/IDAuNSAqICgxLjAgLSBib3VuY2VPdXQoMS4wIC0gdCAqIDIuMCkpXG4gICAgICAgIDogMC41ICogYm91bmNlT3V0KHQgKiAyLjAgLSAxLjApICsgMC41O1xufVxuZnVuY3Rpb24gYm91bmNlSW4odCkge1xuICAgIHJldHVybiAxLjAgLSBib3VuY2VPdXQoMS4wIC0gdCk7XG59XG5mdW5jdGlvbiBjaXJjSW5PdXQodCkge1xuICAgIGlmICgodCAqPSAyKSA8IDEpXG4gICAgICAgIHJldHVybiAtMC41ICogKE1hdGguc3FydCgxIC0gdCAqIHQpIC0gMSk7XG4gICAgcmV0dXJuIDAuNSAqIChNYXRoLnNxcnQoMSAtICh0IC09IDIpICogdCkgKyAxKTtcbn1cbmZ1bmN0aW9uIGNpcmNJbih0KSB7XG4gICAgcmV0dXJuIDEuMCAtIE1hdGguc3FydCgxLjAgLSB0ICogdCk7XG59XG5mdW5jdGlvbiBjaXJjT3V0KHQpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KDEgLSAtLXQgKiB0KTtcbn1cbmZ1bmN0aW9uIGN1YmljSW5PdXQodCkge1xuICAgIHJldHVybiB0IDwgMC41ID8gNC4wICogdCAqIHQgKiB0IDogMC41ICogTWF0aC5wb3coMi4wICogdCAtIDIuMCwgMy4wKSArIDEuMDtcbn1cbmZ1bmN0aW9uIGN1YmljSW4odCkge1xuICAgIHJldHVybiB0ICogdCAqIHQ7XG59XG5mdW5jdGlvbiBjdWJpY091dCh0KSB7XG4gICAgY29uc3QgZiA9IHQgLSAxLjA7XG4gICAgcmV0dXJuIGYgKiBmICogZiArIDEuMDtcbn1cbmZ1bmN0aW9uIGVsYXN0aWNJbk91dCh0KSB7XG4gICAgcmV0dXJuIHQgPCAwLjVcbiAgICAgICAgPyAwLjUgKlxuICAgICAgICAgICAgTWF0aC5zaW4oKCgrMTMuMCAqIE1hdGguUEkpIC8gMikgKiAyLjAgKiB0KSAqXG4gICAgICAgICAgICBNYXRoLnBvdygyLjAsIDEwLjAgKiAoMi4wICogdCAtIDEuMCkpXG4gICAgICAgIDogMC41ICpcbiAgICAgICAgICAgIE1hdGguc2luKCgoLTEzLjAgKiBNYXRoLlBJKSAvIDIpICogKDIuMCAqIHQgLSAxLjAgKyAxLjApKSAqXG4gICAgICAgICAgICBNYXRoLnBvdygyLjAsIC0xMC4wICogKDIuMCAqIHQgLSAxLjApKSArXG4gICAgICAgICAgICAxLjA7XG59XG5mdW5jdGlvbiBlbGFzdGljSW4odCkge1xuICAgIHJldHVybiBNYXRoLnNpbigoMTMuMCAqIHQgKiBNYXRoLlBJKSAvIDIpICogTWF0aC5wb3coMi4wLCAxMC4wICogKHQgLSAxLjApKTtcbn1cbmZ1bmN0aW9uIGVsYXN0aWNPdXQodCkge1xuICAgIHJldHVybiAoTWF0aC5zaW4oKC0xMy4wICogKHQgKyAxLjApICogTWF0aC5QSSkgLyAyKSAqIE1hdGgucG93KDIuMCwgLTEwLjAgKiB0KSArIDEuMCk7XG59XG5mdW5jdGlvbiBleHBvSW5PdXQodCkge1xuICAgIHJldHVybiB0ID09PSAwLjAgfHwgdCA9PT0gMS4wXG4gICAgICAgID8gdFxuICAgICAgICA6IHQgPCAwLjVcbiAgICAgICAgICAgID8gKzAuNSAqIE1hdGgucG93KDIuMCwgMjAuMCAqIHQgLSAxMC4wKVxuICAgICAgICAgICAgOiAtMC41ICogTWF0aC5wb3coMi4wLCAxMC4wIC0gdCAqIDIwLjApICsgMS4wO1xufVxuZnVuY3Rpb24gZXhwb0luKHQpIHtcbiAgICByZXR1cm4gdCA9PT0gMC4wID8gdCA6IE1hdGgucG93KDIuMCwgMTAuMCAqICh0IC0gMS4wKSk7XG59XG5mdW5jdGlvbiBleHBvT3V0KHQpIHtcbiAgICByZXR1cm4gdCA9PT0gMS4wID8gdCA6IDEuMCAtIE1hdGgucG93KDIuMCwgLTEwLjAgKiB0KTtcbn1cbmZ1bmN0aW9uIHF1YWRJbk91dCh0KSB7XG4gICAgdCAvPSAwLjU7XG4gICAgaWYgKHQgPCAxKVxuICAgICAgICByZXR1cm4gMC41ICogdCAqIHQ7XG4gICAgdC0tO1xuICAgIHJldHVybiAtMC41ICogKHQgKiAodCAtIDIpIC0gMSk7XG59XG5mdW5jdGlvbiBxdWFkSW4odCkge1xuICAgIHJldHVybiB0ICogdDtcbn1cbmZ1bmN0aW9uIHF1YWRPdXQodCkge1xuICAgIHJldHVybiAtdCAqICh0IC0gMi4wKTtcbn1cbmZ1bmN0aW9uIHF1YXJ0SW5PdXQodCkge1xuICAgIHJldHVybiB0IDwgMC41XG4gICAgICAgID8gKzguMCAqIE1hdGgucG93KHQsIDQuMClcbiAgICAgICAgOiAtOC4wICogTWF0aC5wb3codCAtIDEuMCwgNC4wKSArIDEuMDtcbn1cbmZ1bmN0aW9uIHF1YXJ0SW4odCkge1xuICAgIHJldHVybiBNYXRoLnBvdyh0LCA0LjApO1xufVxuZnVuY3Rpb24gcXVhcnRPdXQodCkge1xuICAgIHJldHVybiBNYXRoLnBvdyh0IC0gMS4wLCAzLjApICogKDEuMCAtIHQpICsgMS4wO1xufVxuZnVuY3Rpb24gcXVpbnRJbk91dCh0KSB7XG4gICAgaWYgKCh0ICo9IDIpIDwgMSlcbiAgICAgICAgcmV0dXJuIDAuNSAqIHQgKiB0ICogdCAqIHQgKiB0O1xuICAgIHJldHVybiAwLjUgKiAoKHQgLT0gMikgKiB0ICogdCAqIHQgKiB0ICsgMik7XG59XG5mdW5jdGlvbiBxdWludEluKHQpIHtcbiAgICByZXR1cm4gdCAqIHQgKiB0ICogdCAqIHQ7XG59XG5mdW5jdGlvbiBxdWludE91dCh0KSB7XG4gICAgcmV0dXJuIC0tdCAqIHQgKiB0ICogdCAqIHQgKyAxO1xufVxuZnVuY3Rpb24gc2luZUluT3V0KHQpIHtcbiAgICByZXR1cm4gLTAuNSAqIChNYXRoLmNvcyhNYXRoLlBJICogdCkgLSAxKTtcbn1cbmZ1bmN0aW9uIHNpbmVJbih0KSB7XG4gICAgY29uc3QgdiA9IE1hdGguY29zKHQgKiBNYXRoLlBJICogMC41KTtcbiAgICBpZiAoTWF0aC5hYnModikgPCAxZS0xNClcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gMSAtIHY7XG59XG5mdW5jdGlvbiBzaW5lT3V0KHQpIHtcbiAgICByZXR1cm4gTWF0aC5zaW4oKHQgKiBNYXRoLlBJKSAvIDIpO1xufVxuXG5leHBvcnQgeyBiYWNrSW4sIGJhY2tJbk91dCwgYmFja091dCwgYm91bmNlSW4sIGJvdW5jZUluT3V0LCBib3VuY2VPdXQsIGNpcmNJbiwgY2lyY0luT3V0LCBjaXJjT3V0LCBjdWJpY0luLCBjdWJpY0luT3V0LCBjdWJpY091dCwgZWxhc3RpY0luLCBlbGFzdGljSW5PdXQsIGVsYXN0aWNPdXQsIGV4cG9JbiwgZXhwb0luT3V0LCBleHBvT3V0LCBxdWFkSW4sIHF1YWRJbk91dCwgcXVhZE91dCwgcXVhcnRJbiwgcXVhcnRJbk91dCwgcXVhcnRPdXQsIHF1aW50SW4sIHF1aW50SW5PdXQsIHF1aW50T3V0LCBzaW5lSW4sIHNpbmVJbk91dCwgc2luZU91dCB9O1xuIiwiaW1wb3J0IHsgY3ViaWNJbk91dCwgbGluZWFyLCBjdWJpY091dCB9IGZyb20gJy4uL2Vhc2luZyc7XG5pbXBvcnQgeyBpc19mdW5jdGlvbiwgYXNzaWduIH0gZnJvbSAnLi4vaW50ZXJuYWwnO1xuXG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxyXG50aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxyXG5MaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG5LSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXHJcbldBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXHJcbk1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXHJcblxyXG5TZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcclxuYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG5cclxuZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XG5cbmZ1bmN0aW9uIGJsdXIobm9kZSwgeyBkZWxheSA9IDAsIGR1cmF0aW9uID0gNDAwLCBlYXNpbmcgPSBjdWJpY0luT3V0LCBhbW91bnQgPSA1LCBvcGFjaXR5ID0gMCB9KSB7XG4gICAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICAgIGNvbnN0IHRhcmdldF9vcGFjaXR5ID0gK3N0eWxlLm9wYWNpdHk7XG4gICAgY29uc3QgZiA9IHN0eWxlLmZpbHRlciA9PT0gJ25vbmUnID8gJycgOiBzdHlsZS5maWx0ZXI7XG4gICAgY29uc3Qgb2QgPSB0YXJnZXRfb3BhY2l0eSAqICgxIC0gb3BhY2l0eSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVsYXksXG4gICAgICAgIGR1cmF0aW9uLFxuICAgICAgICBlYXNpbmcsXG4gICAgICAgIGNzczogKF90LCB1KSA9PiBgb3BhY2l0eTogJHt0YXJnZXRfb3BhY2l0eSAtIChvZCAqIHUpfTsgZmlsdGVyOiAke2Z9IGJsdXIoJHt1ICogYW1vdW50fXB4KTtgXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGZhZGUobm9kZSwgeyBkZWxheSA9IDAsIGR1cmF0aW9uID0gNDAwLCBlYXNpbmcgPSBsaW5lYXIgfSkge1xuICAgIGNvbnN0IG8gPSArZ2V0Q29tcHV0ZWRTdHlsZShub2RlKS5vcGFjaXR5O1xuICAgIHJldHVybiB7XG4gICAgICAgIGRlbGF5LFxuICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgZWFzaW5nLFxuICAgICAgICBjc3M6IHQgPT4gYG9wYWNpdHk6ICR7dCAqIG99YFxuICAgIH07XG59XG5mdW5jdGlvbiBmbHkobm9kZSwgeyBkZWxheSA9IDAsIGR1cmF0aW9uID0gNDAwLCBlYXNpbmcgPSBjdWJpY091dCwgeCA9IDAsIHkgPSAwLCBvcGFjaXR5ID0gMCB9KSB7XG4gICAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICAgIGNvbnN0IHRhcmdldF9vcGFjaXR5ID0gK3N0eWxlLm9wYWNpdHk7XG4gICAgY29uc3QgdHJhbnNmb3JtID0gc3R5bGUudHJhbnNmb3JtID09PSAnbm9uZScgPyAnJyA6IHN0eWxlLnRyYW5zZm9ybTtcbiAgICBjb25zdCBvZCA9IHRhcmdldF9vcGFjaXR5ICogKDEgLSBvcGFjaXR5KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBkZWxheSxcbiAgICAgICAgZHVyYXRpb24sXG4gICAgICAgIGVhc2luZyxcbiAgICAgICAgY3NzOiAodCwgdSkgPT4gYFxuXHRcdFx0dHJhbnNmb3JtOiAke3RyYW5zZm9ybX0gdHJhbnNsYXRlKCR7KDEgLSB0KSAqIHh9cHgsICR7KDEgLSB0KSAqIHl9cHgpO1xuXHRcdFx0b3BhY2l0eTogJHt0YXJnZXRfb3BhY2l0eSAtIChvZCAqIHUpfWBcbiAgICB9O1xufVxuZnVuY3Rpb24gc2xpZGUobm9kZSwgeyBkZWxheSA9IDAsIGR1cmF0aW9uID0gNDAwLCBlYXNpbmcgPSBjdWJpY091dCB9KSB7XG4gICAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICAgIGNvbnN0IG9wYWNpdHkgPSArc3R5bGUub3BhY2l0eTtcbiAgICBjb25zdCBoZWlnaHQgPSBwYXJzZUZsb2F0KHN0eWxlLmhlaWdodCk7XG4gICAgY29uc3QgcGFkZGluZ190b3AgPSBwYXJzZUZsb2F0KHN0eWxlLnBhZGRpbmdUb3ApO1xuICAgIGNvbnN0IHBhZGRpbmdfYm90dG9tID0gcGFyc2VGbG9hdChzdHlsZS5wYWRkaW5nQm90dG9tKTtcbiAgICBjb25zdCBtYXJnaW5fdG9wID0gcGFyc2VGbG9hdChzdHlsZS5tYXJnaW5Ub3ApO1xuICAgIGNvbnN0IG1hcmdpbl9ib3R0b20gPSBwYXJzZUZsb2F0KHN0eWxlLm1hcmdpbkJvdHRvbSk7XG4gICAgY29uc3QgYm9yZGVyX3RvcF93aWR0aCA9IHBhcnNlRmxvYXQoc3R5bGUuYm9yZGVyVG9wV2lkdGgpO1xuICAgIGNvbnN0IGJvcmRlcl9ib3R0b21fd2lkdGggPSBwYXJzZUZsb2F0KHN0eWxlLmJvcmRlckJvdHRvbVdpZHRoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBkZWxheSxcbiAgICAgICAgZHVyYXRpb24sXG4gICAgICAgIGVhc2luZyxcbiAgICAgICAgY3NzOiB0ID0+IGBvdmVyZmxvdzogaGlkZGVuO2AgK1xuICAgICAgICAgICAgYG9wYWNpdHk6ICR7TWF0aC5taW4odCAqIDIwLCAxKSAqIG9wYWNpdHl9O2AgK1xuICAgICAgICAgICAgYGhlaWdodDogJHt0ICogaGVpZ2h0fXB4O2AgK1xuICAgICAgICAgICAgYHBhZGRpbmctdG9wOiAke3QgKiBwYWRkaW5nX3RvcH1weDtgICtcbiAgICAgICAgICAgIGBwYWRkaW5nLWJvdHRvbTogJHt0ICogcGFkZGluZ19ib3R0b219cHg7YCArXG4gICAgICAgICAgICBgbWFyZ2luLXRvcDogJHt0ICogbWFyZ2luX3RvcH1weDtgICtcbiAgICAgICAgICAgIGBtYXJnaW4tYm90dG9tOiAke3QgKiBtYXJnaW5fYm90dG9tfXB4O2AgK1xuICAgICAgICAgICAgYGJvcmRlci10b3Atd2lkdGg6ICR7dCAqIGJvcmRlcl90b3Bfd2lkdGh9cHg7YCArXG4gICAgICAgICAgICBgYm9yZGVyLWJvdHRvbS13aWR0aDogJHt0ICogYm9yZGVyX2JvdHRvbV93aWR0aH1weDtgXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHNjYWxlKG5vZGUsIHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDQwMCwgZWFzaW5nID0gY3ViaWNPdXQsIHN0YXJ0ID0gMCwgb3BhY2l0eSA9IDAgfSkge1xuICAgIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICBjb25zdCB0YXJnZXRfb3BhY2l0eSA9ICtzdHlsZS5vcGFjaXR5O1xuICAgIGNvbnN0IHRyYW5zZm9ybSA9IHN0eWxlLnRyYW5zZm9ybSA9PT0gJ25vbmUnID8gJycgOiBzdHlsZS50cmFuc2Zvcm07XG4gICAgY29uc3Qgc2QgPSAxIC0gc3RhcnQ7XG4gICAgY29uc3Qgb2QgPSB0YXJnZXRfb3BhY2l0eSAqICgxIC0gb3BhY2l0eSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVsYXksXG4gICAgICAgIGR1cmF0aW9uLFxuICAgICAgICBlYXNpbmcsXG4gICAgICAgIGNzczogKF90LCB1KSA9PiBgXG5cdFx0XHR0cmFuc2Zvcm06ICR7dHJhbnNmb3JtfSBzY2FsZSgkezEgLSAoc2QgKiB1KX0pO1xuXHRcdFx0b3BhY2l0eTogJHt0YXJnZXRfb3BhY2l0eSAtIChvZCAqIHUpfVxuXHRcdGBcbiAgICB9O1xufVxuZnVuY3Rpb24gZHJhdyhub2RlLCB7IGRlbGF5ID0gMCwgc3BlZWQsIGR1cmF0aW9uLCBlYXNpbmcgPSBjdWJpY0luT3V0IH0pIHtcbiAgICBjb25zdCBsZW4gPSBub2RlLmdldFRvdGFsTGVuZ3RoKCk7XG4gICAgaWYgKGR1cmF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHNwZWVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0gODAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZHVyYXRpb24gPSBsZW4gLyBzcGVlZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZHVyYXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZHVyYXRpb24gPSBkdXJhdGlvbihsZW4pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBkZWxheSxcbiAgICAgICAgZHVyYXRpb24sXG4gICAgICAgIGVhc2luZyxcbiAgICAgICAgY3NzOiAodCwgdSkgPT4gYHN0cm9rZS1kYXNoYXJyYXk6ICR7dCAqIGxlbn0gJHt1ICogbGVufWBcbiAgICB9O1xufVxuZnVuY3Rpb24gY3Jvc3NmYWRlKF9hKSB7XG4gICAgdmFyIHsgZmFsbGJhY2sgfSA9IF9hLCBkZWZhdWx0cyA9IF9fcmVzdChfYSwgW1wiZmFsbGJhY2tcIl0pO1xuICAgIGNvbnN0IHRvX3JlY2VpdmUgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgdG9fc2VuZCA9IG5ldyBNYXAoKTtcbiAgICBmdW5jdGlvbiBjcm9zc2ZhZGUoZnJvbSwgbm9kZSwgcGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IGQgPT4gTWF0aC5zcXJ0KGQpICogMzAsIGVhc2luZyA9IGN1YmljT3V0IH0gPSBhc3NpZ24oYXNzaWduKHt9LCBkZWZhdWx0cyksIHBhcmFtcyk7XG4gICAgICAgIGNvbnN0IHRvID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgY29uc3QgZHggPSBmcm9tLmxlZnQgLSB0by5sZWZ0O1xuICAgICAgICBjb25zdCBkeSA9IGZyb20udG9wIC0gdG8udG9wO1xuICAgICAgICBjb25zdCBkdyA9IGZyb20ud2lkdGggLyB0by53aWR0aDtcbiAgICAgICAgY29uc3QgZGggPSBmcm9tLmhlaWdodCAvIHRvLmhlaWdodDtcbiAgICAgICAgY29uc3QgZCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gc3R5bGUudHJhbnNmb3JtID09PSAnbm9uZScgPyAnJyA6IHN0eWxlLnRyYW5zZm9ybTtcbiAgICAgICAgY29uc3Qgb3BhY2l0eSA9ICtzdHlsZS5vcGFjaXR5O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGVsYXksXG4gICAgICAgICAgICBkdXJhdGlvbjogaXNfZnVuY3Rpb24oZHVyYXRpb24pID8gZHVyYXRpb24oZCkgOiBkdXJhdGlvbixcbiAgICAgICAgICAgIGVhc2luZyxcbiAgICAgICAgICAgIGNzczogKHQsIHUpID0+IGBcblx0XHRcdFx0b3BhY2l0eTogJHt0ICogb3BhY2l0eX07XG5cdFx0XHRcdHRyYW5zZm9ybS1vcmlnaW46IHRvcCBsZWZ0O1xuXHRcdFx0XHR0cmFuc2Zvcm06ICR7dHJhbnNmb3JtfSB0cmFuc2xhdGUoJHt1ICogZHh9cHgsJHt1ICogZHl9cHgpIHNjYWxlKCR7dCArICgxIC0gdCkgKiBkd30sICR7dCArICgxIC0gdCkgKiBkaH0pO1xuXHRcdFx0YFxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFuc2l0aW9uKGl0ZW1zLCBjb3VudGVycGFydHMsIGludHJvKSB7XG4gICAgICAgIHJldHVybiAobm9kZSwgcGFyYW1zKSA9PiB7XG4gICAgICAgICAgICBpdGVtcy5zZXQocGFyYW1zLmtleSwge1xuICAgICAgICAgICAgICAgIHJlY3Q6IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlcnBhcnRzLmhhcyhwYXJhbXMua2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHJlY3QgfSA9IGNvdW50ZXJwYXJ0cy5nZXQocGFyYW1zLmtleSk7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJwYXJ0cy5kZWxldGUocGFyYW1zLmtleSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcm9zc2ZhZGUocmVjdCwgbm9kZSwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIG5vZGUgaXMgZGlzYXBwZWFyaW5nIGFsdG9nZXRoZXJcbiAgICAgICAgICAgICAgICAvLyAoaS5lLiB3YXNuJ3QgY2xhaW1lZCBieSB0aGUgb3RoZXIgbGlzdClcbiAgICAgICAgICAgICAgICAvLyB0aGVuIHdlIG5lZWQgdG8gc3VwcGx5IGFuIG91dHJvXG4gICAgICAgICAgICAgICAgaXRlbXMuZGVsZXRlKHBhcmFtcy5rZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxsYmFjayAmJiBmYWxsYmFjayhub2RlLCBwYXJhbXMsIGludHJvKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBbXG4gICAgICAgIHRyYW5zaXRpb24odG9fc2VuZCwgdG9fcmVjZWl2ZSwgZmFsc2UpLFxuICAgICAgICB0cmFuc2l0aW9uKHRvX3JlY2VpdmUsIHRvX3NlbmQsIHRydWUpXG4gICAgXTtcbn1cblxuZXhwb3J0IHsgYmx1ciwgY3Jvc3NmYWRlLCBkcmF3LCBmYWRlLCBmbHksIHNjYWxlLCBzbGlkZSB9O1xuIiwiKGZ1bmN0aW9uKHNlbGYpIHtcblxudmFyIGlycmVsZXZhbnQgPSAoZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAgdmFyIHN1cHBvcnQgPSB7XG4gICAgc2VhcmNoUGFyYW1zOiAnVVJMU2VhcmNoUGFyYW1zJyBpbiBzZWxmLFxuICAgIGl0ZXJhYmxlOiAnU3ltYm9sJyBpbiBzZWxmICYmICdpdGVyYXRvcicgaW4gU3ltYm9sLFxuICAgIGJsb2I6XG4gICAgICAnRmlsZVJlYWRlcicgaW4gc2VsZiAmJlxuICAgICAgJ0Jsb2InIGluIHNlbGYgJiZcbiAgICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBuZXcgQmxvYigpO1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSkoKSxcbiAgICBmb3JtRGF0YTogJ0Zvcm1EYXRhJyBpbiBzZWxmLFxuICAgIGFycmF5QnVmZmVyOiAnQXJyYXlCdWZmZXInIGluIHNlbGZcbiAgfTtcblxuICBmdW5jdGlvbiBpc0RhdGFWaWV3KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgRGF0YVZpZXcucHJvdG90eXBlLmlzUHJvdG90eXBlT2Yob2JqKVxuICB9XG5cbiAgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIpIHtcbiAgICB2YXIgdmlld0NsYXNzZXMgPSBbXG4gICAgICAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICAgICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICAgICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgICAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgICAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgVWludDMyQXJyYXldJyxcbiAgICAgICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgRmxvYXQ2NEFycmF5XSdcbiAgICBdO1xuXG4gICAgdmFyIGlzQXJyYXlCdWZmZXJWaWV3ID1cbiAgICAgIEFycmF5QnVmZmVyLmlzVmlldyB8fFxuICAgICAgZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogJiYgdmlld0NsYXNzZXMuaW5kZXhPZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSkgPiAtMVxuICAgICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZU5hbWUobmFtZSkge1xuICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIG5hbWUgPSBTdHJpbmcobmFtZSk7XG4gICAgfVxuICAgIGlmICgvW15hLXowLTlcXC0jJCUmJyorLl5fYHx+XS9pLnRlc3QobmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgY2hhcmFjdGVyIGluIGhlYWRlciBmaWVsZCBuYW1lJylcbiAgICB9XG4gICAgcmV0dXJuIG5hbWUudG9Mb3dlckNhc2UoKVxuICB9XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgdmFsdWUgPSBTdHJpbmcodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIC8vIEJ1aWxkIGEgZGVzdHJ1Y3RpdmUgaXRlcmF0b3IgZm9yIHRoZSB2YWx1ZSBsaXN0XG4gIGZ1bmN0aW9uIGl0ZXJhdG9yRm9yKGl0ZW1zKSB7XG4gICAgdmFyIGl0ZXJhdG9yID0ge1xuICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGl0ZW1zLnNoaWZ0KCk7XG4gICAgICAgIHJldHVybiB7ZG9uZTogdmFsdWUgPT09IHVuZGVmaW5lZCwgdmFsdWU6IHZhbHVlfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoc3VwcG9ydC5pdGVyYWJsZSkge1xuICAgICAgaXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZXJhdG9yXG4gIH1cblxuICBmdW5jdGlvbiBIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICB0aGlzLm1hcCA9IHt9O1xuXG4gICAgaWYgKGhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzKSB7XG4gICAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQobmFtZSwgdmFsdWUpO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGhlYWRlcnMpKSB7XG4gICAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24oaGVhZGVyKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKGhlYWRlclswXSwgaGVhZGVyWzFdKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH0gZWxzZSBpZiAoaGVhZGVycykge1xuICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKG5hbWUsIGhlYWRlcnNbbmFtZV0pO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKTtcbiAgICB2YWx1ZSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKTtcbiAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLm1hcFtuYW1lXTtcbiAgICB0aGlzLm1hcFtuYW1lXSA9IG9sZFZhbHVlID8gb2xkVmFsdWUgKyAnLCAnICsgdmFsdWUgOiB2YWx1ZTtcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgZGVsZXRlIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldO1xuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKTtcbiAgICByZXR1cm4gdGhpcy5oYXMobmFtZSkgPyB0aGlzLm1hcFtuYW1lXSA6IG51bGxcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwLmhhc093blByb3BlcnR5KG5vcm1hbGl6ZU5hbWUobmFtZSkpXG4gIH07XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKTtcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24oY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMubWFwKSB7XG4gICAgICBpZiAodGhpcy5tYXAuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB0aGlzLm1hcFtuYW1lXSwgbmFtZSwgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgIGl0ZW1zLnB1c2gobmFtZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpdGVtcyA9IFtdO1xuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaXRlbXMucHVzaCh2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgIGl0ZW1zLnB1c2goW25hbWUsIHZhbHVlXSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9O1xuXG4gIGlmIChzdXBwb3J0Lml0ZXJhYmxlKSB7XG4gICAgSGVhZGVycy5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IEhlYWRlcnMucHJvdG90eXBlLmVudHJpZXM7XG4gIH1cblxuICBmdW5jdGlvbiBjb25zdW1lZChib2R5KSB7XG4gICAgaWYgKGJvZHkuYm9keVVzZWQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKSlcbiAgICB9XG4gICAgYm9keS5ib2R5VXNlZCA9IHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXNvbHZlKHJlYWRlci5yZXN1bHQpO1xuICAgICAgfTtcbiAgICAgIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChyZWFkZXIuZXJyb3IpO1xuICAgICAgfTtcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEJsb2JBc0FycmF5QnVmZmVyKGJsb2IpIHtcbiAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICB2YXIgcHJvbWlzZSA9IGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpO1xuICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKTtcbiAgICByZXR1cm4gcHJvbWlzZVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEJsb2JBc1RleHQoYmxvYikge1xuICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgIHZhciBwcm9taXNlID0gZmlsZVJlYWRlclJlYWR5KHJlYWRlcik7XG4gICAgcmVhZGVyLnJlYWRBc1RleHQoYmxvYik7XG4gICAgcmV0dXJuIHByb21pc2VcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRBcnJheUJ1ZmZlckFzVGV4dChidWYpIHtcbiAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1Zik7XG4gICAgdmFyIGNoYXJzID0gbmV3IEFycmF5KHZpZXcubGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xuICAgICAgY2hhcnNbaV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHZpZXdbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gY2hhcnMuam9pbignJylcbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1ZmZlckNsb25lKGJ1Zikge1xuICAgIGlmIChidWYuc2xpY2UpIHtcbiAgICAgIHJldHVybiBidWYuc2xpY2UoMClcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShidWYuYnl0ZUxlbmd0aCk7XG4gICAgICB2aWV3LnNldChuZXcgVWludDhBcnJheShidWYpKTtcbiAgICAgIHJldHVybiB2aWV3LmJ1ZmZlclxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIEJvZHkoKSB7XG4gICAgdGhpcy5ib2R5VXNlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5faW5pdEJvZHkgPSBmdW5jdGlvbihib2R5KSB7XG4gICAgICB0aGlzLl9ib2R5SW5pdCA9IGJvZHk7XG4gICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgdGhpcy5fYm9keVRleHQgPSAnJztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keTtcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5ibG9iICYmIEJsb2IucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUJsb2IgPSBib2R5O1xuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmZvcm1EYXRhICYmIEZvcm1EYXRhLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlGb3JtRGF0YSA9IGJvZHk7XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuc2VhcmNoUGFyYW1zICYmIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHkudG9TdHJpbmcoKTtcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlciAmJiBzdXBwb3J0LmJsb2IgJiYgaXNEYXRhVmlldyhib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIgPSBidWZmZXJDbG9uZShib2R5LmJ1ZmZlcik7XG4gICAgICAgIC8vIElFIDEwLTExIGNhbid0IGhhbmRsZSBhIERhdGFWaWV3IGJvZHkuXG4gICAgICAgIHRoaXMuX2JvZHlJbml0ID0gbmV3IEJsb2IoW3RoaXMuX2JvZHlBcnJheUJ1ZmZlcl0pO1xuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyICYmIChBcnJheUJ1ZmZlci5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSB8fCBpc0FycmF5QnVmZmVyVmlldyhib2R5KSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyID0gYnVmZmVyQ2xvbmUoYm9keSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHkgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYm9keSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QmxvYiAmJiB0aGlzLl9ib2R5QmxvYi50eXBlKSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgdGhpcy5fYm9keUJsb2IudHlwZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5zZWFyY2hQYXJhbXMgJiYgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PVVURi04Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKHN1cHBvcnQuYmxvYikge1xuICAgICAgdGhpcy5ibG9iID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZWplY3RlZCA9IGNvbnN1bWVkKHRoaXMpO1xuICAgICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0ZWRcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9ib2R5QmxvYikge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUJsb2IpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQmxvYihbdGhpcy5fYm9keUFycmF5QnVmZmVyXSkpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhZCBGb3JtRGF0YSBib2R5IGFzIGJsb2InKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3RoaXMuX2JvZHlUZXh0XSkpXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHRoaXMuYXJyYXlCdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgICAgIHJldHVybiBjb25zdW1lZCh0aGlzKSB8fCBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUFycmF5QnVmZmVyKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLmJsb2IoKS50aGVuKHJlYWRCbG9iQXNBcnJheUJ1ZmZlcilcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aGlzLnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByZWplY3RlZCA9IGNvbnN1bWVkKHRoaXMpO1xuICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgIHJldHVybiByZWplY3RlZFxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fYm9keUJsb2IpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRCbG9iQXNUZXh0KHRoaXMuX2JvZHlCbG9iKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZWFkQXJyYXlCdWZmZXJBc1RleHQodGhpcy5fYm9keUFycmF5QnVmZmVyKSlcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyB0ZXh0JylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keVRleHQpXG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChzdXBwb3J0LmZvcm1EYXRhKSB7XG4gICAgICB0aGlzLmZvcm1EYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHQoKS50aGVuKGRlY29kZSlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGhpcy5qc29uID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZXh0KCkudGhlbihKU09OLnBhcnNlKVxuICAgIH07XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gSFRUUCBtZXRob2RzIHdob3NlIGNhcGl0YWxpemF0aW9uIHNob3VsZCBiZSBub3JtYWxpemVkXG4gIHZhciBtZXRob2RzID0gWydERUxFVEUnLCAnR0VUJywgJ0hFQUQnLCAnT1BUSU9OUycsICdQT1NUJywgJ1BVVCddO1xuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZU1ldGhvZChtZXRob2QpIHtcbiAgICB2YXIgdXBjYXNlZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpO1xuICAgIHJldHVybiBtZXRob2RzLmluZGV4T2YodXBjYXNlZCkgPiAtMSA/IHVwY2FzZWQgOiBtZXRob2RcbiAgfVxuXG4gIGZ1bmN0aW9uIFJlcXVlc3QoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgYm9keSA9IG9wdGlvbnMuYm9keTtcblxuICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIFJlcXVlc3QpIHtcbiAgICAgIGlmIChpbnB1dC5ib2R5VXNlZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKVxuICAgICAgfVxuICAgICAgdGhpcy51cmwgPSBpbnB1dC51cmw7XG4gICAgICB0aGlzLmNyZWRlbnRpYWxzID0gaW5wdXQuY3JlZGVudGlhbHM7XG4gICAgICBpZiAoIW9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhpbnB1dC5oZWFkZXJzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubWV0aG9kID0gaW5wdXQubWV0aG9kO1xuICAgICAgdGhpcy5tb2RlID0gaW5wdXQubW9kZTtcbiAgICAgIHRoaXMuc2lnbmFsID0gaW5wdXQuc2lnbmFsO1xuICAgICAgaWYgKCFib2R5ICYmIGlucHV0Ll9ib2R5SW5pdCAhPSBudWxsKSB7XG4gICAgICAgIGJvZHkgPSBpbnB1dC5fYm9keUluaXQ7XG4gICAgICAgIGlucHV0LmJvZHlVc2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51cmwgPSBTdHJpbmcoaW5wdXQpO1xuICAgIH1cblxuICAgIHRoaXMuY3JlZGVudGlhbHMgPSBvcHRpb25zLmNyZWRlbnRpYWxzIHx8IHRoaXMuY3JlZGVudGlhbHMgfHwgJ3NhbWUtb3JpZ2luJztcbiAgICBpZiAob3B0aW9ucy5oZWFkZXJzIHx8ICF0aGlzLmhlYWRlcnMpIHtcbiAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycyk7XG4gICAgfVxuICAgIHRoaXMubWV0aG9kID0gbm9ybWFsaXplTWV0aG9kKG9wdGlvbnMubWV0aG9kIHx8IHRoaXMubWV0aG9kIHx8ICdHRVQnKTtcbiAgICB0aGlzLm1vZGUgPSBvcHRpb25zLm1vZGUgfHwgdGhpcy5tb2RlIHx8IG51bGw7XG4gICAgdGhpcy5zaWduYWwgPSBvcHRpb25zLnNpZ25hbCB8fCB0aGlzLnNpZ25hbDtcbiAgICB0aGlzLnJlZmVycmVyID0gbnVsbDtcblxuICAgIGlmICgodGhpcy5tZXRob2QgPT09ICdHRVQnIHx8IHRoaXMubWV0aG9kID09PSAnSEVBRCcpICYmIGJvZHkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JvZHkgbm90IGFsbG93ZWQgZm9yIEdFVCBvciBIRUFEIHJlcXVlc3RzJylcbiAgICB9XG4gICAgdGhpcy5faW5pdEJvZHkoYm9keSk7XG4gIH1cblxuICBSZXF1ZXN0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgUmVxdWVzdCh0aGlzLCB7Ym9keTogdGhpcy5fYm9keUluaXR9KVxuICB9O1xuXG4gIGZ1bmN0aW9uIGRlY29kZShib2R5KSB7XG4gICAgdmFyIGZvcm0gPSBuZXcgRm9ybURhdGEoKTtcbiAgICBib2R5XG4gICAgICAudHJpbSgpXG4gICAgICAuc3BsaXQoJyYnKVxuICAgICAgLmZvckVhY2goZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgICAgaWYgKGJ5dGVzKSB7XG4gICAgICAgICAgdmFyIHNwbGl0ID0gYnl0ZXMuc3BsaXQoJz0nKTtcbiAgICAgICAgICB2YXIgbmFtZSA9IHNwbGl0LnNoaWZ0KCkucmVwbGFjZSgvXFwrL2csICcgJyk7XG4gICAgICAgICAgdmFyIHZhbHVlID0gc3BsaXQuam9pbignPScpLnJlcGxhY2UoL1xcKy9nLCAnICcpO1xuICAgICAgICAgIGZvcm0uYXBwZW5kKGRlY29kZVVSSUNvbXBvbmVudChuYW1lKSwgZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIHJldHVybiBmb3JtXG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUhlYWRlcnMocmF3SGVhZGVycykge1xuICAgIHZhciBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgICAvLyBSZXBsYWNlIGluc3RhbmNlcyBvZiBcXHJcXG4gYW5kIFxcbiBmb2xsb3dlZCBieSBhdCBsZWFzdCBvbmUgc3BhY2Ugb3IgaG9yaXpvbnRhbCB0YWIgd2l0aCBhIHNwYWNlXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzAjc2VjdGlvbi0zLjJcbiAgICB2YXIgcHJlUHJvY2Vzc2VkSGVhZGVycyA9IHJhd0hlYWRlcnMucmVwbGFjZSgvXFxyP1xcbltcXHQgXSsvZywgJyAnKTtcbiAgICBwcmVQcm9jZXNzZWRIZWFkZXJzLnNwbGl0KC9cXHI/XFxuLykuZm9yRWFjaChmdW5jdGlvbihsaW5lKSB7XG4gICAgICB2YXIgcGFydHMgPSBsaW5lLnNwbGl0KCc6Jyk7XG4gICAgICB2YXIga2V5ID0gcGFydHMuc2hpZnQoKS50cmltKCk7XG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHBhcnRzLmpvaW4oJzonKS50cmltKCk7XG4gICAgICAgIGhlYWRlcnMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBoZWFkZXJzXG4gIH1cblxuICBCb2R5LmNhbGwoUmVxdWVzdC5wcm90b3R5cGUpO1xuXG4gIGZ1bmN0aW9uIFJlc3BvbnNlKGJvZHlJbml0LCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgdGhpcy50eXBlID0gJ2RlZmF1bHQnO1xuICAgIHRoaXMuc3RhdHVzID0gb3B0aW9ucy5zdGF0dXMgPT09IHVuZGVmaW5lZCA/IDIwMCA6IG9wdGlvbnMuc3RhdHVzO1xuICAgIHRoaXMub2sgPSB0aGlzLnN0YXR1cyA+PSAyMDAgJiYgdGhpcy5zdGF0dXMgPCAzMDA7XG4gICAgdGhpcy5zdGF0dXNUZXh0ID0gJ3N0YXR1c1RleHQnIGluIG9wdGlvbnMgPyBvcHRpb25zLnN0YXR1c1RleHQgOiAnT0snO1xuICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycyk7XG4gICAgdGhpcy51cmwgPSBvcHRpb25zLnVybCB8fCAnJztcbiAgICB0aGlzLl9pbml0Qm9keShib2R5SW5pdCk7XG4gIH1cblxuICBCb2R5LmNhbGwoUmVzcG9uc2UucHJvdG90eXBlKTtcblxuICBSZXNwb25zZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKHRoaXMuX2JvZHlJbml0LCB7XG4gICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgc3RhdHVzVGV4dDogdGhpcy5zdGF0dXNUZXh0LFxuICAgICAgaGVhZGVyczogbmV3IEhlYWRlcnModGhpcy5oZWFkZXJzKSxcbiAgICAgIHVybDogdGhpcy51cmxcbiAgICB9KVxuICB9O1xuXG4gIFJlc3BvbnNlLmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IDAsIHN0YXR1c1RleHQ6ICcnfSk7XG4gICAgcmVzcG9uc2UudHlwZSA9ICdlcnJvcic7XG4gICAgcmV0dXJuIHJlc3BvbnNlXG4gIH07XG5cbiAgdmFyIHJlZGlyZWN0U3RhdHVzZXMgPSBbMzAxLCAzMDIsIDMwMywgMzA3LCAzMDhdO1xuXG4gIFJlc3BvbnNlLnJlZGlyZWN0ID0gZnVuY3Rpb24odXJsLCBzdGF0dXMpIHtcbiAgICBpZiAocmVkaXJlY3RTdGF0dXNlcy5pbmRleE9mKHN0YXR1cykgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCBzdGF0dXMgY29kZScpXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7c3RhdHVzOiBzdGF0dXMsIGhlYWRlcnM6IHtsb2NhdGlvbjogdXJsfX0pXG4gIH07XG5cbiAgZXhwb3J0cy5ET01FeGNlcHRpb24gPSBzZWxmLkRPTUV4Y2VwdGlvbjtcbiAgdHJ5IHtcbiAgICBuZXcgZXhwb3J0cy5ET01FeGNlcHRpb24oKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXhwb3J0cy5ET01FeGNlcHRpb24gPSBmdW5jdGlvbihtZXNzYWdlLCBuYW1lKSB7XG4gICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgIHZhciBlcnJvciA9IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgdGhpcy5zdGFjayA9IGVycm9yLnN0YWNrO1xuICAgIH07XG4gICAgZXhwb3J0cy5ET01FeGNlcHRpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuICAgIGV4cG9ydHMuRE9NRXhjZXB0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGV4cG9ydHMuRE9NRXhjZXB0aW9uO1xuICB9XG5cbiAgZnVuY3Rpb24gZmV0Y2goaW5wdXQsIGluaXQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KGlucHV0LCBpbml0KTtcblxuICAgICAgaWYgKHJlcXVlc3Quc2lnbmFsICYmIHJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgZXhwb3J0cy5ET01FeGNlcHRpb24oJ0Fib3J0ZWQnLCAnQWJvcnRFcnJvcicpKVxuICAgICAgfVxuXG4gICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAgIGZ1bmN0aW9uIGFib3J0WGhyKCkge1xuICAgICAgICB4aHIuYWJvcnQoKTtcbiAgICAgIH1cblxuICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICBzdGF0dXM6IHhoci5zdGF0dXMsXG4gICAgICAgICAgc3RhdHVzVGV4dDogeGhyLnN0YXR1c1RleHQsXG4gICAgICAgICAgaGVhZGVyczogcGFyc2VIZWFkZXJzKHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSB8fCAnJylcbiAgICAgICAgfTtcbiAgICAgICAgb3B0aW9ucy51cmwgPSAncmVzcG9uc2VVUkwnIGluIHhociA/IHhoci5yZXNwb25zZVVSTCA6IG9wdGlvbnMuaGVhZGVycy5nZXQoJ1gtUmVxdWVzdC1VUkwnKTtcbiAgICAgICAgdmFyIGJvZHkgPSAncmVzcG9uc2UnIGluIHhociA/IHhoci5yZXNwb25zZSA6IHhoci5yZXNwb25zZVRleHQ7XG4gICAgICAgIHJlc29sdmUobmV3IFJlc3BvbnNlKGJvZHksIG9wdGlvbnMpKTtcbiAgICAgIH07XG5cbiAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJykpO1xuICAgICAgfTtcblxuICAgICAgeGhyLm9udGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcignTmV0d29yayByZXF1ZXN0IGZhaWxlZCcpKTtcbiAgICAgIH07XG5cbiAgICAgIHhoci5vbmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgZXhwb3J0cy5ET01FeGNlcHRpb24oJ0Fib3J0ZWQnLCAnQWJvcnRFcnJvcicpKTtcbiAgICAgIH07XG5cbiAgICAgIHhoci5vcGVuKHJlcXVlc3QubWV0aG9kLCByZXF1ZXN0LnVybCwgdHJ1ZSk7XG5cbiAgICAgIGlmIChyZXF1ZXN0LmNyZWRlbnRpYWxzID09PSAnaW5jbHVkZScpIHtcbiAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHJlcXVlc3QuY3JlZGVudGlhbHMgPT09ICdvbWl0Jykge1xuICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICgncmVzcG9uc2VUeXBlJyBpbiB4aHIgJiYgc3VwcG9ydC5ibG9iKSB7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYmxvYic7XG4gICAgICB9XG5cbiAgICAgIHJlcXVlc3QuaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIHZhbHVlKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAocmVxdWVzdC5zaWduYWwpIHtcbiAgICAgICAgcmVxdWVzdC5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydFhocik7XG5cbiAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIC8vIERPTkUgKHN1Y2Nlc3Mgb3IgZmFpbHVyZSlcbiAgICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICAgIHJlcXVlc3Quc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRYaHIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgeGhyLnNlbmQodHlwZW9mIHJlcXVlc3QuX2JvZHlJbml0ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiByZXF1ZXN0Ll9ib2R5SW5pdCk7XG4gICAgfSlcbiAgfVxuXG4gIGZldGNoLnBvbHlmaWxsID0gdHJ1ZTtcblxuICBpZiAoIXNlbGYuZmV0Y2gpIHtcbiAgICBzZWxmLmZldGNoID0gZmV0Y2g7XG4gICAgc2VsZi5IZWFkZXJzID0gSGVhZGVycztcbiAgICBzZWxmLlJlcXVlc3QgPSBSZXF1ZXN0O1xuICAgIHNlbGYuUmVzcG9uc2UgPSBSZXNwb25zZTtcbiAgfVxuXG4gIGV4cG9ydHMuSGVhZGVycyA9IEhlYWRlcnM7XG4gIGV4cG9ydHMuUmVxdWVzdCA9IFJlcXVlc3Q7XG4gIGV4cG9ydHMuUmVzcG9uc2UgPSBSZXNwb25zZTtcbiAgZXhwb3J0cy5mZXRjaCA9IGZldGNoO1xuXG4gIHJldHVybiBleHBvcnRzO1xuXG59KHt9KSk7XG59KSh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDogdGhpcyk7XG4iLCIoZnVuY3Rpb24gKCkge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICBmdW5jdGlvbiBidG9hKHN0cikge1xuICAgIHZhciBidWZmZXI7XG5cbiAgICBpZiAoc3RyIGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgICBidWZmZXIgPSBzdHI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKHN0ci50b1N0cmluZygpLCAnYmluYXJ5Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZygnYmFzZTY0Jyk7XG4gIH1cblxuICBtb2R1bGUuZXhwb3J0cyA9IGJ0b2E7XG59KCkpO1xuIiwiIWZ1bmN0aW9uKHQsZSl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9ZSgpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoZSk6KHQ9dHx8c2VsZikuemxGZXRjaD1lKCl9KHRoaXMsKGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIHQ9ZnVuY3Rpb24odCl7aWYoQXJyYXkuaXNBcnJheSh0KSlyZXR1cm4gdH07dmFyIGU9ZnVuY3Rpb24odCxlKXtpZihTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KHQpfHxcIltvYmplY3QgQXJndW1lbnRzXVwiPT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQpKXt2YXIgcj1bXSxuPSEwLG89ITEsaT12b2lkIDA7dHJ5e2Zvcih2YXIgYyx1PXRbU3ltYm9sLml0ZXJhdG9yXSgpOyEobj0oYz11Lm5leHQoKSkuZG9uZSkmJihyLnB1c2goYy52YWx1ZSksIWV8fHIubGVuZ3RoIT09ZSk7bj0hMCk7fWNhdGNoKHQpe289ITAsaT10fWZpbmFsbHl7dHJ5e258fG51bGw9PXUucmV0dXJufHx1LnJldHVybigpfWZpbmFsbHl7aWYobyl0aHJvdyBpfX1yZXR1cm4gcn19O3ZhciByPWZ1bmN0aW9uKCl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIil9O3ZhciBuPWZ1bmN0aW9uKG4sbyl7cmV0dXJuIHQobil8fGUobixvKXx8cigpfTt2YXIgbz1mdW5jdGlvbih0LGUpe3JldHVybiB0KGU9e2V4cG9ydHM6e319LGUuZXhwb3J0cyksZS5leHBvcnRzfSgoZnVuY3Rpb24odCl7ZnVuY3Rpb24gZShyKXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/dC5leHBvcnRzPWU9ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0fTp0LmV4cG9ydHM9ZT1mdW5jdGlvbih0KXtyZXR1cm4gdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZ0LmNvbnN0cnVjdG9yPT09U3ltYm9sJiZ0IT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiB0fSxlKHIpfXQuZXhwb3J0cz1lfSkpLGk9ZnVuY3Rpb24oKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e30sZT10LmhlYWRlcnMscj12b2lkIDA9PT1lP3t9OmUsbj0odC5ib2R5LHQubWV0aG9kKSxpPXZvaWQgMD09PW4/XCJnZXRcIjpuLGM9dC5hdXRoO1widW5kZWZpbmVkXCI9PXR5cGVvZiBIZWFkZXJzJiZyZXF1aXJlKFwiY3Jvc3MtZmV0Y2gvcG9seWZpbGxcIik7dmFyIHU9bmV3IEhlYWRlcnMocik7aWYodS5nZXQoXCJjb250ZW50LXR5cGVcIil8fFwiZ2V0XCI9PT1pfHx1LnNldChcImNvbnRlbnQtdHlwZVwiLFwiYXBwbGljYXRpb24vanNvblwiKSxjKWlmKFwib2JqZWN0XCI9PT1vKGMpKXt2YXIgYSxzPWMudXNlcm5hbWUsZj1jLnBhc3N3b3JkO2lmKCFzKXRocm93IG5ldyBFcnJvcihcIlVzZXJuYW1lIHJlcXVpcmVkIGZvciBiYXNpYyBhdXRoZW50aWNhdGlvblwiKTtpZighZil0aHJvdyBuZXcgRXJyb3IoXCJQYXNzd29yZCByZXF1aXJlZCBmb3IgYmFzaWMgYXV0aGVudGljYXRpb25cIik7YT1cImJ0b2FcImluIHdpbmRvdz9idG9hOnJlcXVpcmUoXCJidG9hXCIpLHUuc2V0KFwiQXV0aG9yaXphdGlvblwiLFwiQmFzaWMgXCIrYShcIlwiLmNvbmNhdChzLFwiOlwiKS5jb25jYXQoZikpKX1lbHNlIHUuc2V0KFwiQXV0aG9yaXphdGlvblwiLFwiQmVhcmVyIFwiLmNvbmNhdChjKSk7cmV0dXJuIHV9LGM9ZnVuY3Rpb24odCl7aWYodClyZXR1cm4gT2JqZWN0LmVudHJpZXModCkucmVkdWNlKChmdW5jdGlvbih0LGUscil7dmFyIG89bihlLDIpLGk9b1swXSxjPW9bMV0sdT0wPT09cj9cIlwiLmNvbmNhdChpLFwiPVwiKS5jb25jYXQoZW5jb2RlVVJJQ29tcG9uZW50KGMpKTpcIiZcIi5jb25jYXQoaSxcIj1cIikuY29uY2F0KGVuY29kZVVSSUNvbXBvbmVudChjKSk7cmV0dXJuXCJcIi5jb25jYXQodCkuY29uY2F0KHUpfSksXCJcIil9LHU9ZnVuY3Rpb24odCl7dmFyIGU9dC51cmwscj10LnF1ZXJpZXM7cmV0dXJuIHI/XCJcIi5jb25jYXQoZSxcIj9cIikuY29uY2F0KGMocikpOmV9LGE9ZnVuY3Rpb24odCl7aWYoXCJnZXRcIiE9PXQubWV0aG9kKXt2YXIgZT10LmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpO2lmKGUpcmV0dXJuIGUuaW5jbHVkZXMoXCJ4LXd3dy1mb3JtLXVybGVuY29kZWRcIik/Yyh0LmJvZHkpOmUuaW5jbHVkZXMoXCJqc29uXCIpP0pTT04uc3RyaW5naWZ5KHQuYm9keSk6dC5ib2R5fX0scz1mdW5jdGlvbih0KXtyZXR1cm4gdC5oZWFkZXJzLmVudHJpZXM/ZnVuY3Rpb24odCl7dmFyIGU9e30scj0hMCxvPSExLGk9dm9pZCAwO3RyeXtmb3IodmFyIGMsdT10LmhlYWRlcnMuZW50cmllcygpW1N5bWJvbC5pdGVyYXRvcl0oKTshKHI9KGM9dS5uZXh0KCkpLmRvbmUpO3I9ITApe3ZhciBhPW4oYy52YWx1ZSwyKSxzPWFbMF0sZj1hWzFdO2Vbc109Zn19Y2F0Y2godCl7bz0hMCxpPXR9ZmluYWxseXt0cnl7cnx8bnVsbD09dS5yZXR1cm58fHUucmV0dXJuKCl9ZmluYWxseXtpZihvKXRocm93IGl9fXJldHVybiBlfSh0KTpmdW5jdGlvbih0KXt2YXIgZT17fSxyPXQuaGVhZGVycy5faGVhZGVycztmb3IodmFyIG4gaW4gcillW25dPXJbbl0uam9pbihcIlwiKTtyZXR1cm4gZX0odCl9LGY9ZnVuY3Rpb24odCxlKXt2YXIgcj0oXCJmdW5jdGlvblwiPT10eXBlb2YgdC5jbG9uZT90LmNsb25lKCk6dm9pZCAwKXx8dDtyZXR1cm4gdFtlXSgpLnRoZW4oKGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbih0LGUpe3ZhciByPXtib2R5OmUsaGVhZGVyczpzKHQpLHJlc3BvbnNlOnQsc3RhdHVzOnQuc3RhdHVzLHN0YXR1c1RleHQ6dC5zdGF0dXNUZXh0fTtyZXR1cm4gdC5vaz9Qcm9taXNlLnJlc29sdmUocik6UHJvbWlzZS5yZWplY3Qocil9KHIsdCl9KSl9LGQ9ZnVuY3Rpb24odCl7dmFyIGU9dC5oZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKTtpZihlLmluY2x1ZGVzKFwianNvblwiKSlyZXR1cm4gZih0LFwianNvblwiKTtpZihlLmluY2x1ZGVzKFwidGV4dFwiKSlyZXR1cm4gZih0LFwidGV4dFwiKTtpZihlLmluY2x1ZGVzKFwiaW1hZ2VcIikpcmV0dXJuIGYodCxcImJsb2JcIik7dGhyb3cgbmV3IEVycm9yKFwiemxGZXRjaCBkb2VzIG5vdCBzdXBwb3J0IGNvbnRlbnQtdHlwZSBcIi5jb25jYXQoZSxcIiB5ZXRcIikpfSxsPWZ1bmN0aW9uKHQpe3JldHVyblwiRmFpbGVkIHRvIGZldGNoXCI9PT10Lm1lc3NhZ2U/UHJvbWlzZS5yZWplY3Qoe2Vycm9yOnR9KTpQcm9taXNlLnJlamVjdCh0KX07XCJ1bmRlZmluZWRcIj09dHlwZW9mIGZldGNoJiZyZXF1aXJlKFwiY3Jvc3MtZmV0Y2gvcG9seWZpbGxcIik7Zm9yKHZhciB5PWZ1bmN0aW9uKHQsZSl7dmFyIHI9ZnVuY3Rpb24oKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e30sZT1PYmplY3QuYXNzaWduKHt9LHQpO3JldHVybiBlLnVybD11KGUpLGUubWV0aG9kPWUubWV0aG9kfHxcImdldFwiLGUuaGVhZGVycz1pKGUpLGUuYm9keT1hKGUpLGRlbGV0ZSBlLmF1dGgsZX0oT2JqZWN0LmFzc2lnbih7dXJsOnR9LGUpKTtyZXR1cm4gZmV0Y2goci51cmwscikudGhlbihkKS5jYXRjaChsKX0saD1mdW5jdGlvbigpe3ZhciB0PXZbcF07eVt0XT1mdW5jdGlvbihlLHIpe3JldHVybiByPU9iamVjdC5hc3NpZ24oe21ldGhvZDp0fSxyKSx5KGUscil9fSxwPTAsdj1bXCJnZXRcIixcInBvc3RcIixcInB1dFwiLFwicGF0Y2hcIixcImRlbGV0ZVwiXTtwPHYubGVuZ3RoO3ArKyloKCk7cmV0dXJuIHl9KSk7XG4iLCJpbXBvcnQgemxGZXRjaCBmcm9tICd6bC1mZXRjaCcgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vemVsbHdrL3psLWZldGNoXG5pbXBvcnQgeyBzZXR1cCwgZW5kcG9pbnRzIH0gZnJvbSAnQGNvbmZpZydcblxuY2xhc3MgQVBJU2VydmljZSB7XG4gIC8qKlxuICAgKlxuICAgKiBAdHlwZWRlZiBDb25maWcge3tcbiAgICogICBhZGFwdGVyOiBGdW5jdGlvbiwgKHpsRmV0Y2gpXG4gICAqXG4gICAqICAgYmFzZVBhdGg6IHN0cmluZyxcbiAgICpcbiAgICogICByZXF1ZXN0SW50ZXJjZXB0b3IoW1xuICAgKiAgICAgZW5kcG9pbnQ6IHN0cmluZyxcbiAgICogICAgIHBhcmFtcz86IG9iamVjdCxcbiAgICogICAgIGNvbmZpZz86IG9iamVjdCxcbiAgICogICBdKTogeyp9LFxuICAgKiAgIHJlc3BvbnNlSW50ZXJjZXB0b3IoKSB7XG4gICAqICAgICBib2R5OiB7Kn0sXG4gICAqICAgICBoZWFkZXJzOiBvYmplY3QsXG4gICAqICAgICByZXNwb25zZToge1Jlc3BvbnNlfSxcbiAgICogICAgIHN0YXR1czogbnVtYmVyLFxuICAgKiAgICAgc3RhdHVzVGV4dDogc3RyaW5nLFxuICAgKiAgIH0sXG4gICAqICAgZXJyb3JJbnRlcmNlcHRvcigpIHt7XG4gICAqICAgICBib2R5OiB7Kn0sXG4gICAqICAgICBoZWFkZXJzOiBvYmplY3QsXG4gICAqICAgICByZXNwb25zZToge1Jlc3BvbnNlfSxcbiAgICogICAgIHN0YXR1czogbnVtYmVyLFxuICAgKiAgICAgc3RhdHVzVGV4dDogc3RyaW5nLFxuICAgKiAgIH19LFxuICAgKiB9fVxuICAgKiBAcGFyYW0gY29uZmlnIHtDb25maWd9XG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb25maWcgPSB7fSkge1xuICAgIHRoaXMuX2FkYXB0ZXIgPSBjb25maWcuYWRhcHRlciB8fCB6bEZldGNoXG5cbiAgICB0aGlzLl9iYXNlX3BhdGggPSBjb25maWcuYmFzZVBhdGggPyBjb25maWcuYmFzZVBhdGgucmVwbGFjZSgvXFwvJC8sICcnKSA6ICcnXG5cbiAgICB0aGlzLl9yZXF1ZXN0SW50ZXJjZXB0b3IgPSBjb25maWcucmVxdWVzdEludGVyY2VwdG9yIHx8IChhc3luYyAoLi4uYXJncykgPT4gYXJncylcbiAgICB0aGlzLl9yZXNwb25zZUludGVyY2VwdG9yID0gY29uZmlnLnJlc3BvbnNlSW50ZXJjZXB0b3IgfHwgKGFzeW5jICguLi5hcmdzKSA9PiBhcmdzKVxuICAgIHRoaXMuX2Vycm9ySW50ZXJjZXB0b3IgPSBjb25maWcuZXJyb3JJbnRlcmNlcHRvciB8fCBQcm9taXNlLnJlamVjdFxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSBtZXRob2QgeydnZXQnfCdwdXQnfCdwb3N0J3wnZGVsZXRlJ3wncGF0Y2gnfVxuICAgKiBAcGFyYW0gYXJncyB7KltdfVxuICAgKi9cbiAgZ2V0IG5ld1JlcXVlc3QoKSB7XG4gICAgY29uc3QgbWV0aG9kcyA9IFsnZ2V0JywgJ3B1dCcsICdwb3N0JywgJ2RlbGV0ZScsICdwYXRjaCddXG5cbiAgICByZXR1cm4gbWV0aG9kcy5yZWR1Y2UoKGFjYywgbWV0aG9kKSA9PiB7XG4gICAgICBhY2NbbWV0aG9kXSA9IHRoaXMud2l0aEludGVyY2VwdG9ycy5iaW5kKHRoaXMsIHRoaXMuX2FkYXB0ZXJbbWV0aG9kXSlcbiAgICAgIHJldHVybiBhY2NcbiAgICB9LCB7fSlcbiAgfVxuXG4gIGFzeW5jIHdpdGhJbnRlcmNlcHRvcnMoY2FsbGVyLCAuLi5hcmdzKSB7XG4gICAgY29uc3QgbmV3QXJnczEgPSBhd2FpdCB0aGlzLnJlcXVlc3RJbnRlcmNlcHRvciguLi5hcmdzKVxuICAgIGNvbnN0IG5ld0FyZ3MyID0gYXdhaXQgdGhpcy5fcmVxdWVzdEludGVyY2VwdG9yKC4uLm5ld0FyZ3MxKVxuXG4gICAgcmV0dXJuIGNhbGxlciguLi5uZXdBcmdzMilcbiAgICAgIC50aGVuKGFzeW5jIChyZXNwb25zZSkgPT4ge1xuICAgICAgICBjb25zdCBuZXdSZXNwb25zZSA9IGF3YWl0IHRoaXMuX3Jlc3BvbnNlSW50ZXJjZXB0b3IocmVzcG9uc2UpXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmhhbmRsZVJlc3BvbnNlKG5ld1Jlc3BvbnNlKVxuICAgICAgfSlcbiAgICAgIC5jYXRjaChhc3luYyAocmVqZWN0KSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2Vycm9ySW50ZXJjZXB0b3IocmVqZWN0KVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHRocm93IGVycm9yXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAuY2F0Y2godGhpcy5oYW5kbGVSZWplY3QpXG4gIH1cblxuICBhc3luYyByZXF1ZXN0SW50ZXJjZXB0b3IoLi4uYXJncykge1xuICAgIGlmICh0eXBlb2YgYXJnc1swXSA9PT0gJ3N0cmluZycpIHsgLy8gSWYgVVJMIHRoZW4gY29uY2F0IEJBU0VfUEFUSC5cbiAgICAgIGFyZ3NbMF0gPSBgJHt0aGlzLl9iYXNlX3BhdGh9LyR7YXJnc1swXX1gXG4gICAgfVxuICAgIHJldHVybiBbLi4uYXJnc11cbiAgfVxuXG4gIGFzeW5jIGhhbmRsZVJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmJvZHlcbiAgfVxuXG4gIGFzeW5jIGhhbmRsZVJlamVjdChyZWplY3QpIHtcbiAgICB0aHJvdyByZWplY3RcbiAgfVxufVxuXG4vKipcbiAqXG4gKiBAZGVzY3JpcHRpb24gQVBJIGNsYXNzIGZvciBtYWtpbmcgUkVTVCBBUEkgcmVxdWVzdHMgaW4gYSBicm93c2VyLlxuICovXG5leHBvcnQgY2xhc3MgQXBpQ2xhc3MgZXh0ZW5kcyBBUElTZXJ2aWNlIHtcbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSBjb25maWcge0NvbmZpZ31cbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHN1cGVyKGNvbmZpZylcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAZGVzY3JpcHRpb24gVXNlcnNcbiAgICovXG4gIGdldFVzZXIoaWQsIHBhcmFtcywgY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMubmV3UmVxdWVzdC5nZXQoZW5kcG9pbnRzLlVTRVIoaWQpLCBwYXJhbXMsIGNvbmZpZylcbiAgfVxuXG4gIGdldFVzZXJzKHBhcmFtcywgY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMubmV3UmVxdWVzdC5nZXQoZW5kcG9pbnRzLlVTRVJTKCksIHBhcmFtcywgY29uZmlnKVxuICB9XG5cbiAgcG9zdFVzZXIoaWQsIGJvZHksIGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLm5ld1JlcXVlc3QucG9zdChlbmRwb2ludHMuVVNFUihpZCksIGJvZHksIGNvbmZpZylcbiAgfVxuXG4gIHB1dFVzZXIoaWQsIGJvZHksIGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLm5ld1JlcXVlc3QucHV0KGVuZHBvaW50cy5VU0VSKGlkKSwgYm9keSwgY29uZmlnKVxuICB9XG5cbiAgZGVsZXRlVXNlcihpZCwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMubmV3UmVxdWVzdC5kZWxldGUoZW5kcG9pbnRzLlVTRVIoaWQpLCBjb25maWcpXG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uIFJlY2VudFxuICAgKi9cbiAgZ2V0UmVjZW50KGlkLCBwYXJhbXMsIGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLm5ld1JlcXVlc3QuZ2V0KGVuZHBvaW50cy5SRUNFTlQoaWQpLCBwYXJhbXMsIGNvbmZpZylcbiAgfVxuXG4gIGdldFJlY2VudHMocGFyYW1zLCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5uZXdSZXF1ZXN0LmdldChlbmRwb2ludHMuUkVDRU5UUygpLCBwYXJhbXMsIGNvbmZpZylcbiAgfVxuXG4gIHBvc3RSZWNlbnQoaWQsIGJvZHksIGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLm5ld1JlcXVlc3QucG9zdChlbmRwb2ludHMuUkVDRU5UKGlkKSwgYm9keSwgY29uZmlnKVxuICB9XG5cbiAgcHV0UmVjZW50KGlkLCBib2R5LCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5uZXdSZXF1ZXN0LnB1dChlbmRwb2ludHMuUkVDRU5UKGlkKSwgYm9keSwgY29uZmlnKVxuICB9XG5cbiAgZGVsZXRlUmVjZW50KGlkLCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5uZXdSZXF1ZXN0LmRlbGV0ZShlbmRwb2ludHMuUkVDRU5UKGlkKSwgY29uZmlnKVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvbiBDb21tZW50c1xuICAgKi9cbiAgZ2V0Q29tbWVudChpZCwgcGFyYW1zLCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5uZXdSZXF1ZXN0LmdldChlbmRwb2ludHMuQ09NTUVOVChpZCksIHBhcmFtcywgY29uZmlnKVxuICB9XG5cbiAgZ2V0Q29tbWVudHMocGFyYW1zLCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5uZXdSZXF1ZXN0LmdldChlbmRwb2ludHMuQ09NTUVOVFMoKSwgcGFyYW1zLCBjb25maWcpXG4gIH1cblxuICBwb3N0Q29tbWVudChpZCwgYm9keSwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMubmV3UmVxdWVzdC5wb3N0KGVuZHBvaW50cy5DT01NRU5UKGlkKSwgYm9keSwgY29uZmlnKVxuICB9XG5cbiAgcHV0Q29tbWVudChpZCwgYm9keSwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMubmV3UmVxdWVzdC5wdXQoZW5kcG9pbnRzLkNPTU1FTlQoaWQpLCBib2R5LCBjb25maWcpXG4gIH1cblxuICBkZWxldGVDb21tZW50KGlkLCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5uZXdSZXF1ZXN0LmRlbGV0ZShlbmRwb2ludHMuQ09NTUVOVChpZCksIGNvbmZpZylcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAZGVzY3JpcHRpb24gRnVuZFxuICAgKi9cbiAgZ2V0RnVuZChpZCwgcGFyYW1zLCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5uZXdSZXF1ZXN0LmdldChlbmRwb2ludHMuRlVORChpZCksIHBhcmFtcywgY29uZmlnKVxuICB9XG5cbiAgZ2V0RnVuZHMocGFyYW1zLCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5uZXdSZXF1ZXN0LmdldChlbmRwb2ludHMuRlVORFMoKSwgcGFyYW1zLCBjb25maWcpXG4gIH1cblxuICBwb3N0RnVuZChpZCwgYm9keSwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMubmV3UmVxdWVzdC5wb3N0KGVuZHBvaW50cy5GVU5EKGlkKSwgYm9keSwgY29uZmlnKVxuICB9XG5cbiAgcHV0RnVuZChpZCwgYm9keSwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMubmV3UmVxdWVzdC5wdXQoZW5kcG9pbnRzLkZVTkQoaWQpLCBib2R5LCBjb25maWcpXG4gIH1cblxuICBkZWxldGVGdW5kKGlkLCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5uZXdSZXF1ZXN0LmRlbGV0ZShlbmRwb2ludHMuRlVORChpZCksIGNvbmZpZylcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAZGVzY3JpcHRpb24gT3JnYW5pemF0aW9uXG4gICAqL1xuICBnZXRPcmdhbml6YXRpb24oaWQsIHBhcmFtcywgY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMubmV3UmVxdWVzdC5nZXQoZW5kcG9pbnRzLk9SR0FOSVpBVElPTihpZCksIHBhcmFtcywgY29uZmlnKVxuICB9XG5cbiAgZ2V0T3JnYW5pemF0aW9ucyhwYXJhbXMsIGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLm5ld1JlcXVlc3QuZ2V0KGVuZHBvaW50cy5PUkdBTklaQVRJT05TKCksIHBhcmFtcywgY29uZmlnKVxuICB9XG5cbiAgcG9zdE9yZ2FuaXphdGlvbihpZCwgYm9keSwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMubmV3UmVxdWVzdC5wb3N0KGVuZHBvaW50cy5PUkdBTklaQVRJT04oaWQpLCBib2R5LCBjb25maWcpXG4gIH1cblxuICBwdXRPcmdhbml6YXRpb24oaWQsIGJvZHksIGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLm5ld1JlcXVlc3QucHV0KGVuZHBvaW50cy5PUkdBTklaQVRJT04oaWQpLCBib2R5LCBjb25maWcpXG4gIH1cblxuICBkZWxldGVPcmdhbml6YXRpb24oaWQsIGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLm5ld1JlcXVlc3QuZGVsZXRlKGVuZHBvaW50cy5PUkdBTklaQVRJT04oaWQpLCBjb25maWcpXG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uIE1lZGlhXG4gICAqL1xuICB1cGxvYWRJbWFnZShib2R5LCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5uZXdSZXF1ZXN0LnBvc3QoZW5kcG9pbnRzLklNQUdFU19VUExPQUQoKSwgYm9keSwgY29uZmlnKVxuICB9XG5cbn1cblxuLyoqXG4gKlxuICogQGNvbnN0cnVjdG9yIHtDb25maWd9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IG5ldyBBcGlDbGFzcyh7XG4gIGJhc2VQYXRoOiBzZXR1cC5CQUNLRU5EX1VSTCxcbiAgcmVzcG9uc2VJbnRlcmNlcHRvcjogcmVzID0+IChjb25zb2xlLmluZm8oJ3Jlc3BvbnNlIC0tLS0tLS1cXG4nLCByZXMpLCByZXMpLFxuICBlcnJvckludGVyY2VwdG9yOiByZWogPT4ge1xuICAgIGNvbnNvbGUud2FybigncmVxdWVzdCBlcnJvciAtLS0tLS0tXFxuJywgcmVqKVxuXG4gICAgaWYgKHJlaiAmJiByZWouZXJyb3IgJiYgcmVqLmVycm9yLm1lc3NhZ2UgPT09ICdGYWlsZWQgdG8gZmV0Y2gnKSB7XG4gICAgICBjb25zb2xlLmxvZygnTG9zdCBpbnRlcm5ldCBjb25uZWN0aW9uJylcbiAgICAgIHNob3dPZmZsaW5lTWVzc2FnZSgpXG4gICAgfVxuXG4gICAgdGhyb3cgcmVqXG4gIH0sXG59KVxuXG5mdW5jdGlvbiBzaG93T2ZmbGluZU1lc3NhZ2UoKSB7XG4gIHRyeSB7XG4gICAgbGV0IHRpbWVyID0gbnVsbFxuICAgIGNvbnN0IG9mZmxpbmVFbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNvZmZsaW5lLW1lc3NhZ2UnKVxuICAgIGlmICghdGltZXIpIHtcbiAgICAgIG9mZmxpbmVFbC5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKVxuICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgb2ZmbGluZUVsLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpXG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcilcbiAgICAgIH0sIDUwMDApXG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLndhcm4oZXJyKVxuICB9XG59XG4iLCIhZnVuY3Rpb24odCxlKXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz1lKCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShlKTp0LmRheWpzPWUoKX0odGhpcyxmdW5jdGlvbigpe1widXNlIHN0cmljdFwiO3ZhciB0PVwibWlsbGlzZWNvbmRcIixlPVwic2Vjb25kXCIsbj1cIm1pbnV0ZVwiLHI9XCJob3VyXCIsaT1cImRheVwiLHM9XCJ3ZWVrXCIsdT1cIm1vbnRoXCIsYT1cInF1YXJ0ZXJcIixvPVwieWVhclwiLGg9L14oXFxkezR9KS0/KFxcZHsxLDJ9KT8tPyhcXGR7MCwyfSlbXjAtOV0qKFxcZHsxLDJ9KT86PyhcXGR7MSwyfSk/Oj8oXFxkezEsMn0pPy4/KFxcZHsxLDN9KT8kLyxmPS9cXFsoW15cXF1dKyldfFl7Miw0fXxNezEsNH18RHsxLDJ9fGR7MSw0fXxIezEsMn18aHsxLDJ9fGF8QXxtezEsMn18c3sxLDJ9fFp7MSwyfXxTU1MvZyxjPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1TdHJpbmcodCk7cmV0dXJuIXJ8fHIubGVuZ3RoPj1lP3Q6XCJcIitBcnJheShlKzEtci5sZW5ndGgpLmpvaW4obikrdH0sZD17czpjLHo6ZnVuY3Rpb24odCl7dmFyIGU9LXQudXRjT2Zmc2V0KCksbj1NYXRoLmFicyhlKSxyPU1hdGguZmxvb3Iobi82MCksaT1uJTYwO3JldHVybihlPD0wP1wiK1wiOlwiLVwiKStjKHIsMixcIjBcIikrXCI6XCIrYyhpLDIsXCIwXCIpfSxtOmZ1bmN0aW9uKHQsZSl7dmFyIG49MTIqKGUueWVhcigpLXQueWVhcigpKSsoZS5tb250aCgpLXQubW9udGgoKSkscj10LmNsb25lKCkuYWRkKG4sdSksaT1lLXI8MCxzPXQuY2xvbmUoKS5hZGQobisoaT8tMToxKSx1KTtyZXR1cm4gTnVtYmVyKC0obisoZS1yKS8oaT9yLXM6cy1yKSl8fDApfSxhOmZ1bmN0aW9uKHQpe3JldHVybiB0PDA/TWF0aC5jZWlsKHQpfHwwOk1hdGguZmxvb3IodCl9LHA6ZnVuY3Rpb24oaCl7cmV0dXJue006dSx5Om8sdzpzLGQ6aSxEOlwiZGF0ZVwiLGg6cixtOm4sczplLG1zOnQsUTphfVtoXXx8U3RyaW5nKGh8fFwiXCIpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvcyQvLFwiXCIpfSx1OmZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDA9PT10fX0sJD17bmFtZTpcImVuXCIsd2Vla2RheXM6XCJTdW5kYXlfTW9uZGF5X1R1ZXNkYXlfV2VkbmVzZGF5X1RodXJzZGF5X0ZyaWRheV9TYXR1cmRheVwiLnNwbGl0KFwiX1wiKSxtb250aHM6XCJKYW51YXJ5X0ZlYnJ1YXJ5X01hcmNoX0FwcmlsX01heV9KdW5lX0p1bHlfQXVndXN0X1NlcHRlbWJlcl9PY3RvYmVyX05vdmVtYmVyX0RlY2VtYmVyXCIuc3BsaXQoXCJfXCIpfSxsPVwiZW5cIixtPXt9O21bbF09JDt2YXIgeT1mdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIHZ9LE09ZnVuY3Rpb24odCxlLG4pe3ZhciByO2lmKCF0KXJldHVybiBsO2lmKFwic3RyaW5nXCI9PXR5cGVvZiB0KW1bdF0mJihyPXQpLGUmJihtW3RdPWUscj10KTtlbHNle3ZhciBpPXQubmFtZTttW2ldPXQscj1pfXJldHVybiFuJiZyJiYobD1yKSxyfHwhbiYmbH0sZz1mdW5jdGlvbih0LGUpe2lmKHkodCkpcmV0dXJuIHQuY2xvbmUoKTt2YXIgbj1cIm9iamVjdFwiPT10eXBlb2YgZT9lOnt9O3JldHVybiBuLmRhdGU9dCxuLmFyZ3M9YXJndW1lbnRzLG5ldyB2KG4pfSxEPWQ7RC5sPU0sRC5pPXksRC53PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGcodCx7bG9jYWxlOmUuJEwsdXRjOmUuJHUsJG9mZnNldDplLiRvZmZzZXR9KX07dmFyIHY9ZnVuY3Rpb24oKXtmdW5jdGlvbiBjKHQpe3RoaXMuJEw9dGhpcy4kTHx8TSh0LmxvY2FsZSxudWxsLCEwKSx0aGlzLnBhcnNlKHQpfXZhciBkPWMucHJvdG90eXBlO3JldHVybiBkLnBhcnNlPWZ1bmN0aW9uKHQpe3RoaXMuJGQ9ZnVuY3Rpb24odCl7dmFyIGU9dC5kYXRlLG49dC51dGM7aWYobnVsbD09PWUpcmV0dXJuIG5ldyBEYXRlKE5hTik7aWYoRC51KGUpKXJldHVybiBuZXcgRGF0ZTtpZihlIGluc3RhbmNlb2YgRGF0ZSlyZXR1cm4gbmV3IERhdGUoZSk7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUmJiEvWiQvaS50ZXN0KGUpKXt2YXIgcj1lLm1hdGNoKGgpO2lmKHIpe3ZhciBpPXJbMl0tMXx8MDtyZXR1cm4gbj9uZXcgRGF0ZShEYXRlLlVUQyhyWzFdLGksclszXXx8MSxyWzRdfHwwLHJbNV18fDAscls2XXx8MCxyWzddfHwwKSk6bmV3IERhdGUoclsxXSxpLHJbM118fDEscls0XXx8MCxyWzVdfHwwLHJbNl18fDAscls3XXx8MCl9fXJldHVybiBuZXcgRGF0ZShlKX0odCksdGhpcy5pbml0KCl9LGQuaW5pdD1mdW5jdGlvbigpe3ZhciB0PXRoaXMuJGQ7dGhpcy4keT10LmdldEZ1bGxZZWFyKCksdGhpcy4kTT10LmdldE1vbnRoKCksdGhpcy4kRD10LmdldERhdGUoKSx0aGlzLiRXPXQuZ2V0RGF5KCksdGhpcy4kSD10LmdldEhvdXJzKCksdGhpcy4kbT10LmdldE1pbnV0ZXMoKSx0aGlzLiRzPXQuZ2V0U2Vjb25kcygpLHRoaXMuJG1zPXQuZ2V0TWlsbGlzZWNvbmRzKCl9LGQuJHV0aWxzPWZ1bmN0aW9uKCl7cmV0dXJuIER9LGQuaXNWYWxpZD1mdW5jdGlvbigpe3JldHVybiEoXCJJbnZhbGlkIERhdGVcIj09PXRoaXMuJGQudG9TdHJpbmcoKSl9LGQuaXNTYW1lPWZ1bmN0aW9uKHQsZSl7dmFyIG49Zyh0KTtyZXR1cm4gdGhpcy5zdGFydE9mKGUpPD1uJiZuPD10aGlzLmVuZE9mKGUpfSxkLmlzQWZ0ZXI9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZyh0KTx0aGlzLnN0YXJ0T2YoZSl9LGQuaXNCZWZvcmU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5lbmRPZihlKTxnKHQpfSxkLiRnPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gRC51KHQpP3RoaXNbZV06dGhpcy5zZXQobix0KX0sZC55ZWFyPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLiRnKHQsXCIkeVwiLG8pfSxkLm1vbnRoPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLiRnKHQsXCIkTVwiLHUpfSxkLmRheT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy4kZyh0LFwiJFdcIixpKX0sZC5kYXRlPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLiRnKHQsXCIkRFwiLFwiZGF0ZVwiKX0sZC5ob3VyPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLiRnKHQsXCIkSFwiLHIpfSxkLm1pbnV0ZT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy4kZyh0LFwiJG1cIixuKX0sZC5zZWNvbmQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuJGcodCxcIiRzXCIsZSl9LGQubWlsbGlzZWNvbmQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuJGcoZSxcIiRtc1wiLHQpfSxkLnVuaXg9ZnVuY3Rpb24oKXtyZXR1cm4gTWF0aC5mbG9vcih0aGlzLnZhbHVlT2YoKS8xZTMpfSxkLnZhbHVlT2Y9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy4kZC5nZXRUaW1lKCl9LGQuc3RhcnRPZj1mdW5jdGlvbih0LGEpe3ZhciBoPXRoaXMsZj0hIUQudShhKXx8YSxjPUQucCh0KSxkPWZ1bmN0aW9uKHQsZSl7dmFyIG49RC53KGguJHU/RGF0ZS5VVEMoaC4keSxlLHQpOm5ldyBEYXRlKGguJHksZSx0KSxoKTtyZXR1cm4gZj9uOm4uZW5kT2YoaSl9LCQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gRC53KGgudG9EYXRlKClbdF0uYXBwbHkoaC50b0RhdGUoXCJzXCIpLChmP1swLDAsMCwwXTpbMjMsNTksNTksOTk5XSkuc2xpY2UoZSkpLGgpfSxsPXRoaXMuJFcsbT10aGlzLiRNLHk9dGhpcy4kRCxNPVwic2V0XCIrKHRoaXMuJHU/XCJVVENcIjpcIlwiKTtzd2l0Y2goYyl7Y2FzZSBvOnJldHVybiBmP2QoMSwwKTpkKDMxLDExKTtjYXNlIHU6cmV0dXJuIGY/ZCgxLG0pOmQoMCxtKzEpO2Nhc2Ugczp2YXIgZz10aGlzLiRsb2NhbGUoKS53ZWVrU3RhcnR8fDAsdj0obDxnP2wrNzpsKS1nO3JldHVybiBkKGY/eS12OnkrKDYtdiksbSk7Y2FzZSBpOmNhc2VcImRhdGVcIjpyZXR1cm4gJChNK1wiSG91cnNcIiwwKTtjYXNlIHI6cmV0dXJuICQoTStcIk1pbnV0ZXNcIiwxKTtjYXNlIG46cmV0dXJuICQoTStcIlNlY29uZHNcIiwyKTtjYXNlIGU6cmV0dXJuICQoTStcIk1pbGxpc2Vjb25kc1wiLDMpO2RlZmF1bHQ6cmV0dXJuIHRoaXMuY2xvbmUoKX19LGQuZW5kT2Y9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuc3RhcnRPZih0LCExKX0sZC4kc2V0PWZ1bmN0aW9uKHMsYSl7dmFyIGgsZj1ELnAocyksYz1cInNldFwiKyh0aGlzLiR1P1wiVVRDXCI6XCJcIiksZD0oaD17fSxoW2ldPWMrXCJEYXRlXCIsaC5kYXRlPWMrXCJEYXRlXCIsaFt1XT1jK1wiTW9udGhcIixoW29dPWMrXCJGdWxsWWVhclwiLGhbcl09YytcIkhvdXJzXCIsaFtuXT1jK1wiTWludXRlc1wiLGhbZV09YytcIlNlY29uZHNcIixoW3RdPWMrXCJNaWxsaXNlY29uZHNcIixoKVtmXSwkPWY9PT1pP3RoaXMuJEQrKGEtdGhpcy4kVyk6YTtpZihmPT09dXx8Zj09PW8pe3ZhciBsPXRoaXMuY2xvbmUoKS5zZXQoXCJkYXRlXCIsMSk7bC4kZFtkXSgkKSxsLmluaXQoKSx0aGlzLiRkPWwuc2V0KFwiZGF0ZVwiLE1hdGgubWluKHRoaXMuJEQsbC5kYXlzSW5Nb250aCgpKSkuJGR9ZWxzZSBkJiZ0aGlzLiRkW2RdKCQpO3JldHVybiB0aGlzLmluaXQoKSx0aGlzfSxkLnNldD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmNsb25lKCkuJHNldCh0LGUpfSxkLmdldD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpc1tELnAodCldKCl9LGQuYWRkPWZ1bmN0aW9uKHQsYSl7dmFyIGgsZj10aGlzO3Q9TnVtYmVyKHQpO3ZhciBjPUQucChhKSxkPWZ1bmN0aW9uKGUpe3ZhciBuPWcoZik7cmV0dXJuIEQudyhuLmRhdGUobi5kYXRlKCkrTWF0aC5yb3VuZChlKnQpKSxmKX07aWYoYz09PXUpcmV0dXJuIHRoaXMuc2V0KHUsdGhpcy4kTSt0KTtpZihjPT09bylyZXR1cm4gdGhpcy5zZXQobyx0aGlzLiR5K3QpO2lmKGM9PT1pKXJldHVybiBkKDEpO2lmKGM9PT1zKXJldHVybiBkKDcpO3ZhciAkPShoPXt9LGhbbl09NmU0LGhbcl09MzZlNSxoW2VdPTFlMyxoKVtjXXx8MSxsPXRoaXMuJGQuZ2V0VGltZSgpK3QqJDtyZXR1cm4gRC53KGwsdGhpcyl9LGQuc3VidHJhY3Q9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5hZGQoLTEqdCxlKX0sZC5mb3JtYXQ9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcztpZighdGhpcy5pc1ZhbGlkKCkpcmV0dXJuXCJJbnZhbGlkIERhdGVcIjt2YXIgbj10fHxcIllZWVktTU0tRERUSEg6bW06c3NaXCIscj1ELnoodGhpcyksaT10aGlzLiRsb2NhbGUoKSxzPXRoaXMuJEgsdT10aGlzLiRtLGE9dGhpcy4kTSxvPWkud2Vla2RheXMsaD1pLm1vbnRocyxjPWZ1bmN0aW9uKHQscixpLHMpe3JldHVybiB0JiYodFtyXXx8dChlLG4pKXx8aVtyXS5zdWJzdHIoMCxzKX0sZD1mdW5jdGlvbih0KXtyZXR1cm4gRC5zKHMlMTJ8fDEyLHQsXCIwXCIpfSwkPWkubWVyaWRpZW18fGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj10PDEyP1wiQU1cIjpcIlBNXCI7cmV0dXJuIG4/ci50b0xvd2VyQ2FzZSgpOnJ9LGw9e1lZOlN0cmluZyh0aGlzLiR5KS5zbGljZSgtMiksWVlZWTp0aGlzLiR5LE06YSsxLE1NOkQucyhhKzEsMixcIjBcIiksTU1NOmMoaS5tb250aHNTaG9ydCxhLGgsMyksTU1NTTpjKGgsYSksRDp0aGlzLiRELEREOkQucyh0aGlzLiRELDIsXCIwXCIpLGQ6U3RyaW5nKHRoaXMuJFcpLGRkOmMoaS53ZWVrZGF5c01pbix0aGlzLiRXLG8sMiksZGRkOmMoaS53ZWVrZGF5c1Nob3J0LHRoaXMuJFcsbywzKSxkZGRkOm9bdGhpcy4kV10sSDpTdHJpbmcocyksSEg6RC5zKHMsMixcIjBcIiksaDpkKDEpLGhoOmQoMiksYTokKHMsdSwhMCksQTokKHMsdSwhMSksbTpTdHJpbmcodSksbW06RC5zKHUsMixcIjBcIiksczpTdHJpbmcodGhpcy4kcyksc3M6RC5zKHRoaXMuJHMsMixcIjBcIiksU1NTOkQucyh0aGlzLiRtcywzLFwiMFwiKSxaOnJ9O3JldHVybiBuLnJlcGxhY2UoZixmdW5jdGlvbih0LGUpe3JldHVybiBlfHxsW3RdfHxyLnJlcGxhY2UoXCI6XCIsXCJcIil9KX0sZC51dGNPZmZzZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gMTUqLU1hdGgucm91bmQodGhpcy4kZC5nZXRUaW1lem9uZU9mZnNldCgpLzE1KX0sZC5kaWZmPWZ1bmN0aW9uKHQsaCxmKXt2YXIgYyxkPUQucChoKSwkPWcodCksbD02ZTQqKCQudXRjT2Zmc2V0KCktdGhpcy51dGNPZmZzZXQoKSksbT10aGlzLSQseT1ELm0odGhpcywkKTtyZXR1cm4geT0oYz17fSxjW29dPXkvMTIsY1t1XT15LGNbYV09eS8zLGNbc109KG0tbCkvNjA0OGU1LGNbaV09KG0tbCkvODY0ZTUsY1tyXT1tLzM2ZTUsY1tuXT1tLzZlNCxjW2VdPW0vMWUzLGMpW2RdfHxtLGY/eTpELmEoeSl9LGQuZGF5c0luTW9udGg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lbmRPZih1KS4kRH0sZC4kbG9jYWxlPWZ1bmN0aW9uKCl7cmV0dXJuIG1bdGhpcy4kTF19LGQubG9jYWxlPWZ1bmN0aW9uKHQsZSl7aWYoIXQpcmV0dXJuIHRoaXMuJEw7dmFyIG49dGhpcy5jbG9uZSgpLHI9TSh0LGUsITApO3JldHVybiByJiYobi4kTD1yKSxufSxkLmNsb25lPWZ1bmN0aW9uKCl7cmV0dXJuIEQudyh0aGlzLiRkLHRoaXMpfSxkLnRvRGF0ZT1mdW5jdGlvbigpe3JldHVybiBuZXcgRGF0ZSh0aGlzLnZhbHVlT2YoKSl9LGQudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNWYWxpZCgpP3RoaXMudG9JU09TdHJpbmcoKTpudWxsfSxkLnRvSVNPU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuJGQudG9JU09TdHJpbmcoKX0sZC50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLiRkLnRvVVRDU3RyaW5nKCl9LGN9KCk7cmV0dXJuIGcucHJvdG90eXBlPXYucHJvdG90eXBlLGcuZXh0ZW5kPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQoZSx2LGcpLGd9LGcubG9jYWxlPU0sZy5pc0RheWpzPXksZy51bml4PWZ1bmN0aW9uKHQpe3JldHVybiBnKDFlMyp0KX0sZy5lbj1tW2xdLGcuTHM9bSxnfSk7XG4iLCIhZnVuY3Rpb24ocix0KXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz10KCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZSh0KTpyLmRheWpzX3BsdWdpbl9yZWxhdGl2ZVRpbWU9dCgpfSh0aGlzLGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7cmV0dXJuIGZ1bmN0aW9uKHIsdCxlKXtyPXJ8fHt9O3ZhciBuPXQucHJvdG90eXBlLG89e2Z1dHVyZTpcImluICVzXCIscGFzdDpcIiVzIGFnb1wiLHM6XCJhIGZldyBzZWNvbmRzXCIsbTpcImEgbWludXRlXCIsbW06XCIlZCBtaW51dGVzXCIsaDpcImFuIGhvdXJcIixoaDpcIiVkIGhvdXJzXCIsZDpcImEgZGF5XCIsZGQ6XCIlZCBkYXlzXCIsTTpcImEgbW9udGhcIixNTTpcIiVkIG1vbnRoc1wiLHk6XCJhIHllYXJcIix5eTpcIiVkIHllYXJzXCJ9O2UuZW4ucmVsYXRpdmVUaW1lPW87dmFyIGQ9ZnVuY3Rpb24odCxuLGQsaSl7Zm9yKHZhciB1LGEscyxmPWQuJGxvY2FsZSgpLnJlbGF0aXZlVGltZXx8byxsPXIudGhyZXNob2xkc3x8W3tsOlwic1wiLHI6NDQsZDpcInNlY29uZFwifSx7bDpcIm1cIixyOjg5fSx7bDpcIm1tXCIscjo0NCxkOlwibWludXRlXCJ9LHtsOlwiaFwiLHI6ODl9LHtsOlwiaGhcIixyOjIxLGQ6XCJob3VyXCJ9LHtsOlwiZFwiLHI6MzV9LHtsOlwiZGRcIixyOjI1LGQ6XCJkYXlcIn0se2w6XCJNXCIscjo0NX0se2w6XCJNTVwiLHI6MTAsZDpcIm1vbnRoXCJ9LHtsOlwieVwiLHI6MTd9LHtsOlwieXlcIixkOlwieWVhclwifV0saD1sLmxlbmd0aCxtPTA7bTxoO20rPTEpe3ZhciBjPWxbbV07Yy5kJiYodT1pP2UodCkuZGlmZihkLGMuZCwhMCk6ZC5kaWZmKHQsYy5kLCEwKSk7dmFyIHk9KHIucm91bmRpbmd8fE1hdGgucm91bmQpKE1hdGguYWJzKHUpKTtpZihzPXU+MCx5PD1jLnJ8fCFjLnIpe3k8PTEmJm0+MCYmKGM9bFttLTFdKTt2YXIgcD1mW2MubF07YT1cInN0cmluZ1wiPT10eXBlb2YgcD9wLnJlcGxhY2UoXCIlZFwiLHkpOnAoeSxuLGMubCxzKTticmVha319cmV0dXJuIG4/YToocz9mLmZ1dHVyZTpmLnBhc3QpLnJlcGxhY2UoXCIlc1wiLGEpfTtuLnRvPWZ1bmN0aW9uKHIsdCl7cmV0dXJuIGQocix0LHRoaXMsITApfSxuLmZyb209ZnVuY3Rpb24ocix0KXtyZXR1cm4gZChyLHQsdGhpcyl9O3ZhciBpPWZ1bmN0aW9uKHIpe3JldHVybiByLiR1P2UudXRjKCk6ZSgpfTtuLnRvTm93PWZ1bmN0aW9uKHIpe3JldHVybiB0aGlzLnRvKGkodGhpcykscil9LG4uZnJvbU5vdz1mdW5jdGlvbihyKXtyZXR1cm4gdGhpcy5mcm9tKGkodGhpcykscil9fX0pO1xuIiwiIWZ1bmN0aW9uKHQsaSl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9aSgpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoaSk6dC5kYXlqc19wbHVnaW5fdXRjPWkoKX0odGhpcyxmdW5jdGlvbigpe1widXNlIHN0cmljdFwiO3JldHVybiBmdW5jdGlvbih0LGksZSl7dmFyIHM9KG5ldyBEYXRlKS5nZXRUaW1lem9uZU9mZnNldCgpLG49aS5wcm90b3R5cGU7ZS51dGM9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBpKHtkYXRlOnQsdXRjOiEwLGFyZ3M6YXJndW1lbnRzfSl9LG4udXRjPWZ1bmN0aW9uKCl7cmV0dXJuIGUodGhpcy50b0RhdGUoKSx7bG9jYWxlOnRoaXMuJEwsdXRjOiEwfSl9LG4ubG9jYWw9ZnVuY3Rpb24oKXtyZXR1cm4gZSh0aGlzLnRvRGF0ZSgpLHtsb2NhbGU6dGhpcy4kTCx1dGM6ITF9KX07dmFyIHU9bi5wYXJzZTtuLnBhcnNlPWZ1bmN0aW9uKHQpe3QudXRjJiYodGhpcy4kdT0hMCksdGhpcy4kdXRpbHMoKS51KHQuJG9mZnNldCl8fCh0aGlzLiRvZmZzZXQ9dC4kb2Zmc2V0KSx1LmNhbGwodGhpcyx0KX07dmFyIG89bi5pbml0O24uaW5pdD1mdW5jdGlvbigpe2lmKHRoaXMuJHUpe3ZhciB0PXRoaXMuJGQ7dGhpcy4keT10LmdldFVUQ0Z1bGxZZWFyKCksdGhpcy4kTT10LmdldFVUQ01vbnRoKCksdGhpcy4kRD10LmdldFVUQ0RhdGUoKSx0aGlzLiRXPXQuZ2V0VVRDRGF5KCksdGhpcy4kSD10LmdldFVUQ0hvdXJzKCksdGhpcy4kbT10LmdldFVUQ01pbnV0ZXMoKSx0aGlzLiRzPXQuZ2V0VVRDU2Vjb25kcygpLHRoaXMuJG1zPXQuZ2V0VVRDTWlsbGlzZWNvbmRzKCl9ZWxzZSBvLmNhbGwodGhpcyl9O3ZhciBmPW4udXRjT2Zmc2V0O24udXRjT2Zmc2V0PWZ1bmN0aW9uKHQpe3ZhciBpPXRoaXMuJHV0aWxzKCkudTtpZihpKHQpKXJldHVybiB0aGlzLiR1PzA6aSh0aGlzLiRvZmZzZXQpP2YuY2FsbCh0aGlzKTp0aGlzLiRvZmZzZXQ7dmFyIGUsbj1NYXRoLmFicyh0KTw9MTY/NjAqdDp0O3JldHVybiAwIT09dD8oZT10aGlzLmxvY2FsKCkuYWRkKG4rcyxcIm1pbnV0ZVwiKSkuJG9mZnNldD1uOmU9dGhpcy51dGMoKSxlfTt2YXIgcj1uLmZvcm1hdDtuLmZvcm1hdD1mdW5jdGlvbih0KXt2YXIgaT10fHwodGhpcy4kdT9cIllZWVktTU0tRERUSEg6bW06c3NbWl1cIjpcIlwiKTtyZXR1cm4gci5jYWxsKHRoaXMsaSl9LG4udmFsdWVPZj1mdW5jdGlvbigpe3ZhciB0PXRoaXMuJHV0aWxzKCkudSh0aGlzLiRvZmZzZXQpPzA6dGhpcy4kb2Zmc2V0K3M7cmV0dXJuIHRoaXMuJGQudmFsdWVPZigpLTZlNCp0fSxuLmlzVVRDPWZ1bmN0aW9uKCl7cmV0dXJuISF0aGlzLiR1fSxuLnRvSVNPU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudG9EYXRlKCkudG9JU09TdHJpbmcoKX0sbi50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRvRGF0ZSgpLnRvVVRDU3RyaW5nKCl9O3ZhciBhPW4udG9EYXRlO24udG9EYXRlPWZ1bmN0aW9uKHQpe3JldHVyblwic1wiPT09dCYmdGhpcy4kb2Zmc2V0P2UodGhpcy5mb3JtYXQoXCJZWVlZLU1NLUREIEhIOm1tOnNzOlNTU1wiKSkudG9EYXRlKCk6YS5jYWxsKHRoaXMpfX19KTtcbiIsIiFmdW5jdGlvbihlLHQpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPXQoKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKHQpOmUuZGF5anNfcGx1Z2luX3dlZWtkYXk9dCgpfSh0aGlzLGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7cmV0dXJuIGZ1bmN0aW9uKGUsdCl7dC5wcm90b3R5cGUud2Vla2RheT1mdW5jdGlvbihlKXt2YXIgdD10aGlzLiRsb2NhbGUoKS53ZWVrU3RhcnR8fDAsbj10aGlzLiRXLGk9KG48dD9uKzc6biktdDtyZXR1cm4gdGhpcy4kdXRpbHMoKS51KGUpP2k6dGhpcy5zdWJ0cmFjdChpLFwiZGF5XCIpLmFkZChlLFwiZGF5XCIpfX19KTtcbiIsIiFmdW5jdGlvbihlLG4pe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPW4oKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKG4pOmUuZGF5anNfbG9jYWxlX2VuPW4oKX0odGhpcyxmdW5jdGlvbigpe1widXNlIHN0cmljdFwiO3JldHVybntuYW1lOlwiZW5cIix3ZWVrZGF5czpcIlN1bmRheV9Nb25kYXlfVHVlc2RheV9XZWRuZXNkYXlfVGh1cnNkYXlfRnJpZGF5X1NhdHVyZGF5XCIuc3BsaXQoXCJfXCIpLG1vbnRoczpcIkphbnVhcnlfRmVicnVhcnlfTWFyY2hfQXByaWxfTWF5X0p1bmVfSnVseV9BdWd1c3RfU2VwdGVtYmVyX09jdG9iZXJfTm92ZW1iZXJfRGVjZW1iZXJcIi5zcGxpdChcIl9cIil9fSk7XG4iLCIhZnVuY3Rpb24oXyx0KXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz10KHJlcXVpcmUoXCJkYXlqc1wiKSk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXCJkYXlqc1wiXSx0KTpfLmRheWpzX2xvY2FsZV9ydT10KF8uZGF5anMpfSh0aGlzLGZ1bmN0aW9uKF8pe1widXNlIHN0cmljdFwiO189XyYmXy5oYXNPd25Qcm9wZXJ0eShcImRlZmF1bHRcIik/Xy5kZWZhdWx0Ol87dmFyIHQ9XCLRj9C90LLQsNGA0Y9f0YTQtdCy0YDQsNC70Y9f0LzQsNGA0YLQsF/QsNC/0YDQtdC70Y9f0LzQsNGPX9C40Y7QvdGPX9C40Y7Qu9GPX9Cw0LLQs9GD0YHRgtCwX9GB0LXQvdGC0Y/QsdGA0Y9f0L7QutGC0Y/QsdGA0Y9f0L3QvtGP0LHRgNGPX9C00LXQutCw0LHRgNGPXCIuc3BsaXQoXCJfXCIpLGU9XCLRj9C90LLQsNGA0Yxf0YTQtdCy0YDQsNC70Yxf0LzQsNGA0YJf0LDQv9GA0LXQu9GMX9C80LDQuV/QuNGO0L3RjF/QuNGO0LvRjF/QsNCy0LPRg9GB0YJf0YHQtdC90YLRj9Cx0YDRjF/QvtC60YLRj9Cx0YDRjF/QvdC+0Y/QsdGA0Yxf0LTQtdC60LDQsdGA0YxcIi5zcGxpdChcIl9cIiksbj1cItGP0L3Qsi5f0YTQtdCy0YAuX9C80LDRgC5f0LDQv9GALl/QvNCw0Y9f0LjRjtC90Y9f0LjRjtC70Y9f0LDQstCzLl/RgdC10L3Rgi5f0L7QutGCLl/QvdC+0Y/QsS5f0LTQtdC6LlwiLnNwbGl0KFwiX1wiKSxzPVwi0Y/QvdCyLl/RhNC10LLRgC5f0LzQsNGA0YJf0LDQv9GALl/QvNCw0Llf0LjRjtC90Yxf0LjRjtC70Yxf0LDQstCzLl/RgdC10L3Rgi5f0L7QutGCLl/QvdC+0Y/QsS5f0LTQtdC6LlwiLnNwbGl0KFwiX1wiKSxyPS9EW29EXT8oXFxbW15bXFxdXSpcXF18XFxzKStNTU1NPy87ZnVuY3Rpb24gbyhfLHQsZSl7dmFyIG4scztyZXR1cm5cIm1cIj09PWU/dD9cItC80LjQvdGD0YLQsFwiOlwi0LzQuNC90YPRgtGDXCI6XytcIiBcIisobj0rXyxzPXttbTp0P1wi0LzQuNC90YPRgtCwX9C80LjQvdGD0YLRi1/QvNC40L3Rg9GCXCI6XCLQvNC40L3Rg9GC0YNf0LzQuNC90YPRgtGLX9C80LjQvdGD0YJcIixoaDpcItGH0LDRgV/Rh9Cw0YHQsF/Rh9Cw0YHQvtCyXCIsZGQ6XCLQtNC10L3RjF/QtNC90Y9f0LTQvdC10LlcIixNTTpcItC80LXRgdGP0YZf0LzQtdGB0Y/RhtCwX9C80LXRgdGP0YbQtdCyXCIseXk6XCLQs9C+0LRf0LPQvtC00LBf0LvQtdGCXCJ9W2VdLnNwbGl0KFwiX1wiKSxuJTEwPT0xJiZuJTEwMCE9MTE/c1swXTpuJTEwPj0yJiZuJTEwPD00JiYobiUxMDA8MTB8fG4lMTAwPj0yMCk/c1sxXTpzWzJdKX12YXIgZD1mdW5jdGlvbihfLG4pe3JldHVybiByLnRlc3Qobik/dFtfLm1vbnRoKCldOmVbXy5tb250aCgpXX07ZC5zPWUsZC5mPXQ7dmFyIGk9ZnVuY3Rpb24oXyx0KXtyZXR1cm4gci50ZXN0KHQpP25bXy5tb250aCgpXTpzW18ubW9udGgoKV19O2kucz1zLGkuZj1uO3ZhciBtPXtuYW1lOlwicnVcIix3ZWVrZGF5czpcItCy0L7RgdC60YDQtdGB0LXQvdGM0LVf0L/QvtC90LXQtNC10LvRjNC90LjQul/QstGC0L7RgNC90LjQul/RgdGA0LXQtNCwX9GH0LXRgtCy0LXRgNCzX9C/0Y/RgtC90LjRhtCwX9GB0YPQsdCx0L7RgtCwXCIuc3BsaXQoXCJfXCIpLHdlZWtkYXlzU2hvcnQ6XCLQstGB0Lpf0L/QvdC0X9Cy0YLRgF/RgdGA0LRf0YfRgtCyX9C/0YLQvV/RgdCx0YJcIi5zcGxpdChcIl9cIiksd2Vla2RheXNNaW46XCLQstGBX9C/0L1f0LLRgl/RgdGAX9GH0YJf0L/Rgl/RgdCxXCIuc3BsaXQoXCJfXCIpLG1vbnRoczpkLG1vbnRoc1Nob3J0Omksd2Vla1N0YXJ0OjEsZm9ybWF0czp7TFQ6XCJIOm1tXCIsTFRTOlwiSDptbTpzc1wiLEw6XCJERC5NTS5ZWVlZXCIsTEw6XCJEIE1NTU0gWVlZWSDQsy5cIixMTEw6XCJEIE1NTU0gWVlZWSDQsy4sIEg6bW1cIixMTExMOlwiZGRkZCwgRCBNTU1NIFlZWVkg0LMuLCBIOm1tXCJ9LHJlbGF0aXZlVGltZTp7ZnV0dXJlOlwi0YfQtdGA0LXQtyAlc1wiLHBhc3Q6XCIlcyDQvdCw0LfQsNC0XCIsczpcItC90LXRgdC60L7Qu9GM0LrQviDRgdC10LrRg9C90LRcIixtOm8sbW06byxoOlwi0YfQsNGBXCIsaGg6byxkOlwi0LTQtdC90YxcIixkZDpvLE06XCLQvNC10YHRj9GGXCIsTU06byx5Olwi0LPQvtC0XCIseXk6b30sb3JkaW5hbDpmdW5jdGlvbihfKXtyZXR1cm4gX319O3JldHVybiBfLmxvY2FsZShtLG51bGwsITApLG19KTtcbiIsIiFmdW5jdGlvbihfLHQpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPXQocmVxdWlyZShcImRheWpzXCIpKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcImRheWpzXCJdLHQpOl8uZGF5anNfbG9jYWxlX3VrPXQoXy5kYXlqcyl9KHRoaXMsZnVuY3Rpb24oXyl7XCJ1c2Ugc3RyaWN0XCI7Xz1fJiZfLmhhc093blByb3BlcnR5KFwiZGVmYXVsdFwiKT9fLmRlZmF1bHQ6Xzt2YXIgdD1cItGB0ZbRh9C90Y9f0LvRjtGC0L7Qs9C+X9Cx0LXRgNC10LfQvdGPX9C60LLRltGC0L3Rj1/RgtGA0LDQstC90Y9f0YfQtdGA0LLQvdGPX9C70LjQv9C90Y9f0YHQtdGA0L/QvdGPX9Cy0LXRgNC10YHQvdGPX9C20L7QstGC0L3Rj1/Qu9C40YHRgtC+0L/QsNC00LBf0LPRgNGD0LTQvdGPXCIuc3BsaXQoXCJfXCIpLGU9XCLRgdGW0YfQtdC90Yxf0LvRjtGC0LjQuV/QsdC10YDQtdC30LXQvdGMX9C60LLRltGC0LXQvdGMX9GC0YDQsNCy0LXQvdGMX9GH0LXRgNCy0LXQvdGMX9C70LjQv9C10L3RjF/RgdC10YDQv9C10L3RjF/QstC10YDQtdGB0LXQvdGMX9C20L7QstGC0LXQvdGMX9C70LjRgdGC0L7Qv9Cw0LRf0LPRgNGD0LTQtdC90YxcIi5zcGxpdChcIl9cIikscz0vRFtvRF0/KFxcW1teW1xcXV0qXFxdfFxccykrTU1NTT8vO2Z1bmN0aW9uIG4oXyx0LGUpe3ZhciBzLG47cmV0dXJuXCJtXCI9PT1lP3Q/XCLRhdCy0LjQu9C40L3QsFwiOlwi0YXQstC40LvQuNC90YNcIjpcImhcIj09PWU/dD9cItCz0L7QtNC40L3QsFwiOlwi0LPQvtC00LjQvdGDXCI6XytcIiBcIisocz0rXyxuPXtzczp0P1wi0YHQtdC60YPQvdC00LBf0YHQtdC60YPQvdC00Lhf0YHQtdC60YPQvdC0XCI6XCLRgdC10LrRg9C90LTRg1/RgdC10LrRg9C90LTQuF/RgdC10LrRg9C90LRcIixtbTp0P1wi0YXQstC40LvQuNC90LBf0YXQstC40LvQuNC90Lhf0YXQstC40LvQuNC9XCI6XCLRhdCy0LjQu9C40L3Rg1/RhdCy0LjQu9C40L3QuF/RhdCy0LjQu9C40L1cIixoaDp0P1wi0LPQvtC00LjQvdCwX9Cz0L7QtNC40L3QuF/Qs9C+0LTQuNC9XCI6XCLQs9C+0LTQuNC90YNf0LPQvtC00LjQvdC4X9Cz0L7QtNC40L1cIixkZDpcItC00LXQvdGMX9C00L3Rll/QtNC90ZbQslwiLE1NOlwi0LzRltGB0Y/RhtGMX9C80ZbRgdGP0YbRll/QvNGW0YHRj9GG0ZbQslwiLHl5Olwi0YDRltC6X9GA0L7QutC4X9GA0L7QutGW0LJcIn1bZV0uc3BsaXQoXCJfXCIpLHMlMTA9PTEmJnMlMTAwIT0xMT9uWzBdOnMlMTA+PTImJnMlMTA8PTQmJihzJTEwMDwxMHx8cyUxMDA+PTIwKT9uWzFdOm5bMl0pfXZhciBkPWZ1bmN0aW9uKF8sbil7cmV0dXJuIHMudGVzdChuKT90W18ubW9udGgoKV06ZVtfLm1vbnRoKCldfTtkLnM9ZSxkLmY9dDt2YXIgaT17bmFtZTpcInVrXCIsd2Vla2RheXM6XCLQvdC10LTRltC70Y9f0L/QvtC90LXQtNGW0LvQvtC6X9Cy0ZbQstGC0L7RgNC+0Lpf0YHQtdGA0LXQtNCwX9GH0LXRgtCy0LXRgF/Qv+KAmdGP0YLQvdC40YbRj1/RgdGD0LHQvtGC0LBcIi5zcGxpdChcIl9cIiksd2Vla2RheXNTaG9ydDpcItC90LTQu1/Qv9C90LRf0LLRgtGAX9GB0YDQtF/Rh9GC0LJf0L/RgtC9X9GB0LHRglwiLnNwbGl0KFwiX1wiKSx3ZWVrZGF5c01pbjpcItC90LRf0L/QvV/QstGCX9GB0YBf0YfRgl/Qv9GCX9GB0LFcIi5zcGxpdChcIl9cIiksbW9udGhzOmQsbW9udGhzU2hvcnQ6XCLRgWnRh1/Qu9GO0YJf0LHQtdGAX9C60LJp0YJf0YLRgNCw0LJf0YfQtdGA0LJf0LvQuNC/X9GB0LXRgNC/X9Cy0LXRgF/QttC+0LLRgl/Qu9C40YHRgl/Qs9GA0YPQtFwiLnNwbGl0KFwiX1wiKSx3ZWVrU3RhcnQ6MSxyZWxhdGl2ZVRpbWU6e2Z1dHVyZTpcItC30LAgJXNcIixwYXN0OlwiJXMg0YLQvtC80YNcIixzOlwi0LTQtdC60ZbQu9GM0LrQsCDRgdC10LrRg9C90LRcIixtOm4sbW06bixoOm4saGg6bixkOlwi0LTQtdC90YxcIixkZDpuLE06XCLQvNGW0YHRj9GG0YxcIixNTTpuLHk6XCLRgNGW0LpcIix5eTpufSxvcmRpbmFsOmZ1bmN0aW9uKF8pe3JldHVybiBffSxmb3JtYXRzOntMVDpcIkhIOm1tXCIsTFRTOlwiSEg6bW06c3NcIixMOlwiREQuTU0uWVlZWVwiLExMOlwiRCBNTU1NIFlZWVkg0YAuXCIsTExMOlwiRCBNTU1NIFlZWVkg0YAuLCBISDptbVwiLExMTEw6XCJkZGRkLCBEIE1NTU0gWVlZWSDRgC4sIEhIOm1tXCJ9fTtyZXR1cm4gXy5sb2NhbGUoaSxudWxsLCEwKSxpfSk7XG4iLCJcbmltcG9ydCBkYXlqcyBmcm9tICdkYXlqcydcblxuaW1wb3J0IHJlbGF0aXZlVGltZSBmcm9tICdkYXlqcy9wbHVnaW4vcmVsYXRpdmVUaW1lJ1xuaW1wb3J0IHV0YyBmcm9tICdkYXlqcy9wbHVnaW4vdXRjJ1xuaW1wb3J0IHdlZWtkYXkgZnJvbSAnZGF5anMvcGx1Z2luL3dlZWtkYXknXG5cbmltcG9ydCAnZGF5anMvbG9jYWxlL2VuJyAvLyBsb2FkIG9uIGRlbWFuZFxuaW1wb3J0ICdkYXlqcy9sb2NhbGUvcnUnIC8vIGxvYWQgb24gZGVtYW5kXG5pbXBvcnQgJ2RheWpzL2xvY2FsZS91aycgLy8gbG9hZCBvbiBkZW1hbmRcblxuZGF5anMuZXh0ZW5kKHJlbGF0aXZlVGltZSkgLy8gdXNlIFJlbGF0aXZlVGltZSBwbHVnZ2luXG5kYXlqcy5leHRlbmQodXRjKSAvLyB1c2UgVVRDIHBsdWdnaW5cbmRheWpzLmV4dGVuZCh3ZWVrZGF5KSAvLyB1c2UgV2Vla2RheSBwbHVnZ2luXG5cbmRheWpzLmxvY2FsZSgnZW4nKSAvLyB1c2UgRW5nbGxpc2hcbmRheWpzLmxvY2FsZSgncnUnKSAvLyB1c2UgUnVzc2lhblxuZGF5anMubG9jYWxlKCd1aycpIC8vIHVzZSBVa3JhaW5pYW5cblxuZXhwb3J0IGRlZmF1bHQgZGF5anNcbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIFN3aXBlIHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCkge1xuICAgIHRoaXMuaXNNb3ZlU3RhcnQgPSBmYWxzZVxuICAgIHRoaXMuaXNUd29GaW5nZXJzID0gZmFsc2VcblxuICAgIHRoaXMueERvd24gPSBudWxsO1xuICAgIHRoaXMueURvd24gPSBudWxsO1xuICAgIHRoaXMuZWxlbWVudCA9IHR5cGVvZiAoZWxlbWVudCkgPT09ICdzdHJpbmcnID8gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbGVtZW50KSA6IGVsZW1lbnQ7XG5cbiAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMudG91Y2hTdGFydEhhbmRsZXIuYmluZCh0aGlzKSwgZmFsc2UpO1xuICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMudG91Y2hFbmRIYW5kbGVyLmJpbmQodGhpcyksIGZhbHNlKVxuXG4gICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2dlc3R1cmVzdGFydCcsICgpID0+IHtcbiAgICAgIHRoaXMuaXNUd29GaW5nZXJzID0gdHJ1ZVxuICAgIH0pXG5cbiAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZ2VzdHVyZWVuZCcsICgpID0+IHtcbiAgICAgIHRoaXMuaXNUd29GaW5nZXJzID0gZmFsc2VcbiAgICB9KVxuICB9XG5cbiAgdG91Y2hTdGFydEhhbmRsZXIoZXZ0KSB7XG4gICAgaWYgKHRoaXMuaXNUd29GaW5nZXJzKSByZXR1cm5cblxuICAgIHRoaXMuaXNNb3ZlU3RhcnQgPSB0cnVlXG5cbiAgICB0aGlzLnhEb3duID0gZXZ0LnRvdWNoZXNbMF0uY2xpZW50WDtcbiAgICB0aGlzLnlEb3duID0gZXZ0LnRvdWNoZXNbMF0uY2xpZW50WTtcblxuICAgIHRyeSB7XG4gICAgICB0aGlzLm9uVG91Y2hTdGFydCh0aGlzLnhEb3duLCB0aGlzLnlEb3duLCBldnQsIHRoaXMuZWxlbWVudClcbiAgICB9IGNhdGNoKGVycikgeyAvKiBpZ25vcmUgdGhyb3dpbmcgb2YgdW5rbm93biBmdW5jdGlvbnMgKi8gfVxuICB9XG5cbiAgdG91Y2hFbmRIYW5kbGVyKGV2dCkge1xuICAgIGlmICh0aGlzLmlzVHdvRmluZ2VycykgcmV0dXJuXG5cbiAgICB0aGlzLmlzTW92ZVN0YXJ0ID0gZmFsc2VcblxuICAgIHRoaXMueERvd24gPSBudWxsO1xuICAgIHRoaXMueURvd24gPSBudWxsO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHhVcCA9IGV2dC5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRYO1xuICAgICAgY29uc3QgeVVwID0gZXZ0LmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFk7XG4gICAgICB0aGlzLm9uVG91Y2hFbmQoeFVwLCB5VXAsIGV2dCwgdGhpcy5lbGVtZW50KVxuICAgIH0gY2F0Y2goZXJyKSB7IC8qIGlnbm9yZSB0aHJvd2luZyBvZiB1bmtub3duIGZ1bmN0aW9ucyAqLyB9XG4gIH1cblxuICBvbkxlZnQoY2FsbGJhY2spIHtcbiAgICB0aGlzLm9uTGVmdCA9IGNhbGxiYWNrO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBvblJpZ2h0KGNhbGxiYWNrKSB7XG4gICAgdGhpcy5vblJpZ2h0ID0gY2FsbGJhY2s7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIG9uVXAoY2FsbGJhY2spIHtcbiAgICB0aGlzLm9uVXAgPSBjYWxsYmFjaztcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgb25Eb3duKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5vbkRvd24gPSBjYWxsYmFjaztcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgb25Ub3VjaFN0YXJ0KGNhbGxiYWNrKSB7XG4gICAgdGhpcy5vblRvdWNoU3RhcnQgPSBjYWxsYmFjaztcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgb25Ub3VjaEVuZChjYWxsYmFjaykge1xuICAgIHRoaXMub25Ub3VjaEVuZCA9IGNhbGxiYWNrO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBoYW5kbGVUb3VjaE1vdmUoZXZ0KSB7XG4gICAgaWYgKCF0aGlzLmlzTW92ZVN0YXJ0IHx8IHRoaXMuaXNUd29GaW5nZXJzKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCB4VXAgPSBldnQudG91Y2hlc1swXS5jbGllbnRYO1xuICAgIGNvbnN0IHlVcCA9IGV2dC50b3VjaGVzWzBdLmNsaWVudFk7XG5cbiAgICB0aGlzLnhEaWZmID0geFVwIC0gdGhpcy54RG93bjtcbiAgICB0aGlzLnlEaWZmID0geVVwIC0gdGhpcy55RG93bjtcblxuICAgIHRyeSB7XG4gICAgICBpZiAoIE1hdGguYWJzKCB0aGlzLnhEaWZmICkgPiBNYXRoLmFicyggdGhpcy55RGlmZiApICkgeyAvLyBNb3N0IHNpZ25pZmljYW50LlxuICAgICAgICBpZiAoIHRoaXMueERpZmYgPCAwICkge1xuICAgICAgICAgIHJldHVybiB0aGlzLm9uTGVmdCh0aGlzLnhEb3duLCB4VXAsIGV2dCwgdGhpcy5lbGVtZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5vblJpZ2h0KHRoaXMueERvd24sIHhVcCwgZXZ0LCB0aGlzLmVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIHRoaXMueURpZmYgPCAwICkge1xuICAgICAgICAgIHJldHVybiB0aGlzLm9uVXAodGhpcy55RG93biwgeVVwLCBldnQsIHRoaXMuZWxlbWVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMub25Eb3duKHRoaXMueURvd24sIHlVcCwgZXZ0LCB0aGlzLmVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaChlcnIpIHsgLyogaWdub3JlIHRocm93aW5nIG9mIHVua25vd24gZnVuY3Rpb25zICovIH1cbiAgfVxuXG4gIGhhbmRsZU1vdmUoZSkge1xuICAgIHJldHVybiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy5oYW5kbGVUb3VjaE1vdmUoZSkpXG4gIH1cblxuICBzdG9wKCkge1xuICAgIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLmhhbmRsZU1vdmUuYmluZCh0aGlzKSwgZmFsc2UpO1xuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHJ1bigpIHtcbiAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5oYW5kbGVNb3ZlLmJpbmQodGhpcyksIGZhbHNlKTtcblxuICAgIHJldHVybiB0aGlzXG4gIH1cbn0iLCIvKlxuICogSlMgU3RvcmFnZSBQbHVnaW5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTkgSnVsaWVuIE1hdXJlbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZTpcbiAqIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gKlxuICogUHJvamVjdCBob21lOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2p1bGllbi1tYXVyZWwvanMtc3RvcmFnZVxuICpcbiAqIFZlcnNpb246IDEuMS4wXG4gKi9cbihmdW5jdGlvbiAoZmFjdG9yeSkge1xuICAgIHZhciByZWdpc3RlcmVkSW5Nb2R1bGVMb2FkZXIgPSBmYWxzZTtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShmYWN0b3J5KTtcbiAgICAgICAgcmVnaXN0ZXJlZEluTW9kdWxlTG9hZGVyID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgICAgICAgcmVnaXN0ZXJlZEluTW9kdWxlTG9hZGVyID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFyZWdpc3RlcmVkSW5Nb2R1bGVMb2FkZXIpIHtcbiAgICAgICAgdmFyIE9sZFN0b3JhZ2VzID0gd2luZG93LlN0b3JhZ2VzO1xuICAgICAgICB2YXIgYXBpID0gd2luZG93LlN0b3JhZ2VzID0gZmFjdG9yeSgpO1xuICAgICAgICBhcGkubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHdpbmRvdy5TdG9yYWdlcyA9IE9sZFN0b3JhZ2VzO1xuICAgICAgICAgICAgcmV0dXJuIGFwaTtcbiAgICAgICAgfTtcbiAgICB9XG59KGZ1bmN0aW9uICgpIHtcbiAgICAvLyBWYXJpYWJsZXMgdXNlZCBieSB1dGlsaXRpZXMgZnVuY3Rpb25zIChsaWtlIGlzUGxhaW5PYmplY3QuLi4pXG4gICAgdmFyIGNsYXNzMnR5cGUgPSB7fTtcbiAgICB2YXIgdG9TdHJpbmcgPSBjbGFzczJ0eXBlLnRvU3RyaW5nO1xuICAgIHZhciBoYXNPd24gPSBjbGFzczJ0eXBlLmhhc093blByb3BlcnR5O1xuICAgIHZhciBmblRvU3RyaW5nID0gaGFzT3duLnRvU3RyaW5nO1xuICAgIHZhciBPYmplY3RGdW5jdGlvblN0cmluZyA9IGZuVG9TdHJpbmcuY2FsbChPYmplY3QpO1xuICAgIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgICB2YXIgYXBpcyA9IHt9O1xuXG4gICAgLy8gUHJlZml4IHRvIHVzZSB3aXRoIGNvb2tpZSBmYWxsYmFja1xuICAgIHZhciBjb29raWVfbG9jYWxfcHJlZml4ID0gXCJsc19cIjtcbiAgICB2YXIgY29va2llX3Nlc3Npb25fcHJlZml4ID0gXCJzc19cIjtcblxuICAgIC8vIEdldCBpdGVtcyBmcm9tIGEgc3RvcmFnZVxuICAgIGZ1bmN0aW9uIF9nZXQoKSB7XG4gICAgICAgIHZhciBzdG9yYWdlID0gdGhpcy5fdHlwZSwgbCA9IGFyZ3VtZW50cy5sZW5ndGgsIHMgPSB3aW5kb3dbc3RvcmFnZV0sIGEgPSBhcmd1bWVudHMsIGEwID0gYVswXSwgdmksIHJldCwgdG1wLCBpLCBqO1xuICAgICAgICBpZiAobCA8IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWluaW11bSAxIGFyZ3VtZW50IG11c3QgYmUgZ2l2ZW4nKTtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGEwKSkge1xuICAgICAgICAgICAgLy8gSWYgc2Vjb25kIGFyZ3VtZW50IGlzIGFuIGFycmF5LCByZXR1cm4gYW4gb2JqZWN0IHdpdGggdmFsdWUgb2Ygc3RvcmFnZSBmb3IgZWFjaCBpdGVtIGluIHRoaXMgYXJyYXlcbiAgICAgICAgICAgIHJldCA9IHt9O1xuICAgICAgICAgICAgZm9yIChpIGluIGEwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGEwLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZpID0gYTBbaV07XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXRbdmldID0gSlNPTi5wYXJzZShzLmdldEl0ZW0odmkpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0W3ZpXSA9IHMuZ2V0SXRlbSh2aSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9IGVsc2UgaWYgKGwgPT0gMSkge1xuICAgICAgICAgICAgLy8gSWYgb25seSAxIGFyZ3VtZW50LCByZXR1cm4gdmFsdWUgZGlyZWN0bHlcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2Uocy5nZXRJdGVtKGEwKSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHMuZ2V0SXRlbShhMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiBtb3JlIHRoYW4gMSBhcmd1bWVudCwgcGFyc2Ugc3RvcmFnZSB0byByZXRyaWV2ZSBmaW5hbCB2YWx1ZSB0byByZXR1cm4gaXRcbiAgICAgICAgICAgIC8vIEdldCBmaXJzdCBsZXZlbFxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXQgPSBKU09OLnBhcnNlKHMuZ2V0SXRlbShhMCkpO1xuICAgICAgICAgICAgICAgIGlmICghcmV0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihhMCArICcgaXMgbm90IGRlZmluZWQgaW4gdGhpcyBzdG9yYWdlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihhMCArICcgaXMgbm90IGRlZmluZWQgaW4gdGhpcyBzdG9yYWdlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQYXJzZSBuZXh0IGxldmVsc1xuICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8IGwgLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXQgPSByZXRbYVtpXV07XG4gICAgICAgICAgICAgICAgaWYgKHJldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihbXS5zbGljZS5jYWxsKGEsIDAsIGkgKyAxKS5qb2luKCcuJykgKyAnIGlzIG5vdCBkZWZpbmVkIGluIHRoaXMgc3RvcmFnZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIGxhc3QgYXJndW1lbnQgaXMgYW4gYXJyYXksIHJldHVybiBhbiBvYmplY3Qgd2l0aCB2YWx1ZSBmb3IgZWFjaCBpdGVtIGluIHRoaXMgYXJyYXlcbiAgICAgICAgICAgIC8vIEVsc2UgcmV0dXJuIHZhbHVlIG5vcm1hbGx5XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhW2ldKSkge1xuICAgICAgICAgICAgICAgIHRtcCA9IHJldDtcbiAgICAgICAgICAgICAgICByZXQgPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKGogaW4gYVtpXSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYVtpXS5oYXNPd25Qcm9wZXJ0eShqKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0W2FbaV1bal1dID0gdG1wW2FbaV1bal1dO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXRbYVtpXV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTZXQgaXRlbXMgb2YgYSBzdG9yYWdlXG4gICAgZnVuY3Rpb24gX3NldCgpIHtcbiAgICAgICAgdmFyIHN0b3JhZ2UgPSB0aGlzLl90eXBlLCBsID0gYXJndW1lbnRzLmxlbmd0aCwgcyA9IHdpbmRvd1tzdG9yYWdlXSwgYSA9IGFyZ3VtZW50cywgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIHZpLCB0b19zdG9yZSA9IGlzTmFOKGExKSA/IHt9IDogW10sIHR5cGUsIHRtcCwgaTtcbiAgICAgICAgaWYgKGwgPCAxIHx8ICFfaXNQbGFpbk9iamVjdChhMCkgJiYgbCA8IDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWluaW11bSAyIGFyZ3VtZW50cyBtdXN0IGJlIGdpdmVuIG9yIGZpcnN0IHBhcmFtZXRlciBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgICAgICB9IGVsc2UgaWYgKF9pc1BsYWluT2JqZWN0KGEwKSkge1xuICAgICAgICAgICAgLy8gSWYgZmlyc3QgYXJndW1lbnQgaXMgYW4gb2JqZWN0LCBzZXQgdmFsdWVzIG9mIHN0b3JhZ2UgZm9yIGVhY2ggcHJvcGVydHkgb2YgdGhpcyBvYmplY3RcbiAgICAgICAgICAgIGZvciAoaSBpbiBhMCkge1xuICAgICAgICAgICAgICAgIGlmIChhMC5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgICAgICAgICB2aSA9IGEwW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV9pc1BsYWluT2JqZWN0KHZpKSAmJiAhdGhpcy5hbHdheXNVc2VKc29uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzLnNldEl0ZW0oaSwgdmkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcy5zZXRJdGVtKGksIEpTT04uc3RyaW5naWZ5KHZpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYTA7XG4gICAgICAgIH0gZWxzZSBpZiAobCA9PSAyKSB7XG4gICAgICAgICAgICAvLyBJZiBvbmx5IDIgYXJndW1lbnRzLCBzZXQgdmFsdWUgb2Ygc3RvcmFnZSBkaXJlY3RseVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBhMSA9PT0gJ29iamVjdCcgfHwgdGhpcy5hbHdheXNVc2VKc29uKSB7XG4gICAgICAgICAgICAgICAgcy5zZXRJdGVtKGEwLCBKU09OLnN0cmluZ2lmeShhMSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzLnNldEl0ZW0oYTAsIGExKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIG1vcmUgdGhhbiAzIGFyZ3VtZW50cywgcGFyc2Ugc3RvcmFnZSB0byByZXRyaWV2ZSBmaW5hbCBub2RlIGFuZCBzZXQgdmFsdWVcbiAgICAgICAgICAgIC8vIEdldCBmaXJzdCBsZXZlbFxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0bXAgPSBzLmdldEl0ZW0oYTApO1xuICAgICAgICAgICAgICAgIGlmICh0bXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0b19zdG9yZSA9IEpTT04ucGFyc2UodG1wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0bXAgPSB0b19zdG9yZTtcbiAgICAgICAgICAgIC8vIFBhcnNlIG5leHQgbGV2ZWxzIGFuZCBzZXQgdmFsdWVcbiAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPCBsIC0gMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmkgPSBhW2ldO1xuICAgICAgICAgICAgICAgIHR5cGUgPSBpc05hTihhW2kgKyAxXSkgPyBcIm9iamVjdFwiIDogXCJhcnJheVwiO1xuICAgICAgICAgICAgICAgIGlmICghdG1wW3ZpXSB8fCB0eXBlID09IFwib2JqZWN0XCIgJiYgIV9pc1BsYWluT2JqZWN0KHRtcFt2aV0pIHx8IHR5cGUgPT0gXCJhcnJheVwiICYmICFBcnJheS5pc0FycmF5KHRtcFt2aV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09IFwiYXJyYXlcIikgdG1wW3ZpXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIHRtcFt2aV0gPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdG1wID0gdG1wW3ZpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRtcFthW2ldXSA9IGFbaSArIDFdO1xuICAgICAgICAgICAgcy5zZXRJdGVtKGEwLCBKU09OLnN0cmluZ2lmeSh0b19zdG9yZSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRvX3N0b3JlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGl0ZW1zIGZyb20gYSBzdG9yYWdlXG4gICAgZnVuY3Rpb24gX3JlbW92ZSgpIHtcbiAgICAgICAgdmFyIHN0b3JhZ2UgPSB0aGlzLl90eXBlLCBsID0gYXJndW1lbnRzLmxlbmd0aCwgcyA9IHdpbmRvd1tzdG9yYWdlXSwgYSA9IGFyZ3VtZW50cywgYTAgPSBhWzBdLCB0b19zdG9yZSwgdG1wLCBpLCBqO1xuICAgICAgICBpZiAobCA8IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWluaW11bSAxIGFyZ3VtZW50IG11c3QgYmUgZ2l2ZW4nKTtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGEwKSkge1xuICAgICAgICAgICAgLy8gSWYgZmlyc3QgYXJndW1lbnQgaXMgYW4gYXJyYXksIHJlbW92ZSB2YWx1ZXMgZnJvbSBzdG9yYWdlIGZvciBlYWNoIGl0ZW0gb2YgdGhpcyBhcnJheVxuICAgICAgICAgICAgZm9yIChpIGluIGEwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGEwLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHMucmVtb3ZlSXRlbShhMFtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAobCA9PSAxKSB7XG4gICAgICAgICAgICAvLyBJZiBvbmx5IDIgYXJndW1lbnRzLCByZW1vdmUgdmFsdWUgZnJvbSBzdG9yYWdlIGRpcmVjdGx5XG4gICAgICAgICAgICBzLnJlbW92ZUl0ZW0oYTApO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiBtb3JlIHRoYW4gMiBhcmd1bWVudHMsIHBhcnNlIHN0b3JhZ2UgdG8gcmV0cmlldmUgZmluYWwgbm9kZSBhbmQgcmVtb3ZlIHZhbHVlXG4gICAgICAgICAgICAvLyBHZXQgZmlyc3QgbGV2ZWxcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdG9fc3RvcmUgPSB0bXAgPSBKU09OLnBhcnNlKHMuZ2V0SXRlbShhMCkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihhMCArICcgaXMgbm90IGRlZmluZWQgaW4gdGhpcyBzdG9yYWdlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQYXJzZSBuZXh0IGxldmVscyBhbmQgcmVtb3ZlIHZhbHVlXG4gICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbCAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgIHRtcCA9IHRtcFthW2ldXTtcbiAgICAgICAgICAgICAgICBpZiAodG1wID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFtdLnNsaWNlLmNhbGwoYSwgMSwgaSkuam9pbignLicpICsgJyBpcyBub3QgZGVmaW5lZCBpbiB0aGlzIHN0b3JhZ2UnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBsYXN0IGFyZ3VtZW50IGlzIGFuIGFycmF5LHJlbW92ZSB2YWx1ZSBmb3IgZWFjaCBpdGVtIGluIHRoaXMgYXJyYXlcbiAgICAgICAgICAgIC8vIEVsc2UgcmVtb3ZlIHZhbHVlIG5vcm1hbGx5XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhW2ldKSkge1xuICAgICAgICAgICAgICAgIGZvciAoaiBpbiBhW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhW2ldLmhhc093blByb3BlcnR5KGopKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdG1wW2FbaV1bal1dO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdG1wW2FbaV1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcy5zZXRJdGVtKGEwLCBKU09OLnN0cmluZ2lmeSh0b19zdG9yZSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgYWxsIGl0ZW1zIGZyb20gYSBzdG9yYWdlXG4gICAgZnVuY3Rpb24gX3JlbW92ZUFsbChyZWluaXRfbnMpIHtcbiAgICAgICAgdmFyIGtleXMgPSBfa2V5cy5jYWxsKHRoaXMpLCBpO1xuICAgICAgICBmb3IgKGkgaW4ga2V5cykge1xuICAgICAgICAgICAgaWYgKGtleXMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgICAgICBfcmVtb3ZlLmNhbGwodGhpcywga2V5c1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVpbml0aWFsaXplIGFsbCBuYW1lc3BhY2Ugc3RvcmFnZXNcbiAgICAgICAgaWYgKHJlaW5pdF9ucykge1xuICAgICAgICAgICAgZm9yIChpIGluIGFwaXMubmFtZXNwYWNlU3RvcmFnZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXBpcy5uYW1lc3BhY2VTdG9yYWdlcy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgICAgICAgICBfY3JlYXRlTmFtZXNwYWNlKGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIGl0ZW1zIG9mIGEgc3RvcmFnZSBhcmUgZW1wdHlcbiAgICBmdW5jdGlvbiBfaXNFbXB0eSgpIHtcbiAgICAgICAgdmFyIGwgPSBhcmd1bWVudHMubGVuZ3RoLCBhID0gYXJndW1lbnRzLCBhMCA9IGFbMF0sIGk7XG4gICAgICAgIGlmIChsID09IDApIHtcbiAgICAgICAgICAgIC8vIElmIG5vIGFyZ3VtZW50LCB0ZXN0IGlmIHN0b3JhZ2UgaXMgZW1wdHlcbiAgICAgICAgICAgIHJldHVybiAoX2tleXMuY2FsbCh0aGlzKS5sZW5ndGggPT0gMCk7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhMCkpIHtcbiAgICAgICAgICAgIC8vIElmIGZpcnN0IGFyZ3VtZW50IGlzIGFuIGFycmF5LCB0ZXN0IGVhY2ggaXRlbSBvZiB0aGlzIGFycmF5IGFuZCByZXR1cm4gdHJ1ZSBvbmx5IGlmIGFsbCBpdGVtcyBhcmUgZW1wdHlcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhMC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICghX2lzRW1wdHkuY2FsbCh0aGlzLCBhMFtpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgYXQgbGVhc3QgMSBhcmd1bWVudCwgdHJ5IHRvIGdldCB2YWx1ZSBhbmQgdGVzdCBpdFxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgdiA9IF9nZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IHJlc3VsdCB0byBhbiBvYmplY3QgKGlmIGxhc3QgYXJndW1lbnQgaXMgYW4gYXJyYXksIF9nZXQgcmV0dXJuIGFscmVhZHkgYW4gb2JqZWN0KSBhbmQgdGVzdCBlYWNoIGl0ZW1cbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYVtsIC0gMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHYgPSB7J3RvdGVzdCc6IHZ9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGkgaW4gdikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodi5oYXNPd25Qcm9wZXJ0eShpKSAmJiAhKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChfaXNQbGFpbk9iamVjdCh2W2ldKSAmJiBfaXNFbXB0eU9iamVjdCh2W2ldKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoQXJyYXkuaXNBcnJheSh2W2ldKSAmJiAhdltpXS5sZW5ndGgpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiB2W2ldICE9PSAnYm9vbGVhbicgJiYgIXZbaV0pXG4gICAgICAgICAgICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBpdGVtcyBvZiBhIHN0b3JhZ2UgZXhpc3RcbiAgICBmdW5jdGlvbiBfaXNTZXQoKSB7XG4gICAgICAgIHZhciBsID0gYXJndW1lbnRzLmxlbmd0aCwgYSA9IGFyZ3VtZW50cywgYTAgPSBhWzBdLCBpO1xuICAgICAgICBpZiAobCA8IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWluaW11bSAxIGFyZ3VtZW50IG11c3QgYmUgZ2l2ZW4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhMCkpIHtcbiAgICAgICAgICAgIC8vIElmIGZpcnN0IGFyZ3VtZW50IGlzIGFuIGFycmF5LCB0ZXN0IGVhY2ggaXRlbSBvZiB0aGlzIGFycmF5IGFuZCByZXR1cm4gdHJ1ZSBvbmx5IGlmIGFsbCBpdGVtcyBleGlzdFxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGEwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfaXNTZXQuY2FsbCh0aGlzLCBhMFtpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRm9yIG90aGVyIGNhc2UsIHRyeSB0byBnZXQgdmFsdWUgYW5kIHRlc3QgaXRcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIHYgPSBfZ2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgLy8gQ29udmVydCByZXN1bHQgdG8gYW4gb2JqZWN0IChpZiBsYXN0IGFyZ3VtZW50IGlzIGFuIGFycmF5LCBfZ2V0IHJldHVybiBhbHJlYWR5IGFuIG9iamVjdCkgYW5kIHRlc3QgZWFjaCBpdGVtXG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFbbCAtIDFdKSkge1xuICAgICAgICAgICAgICAgICAgICB2ID0geyd0b3Rlc3QnOiB2fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChpIGluIHYpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHYuaGFzT3duUHJvcGVydHkoaSkgJiYgISh2W2ldICE9PSB1bmRlZmluZWQgJiYgdltpXSAhPT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBHZXQga2V5cyBvZiBhIHN0b3JhZ2Ugb3Igb2YgYW4gaXRlbSBvZiB0aGUgc3RvcmFnZVxuICAgIGZ1bmN0aW9uIF9rZXlzKCkge1xuICAgICAgICB2YXIgc3RvcmFnZSA9IHRoaXMuX3R5cGUsIGwgPSBhcmd1bWVudHMubGVuZ3RoLCBzID0gd2luZG93W3N0b3JhZ2VdLCBrZXlzID0gW10sIG8gPSB7fTtcbiAgICAgICAgLy8gSWYgYXQgbGVhc3QgMSBhcmd1bWVudCwgZ2V0IHZhbHVlIGZyb20gc3RvcmFnZSB0byByZXRyaWV2ZSBrZXlzXG4gICAgICAgIC8vIEVsc2UsIHVzZSBzdG9yYWdlIHRvIHJldHJpZXZlIGtleXNcbiAgICAgICAgaWYgKGwgPiAwKSB7XG4gICAgICAgICAgICBvID0gX2dldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbyA9IHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG8gJiYgby5fY29va2llKSB7XG4gICAgICAgICAgICAvLyBJZiBzdG9yYWdlIGlzIGEgY29va2llLCB1c2UganMtY29va2llIHRvIHJldHJpZXZlIGtleXNcbiAgICAgICAgICAgIHZhciBjb29raWVzID0gQ29va2llcy5nZXQoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBjb29raWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvb2tpZXMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBrZXkgIT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5cy5wdXNoKGtleS5yZXBsYWNlKG8uX3ByZWZpeCwgJycpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIG8pIHtcbiAgICAgICAgICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgICAgICAgICBrZXlzLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXlzO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBuZXcgbmFtZXNwYWNlIHN0b3JhZ2VcbiAgICBmdW5jdGlvbiBfY3JlYXRlTmFtZXNwYWNlKG5hbWUpIHtcbiAgICAgICAgaWYgKCFuYW1lIHx8IHR5cGVvZiBuYW1lICE9IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmlyc3QgcGFyYW1ldGVyIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RvcmFnZV9hdmFpbGFibGUpIHtcbiAgICAgICAgICAgIGlmICghd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKG5hbWUsICd7fScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF3aW5kb3cuc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShuYW1lKSkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5zZXRJdGVtKG5hbWUsICd7fScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCF3aW5kb3cubG9jYWxDb29raWVTdG9yYWdlLmdldEl0ZW0obmFtZSkpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cubG9jYWxDb29raWVTdG9yYWdlLnNldEl0ZW0obmFtZSwgJ3t9Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXdpbmRvdy5zZXNzaW9uQ29va2llU3RvcmFnZS5nZXRJdGVtKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LnNlc3Npb25Db29raWVTdG9yYWdlLnNldEl0ZW0obmFtZSwgJ3t9Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5zID0ge1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlOiBfZXh0ZW5kKHt9LCBhcGlzLmxvY2FsU3RvcmFnZSwge19uczogbmFtZX0pLFxuICAgICAgICAgICAgc2Vzc2lvblN0b3JhZ2U6IF9leHRlbmQoe30sIGFwaXMuc2Vzc2lvblN0b3JhZ2UsIHtfbnM6IG5hbWV9KVxuICAgICAgICB9O1xuICAgICAgICBpZiAoY29va2llc19hdmFpbGFibGUpIHtcbiAgICAgICAgICAgIGlmICghd2luZG93LmNvb2tpZVN0b3JhZ2UuZ2V0SXRlbShuYW1lKSkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5jb29raWVTdG9yYWdlLnNldEl0ZW0obmFtZSwgJ3t9Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBucy5jb29raWVTdG9yYWdlID0gX2V4dGVuZCh7fSwgYXBpcy5jb29raWVTdG9yYWdlLCB7X25zOiBuYW1lfSk7XG4gICAgICAgIH1cbiAgICAgICAgYXBpcy5uYW1lc3BhY2VTdG9yYWdlc1tuYW1lXSA9IG5zO1xuICAgICAgICByZXR1cm4gbnM7XG4gICAgfVxuXG4gICAgLy8gVGVzdCBpZiBzdG9yYWdlIGlzIG5hdGl2ZWx5IGF2YWlsYWJsZSBvbiBicm93c2VyXG4gICAgZnVuY3Rpb24gX3Rlc3RTdG9yYWdlKG5hbWUpIHtcbiAgICAgICAgdmFyIGZvbyA9ICdqc2FwaSc7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIXdpbmRvd1tuYW1lXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdpbmRvd1tuYW1lXS5zZXRJdGVtKGZvbywgZm9vKTtcbiAgICAgICAgICAgIHdpbmRvd1tuYW1lXS5yZW1vdmVJdGVtKGZvbyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGVzdCBpZiBhIHZhcmlhYmxlIGlzIGEgcGxhaW4gb2JqZWN0IChmcm9tIGpRdWVyeSlcbiAgICBmdW5jdGlvbiBfaXNQbGFpbk9iamVjdChvYmopIHtcbiAgICAgICAgdmFyIHByb3RvLCBDdG9yO1xuXG4gICAgICAgIC8vIERldGVjdCBvYnZpb3VzIG5lZ2F0aXZlc1xuICAgICAgICAvLyBVc2UgdG9TdHJpbmcgaW5zdGVhZCBvZiBqUXVlcnkudHlwZSB0byBjYXRjaCBob3N0IG9iamVjdHNcbiAgICAgICAgaWYgKCFvYmogfHwgdG9TdHJpbmcuY2FsbChvYmopICE9PSBcIltvYmplY3QgT2JqZWN0XVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBwcm90byA9IGdldFByb3RvKG9iaik7XG5cbiAgICAgICAgLy8gT2JqZWN0cyB3aXRoIG5vIHByb3RvdHlwZSAoZS5nLiwgYE9iamVjdC5jcmVhdGUoIG51bGwgKWApIGFyZSBwbGFpblxuICAgICAgICBpZiAoIXByb3RvKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE9iamVjdHMgd2l0aCBwcm90b3R5cGUgYXJlIHBsYWluIGlmZiB0aGV5IHdlcmUgY29uc3RydWN0ZWQgYnkgYSBnbG9iYWwgT2JqZWN0IGZ1bmN0aW9uXG4gICAgICAgIEN0b3IgPSBoYXNPd24uY2FsbChwcm90bywgXCJjb25zdHJ1Y3RvclwiKSAmJiBwcm90by5jb25zdHJ1Y3RvcjtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBDdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgZm5Ub1N0cmluZy5jYWxsKEN0b3IpID09PSBPYmplY3RGdW5jdGlvblN0cmluZztcbiAgICB9XG5cbiAgICAvLyBUZXN0IGlmIGEgdmFyaWFibGUgaXMgYW4gZW1wdHkgb2JqZWN0IChmcm9tIGpRdWVyeSlcbiAgICBmdW5jdGlvbiBfaXNFbXB0eU9iamVjdChvYmopIHtcbiAgICAgICAgdmFyIG5hbWU7XG5cbiAgICAgICAgZm9yIChuYW1lIGluIG9iaikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIE1lcmdlIG9iamVjdHNcbiAgICBmdW5jdGlvbiBfZXh0ZW5kKCkge1xuICAgICAgICB2YXIgaSA9IDE7XG4gICAgICAgIHZhciByZXN1bHQgPSBhcmd1bWVudHNbMF07XG4gICAgICAgIGZvciAoOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBzdG9yYWdlcyBhcmUgbmF0aXZlbHkgYXZhaWxhYmxlIG9uIGJyb3dzZXIgYW5kIGNoZWNrIGlzIGpzLWNvb2tpZSBpcyBwcmVzZW50XG4gICAgdmFyIHN0b3JhZ2VfYXZhaWxhYmxlID0gX3Rlc3RTdG9yYWdlKCdsb2NhbFN0b3JhZ2UnKTtcbiAgICB2YXIgY29va2llc19hdmFpbGFibGUgPSB0eXBlb2YgQ29va2llcyAhPT0gJ3VuZGVmaW5lZCc7XG5cbiAgICAvLyBOYW1lc3BhY2Ugb2JqZWN0XG4gICAgdmFyIHN0b3JhZ2UgPSB7XG4gICAgICAgIF90eXBlOiAnJyxcbiAgICAgICAgX25zOiAnJyxcbiAgICAgICAgX2NhbGxNZXRob2Q6IGZ1bmN0aW9uIChmLCBhKSB7XG4gICAgICAgICAgICBhID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYSk7XG4gICAgICAgICAgICB2YXIgcCA9IFtdLCBhMCA9IGFbMF07XG4gICAgICAgICAgICBpZiAodGhpcy5fbnMpIHtcbiAgICAgICAgICAgICAgICBwLnB1c2godGhpcy5fbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBhMCA9PT0gJ3N0cmluZycgJiYgYTAuaW5kZXhPZignLicpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGEuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICBbXS51bnNoaWZ0LmFwcGx5KGEsIGEwLnNwbGl0KCcuJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgW10ucHVzaC5hcHBseShwLCBhKTtcbiAgICAgICAgICAgIHJldHVybiBmLmFwcGx5KHRoaXMsIHApO1xuICAgICAgICB9LFxuICAgICAgICAvLyBEZWZpbmUgaWYgcGx1Z2luIGFsd2F5cyB1c2UgSlNPTiB0byBzdG9yZSB2YWx1ZXMgKGV2ZW4gdG8gc3RvcmUgc2ltcGxlIHZhbHVlcyBsaWtlIHN0cmluZywgaW50Li4uKSBvciBub3RcbiAgICAgICAgYWx3YXlzVXNlSnNvbjogZmFsc2UsXG4gICAgICAgIC8vIEdldCBpdGVtcy4gSWYgbm8gcGFyYW1ldGVycyBhbmQgc3RvcmFnZSBoYXZlIGEgbmFtZXNwYWNlLCByZXR1cm4gYWxsIG5hbWVzcGFjZVxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghc3RvcmFnZV9hdmFpbGFibGUgJiYgIWNvb2tpZXNfYXZhaWxhYmxlKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWxsTWV0aG9kKF9nZXQsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFNldCBpdGVtc1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBsID0gYXJndW1lbnRzLmxlbmd0aCwgYSA9IGFyZ3VtZW50cywgYTAgPSBhWzBdO1xuICAgICAgICAgICAgaWYgKGwgPCAxIHx8ICFfaXNQbGFpbk9iamVjdChhMCkgJiYgbCA8IDIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pbmltdW0gMiBhcmd1bWVudHMgbXVzdCBiZSBnaXZlbiBvciBmaXJzdCBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc3RvcmFnZV9hdmFpbGFibGUgJiYgIWNvb2tpZXNfYXZhaWxhYmxlKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIGZpcnN0IGFyZ3VtZW50IGlzIGFuIG9iamVjdCBhbmQgc3RvcmFnZSBpcyBhIG5hbWVzcGFjZSBzdG9yYWdlLCBzZXQgdmFsdWVzIGluZGl2aWR1YWxseVxuICAgICAgICAgICAgaWYgKF9pc1BsYWluT2JqZWN0KGEwKSAmJiB0aGlzLl9ucykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgaW4gYTApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGEwLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWxsTWV0aG9kKF9zZXQsIFtpLCBhMFtpXV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHIgPSB0aGlzLl9jYWxsTWV0aG9kKF9zZXQsIGEpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9ucykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gclthMC5zcGxpdCgnLicpWzBdXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIERlbGV0ZSBpdGVtc1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWluaW11bSAxIGFyZ3VtZW50IG11c3QgYmUgZ2l2ZW4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc3RvcmFnZV9hdmFpbGFibGUgJiYgIWNvb2tpZXNfYXZhaWxhYmxlKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWxsTWV0aG9kKF9yZW1vdmUsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIERlbGV0ZSBhbGwgaXRlbXNcbiAgICAgICAgcmVtb3ZlQWxsOiBmdW5jdGlvbiAocmVpbml0X25zKSB7XG4gICAgICAgICAgICBpZiAoIXN0b3JhZ2VfYXZhaWxhYmxlICYmICFjb29raWVzX2F2YWlsYWJsZSl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWxsTWV0aG9kKF9zZXQsIFt7fV0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FsbE1ldGhvZChfcmVtb3ZlQWxsLCBbcmVpbml0X25zXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEl0ZW1zIGVtcHR5XG4gICAgICAgIGlzRW1wdHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghc3RvcmFnZV9hdmFpbGFibGUgJiYgIWNvb2tpZXNfYXZhaWxhYmxlKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWxsTWV0aG9kKF9pc0VtcHR5LCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBJdGVtcyBleGlzdHNcbiAgICAgICAgaXNTZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWluaW11bSAxIGFyZ3VtZW50IG11c3QgYmUgZ2l2ZW4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc3RvcmFnZV9hdmFpbGFibGUgJiYgIWNvb2tpZXNfYXZhaWxhYmxlKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWxsTWV0aG9kKF9pc1NldCwgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gR2V0IGtleXMgb2YgaXRlbXNcbiAgICAgICAga2V5czogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFzdG9yYWdlX2F2YWlsYWJsZSAmJiAhY29va2llc19hdmFpbGFibGUpe1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGxNZXRob2QoX2tleXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gVXNlIGpzLWNvb2tpZSBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG9sZCBicm93c2VycyBhbmQgZ2l2ZSBhY2Nlc3MgdG8gY29va2llU3RvcmFnZVxuICAgIGlmIChjb29raWVzX2F2YWlsYWJsZSkge1xuICAgICAgICAvLyBzZXNzaW9uU3RvcmFnZSBpcyB2YWxpZCBmb3Igb25lIHdpbmRvdy90YWIuIFRvIHNpbXVsYXRlIHRoYXQgd2l0aCBjb29raWUsIHdlIHNldCBhIG5hbWUgZm9yIHRoZSB3aW5kb3cgYW5kIHVzZSBpdCBmb3IgdGhlIG5hbWUgb2YgdGhlIGNvb2tpZVxuICAgICAgICBpZiAoIXdpbmRvdy5uYW1lKSB7XG4gICAgICAgICAgICB3aW5kb3cubmFtZSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwMDAwMCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvb2tpZV9zdG9yYWdlID0ge1xuICAgICAgICAgICAgX2Nvb2tpZTogdHJ1ZSxcbiAgICAgICAgICAgIF9wcmVmaXg6ICcnLFxuICAgICAgICAgICAgX2V4cGlyZXM6IG51bGwsXG4gICAgICAgICAgICBfcGF0aDogbnVsbCxcbiAgICAgICAgICAgIF9kb21haW46IG51bGwsXG4gICAgICAgICAgICBfc2VjdXJlOiBmYWxzZSxcbiAgICAgICAgICAgIHNldEl0ZW06IGZ1bmN0aW9uIChuLCB2KSB7XG4gICAgICAgICAgICAgICAgQ29va2llcy5zZXQodGhpcy5fcHJlZml4ICsgbiwgdiwge2V4cGlyZXM6IHRoaXMuX2V4cGlyZXMsIHBhdGg6IHRoaXMuX3BhdGgsIGRvbWFpbjogdGhpcy5fZG9tYWluLCBzZWN1cmU6IHRoaXMuX3NlY3VyZX0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldEl0ZW06IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIENvb2tpZXMuZ2V0KHRoaXMuX3ByZWZpeCArIG4pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlbW92ZUl0ZW06IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIENvb2tpZXMucmVtb3ZlKHRoaXMuX3ByZWZpeCArIG4sIHtwYXRoOiB0aGlzLl9wYXRofSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29va2llcyA9IENvb2tpZXMuZ2V0KCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGNvb2tpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvb2tpZXMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBrZXkgIT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fcHJlZml4ICYmIGtleS5pbmRleE9mKGNvb2tpZV9sb2NhbF9wcmVmaXgpID09PSAtMSAmJiBrZXkuaW5kZXhPZihjb29raWVfc2Vzc2lvbl9wcmVmaXgpID09PSAtMSB8fCB0aGlzLl9wcmVmaXggJiYga2V5LmluZGV4T2YodGhpcy5fcHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIENvb2tpZXMucmVtb3ZlKGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0RXhwaXJlczogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9leHBpcmVzID0gZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXRQYXRoOiBmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhdGggPSBwO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldERvbWFpbjogZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kb21haW4gPSBkO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldFNlY3VyZTogZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZWN1cmUgPSBzO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldENvbmY6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgaWYgKGMucGF0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXRoID0gYy5wYXRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYy5kb21haW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZG9tYWluID0gYy5kb21haW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjLnNlY3VyZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZWN1cmUgPSBjLnNlY3VyZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGMuZXhwaXJlcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9leHBpcmVzID0gYy5leHBpcmVzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXREZWZhdWx0Q29uZjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhdGggPSB0aGlzLl9kb21haW4gPSB0aGlzLl9leHBpcmVzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZWN1cmUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFzdG9yYWdlX2F2YWlsYWJsZSkge1xuICAgICAgICAgICAgd2luZG93LmxvY2FsQ29va2llU3RvcmFnZSA9IF9leHRlbmQoe30sIGNvb2tpZV9zdG9yYWdlLCB7XG4gICAgICAgICAgICAgICAgX3ByZWZpeDogY29va2llX2xvY2FsX3ByZWZpeCxcbiAgICAgICAgICAgICAgICBfZXhwaXJlczogMzY1ICogMTAsXG4gICAgICAgICAgICAgICAgX3NlY3VyZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB3aW5kb3cuc2Vzc2lvbkNvb2tpZVN0b3JhZ2UgPSBfZXh0ZW5kKHt9LCBjb29raWVfc3RvcmFnZSwge1xuICAgICAgICAgICAgICAgIF9wcmVmaXg6IGNvb2tpZV9zZXNzaW9uX3ByZWZpeCArIHdpbmRvdy5uYW1lICsgJ18nLFxuICAgICAgICAgICAgICAgIF9zZWN1cmU6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHdpbmRvdy5jb29raWVTdG9yYWdlID0gX2V4dGVuZCh7fSwgY29va2llX3N0b3JhZ2UpO1xuICAgICAgICAvLyBjb29raWVTdG9yYWdlIEFQSVxuICAgICAgICBhcGlzLmNvb2tpZVN0b3JhZ2UgPSBfZXh0ZW5kKHt9LCBzdG9yYWdlLCB7XG4gICAgICAgICAgICBfdHlwZTogJ2Nvb2tpZVN0b3JhZ2UnLFxuICAgICAgICAgICAgc2V0RXhwaXJlczogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuY29va2llU3RvcmFnZS5zZXRFeHBpcmVzKGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldFBhdGg6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmNvb2tpZVN0b3JhZ2Uuc2V0UGF0aChwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXREb21haW46IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmNvb2tpZVN0b3JhZ2Uuc2V0RG9tYWluKGQpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldFNlY3VyZTogZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuY29va2llU3RvcmFnZS5zZXRTZWN1cmUocyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0Q29uZjogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuY29va2llU3RvcmFnZS5zZXRDb25mKGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldERlZmF1bHRDb25mOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmNvb2tpZVN0b3JhZ2Uuc2V0RGVmYXVsdENvbmYoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gR2V0IGEgbmV3IEFQSSBvbiBhIG5hbWVzcGFjZVxuICAgIGFwaXMuaW5pdE5hbWVzcGFjZVN0b3JhZ2UgPSBmdW5jdGlvbiAobnMpIHtcbiAgICAgICAgcmV0dXJuIF9jcmVhdGVOYW1lc3BhY2UobnMpO1xuICAgIH07XG4gICAgaWYgKHN0b3JhZ2VfYXZhaWxhYmxlKSB7XG4gICAgICAgIC8vIGxvY2FsU3RvcmFnZSBBUElcbiAgICAgICAgYXBpcy5sb2NhbFN0b3JhZ2UgPSBfZXh0ZW5kKHt9LCBzdG9yYWdlLCB7X3R5cGU6ICdsb2NhbFN0b3JhZ2UnfSk7XG4gICAgICAgIC8vIHNlc3Npb25TdG9yYWdlIEFQSVxuICAgICAgICBhcGlzLnNlc3Npb25TdG9yYWdlID0gX2V4dGVuZCh7fSwgc3RvcmFnZSwge190eXBlOiAnc2Vzc2lvblN0b3JhZ2UnfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbG9jYWxTdG9yYWdlIEFQSVxuICAgICAgICBhcGlzLmxvY2FsU3RvcmFnZSA9IF9leHRlbmQoe30sIHN0b3JhZ2UsIHtfdHlwZTogJ2xvY2FsQ29va2llU3RvcmFnZSd9KTtcbiAgICAgICAgLy8gc2Vzc2lvblN0b3JhZ2UgQVBJXG4gICAgICAgIGFwaXMuc2Vzc2lvblN0b3JhZ2UgPSBfZXh0ZW5kKHt9LCBzdG9yYWdlLCB7X3R5cGU6ICdzZXNzaW9uQ29va2llU3RvcmFnZSd9KTtcbiAgICB9XG4gICAgLy8gTGlzdCBvZiBhbGwgbmFtZXNwYWNlIHN0b3JhZ2VcbiAgICBhcGlzLm5hbWVzcGFjZVN0b3JhZ2VzID0ge307XG4gICAgLy8gUmVtb3ZlIGFsbCBpdGVtcyBpbiBhbGwgc3RvcmFnZXNcbiAgICBhcGlzLnJlbW92ZUFsbFN0b3JhZ2VzID0gZnVuY3Rpb24gKHJlaW5pdF9ucykge1xuICAgICAgICBhcGlzLmxvY2FsU3RvcmFnZS5yZW1vdmVBbGwocmVpbml0X25zKTtcbiAgICAgICAgYXBpcy5zZXNzaW9uU3RvcmFnZS5yZW1vdmVBbGwocmVpbml0X25zKTtcbiAgICAgICAgaWYgKGFwaXMuY29va2llU3RvcmFnZSkge1xuICAgICAgICAgICAgYXBpcy5jb29raWVTdG9yYWdlLnJlbW92ZUFsbChyZWluaXRfbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVpbml0X25zKSB7XG4gICAgICAgICAgICBhcGlzLm5hbWVzcGFjZVN0b3JhZ2VzID0ge307XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIEFib3V0IGFsd2F5c1VzZUpzb25cbiAgICAvLyBCeSBkZWZhdWx0LCBhbGwgdmFsdWVzIGFyZSBzdHJpbmcgb24gaHRtbCBzdG9yYWdlcyBhbmQgdGhlIHBsdWdpbiBkb24ndCB1c2UganNvbiB0byBzdG9yZSBzaW1wbGUgdmFsdWVzIChzdHJpbmdzLCBpbnQsIGZsb2F0Li4uKVxuICAgIC8vIFNvIGJ5IGRlZmF1bHQsIGlmIHlvdSBkbyBzdG9yYWdlLnNldEl0ZW0oJ3Rlc3QnLDIpLCB2YWx1ZSBpbiBzdG9yYWdlIHdpbGwgYmUgXCIyXCIsIG5vdCAyXG4gICAgLy8gSWYgeW91IHNldCB0aGlzIHByb3BlcnR5IHRvIHRydWUsIGFsbCB2YWx1ZXMgc2V0IHdpdGggdGhlIHBsdWdpbiB3aWxsIGJlIHN0b3JlZCBhcyBqc29uIHRvIGhhdmUgdHlwZWQgdmFsdWVzIGluIGFueSBjYXNlc1xuICAgIGFwaXMuYWx3YXlzVXNlSnNvbkluU3RvcmFnZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBzdG9yYWdlLmFsd2F5c1VzZUpzb24gPSB2YWx1ZTtcbiAgICAgICAgYXBpcy5sb2NhbFN0b3JhZ2UuYWx3YXlzVXNlSnNvbiA9IHZhbHVlO1xuICAgICAgICBhcGlzLnNlc3Npb25TdG9yYWdlLmFsd2F5c1VzZUpzb24gPSB2YWx1ZTtcbiAgICAgICAgaWYgKGFwaXMuY29va2llU3RvcmFnZSkge1xuICAgICAgICAgICAgYXBpcy5jb29raWVTdG9yYWdlLmFsd2F5c1VzZUpzb24gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gYXBpcztcbn0pKTtcbiIsIi8qIVxuICogSmF2YVNjcmlwdCBDb29raWUgdjIuMi4xXG4gKiBodHRwczovL2dpdGh1Yi5jb20vanMtY29va2llL2pzLWNvb2tpZVxuICpcbiAqIENvcHlyaWdodCAyMDA2LCAyMDE1IEtsYXVzIEhhcnRsICYgRmFnbmVyIEJyYWNrXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuOyhmdW5jdGlvbiAoZmFjdG9yeSkge1xuXHR2YXIgcmVnaXN0ZXJlZEluTW9kdWxlTG9hZGVyO1xuXHRpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0ZGVmaW5lKGZhY3RvcnkpO1xuXHRcdHJlZ2lzdGVyZWRJbk1vZHVsZUxvYWRlciA9IHRydWU7XG5cdH1cblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRcdHJlZ2lzdGVyZWRJbk1vZHVsZUxvYWRlciA9IHRydWU7XG5cdH1cblx0aWYgKCFyZWdpc3RlcmVkSW5Nb2R1bGVMb2FkZXIpIHtcblx0XHR2YXIgT2xkQ29va2llcyA9IHdpbmRvdy5Db29raWVzO1xuXHRcdHZhciBhcGkgPSB3aW5kb3cuQ29va2llcyA9IGZhY3RvcnkoKTtcblx0XHRhcGkubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHdpbmRvdy5Db29raWVzID0gT2xkQ29va2llcztcblx0XHRcdHJldHVybiBhcGk7XG5cdFx0fTtcblx0fVxufShmdW5jdGlvbiAoKSB7XG5cdGZ1bmN0aW9uIGV4dGVuZCAoKSB7XG5cdFx0dmFyIGkgPSAwO1xuXHRcdHZhciByZXN1bHQgPSB7fTtcblx0XHRmb3IgKDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGF0dHJpYnV0ZXMgPSBhcmd1bWVudHNbIGkgXTtcblx0XHRcdGZvciAodmFyIGtleSBpbiBhdHRyaWJ1dGVzKSB7XG5cdFx0XHRcdHJlc3VsdFtrZXldID0gYXR0cmlidXRlc1trZXldO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0ZnVuY3Rpb24gZGVjb2RlIChzKSB7XG5cdFx0cmV0dXJuIHMucmVwbGFjZSgvKCVbMC05QS1aXXsyfSkrL2csIGRlY29kZVVSSUNvbXBvbmVudCk7XG5cdH1cblxuXHRmdW5jdGlvbiBpbml0IChjb252ZXJ0ZXIpIHtcblx0XHRmdW5jdGlvbiBhcGkoKSB7fVxuXG5cdFx0ZnVuY3Rpb24gc2V0IChrZXksIHZhbHVlLCBhdHRyaWJ1dGVzKSB7XG5cdFx0XHRpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGF0dHJpYnV0ZXMgPSBleHRlbmQoe1xuXHRcdFx0XHRwYXRoOiAnLydcblx0XHRcdH0sIGFwaS5kZWZhdWx0cywgYXR0cmlidXRlcyk7XG5cblx0XHRcdGlmICh0eXBlb2YgYXR0cmlidXRlcy5leHBpcmVzID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHRhdHRyaWJ1dGVzLmV4cGlyZXMgPSBuZXcgRGF0ZShuZXcgRGF0ZSgpICogMSArIGF0dHJpYnV0ZXMuZXhwaXJlcyAqIDg2NGUrNSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFdlJ3JlIHVzaW5nIFwiZXhwaXJlc1wiIGJlY2F1c2UgXCJtYXgtYWdlXCIgaXMgbm90IHN1cHBvcnRlZCBieSBJRVxuXHRcdFx0YXR0cmlidXRlcy5leHBpcmVzID0gYXR0cmlidXRlcy5leHBpcmVzID8gYXR0cmlidXRlcy5leHBpcmVzLnRvVVRDU3RyaW5nKCkgOiAnJztcblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dmFyIHJlc3VsdCA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcblx0XHRcdFx0aWYgKC9eW1xce1xcW10vLnRlc3QocmVzdWx0KSkge1xuXHRcdFx0XHRcdHZhbHVlID0gcmVzdWx0O1xuXHRcdFx0XHR9XG5cdFx0XHR9IGNhdGNoIChlKSB7fVxuXG5cdFx0XHR2YWx1ZSA9IGNvbnZlcnRlci53cml0ZSA/XG5cdFx0XHRcdGNvbnZlcnRlci53cml0ZSh2YWx1ZSwga2V5KSA6XG5cdFx0XHRcdGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcodmFsdWUpKVxuXHRcdFx0XHRcdC5yZXBsYWNlKC8lKDIzfDI0fDI2fDJCfDNBfDNDfDNFfDNEfDJGfDNGfDQwfDVCfDVEfDVFfDYwfDdCfDdEfDdDKS9nLCBkZWNvZGVVUklDb21wb25lbnQpO1xuXG5cdFx0XHRrZXkgPSBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGtleSkpXG5cdFx0XHRcdC5yZXBsYWNlKC8lKDIzfDI0fDI2fDJCfDVFfDYwfDdDKS9nLCBkZWNvZGVVUklDb21wb25lbnQpXG5cdFx0XHRcdC5yZXBsYWNlKC9bXFwoXFwpXS9nLCBlc2NhcGUpO1xuXG5cdFx0XHR2YXIgc3RyaW5naWZpZWRBdHRyaWJ1dGVzID0gJyc7XG5cdFx0XHRmb3IgKHZhciBhdHRyaWJ1dGVOYW1lIGluIGF0dHJpYnV0ZXMpIHtcblx0XHRcdFx0aWYgKCFhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0c3RyaW5naWZpZWRBdHRyaWJ1dGVzICs9ICc7ICcgKyBhdHRyaWJ1dGVOYW1lO1xuXHRcdFx0XHRpZiAoYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXSA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ29uc2lkZXJzIFJGQyA2MjY1IHNlY3Rpb24gNS4yOlxuXHRcdFx0XHQvLyAuLi5cblx0XHRcdFx0Ly8gMy4gIElmIHRoZSByZW1haW5pbmcgdW5wYXJzZWQtYXR0cmlidXRlcyBjb250YWlucyBhICV4M0IgKFwiO1wiKVxuXHRcdFx0XHQvLyAgICAgY2hhcmFjdGVyOlxuXHRcdFx0XHQvLyBDb25zdW1lIHRoZSBjaGFyYWN0ZXJzIG9mIHRoZSB1bnBhcnNlZC1hdHRyaWJ1dGVzIHVwIHRvLFxuXHRcdFx0XHQvLyBub3QgaW5jbHVkaW5nLCB0aGUgZmlyc3QgJXgzQiAoXCI7XCIpIGNoYXJhY3Rlci5cblx0XHRcdFx0Ly8gLi4uXG5cdFx0XHRcdHN0cmluZ2lmaWVkQXR0cmlidXRlcyArPSAnPScgKyBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdLnNwbGl0KCc7JylbMF07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAoZG9jdW1lbnQuY29va2llID0ga2V5ICsgJz0nICsgdmFsdWUgKyBzdHJpbmdpZmllZEF0dHJpYnV0ZXMpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldCAoa2V5LCBqc29uKSB7XG5cdFx0XHRpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHZhciBqYXIgPSB7fTtcblx0XHRcdC8vIFRvIHByZXZlbnQgdGhlIGZvciBsb29wIGluIHRoZSBmaXJzdCBwbGFjZSBhc3NpZ24gYW4gZW1wdHkgYXJyYXlcblx0XHRcdC8vIGluIGNhc2UgdGhlcmUgYXJlIG5vIGNvb2tpZXMgYXQgYWxsLlxuXHRcdFx0dmFyIGNvb2tpZXMgPSBkb2N1bWVudC5jb29raWUgPyBkb2N1bWVudC5jb29raWUuc3BsaXQoJzsgJykgOiBbXTtcblx0XHRcdHZhciBpID0gMDtcblxuXHRcdFx0Zm9yICg7IGkgPCBjb29raWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciBwYXJ0cyA9IGNvb2tpZXNbaV0uc3BsaXQoJz0nKTtcblx0XHRcdFx0dmFyIGNvb2tpZSA9IHBhcnRzLnNsaWNlKDEpLmpvaW4oJz0nKTtcblxuXHRcdFx0XHRpZiAoIWpzb24gJiYgY29va2llLmNoYXJBdCgwKSA9PT0gJ1wiJykge1xuXHRcdFx0XHRcdGNvb2tpZSA9IGNvb2tpZS5zbGljZSgxLCAtMSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHZhciBuYW1lID0gZGVjb2RlKHBhcnRzWzBdKTtcblx0XHRcdFx0XHRjb29raWUgPSAoY29udmVydGVyLnJlYWQgfHwgY29udmVydGVyKShjb29raWUsIG5hbWUpIHx8XG5cdFx0XHRcdFx0XHRkZWNvZGUoY29va2llKTtcblxuXHRcdFx0XHRcdGlmIChqc29uKSB7XG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRjb29raWUgPSBKU09OLnBhcnNlKGNvb2tpZSk7XG5cdFx0XHRcdFx0XHR9IGNhdGNoIChlKSB7fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGphcltuYW1lXSA9IGNvb2tpZTtcblxuXHRcdFx0XHRcdGlmIChrZXkgPT09IG5hbWUpIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBjYXRjaCAoZSkge31cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGtleSA/IGphcltrZXldIDogamFyO1xuXHRcdH1cblxuXHRcdGFwaS5zZXQgPSBzZXQ7XG5cdFx0YXBpLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdHJldHVybiBnZXQoa2V5LCBmYWxzZSAvKiByZWFkIGFzIHJhdyAqLyk7XG5cdFx0fTtcblx0XHRhcGkuZ2V0SlNPTiA9IGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdHJldHVybiBnZXQoa2V5LCB0cnVlIC8qIHJlYWQgYXMganNvbiAqLyk7XG5cdFx0fTtcblx0XHRhcGkucmVtb3ZlID0gZnVuY3Rpb24gKGtleSwgYXR0cmlidXRlcykge1xuXHRcdFx0c2V0KGtleSwgJycsIGV4dGVuZChhdHRyaWJ1dGVzLCB7XG5cdFx0XHRcdGV4cGlyZXM6IC0xXG5cdFx0XHR9KSk7XG5cdFx0fTtcblxuXHRcdGFwaS5kZWZhdWx0cyA9IHt9O1xuXG5cdFx0YXBpLndpdGhDb252ZXJ0ZXIgPSBpbml0O1xuXG5cdFx0cmV0dXJuIGFwaTtcblx0fVxuXG5cdHJldHVybiBpbml0KGZ1bmN0aW9uICgpIHt9KTtcbn0pKTtcbiIsIlxuaW1wb3J0IFN0b3JhZ2VzIGZyb20gJ2pzLXN0b3JhZ2UnXG5pbXBvcnQgQ29va2llcyBmcm9tICdqcy1jb29raWUnXG5cblN0b3JhZ2VzLmFsd2F5c1VzZUpzb25JblN0b3JhZ2UoKVxuXG5leHBvcnQgY29uc3QgbG9jYWxTdG9yYWdlID0gU3RvcmFnZXMubG9jYWxTdG9yYWdlXG5leHBvcnQgY29uc3Qgc2Vzc2lvblN0b3JhZ2UgPSBTdG9yYWdlcy5zZXNzaW9uU3RvcmFnZVxuZXhwb3J0IGNvbnN0IGNvb2tpZVN0b3JhZ2UgPSBDb29raWVzXG5cbmV4cG9ydCBkZWZhdWx0IFN0b3JhZ2VzIiwiaW1wb3J0IHsgd3JpdGFibGUgfSBmcm9tICdzdmVsdGUvc3RvcmUnO1xuXG5leHBvcnQgY29uc3QgbW9kYWxzID0gd3JpdGFibGUoe30pOyIsImltcG9ydCB7IGdldCBhcyBnZXQkMSwgd3JpdGFibGUgYXMgd3JpdGFibGUkMSB9IGZyb20gJ3N2ZWx0ZS9zdG9yZSc7XG5pbXBvcnQgeyBub29wLCBydW5fYWxsLCBpc19mdW5jdGlvbiB9IGZyb20gJ3N2ZWx0ZS9pbnRlcm5hbCc7XG5cbmZ1bmN0aW9uIGlzU2ltcGxlRGVyaXZlcihkZXJpdmVyKSB7XHJcbiAgICByZXR1cm4gZGVyaXZlci5sZW5ndGggPCAyO1xyXG59XHJcbmZ1bmN0aW9uIGdlbmVyYXRvcihzdG9yYWdlKSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBgUmVhZGFibGVgIHN0b3JlIHRoYXQgYWxsb3dzIHJlYWRpbmcgYnkgc3Vic2NyaXB0aW9uLlxyXG4gICAgICogQHBhcmFtIGtleSBzdG9yYWdlIGtleVxyXG4gICAgICogQHBhcmFtIHZhbHVlIGluaXRpYWwgdmFsdWVcclxuICAgICAqIEBwYXJhbSB7U3RhcnRTdG9wTm90aWZpZXJ9c3RhcnQgc3RhcnQgYW5kIHN0b3Agbm90aWZpY2F0aW9ucyBmb3Igc3Vic2NyaXB0aW9uc1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiByZWFkYWJsZShrZXksIHZhbHVlLCBzdGFydCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHN1YnNjcmliZTogd3JpdGFibGUoa2V5LCB2YWx1ZSwgc3RhcnQpLnN1YnNjcmliZVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIGBXcml0YWJsZWAgc3RvcmUgdGhhdCBhbGxvd3MgYm90aCB1cGRhdGluZyBhbmQgcmVhZGluZyBieSBzdWJzY3JpcHRpb24uXHJcbiAgICAgKiBAcGFyYW0ga2V5IHN0b3JhZ2Uga2V5XHJcbiAgICAgKiBAcGFyYW0geyo9fXZhbHVlIGRlZmF1bHQgdmFsdWVcclxuICAgICAqIEBwYXJhbSB7U3RhcnRTdG9wTm90aWZpZXI9fXN0YXJ0IHN0YXJ0IGFuZCBzdG9wIG5vdGlmaWNhdGlvbnMgZm9yIHN1YnNjcmlwdGlvbnNcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gd3JpdGFibGUoa2V5LCB2YWx1ZSwgc3RhcnQgPSBub29wKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gd3JhcF9zdGFydChvZ1NldCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc3RhcnQoZnVuY3Rpb24gd3JhcF9zZXQobmV3X3ZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RvcmFnZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0b3JhZ2Uuc2V0SXRlbShrZXksIEpTT04uc3RyaW5naWZ5KG5ld192YWx1ZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9nU2V0KG5ld192YWx1ZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3RvcmFnZSkge1xyXG4gICAgICAgICAgICBpZiAoc3RvcmFnZS5nZXRJdGVtKGtleSkpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gSlNPTi5wYXJzZShzdG9yYWdlLmdldEl0ZW0oa2V5KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3RvcmFnZS5zZXRJdGVtKGtleSwgSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgb2dTdG9yZSA9IHdyaXRhYmxlJDEodmFsdWUsIHN0YXJ0ID8gd3JhcF9zdGFydCA6IHVuZGVmaW5lZCk7XHJcbiAgICAgICAgZnVuY3Rpb24gc2V0KG5ld192YWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAoc3RvcmFnZSkge1xyXG4gICAgICAgICAgICAgICAgc3RvcmFnZS5zZXRJdGVtKGtleSwgSlNPTi5zdHJpbmdpZnkobmV3X3ZhbHVlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb2dTdG9yZS5zZXQobmV3X3ZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlKGZuKSB7XHJcbiAgICAgICAgICAgIHNldChmbihnZXQkMShvZ1N0b3JlKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBzdWJzY3JpYmUocnVuLCBpbnZhbGlkYXRlID0gbm9vcCkge1xyXG4gICAgICAgICAgICByZXR1cm4gb2dTdG9yZS5zdWJzY3JpYmUocnVuLCBpbnZhbGlkYXRlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgc2V0LCB1cGRhdGUsIHN1YnNjcmliZSB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEZXJpdmVkIHZhbHVlIHN0b3JlIGJ5IHN5bmNocm9uaXppbmcgb25lIG9yIG1vcmUgcmVhZGFibGUgc3RvcmVzIGFuZFxyXG4gICAgICogYXBwbHlpbmcgYW4gYWdncmVnYXRpb24gZnVuY3Rpb24gb3ZlciBpdHMgaW5wdXQgdmFsdWVzLlxyXG4gICAgICogQHBhcmFtIGtleSBzdG9yYWdlIGtleVxyXG4gICAgICogQHBhcmFtIHtTdG9yZXN9IHN0b3JlcyBpbnB1dCBzdG9yZXNcclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oU3RvcmVzPSwgZnVuY3Rpb24oKik9KToqfWZuIGZ1bmN0aW9uIGNhbGxiYWNrIHRoYXQgYWdncmVnYXRlcyB0aGUgdmFsdWVzXHJcbiAgICAgKiBAcGFyYW0geyo9fWluaXRpYWxfdmFsdWUgd2hlbiB1c2VkIGFzeW5jaHJvbm91c2x5XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGRlcml2ZWQoa2V5LCBzdG9yZXMsIGZuLCBpbml0aWFsX3ZhbHVlKSB7XHJcbiAgICAgICAgY29uc3Qgc2luZ2xlID0gIUFycmF5LmlzQXJyYXkoc3RvcmVzKTtcclxuICAgICAgICBjb25zdCBzdG9yZXNfYXJyYXkgPSBzaW5nbGVcclxuICAgICAgICAgICAgPyBbc3RvcmVzXVxyXG4gICAgICAgICAgICA6IHN0b3JlcztcclxuICAgICAgICBpZiAoc3RvcmFnZSAmJiBzdG9yYWdlLmdldEl0ZW0oa2V5KSkge1xyXG4gICAgICAgICAgICBpbml0aWFsX3ZhbHVlID0gSlNPTi5wYXJzZShzdG9yYWdlLmdldEl0ZW0oa2V5KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZWFkYWJsZShrZXksIGluaXRpYWxfdmFsdWUsIChzZXQpID0+IHtcclxuICAgICAgICAgICAgbGV0IGluaXRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBbXTtcclxuICAgICAgICAgICAgbGV0IHBlbmRpbmcgPSAwO1xyXG4gICAgICAgICAgICBsZXQgY2xlYW51cCA9IG5vb3A7XHJcbiAgICAgICAgICAgIGNvbnN0IHN5bmMgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAocGVuZGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNsZWFudXAoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0ID0gc2luZ2xlID8gdmFsdWVzWzBdIDogdmFsdWVzO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzU2ltcGxlRGVyaXZlcihmbikpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXQoZm4oaW5wdXQpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGZuKGlucHV0LCBzZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNsZWFudXAgPSBpc19mdW5jdGlvbihyZXN1bHQpID8gcmVzdWx0IDogbm9vcDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29uc3QgdW5zdWJzY3JpYmVycyA9IHN0b3Jlc19hcnJheS5tYXAoKHN0b3JlLCBpKSA9PiBzdG9yZS5zdWJzY3JpYmUoKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZXNbaV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIHBlbmRpbmcgJj0gfigxIDw8IGkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGluaXRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN5bmMoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcGVuZGluZyB8PSAoMSA8PCBpKTtcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICBpbml0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBzeW5jKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBzdG9wKCkge1xyXG4gICAgICAgICAgICAgICAgcnVuX2FsbCh1bnN1YnNjcmliZXJzKTtcclxuICAgICAgICAgICAgICAgIGNsZWFudXAoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVhZGFibGUsXHJcbiAgICAgICAgd3JpdGFibGUsXHJcbiAgICAgICAgZGVyaXZlZCxcclxuICAgICAgICBnZXQ6IGdldCQxXHJcbiAgICB9O1xyXG59XG5cbmNvbnN0IHN0b3JhZ2UgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5sb2NhbFN0b3JhZ2UgOiB1bmRlZmluZWQ7XHJcbmNvbnN0IHsgcmVhZGFibGUsIHdyaXRhYmxlLCBkZXJpdmVkLCBnZXQgfSA9IGdlbmVyYXRvcihzdG9yYWdlKTtcblxuZXhwb3J0IHsgZGVyaXZlZCwgZ2V0LCByZWFkYWJsZSwgd3JpdGFibGUgfTtcbiIsImltcG9ydCB7IHdyaXRhYmxlIH0gZnJvbSAnc3ZlbHRlLXBlcnNpc3RlbnQtc3RvcmUvZGlzdC9sb2NhbCc7XG5cbmV4cG9ydCBjb25zdCBvcmdhbml6YXRpb24gPSB3cml0YWJsZSgnb3JnYW5pemF0aW9uJywgbnVsbCk7XG5leHBvcnQgY29uc3Qgb3JnYW5pemF0aW9ucyA9IHdyaXRhYmxlKCdvcmdhbml6YXRpb25zJywgbnVsbCk7XG4iLCI8c2NyaXB0PlxuICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuXG4gIGV4cG9ydCBsZXQgaWQgPSB1bmRlZmluZWRcbiAgZXhwb3J0IGxldCBvZmYgPSBmYWxzZVxuXG4gIGxldCByZWY7XG4gIGxldCBwb3J0YWw7XG5cbiAgb25Nb3VudCgoKSA9PiB7XG4gICAgaWYgKG9mZikgcmV0dXJuXG4gICAgY29uc3QgcHJldlBvcnRhbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGBwb3J0YWxfJHtpZH1gKVxuICAgIGlmIChpZCAmJiBwcmV2UG9ydGFsKSBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHByZXZQb3J0YWwpO1xuICAgIHBvcnRhbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgcG9ydGFsLmNsYXNzTmFtZSA9IFwicG9ydGFsXCI7XG4gICAgcG9ydGFsLmlkID0gYHBvcnRhbF8ke2lkfWA7XG4gICAgcG9ydGFsLmFwcGVuZENoaWxkKHJlZik7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChwb3J0YWwpO1xuICAgIHJldHVybiAoKSA9PiBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHBvcnRhbClcbiAgfSk7XG5cbjwvc2NyaXB0PlxuXG57I2lmIG9mZn1cbiAgPHNsb3QgLz5cbns6ZWxzZX1cbiAgPGRpdiBjbGFzcz1cInBvcnRhbC1jbG9uZVwiPlxuICAgICAgPGRpdiBiaW5kOnRoaXM9e3JlZn0+XG4gICAgICAgICAgPHNsb3QgLz5cbiAgICAgIDwvZGl2PlxuICA8L2Rpdj5cbnsvaWZ9XG5cbjxzdHlsZT5cbiAgLnBvcnRhbC1jbG9uZSB7XG4gICAgZGlzcGxheTogbm9uZTtcbiAgfVxuPC9zdHlsZT5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgY3JlYXRlRXZlbnREaXNwYXRjaGVyLCB0aWNrIH0gZnJvbSAnc3ZlbHRlJ1xuICAgIGltcG9ydCB7IGZseSB9IGZyb20gXCJzdmVsdGUvdHJhbnNpdGlvblwiO1xuICAgIGltcG9ydCB7IFN3aXBlIH0gZnJvbSAnQHNlcnZpY2VzJ1xuICAgIGltcG9ydCB7IHNhZmVHZXQsIGNsYXNzbmFtZXMsIGRlbGF5LCBib2R5U2Nyb2xsLCBzdG9wUHJvcGFnYXRpb25JblJhbmdlcyB9IGZyb20gXCJAdXRpbHNcIjtcbiAgICBpbXBvcnQgeyBtb2RhbHMgfSBmcm9tIFwiQHN0b3JlXCI7XG4gICAgaW1wb3J0IFBvcnRhbCBmcm9tIFwiLi9Qb3J0YWwuc3ZlbHRlXCI7XG4gICAgaW1wb3J0IEJyIGZyb20gXCIuL0JyLnN2ZWx0ZVwiO1xuICAgIGltcG9ydCBJY29uIGZyb20gXCIuL0ljb24uc3ZlbHRlXCI7XG5cbiAgICBjb25zdCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpXG4gICAgXG4gICAgY29uc3QgRFVSQVRJT04gPSAyNTBcbiAgICBjb25zdCBUSFJFU0hPTEQgPSA1MFxuICAgIGNvbnN0IFNXSVBFX1NQRUVEID0gLjVcbiAgICBjb25zdCBUSFJFU0hPTERfUkFOR0VTID0geyB4OiBbMCwgMTAwXSwgeTogWzEsIDk5XSB9XG4gICAgY29uc3QgU1RBUlRfUE9TSVRJT04gPSB7XG4gICAgICAgIHg6IDUwLFxuICAgICAgICB5OiAwXG4gICAgfVxuXG4gICAgZXhwb3J0IGxldCBpZFxuICAgIGV4cG9ydCBsZXQgcmVmID0gbnVsbFxuICAgIGV4cG9ydCBsZXQgc2l6ZSA9ICdmdWxsJyAgICAvLyBzbWFsbC9tZWRpdW0vYmlnL2Z1bGxcbiAgICBleHBvcnQgbGV0IHN3aXBlID0gW10gICAgICAgLy8gdXAgZG93biBsZWZ0IHJpZ2h0IGFsbFxuICAgIGV4cG9ydCBsZXQgdGl0bGUgPSAn0JfQsNC60YDQuNGC0LgnXG4gICAgZXhwb3J0IGxldCBvcGVuID0gbnVsbFxuICAgIGV4cG9ydCBsZXQgc3RhcnRQb3NpdGlvbiA9IFNUQVJUX1BPU0lUSU9OXG4gICAgZXhwb3J0IGxldCBibG9ja0JvZHkgPSB0cnVlXG4gICAgZXhwb3J0IGxldCB3aXRoSGVhZGVyID0gdHJ1ZVxuXG4gICAgbGV0IHJlZkhlYWRlclxuICAgIGxldCBpc0JvZHlCbG9ja2VkID0gZmFsc2VcbiAgICBsZXQgaXNBbGxvd2VkID0ge1xuICAgICAgICB1cDogdHJ1ZSxcbiAgICAgICAgZG93bjogZmFsc2UsXG4gICAgICAgIGxlZnQ6IHRydWUsXG4gICAgICAgIHJpZ2h0OiB0cnVlLFxuICAgIH1cblxuICAgICQ6IGlzU3dpcGUgPSB7XG4gICAgICAgIHVwOiBzYWZlR2V0KCgpID0+IHN3aXBlLmluY2x1ZGVzKCd1cCcpIHx8IHN3aXBlLmluY2x1ZGVzKCdhbGwnKSksXG4gICAgICAgIGRvd246IHNhZmVHZXQoKCkgPT4gc3dpcGUuaW5jbHVkZXMoJ2Rvd24nKSB8fCBzd2lwZS5pbmNsdWRlcygnYWxsJykpLFxuICAgICAgICBsZWZ0OiBzYWZlR2V0KCgpID0+IHN3aXBlLmluY2x1ZGVzKCdsZWZ0JykgfHwgc3dpcGUuaW5jbHVkZXMoJ2FsbCcpKSxcbiAgICAgICAgcmlnaHQ6IHNhZmVHZXQoKCkgPT4gc3dpcGUuaW5jbHVkZXMoJ3JpZ2h0JykgfHwgc3dpcGUuaW5jbHVkZXMoJ2FsbCcpKSxcbiAgICB9XG4gICAgJDogc2Nyb2xsWSA9IHJlZiAmJiByZWYuc2Nyb2xsVG9wXG4gICAgJDogYWN0aXZlID0gc2FmZUdldCgoKSA9PiBvcGVuICE9PSBudWxsID8gb3BlbiA6ICRtb2RhbHNbYG1vZGFsLSR7aWR9YF0ub3BlbiwgbnVsbClcbiAgICAkOiBjbGFzc1Byb3AgPSBjbGFzc25hbWVzKCdtb2RhbCcsIHNpemUsIHsgYWN0aXZlIH0pXG4gICAgJDogb25BY3RpdmVDaGFuZ2UoYWN0aXZlKVxuICAgICQ6IGJsb2NrU2Nyb2xsKHJlZilcblxuICAgIGZ1bmN0aW9uIGJsb2NrU2Nyb2xsKG1vZGFsKSB7XG4gICAgICAgIGlmIChibG9ja0JvZHkgJiYgYWN0aXZlICYmICFpc0JvZHlCbG9ja2VkKSB7XG4gICAgICAgICAgICBib2R5U2Nyb2xsLmRpc2FibGVTY3JvbGwobW9kYWwsIHsgZXh0cmFMb2NrOiBzaXplID09PSAnZnVsbCcgfSk7XG4gICAgICAgICAgICBpc0JvZHlCbG9ja2VkID0gdHJ1ZVxuICAgICAgICAgICAgbW9kYWwgJiYgKG1vZGFsLnNjcm9sbFRvcCA9IDApXG4gICAgICAgICAgICBpc0FsbG93ZWQgPSB7XG4gICAgICAgICAgICAgICAgdXA6IHRydWUsXG4gICAgICAgICAgICAgICAgZG93bjogZmFsc2UsXG4gICAgICAgICAgICAgICAgbGVmdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICByaWdodDogdHJ1ZSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChibG9ja0JvZHkgJiYgIWFjdGl2ZSAmJiBpc0JvZHlCbG9ja2VkKSB7XG4gICAgICAgICAgICBib2R5U2Nyb2xsLmVuYWJsZVNjcm9sbChtb2RhbCwgeyBleHRyYUxvY2s6IHNpemUgPT09ICdmdWxsJyB9KTtcbiAgICAgICAgICAgIGlzQm9keUJsb2NrZWQgPSBmYWxzZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gb25BY3RpdmVDaGFuZ2UoYWN0aXZlKSB7XG4gICAgICAgIGlmIChhY3RpdmUpIHtcbiAgICAgICAgICAgIHNldER1cmF0aW9uKHJlZiwgRFVSQVRJT04pXG4gICAgICAgICAgICBzZXREdXJhdGlvbihyZWZIZWFkZXIsIERVUkFUSU9OKVxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBzZXREdXJhdGlvbihyZWYsIDApLCBEVVJBVElPTilcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gc2V0RHVyYXRpb24ocmVmSGVhZGVyLCAwKSwgRFVSQVRJT04pXG4gICAgICAgICAgICBkcmF3VHJhbnNmb3JtKHJlZiwgMCwgMClcbiAgICAgICAgICAgIGRyYXdUcmFuc2Zvcm0ocmVmSGVhZGVyLCAwLCAwKVxuICAgICAgICAgICAgZHJhd09wYWNpdHkocmVmLCAwLCAwKVxuICAgICAgICAgICAgZHJhd09wYWNpdHkocmVmSGVhZGVyLCAwLCAwKVxuICAgICAgICAgICAgYmxvY2tTY3JvbGwocmVmKVxuICAgICAgICAgICAgYXdhaXQgdGljaygpXG4gICAgICAgICAgICBkaXNwYXRjaCgnb3BlbicpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBibG9ja1Njcm9sbChyZWYpXG4gICAgICAgICAgICBhd2FpdCB0aWNrKClcbiAgICAgICAgICAgIGRpc3BhdGNoKCdjbG9zZScpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRBY3RpdmUoaXNBY3RpdmUpIHtcbiAgICAgICAgaWYgKG9wZW4gIT09IG51bGwpIG9wZW4gPSBpc0FjdGl2ZVxuICAgICAgICBtb2RhbHMudXBkYXRlKHMgPT4gKHsgLi4ucywgW2Btb2RhbC0ke2lkfWBdOiB7IG9wZW46IGlzQWN0aXZlIH0gfSkpXG4gICAgfVxuXG4gICAgbGV0IHhTd2lwZSA9IDBcbiAgICBsZXQgeVN3aXBlID0gMFxuXG4gICAgZnVuY3Rpb24gYWRkU3dpcGUoZWwpIHtcbiAgICAgICAgc3RvcFByb3BhZ2F0aW9uSW5SYW5nZXMoZWwsIFRIUkVTSE9MRF9SQU5HRVMsICh7IHgsIHkgfSkgPT4ge1xuICAgICAgICAgICAgaXNBbGxvd2VkID0ge1xuICAgICAgICAgICAgICAgIHVwOiB5IDw9IFRIUkVTSE9MRF9SQU5HRVMueVswXSxcbiAgICAgICAgICAgICAgICBkb3duOiB5ID49IFRIUkVTSE9MRF9SQU5HRVMueVsxXSxcbiAgICAgICAgICAgICAgICBsZWZ0OiB4IDw9IFRIUkVTSE9MRF9SQU5HRVMueFswXSB8fCB4ID49IFRIUkVTSE9MRF9SQU5HRVMueFsxXSxcbiAgICAgICAgICAgICAgICByaWdodDogeCA8PSBUSFJFU0hPTERfUkFOR0VTLnhbMF0gfHwgeCA+PSBUSFJFU0hPTERfUkFOR0VTLnhbMV0sXG4gICAgICAgICAgICB9IFxuICAgICAgICB9KVxuXG4gICAgICAgIG5ldyBTd2lwZShlbClcbiAgICAgICAgICAgICAgICAucnVuKClcbiAgICAgICAgICAgICAgICAub25VcChpc1N3aXBlLnVwID8gaGFuZGxlVmVydGljYWxTd2lwZSA6IG51bGwpXG4gICAgICAgICAgICAgICAgLm9uRG93bihpc1N3aXBlLmRvd24gPyBoYW5kbGVWZXJ0aWNhbFN3aXBlIDogbnVsbClcbiAgICAgICAgICAgICAgICAub25MZWZ0KGlzU3dpcGUubGVmdCA/IGhhbmRsZUhvcml6b250YWxTd2lwZSA6IG51bGwpXG4gICAgICAgICAgICAgICAgLm9uUmlnaHQoaXNTd2lwZS5yaWdodCA/IGhhbmRsZUhvcml6b250YWxTd2lwZSA6IG51bGwpXG4gICAgICAgICAgICAgICAgLm9uVG91Y2hFbmQoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzaGlmdCA9IDUwXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHhTd2lwZSA+IFRIUkVTSE9MRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0RHVyYXRpb24oZWwsIERVUkFUSU9OKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0RHVyYXRpb24ocmVmSGVhZGVyLCBEVVJBVElPTilcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gc2V0RHVyYXRpb24oZWwsIDApLCBEVVJBVElPTilcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gc2V0RHVyYXRpb24ocmVmSGVhZGVyLCAwKSwgRFVSQVRJT04pXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRBY3RpdmUoZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICBkcmF3T3BhY2l0eShlbCwgeFN3aXBlICsgc2hpZnQsIHlTd2lwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdPcGFjaXR5KHJlZkhlYWRlciwgeFN3aXBlICsgc2hpZnQsIHlTd2lwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdUcmFuc2Zvcm0oZWwsIHhTd2lwZSArIHNoaWZ0LCB5U3dpcGUpXG4gICAgICAgICAgICAgICAgICAgICAgICBkcmF3VHJhbnNmb3JtKHJlZkhlYWRlciwgeFN3aXBlICsgc2hpZnQsIHlTd2lwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGRlbGF5KERVUkFUSU9OKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHhTd2lwZSA8IC1USFJFU0hPTEQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldER1cmF0aW9uKGVsLCBEVVJBVElPTilcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldER1cmF0aW9uKHJlZkhlYWRlciwgRFVSQVRJT04pXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHNldER1cmF0aW9uKGVsLCAwKSwgRFVSQVRJT04pXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHNldER1cmF0aW9uKHJlZkhlYWRlciwgMCksIERVUkFUSU9OKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0QWN0aXZlKGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgZHJhd09wYWNpdHkoZWwsIHhTd2lwZSAtIHNoaWZ0LCB5U3dpcGUpXG4gICAgICAgICAgICAgICAgICAgICAgICBkcmF3T3BhY2l0eShyZWZIZWFkZXIsIHhTd2lwZSAtIHNoaWZ0LCB5U3dpcGUpXG4gICAgICAgICAgICAgICAgICAgICAgICBkcmF3VHJhbnNmb3JtKGVsLCB4U3dpcGUgLSBzaGlmdCwgeVN3aXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgZHJhd1RyYW5zZm9ybShyZWZIZWFkZXIsIHhTd2lwZSAtIHNoaWZ0LCB5U3dpcGUpXG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBkZWxheShEVVJBVElPTilcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKHlTd2lwZSA+IFRIUkVTSE9MRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0RHVyYXRpb24oZWwsIERVUkFUSU9OKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0RHVyYXRpb24ocmVmSGVhZGVyLCBEVVJBVElPTilcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gc2V0RHVyYXRpb24oZWwsIDApLCBEVVJBVElPTilcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gc2V0RHVyYXRpb24ocmVmSGVhZGVyLCAwKSwgRFVSQVRJT04pXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRBY3RpdmUoZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICBkcmF3T3BhY2l0eShlbCwgeFN3aXBlLCB5U3dpcGUgKyBzaGlmdClcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdPcGFjaXR5KHJlZkhlYWRlciwgeFN3aXBlLCB5U3dpcGUgKyBzaGlmdClcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdUcmFuc2Zvcm0oZWwsIHhTd2lwZSwgeVN3aXBlICsgc2hpZnQpXG4gICAgICAgICAgICAgICAgICAgICAgICBkcmF3VHJhbnNmb3JtKHJlZkhlYWRlciwgeFN3aXBlLCB5U3dpcGUgKyBzaGlmdClcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGRlbGF5KERVUkFUSU9OKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHlTd2lwZSA8IC1USFJFU0hPTEQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldER1cmF0aW9uKGVsLCBEVVJBVElPTilcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldER1cmF0aW9uKHJlZkhlYWRlciwgRFVSQVRJT04pXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHNldER1cmF0aW9uKGVsLCAwKSwgRFVSQVRJT04pXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHNldER1cmF0aW9uKHJlZkhlYWRlciwgMCksIERVUkFUSU9OKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0QWN0aXZlKGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgZHJhd09wYWNpdHkoZWwsIHhTd2lwZSwgeVN3aXBlIC0gc2hpZnQpXG4gICAgICAgICAgICAgICAgICAgICAgICBkcmF3T3BhY2l0eShyZWZIZWFkZXIsIHhTd2lwZSwgeVN3aXBlIC0gc2hpZnQpXG4gICAgICAgICAgICAgICAgICAgICAgICBkcmF3VHJhbnNmb3JtKGVsLCB4U3dpcGUsIHlTd2lwZSAtIHNoaWZ0KVxuICAgICAgICAgICAgICAgICAgICAgICAgZHJhd1RyYW5zZm9ybShyZWZIZWFkZXIsIHhTd2lwZSwgeVN3aXBlIC0gc2hpZnQpXG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBkZWxheShEVVJBVElPTilcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICh4U3dpcGUgPD0gVEhSRVNIT0xEICYmIHhTd2lwZSA+PSAtVEhSRVNIT0xEICYmIHlTd2lwZSA8PSBUSFJFU0hPTEQgJiYgeVN3aXBlID49IC1USFJFU0hPTEQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldER1cmF0aW9uKGVsLCBEVVJBVElPTilcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldER1cmF0aW9uKHJlZkhlYWRlciwgRFVSQVRJT04pXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHNldER1cmF0aW9uKGVsLCAwKSwgRFVSQVRJT04pXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHNldER1cmF0aW9uKHJlZkhlYWRlciwgMCksIERVUkFUSU9OKVxuICAgICAgICAgICAgICAgICAgICAgICAgZHJhd1RyYW5zZm9ybShlbCwgMCwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdUcmFuc2Zvcm0ocmVmSGVhZGVyLCAwLCAwKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0U3RhcnRQb3NpdGlvbigpXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB4U3dpcGUgPSAwXG4gICAgICAgICAgICAgICAgICAgIHlTd2lwZSA9IDBcbiAgICAgICAgICAgICAgICAgICAgZWwgJiYgKGVsLnN0eWxlLm9wYWNpdHkgPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICByZWZIZWFkZXIgJiYgKHJlZkhlYWRlci5zdHlsZS5vcGFjaXR5ID0gbnVsbClcbiAgICAgICAgICAgICAgICB9KVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZVZlcnRpY2FsU3dpcGUoeURvd24sIHlVcCwgZXZ0LCBlbCkge1xuICAgICAgICBjb25zdCBkaXIgPSB5VXAgLSB5RG93blxuICAgICAgICBpZiAoIWlzQWxsb3dlZC51cCAmJiBkaXIgPiAwIHx8ICFpc0FsbG93ZWQuZG93biAmJiBkaXIgPCAwKSByZXR1cm5cbiAgICAgICAgeVN3aXBlID0gZGlyICogU1dJUEVfU1BFRURcbiAgICAgICAgZHJhd1RyYW5zZm9ybShlbCwgeFN3aXBlLCB5U3dpcGUpXG4gICAgICAgIGRyYXdUcmFuc2Zvcm0ocmVmSGVhZGVyLCB4U3dpcGUsIHlTd2lwZSlcbiAgICAgICAgZHJhd09wYWNpdHkoZWwsIHhTd2lwZSwgeVN3aXBlKVxuICAgICAgICBkcmF3T3BhY2l0eShyZWZIZWFkZXIsIHhTd2lwZSwgeVN3aXBlKVxuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVIb3Jpem9udGFsU3dpcGUoeERvd24sIHhVcCwgZXZ0LCBlbCkge1xuICAgICAgICBjb25zdCBkaXIgPSB4VXAgLSB4RG93blxuICAgICAgICBpZiAoIWlzQWxsb3dlZC5sZWZ0ICYmIGRpciA+IDAgfHwgIWlzQWxsb3dlZC5yaWdodCAmJiBkaXIgPCAwKSByZXR1cm5cbiAgICAgICAgeFN3aXBlID0gZGlyICogU1dJUEVfU1BFRURcbiAgICAgICAgZHJhd1RyYW5zZm9ybShlbCwgeFN3aXBlLCB5U3dpcGUpXG4gICAgICAgIGRyYXdUcmFuc2Zvcm0ocmVmSGVhZGVyLCB4U3dpcGUsIHlTd2lwZSlcbiAgICAgICAgZHJhd09wYWNpdHkoZWwsIHhTd2lwZSwgeVN3aXBlKVxuICAgICAgICBkcmF3T3BhY2l0eShyZWZIZWFkZXIsIHhTd2lwZSwgeVN3aXBlKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFN0YXJ0UG9zaXRpb24oKSB7XG4gICAgICAgIGRyYXdUcmFuc2Zvcm0ocmVmLCBzdGFydFBvc2l0aW9uLngsIHN0YXJ0UG9zaXRpb24ueSlcbiAgICAgICAgZHJhd1RyYW5zZm9ybShyZWZIZWFkZXIsIHN0YXJ0UG9zaXRpb24ueCwgc3RhcnRQb3NpdGlvbi55KVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRyYXdUcmFuc2Zvcm0oZWwsIHgsIHkpIHtcbiAgICAgICAgY29uc3QgZGVsdGEgPSBNYXRoLmFicyh4KSA+IE1hdGguYWJzKHkpID8geCA6IHlcbiAgICAgICAgbGV0IHNjYWxlID0gMSAtIE1hdGguYWJzKGRlbHRhIC8gd2luZG93LmlubmVySGVpZ2h0KVxuICAgICAgICBlbCAmJiAoZWwuc3R5bGUudHJhbnNmb3JtID0gYG1hdHJpeCgke3NjYWxlfSwgMCwgMCwgJHtzY2FsZX0sICR7eH0sICR7eX0pYClcbiAgICB9XG4gICAgIGZ1bmN0aW9uIHNldER1cmF0aW9uKGVsLCBtcykge1xuICAgICAgICBlbCAmJiAoZWwuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gYCR7bXN9bXNgKVxuICAgIH1cbiAgICBmdW5jdGlvbiBkcmF3T3BhY2l0eShlbCwgeCwgeSkge1xuICAgICAgICBjb25zdCBkZWx0YSA9IE1hdGguYWJzKHgpID4gTWF0aC5hYnMoeSkgPyB4IDogeVxuICAgICAgICBlbCAmJiAoZWwuc3R5bGUub3BhY2l0eSA9IDEgLSBNYXRoLm1pbihNYXRoLmFicyhkZWx0YSAvIChUSFJFU0hPTEQgKiAxLjUpKSwgMSkpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwZWFyKG5vZGUsIHBhcmFtcykge1xuICAgICAgICBpZiAoIWFjdGl2ZSkgcmV0dXJuXG5cdFx0Y29uc3QgZXhpc3RpbmdUcmFuc2Zvcm0gPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpLnRyYW5zZm9ybS5yZXBsYWNlKCdub25lJywgJycpO1xuICAgICAgICBjb25zdCBnZXRTY2FsZSA9IHQgPT4gLjkgKyAuMSAqIHRcbiAgICAgICAgY29uc3QgZ2V0WCA9IHQgPT4gc3RhcnRQb3NpdGlvbi54IC0gc3RhcnRQb3NpdGlvbi54ICogdFxuXHRcdHJldHVybiB7XG5cdFx0XHRkdXJhdGlvbjogRFVSQVRJT04sXG5cdFx0XHRjc3M6ICh0KSA9PiBgb3BhY2l0eTogJHt0fTsgdHJhbnNmb3JtOiBtYXRyaXgoJHtnZXRTY2FsZSh0KX0sIDAsIDAsICR7Z2V0U2NhbGUodCl9LCAke2dldFgodCl9LCAwKWBcblx0XHR9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uQ2xvc2VNb2RhbCgpIHtcbiAgICAgICAgc2V0RHVyYXRpb24ocmVmLCBEVVJBVElPTilcbiAgICAgICAgc2V0RHVyYXRpb24ocmVmSGVhZGVyLCBEVVJBVElPTilcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiBzZXREdXJhdGlvbihyZWYsIDApLCBEVVJBVElPTilcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiBzZXREdXJhdGlvbihyZWZIZWFkZXIsIDApLCBEVVJBVElPTilcbiAgICAgICAgc2V0U3RhcnRQb3NpdGlvbigpXG4gICAgICAgIGRyYXdPcGFjaXR5KHJlZiwgc3RhcnRQb3NpdGlvbi54ICogMiwgc3RhcnRQb3NpdGlvbi55KVxuICAgICAgICBkcmF3T3BhY2l0eShyZWZIZWFkZXIsIHN0YXJ0UG9zaXRpb24ueCAqIDIsIHN0YXJ0UG9zaXRpb24ueSlcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiBzZXRBY3RpdmUoZmFsc2UpLCBEVVJBVElPTilcbiAgICB9XG48L3NjcmlwdD5cblxueyNpZiBhY3RpdmV9XG4gICAgPFBvcnRhbCB7aWR9PlxuICAgICAgICA8ZGl2XG4gICAgICAgICAgICBpZD17YG1vZGFsLSR7aWR9YH1cbiAgICAgICAgICAgIGJpbmQ6dGhpcz17cmVmfVxuICAgICAgICAgICAgYXJpYS1oaWRkZW49XCJ0cnVlXCIgXG4gICAgICAgICAgICBjbGFzcz17Y2xhc3NQcm9wfVxuICAgICAgICAgICAgdXNlOmFkZFN3aXBlXG4gICAgICAgICAgICBpbjphcHBlYXJcbiAgICAgICAgICAgIG9uOmNsaWNrPXtzZXRBY3RpdmUuYmluZChudWxsLCBmYWxzZSl9XG4gICAgICAgID5cbiAgICAgICAgICAgIHsjaWYgd2l0aEhlYWRlciAmJiBzaXplID09PSAnZnVsbCd9XG4gICAgICAgICAgICAgICAgPFBvcnRhbD5cbiAgICAgICAgICAgICAgICAgICAgPHNsb3QgbmFtZT1cImhlYWRlclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz17Y2xhc3NuYW1lcygnbW9kYWwtaGVhZGVyJywgeyBhY3RpdmUgfSl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW46YXBwZWFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmluZDp0aGlzPXtyZWZIZWFkZXJ9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb246Y2xpY2s9e29uQ2xvc2VNb2RhbH1cbiAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aDIgc3R5bGU9XCJwYWRkaW5nOiAxNXB4XCI+eyB0aXRsZSB9PC9oMj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImNsb3NlXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8SWNvbiB0eXBlPVwiY2xvc2VcIiBzaXplPVwiYmlnXCIgaXM9XCJsaWdodFwiLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgPC9zbG90PlxuICAgICAgICAgICAgICAgIDwvUG9ydGFsPiAgIFxuICAgICAgICAgICAgICAgIDxCciBzaXplPVwiNjBcIi8+XG4gICAgICAgICAgICB7L2lmfVxuICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgIGNsYXNzPVwibW9kYWwtaW5uZXJcIlxuICAgICAgICAgICAgICAgIHRhYmluZGV4PVwiLTFcIlxuICAgICAgICAgICAgICAgIHJvbGU9XCJkaWFsb2dcIlxuICAgICAgICAgICAgICAgIGFyaWEtbW9kYWw9XCJ0cnVlXCJcbiAgICAgICAgICAgICAgICBhcmlhLWxhYmVsbGVkYnk9XCLQvNC+0LTQsNC70YzQvdC1INCy0ZbQutC90L5cIlxuICAgICAgICAgICAgICAgIG9uOmNsaWNrPXtlID0+IGUuc3RvcFByb3BhZ2F0aW9uKCl9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgeyNpZiB3aXRoSGVhZGVyICYmIHNpemUgIT09ICdmdWxsJ31cbiAgICAgICAgICAgICAgICAgICAgPHNsb3QgbmFtZT1cImhlYWRlclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9e2NsYXNzbmFtZXMoJ21vZGFsLWhlYWRlci1yZWxhdGl2ZSBhY3RpdmUnKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW46YXBwZWFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uOmNsaWNrPXtvbkNsb3NlTW9kYWx9XG4gICAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGgyIHN0eWxlPVwicGFkZGluZzogMTVweFwiPnsgdGl0bGUgfTwvaDI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJjbG9zZVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPEljb24gdHlwZT1cImNsb3NlXCIgc2l6ZT1cImJpZ1wiIGlzPVwibGlnaHRcIi8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgIDwvc2xvdD5cbiAgICAgICAgICAgICAgICB7L2lmfVxuICAgICAgICAgICAgICAgIDxzbG90IHByb3BzPXtzYWZlR2V0KCgpID0+ICRtb2RhbHNbYG1vZGFsLSR7aWR9YF0sIHt9LCB0cnVlKX0vPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgIDwvUG9ydGFsPlxuey9pZn1cblxuPHN0eWxlPlxuICAgIC5tb2RhbCB7XG4gICAgICAgIHotaW5kZXg6IDg7XG4gICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgICAgdG9wOiAwO1xuICAgICAgICBsZWZ0OiAwO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBvdmVyZmxvdy14OiBoaWRkZW47XG4gICAgICAgIG92ZXJmbG93LXk6IGF1dG87XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgICB0b3VjaC1hY3Rpb246IG1hbmlwdWxhdGlvbjtcbiAgICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEodmFyKC0tY29sb3ItYmxhY2spLCAuNzUpO1xuICAgICAgICBvdXRsaW5lOiAxNTBweCBzb2xpZCByZ2JhKHZhcigtLWNvbG9yLWJsYWNrKSwgLjc1KTtcbiAgICAgICAgdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246IGVhc2Utb3V0O1xuICAgICAgICBvcGFjaXR5OiAwO1xuICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICB9XG5cbiAgICAubW9kYWwuYWN0aXZlLCAubW9kYWwtaGVhZGVyLmFjdGl2ZSB7XG4gICAgICAgIG9wYWNpdHk6IDE7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBhdXRvO1xuICAgIH1cblxuICAgIC5tb2RhbC1pbm5lciB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICAgIGFsaWduLWl0ZW1zOiBzdHJldGNoO1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHN0cmV0Y2g7XG4gICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWigwKTtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSh2YXIoLS10aGVtZS1jb2xvci1wcmltYXJ5KSk7XG4gICAgfVxuICAgIC5zbWFsbCAubW9kYWwtaW5uZXIge1xuICAgICAgICB3aWR0aDogMjAwcHg7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IHZhcigtLWJvcmRlci1yYWRpdXMtYmlnKTtcbiAgICAgICAgbWF4LXdpZHRoOiB2YXIoLS1mdWxsLWNvbnRhaW5lcik7XG4gICAgfVxuXG4gICAgLm1lZGl1bSAubW9kYWwtaW5uZXIge1xuICAgICAgICB3aWR0aDogY2FsYygxMDB2dyAtIHZhcigtLXNjcmVlbi1wYWRkaW5nKSAqIDIpO1xuICAgICAgICBib3JkZXItcmFkaXVzOiB2YXIoLS1ib3JkZXItcmFkaXVzLWJpZyk7XG4gICAgICAgIG1heC13aWR0aDogdmFyKC0tZnVsbC1jb250YWluZXIpO1xuICAgIH1cbiAgICAuYmlnIC5tb2RhbC1pbm5lciB7XG4gICAgICAgIHdpZHRoOiBjYWxjKDEwMCUgLSB2YXIoLS1zY3JlZW4tcGFkZGluZykgKiAyKTtcbiAgICAgICAgaGVpZ2h0OiBjYWxjKDEwMCUgLSB2YXIoLS1zY3JlZW4tcGFkZGluZykgKiAyKTtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogdmFyKC0tYm9yZGVyLXJhZGl1cy1iaWcpO1xuICAgICAgICBtYXgtd2lkdGg6IHZhcigtLWZ1bGwtY29udGFpbmVyKTtcbiAgICB9XG5cbiAgICAuZnVsbCB7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBzdHJldGNoO1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHN0cmV0Y2g7XG4gICAgfVxuXG4gICAgLmZ1bGwgLm1vZGFsLWlubmVyIHtcbiAgICAgICAgZmxleDogbm9uZTtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIG1pbi1oZWlnaHQ6IDEwMCU7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDA7XG4gICAgfVxuXG4gICAgLm1vZGFsLWhlYWRlciB7XG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWigwKTtcbiAgICAgICAgei1pbmRleDogOTtcbiAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgICB0b3A6IDA7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgICAgIGNvbG9yOiByZ2IodmFyKC0tY29sb3Itd2hpdGUpKTtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiKHZhcigtLWNvbG9yLWluZm8pKTtcbiAgICAgICAgb3BhY2l0eTogMDtcbiAgICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgICAgIHRyYW5zZm9ybS1vcmlnaW46IDUwJSA1MHZoO1xuICAgIH1cblxuICAgIC5tb2RhbC1oZWFkZXItcmVsYXRpdmUge1xuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVooMCk7XG4gICAgICAgIHotaW5kZXg6IDk7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgICAgICAgY29sb3I6IHJnYih2YXIoLS1jb2xvci13aGl0ZSkpO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IodmFyKC0tY29sb3ItaW5mbykpO1xuICAgIH1cblxuICAgIC5tb2RhbC1oZWFkZXIgLmNsb3NlLFxuICAgIC5tb2RhbC1oZWFkZXItcmVsYXRpdmUgLmNsb3NlIHtcbiAgICAgICAgZm9udC1zaXplOiAyNHB4O1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgd2lkdGg6IDUwcHg7XG4gICAgICAgIGhlaWdodDogNjBweDtcbiAgICB9XG48L3N0eWxlPiAgIFxuIiwiPHNjcmlwdD5cbiAgICBleHBvcnQgbGV0IHN0eWxlID0gdW5kZWZpbmVkXG48L3NjcmlwdD4gIFxuXG48c2VjdGlvbiB7c3R5bGV9IGNsYXNzPXtgc3F1YXJlICR7JCRwcm9wcy5jbGFzcyB8fCAnJ31gfT5cbiAgICA8ZGl2PlxuICAgICAgICA8c2xvdD48L3Nsb3Q+XG4gICAgPC9kaXY+XG48L3NlY3Rpb24+XG5cbjxzdHlsZT5cbiAgICBzZWN0aW9uIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVaKDApO1xuICAgIH1cblxuICAgIHNlY3Rpb246YWZ0ZXIge1xuICAgICAgICBjb250ZW50OiBcIlwiO1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgcGFkZGluZy10b3A6IDEwMCU7XG4gICAgfVxuXG4gICAgZGl2IHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IDA7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIHJpZ2h0OiAwO1xuICAgICAgICBib3R0b206IDA7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgfVxuPC9zdHlsZT5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgY3JlYXRlRXZlbnREaXNwYXRjaGVyIH0gZnJvbSAnc3ZlbHRlJ1xuICAgIGltcG9ydCB7IGNsYXNzbmFtZXMgfSBmcm9tICdAdXRpbHMnXG5cbiAgICBjb25zdCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpXG5cbiAgICBleHBvcnQgbGV0IHNyY1xuICAgIGV4cG9ydCBsZXQgYWx0XG4gICAgZXhwb3J0IGxldCBzaXplID0gJ2NvdmVyJ1xuICAgIGV4cG9ydCBsZXQgc3JjQmlnID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCBpZCA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgd2lkdGggPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IGhlaWdodCA9IHVuZGVmaW5lZFxuXG4gICAgbGV0IGxvYWRpbmdTcmNTbWFsbCA9IHRydWVcbiAgICBsZXQgbG9hZGluZ1NyY0JpZyA9IHRydWVcbiAgICBsZXQgaXNFcnJvclNtYWxsID0gZmFsc2VcbiAgICBsZXQgaXNFcnJvckJpZyA9IGZhbHNlXG5cbiAgICAkOiB3cmFwQ2xhc3NQcm9wID0gY2xhc3NuYW1lcygncGljdHVyZScsICQkcHJvcHMuY2xhc3MsIHNpemUsIHsgbG9hZGluZ1NyY1NtYWxsLCBsb2FkaW5nU3JjQmlnLCBpc0Vycm9yU21hbGwsIGlzRXJyb3JCaWcgfSlcblxuICAgIGZ1bmN0aW9uIGltZ1NlcnZpY2Uobm9kZSwgcG9zdEZpeCkge1xuICAgICAgICBpZiAobm9kZS5jb21wbGV0ZSkge1xuICAgICAgICAgICAgb25Mb2FkKG5vZGUsIHBvc3RGaXgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub2RlLm9ubG9hZCA9IG9uTG9hZC5iaW5kKG51bGwsIG5vZGUsIHBvc3RGaXgpXG4gICAgICAgICAgICBub2RlLm9uZXJyb3IgPSBvbkVycm9yLmJpbmQobnVsbCwgbm9kZSwgcG9zdEZpeClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uTG9hZChub2RlLCBwb3N0Rml4KSB7XG4gICAgICAgIGNoYW5nZUxvYWRpbmcocG9zdEZpeCwgZmFsc2UpXG4gICAgICAgIGNoYW5nZUVycm9yKHBvc3RGaXgsIGZhbHNlKVxuICAgICAgICBkaXNwYXRjaChgbG9hZCR7cG9zdEZpeH1gLCBub2RlKVxuXG4gICAgICAgIGlmICghc3JjQmlnIHx8ICFsb2FkaW5nU3JjQmlnKSB7XG4gICAgICAgICAgICBkaXNwYXRjaCgnbG9hZCcsIG5vZGUpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkVycm9yKG5vZGUsIHBvc3RGaXgpIHtcbiAgICAgICAgY2hhbmdlTG9hZGluZyhwb3N0Rml4LCBmYWxzZSlcbiAgICAgICAgY2hhbmdlRXJyb3IocG9zdEZpeCwgdHJ1ZSlcbiAgICAgICAgZGlzcGF0Y2goYGVycm9yJHtwb3N0Rml4fWAsIG5vZGUpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hhbmdlTG9hZGluZyh0eXBlLCBpc0xvYWRpbmcpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdTbWFsbCc6XG4gICAgICAgICAgICAgICAgbG9hZGluZ1NyY1NtYWxsID0gaXNMb2FkaW5nXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIGNhc2UgJ0JpZyc6XG4gICAgICAgICAgICAgICAgbG9hZGluZ1NyY0JpZyA9IGlzTG9hZGluZ1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGFuZ2VFcnJvcih0eXBlLCBpc0Vycm9yKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnU21hbGwnOlxuICAgICAgICAgICAgICAgIGlzRXJyb3JTbWFsbCA9IGlzRXJyb3JcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgY2FzZSAnQmlnJzpcbiAgICAgICAgICAgICAgICBpc0Vycm9yQmlnID0gaXNFcnJvclxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICB9XG5cbjwvc2NyaXB0PlxuXG48ZmlndXJlIGNsYXNzPXt3cmFwQ2xhc3NQcm9wfT5cbiAgICB7I2lmIHNyY31cbiAgICAgICAgPGltZ1xuICAgICAgICAgICAgdXNlOmltZ1NlcnZpY2U9eydTbWFsbCd9XG4gICAgICAgICAgICB7aWR9XG4gICAgICAgICAgICB7YWx0fVxuICAgICAgICAgICAge3NyY31cbiAgICAgICAgICAgIHt3aWR0aH1cbiAgICAgICAgICAgIHtoZWlnaHR9XG4gICAgICAgICAgICBjbGFzcz1cInBpYyBwaWMtMXhcIlxuICAgICAgICAvPlxuICAgIHsvaWZ9XG5cbiAgICB7I2lmIHNyY0JpZyAmJiAhbG9hZGluZ1NyY1NtYWxsfVxuICAgICAgICA8aW1nXG4gICAgICAgICAgICB1c2U6aW1nU2VydmljZT17J0JpZyd9XG4gICAgICAgICAgICB7YWx0fVxuICAgICAgICAgICAge3dpZHRofVxuICAgICAgICAgICAge2hlaWdodH1cbiAgICAgICAgICAgIHNyYz17c3JjQmlnfVxuICAgICAgICAgICAgY2xhc3M9XCJwaWMgcGljLTJ4XCJcbiAgICAgICAgLz5cbiAgICB7L2lmfVxuXG4gICAgPGZpZ2NhcHRpb24+XG4gICAgICAgIDxzbG90Pjwvc2xvdD5cbiAgICA8L2ZpZ2NhcHRpb24+XG48L2ZpZ3VyZT5cblxuPHN0eWxlPlxuICAgIC5waWN0dXJlIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBmbGV4LWdyb3c6IDE7XG4gICAgICAgIGFsaWduLXNlbGY6IHN0cmV0Y2g7XG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1mbGV4O1xuICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgICBhbGlnbi1pdGVtczogc3RyZXRjaDtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBzdHJldGNoO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKHZhcigtLXRoZW1lLWJnLWNvbG9yLW9wcG9zaXRlKSwgLjA0KTtcbiAgICB9XG5cbiAgICAucGljdHVyZSAucGljIHtcbiAgICAgICAgZmxleC1ncm93OiAxO1xuICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICBhbGlnbi1zZWxmOiBzdHJldGNoO1xuICAgICAgICBvYmplY3QtcG9zaXRpb246IGNlbnRlcjtcbiAgICAgICAgdHJhbnNpdGlvbjogb3BhY2l0eSAuNXMgZWFzZS1pbjtcbiAgICB9XG5cbiAgICAucGljdHVyZSAucGljLTJ4IHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IDA7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgfVxuXG4gICAgLnBpY3R1cmUuY292ZXIgLnBpYyB7XG4gICAgICAgIG9iamVjdC1maXQ6IGNvdmVyO1xuICAgIH1cblxuICAgIC5waWN0dXJlLmNvbnRhaW4gLnBpYyB7XG4gICAgICAgIG9iamVjdC1maXQ6IGNvbnRhaW47XG4gICAgfVxuXG4gICAgLnBpY3R1cmUuaXNFcnJvclNtYWxsIC5waWMtMXgsXG4gICAgLnBpY3R1cmUuaXNFcnJvckJpZyAucGljLTJ4LFxuICAgIC5waWN0dXJlLmxvYWRpbmdTcmNTbWFsbCAucGljLTF4LFxuICAgIC5waWN0dXJlLmxvYWRpbmdTcmNCaWcgLnBpYy0yeCB7XG4gICAgICAgIG9wYWNpdHk6IDA7XG4gICAgfVxuPC9zdHlsZT5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgY2xhc3NuYW1lcyB9IGZyb20gJ0B1dGlscydcbiAgICBpbXBvcnQgUGljdHVyZSBmcm9tICcuL1BpY3R1cmUuc3ZlbHRlJ1xuXG4gICAgZXhwb3J0IGxldCBzcmNcbiAgICBleHBvcnQgbGV0IGFsdFxuICAgIGV4cG9ydCBsZXQgc2l6ZSA9IG51bGwgLy8gc21hbGx8bWVkaXVtfGJpZ1xuICAgIGV4cG9ydCBsZXQgc3JjQmlnID0gdW5kZWZpbmVkXG5cbiAgICAkOiBjbGFzc1Byb3AgPSBjbGFzc25hbWVzKCdhdmEnLCBzaXplLCAkJHByb3BzLmNsYXNzKVxuPC9zY3JpcHQ+XG5cbjxkaXYgY2xhc3M9e2NsYXNzUHJvcH0+XG4gICAgPFBpY3R1cmUge3NyY30ge3NyY0JpZ30ge2FsdH0vPlxuPC9kaXY+XG5cbjxzdHlsZT5cbiAgICAuYXZhIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBmbGV4LWdyb3c6IDE7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVaKDApO1xuICAgIH1cblxuICAgIC5hdmEuc21hbGwge1xuICAgICAgICBmbGV4OiBub25lO1xuICAgICAgICB3aWR0aDogMzBweDtcbiAgICAgICAgaGVpZ2h0OiAzMHB4O1xuICAgIH1cbiAgICAuYXZhLm1lZGl1bSB7XG4gICAgICAgIGZsZXg6IG5vbmU7XG4gICAgICAgIHdpZHRoOiA2MHB4O1xuICAgICAgICBoZWlnaHQ6IDYwcHg7XG4gICAgfVxuICAgIC5hdmEuYmlnIHtcbiAgICAgICAgZmxleDogbm9uZTtcbiAgICAgICAgd2lkdGg6IDEzMHB4O1xuICAgICAgICBoZWlnaHQ6IDEzMHB4O1xuICAgIH1cbjwvc3R5bGU+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJ3N2ZWx0ZSdcbiAgICBpbXBvcnQgeyBjbGFzc25hbWVzIH0gZnJvbSAnQHV0aWxzJ1xuXG4gICAgY29uc3QgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXIoKVxuXG4gICAgZXhwb3J0IGxldCBpcyA9IHVuZGVmaW5lZCAvLyB0aGVtZSwgdGhlbWUtYm9yZGVyLCB3aGl0ZSwgc3VjY2Vzcywgd2FybmluZywgZGFuZ2VyLCBkYXJrLCBkYXJrLWJvcmRlclxuICAgIGV4cG9ydCBsZXQgaWQgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IHJlbCA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgaHJlZiA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgYXV0byA9IGZhbHNlXG4gICAgZXhwb3J0IGxldCB0eXBlID0gJ2J1dHRvbidcbiAgICBleHBvcnQgbGV0IGZvcm0gPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IHNpemUgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IHRpdGxlID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCBzdHlsZSA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgaHRtbEZvciA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgZGlzYWJsZWQgPSBmYWxzZVxuICAgIGV4cG9ydCBsZXQgYXJpYUxhYmVsID0gdW5kZWZpbmVkXG5cbiAgICBsZXQgdGl0bGVQcm9wID0gdGl0bGUgfHwgYXJpYUxhYmVsXG4gICAgbGV0IGFyaWFMYWJlbFByb3AgPSBhcmlhTGFiZWwgfHwgdGl0bGVcblxuICAgICQ6IGNsYXNzUHJvcCA9IGNsYXNzbmFtZXMoJ2J0bicsIGlzLCBzaXplLCAkJHByb3BzLmNsYXNzLCB7IGF1dG8sIGRpc2FibGVkIH0pXG5cbiAgICBmdW5jdGlvbiBvbkxhYmVsQ2xpY2soZSkge1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChodG1sRm9yKS5jbGljaygpXG4gICAgICAgICFkaXNhYmxlZCAmJiBkaXNwYXRjaCgnY2xpY2snLCBlKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uQ2xpY2soZSkge1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAhZGlzYWJsZWQgJiYgZGlzcGF0Y2goJ2NsaWNrJywgZSlcbiAgICB9XG48L3NjcmlwdD5cblxueyNpZiBocmVmfVxuICAgIDxhXG4gICAgICAgICAgICB7aWR9XG4gICAgICAgICAgICB7cmVsfVxuICAgICAgICAgICAge2hyZWZ9XG4gICAgICAgICAgICB7c3R5bGV9XG4gICAgICAgICAgICB0aXRsZT17dGl0bGVQcm9wfVxuICAgICAgICAgICAgY2xhc3M9e2NsYXNzUHJvcH1cbiAgICAgICAgICAgIGFyaWEtbGFiZWw9e2FyaWFMYWJlbFByb3B9XG4gICAgICAgICAgICBvbjpjbGljaz17b25DbGlja31cbiAgICA+XG4gICAgICAgIDxzbG90Pjwvc2xvdD5cbiAgICA8L2E+XG57OmVsc2UgaWYgaHRtbEZvcn1cbiAgICA8bGFiZWxcbiAgICAgICAgICAgIHtpZH1cbiAgICAgICAgICAgIHtzdHlsZX1cbiAgICAgICAgICAgIHtkaXNhYmxlZH1cbiAgICAgICAgICAgIGZvcj17aHRtbEZvcn1cbiAgICAgICAgICAgIHRpdGxlPXt0aXRsZVByb3B9XG4gICAgICAgICAgICBjbGFzcz17Y2xhc3NQcm9wfVxuICAgICAgICAgICAgYXJpYS1sYWJlbD17YXJpYUxhYmVsUHJvcH1cbiAgICAgICAgICAgIG9uOmNsaWNrPXtvbkxhYmVsQ2xpY2t9XG4gICAgPlxuICAgICAgICA8c2xvdD48L3Nsb3Q+XG4gICAgPC9sYWJlbD5cbns6ZWxzZX1cbiAgICA8YnV0dG9uXG4gICAgICAgICAgICB7aWR9XG4gICAgICAgICAgICB7Zm9ybX1cbiAgICAgICAgICAgIHt0eXBlfVxuICAgICAgICAgICAge3N0eWxlfVxuICAgICAgICAgICAge2Rpc2FibGVkfVxuICAgICAgICAgICAgdGl0bGU9e3RpdGxlUHJvcH1cbiAgICAgICAgICAgIGNsYXNzPXtjbGFzc1Byb3B9XG4gICAgICAgICAgICBhcmlhLWxhYmVsPXthcmlhTGFiZWxQcm9wfVxuICAgICAgICAgICAgb246Y2xpY2s9e29uQ2xpY2t9XG4gICAgPlxuICAgICAgICA8c2xvdD48L3Nsb3Q+XG4gICAgPC9idXR0b24+XG57L2lmfVxuXG48c3R5bGU+XG4gICAgLmJ0bjpub3QoLmF1dG8pIHtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIHBhZGRpbmc6IDVweCAxNXB4O1xuICAgIH1cblxuICAgIDpnbG9iYWwoLmJ0bikge1xuICAgICAgICBmbGV4OiBub25lO1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgIG1heC13aWR0aDogMTAwJTtcbiAgICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1mbGV4O1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgY29sb3I6IHJnYmEodmFyKC0tdGhlbWUtZm9udC1jb2xvcikpO1xuICAgICAgICBib3JkZXItcmFkaXVzOiB2YXIoLS1ib3JkZXItcmFkaXVzLW1lZGl1bSk7XG4gICAgfVxuXG4gICAgOmdsb2JhbCguYnRuLnNtYWxsKSB7XG4gICAgICAgIHBhZGRpbmc6IDVweDtcbiAgICAgICAgbWluLXdpZHRoOiBjYWxjKHZhcigtLW1pbi1pbnRlcmFjdGl2ZS1zaXplKSAvIDEuMyk7XG4gICAgICAgIG1pbi1oZWlnaHQ6IGNhbGModmFyKC0tbWluLWludGVyYWN0aXZlLXNpemUpIC8gMS4zKTtcbiAgICB9XG5cbiAgICA6Z2xvYmFsKC5idG4ubWVkaXVtKSB7XG4gICAgICAgIHBhZGRpbmc6IDVweCAxMHB4O1xuICAgICAgICBtaW4td2lkdGg6IHZhcigtLW1pbi1pbnRlcmFjdGl2ZS1zaXplKTtcbiAgICAgICAgbWluLWhlaWdodDogdmFyKC0tbWluLWludGVyYWN0aXZlLXNpemUpO1xuICAgIH1cblxuICAgIDpnbG9iYWwoLmJ0bi5iaWcpIHtcbiAgICAgICAgcGFkZGluZzogNXB4IDE1cHg7XG4gICAgICAgIG1pbi13aWR0aDogY2FsYyh2YXIoLS1taW4taW50ZXJhY3RpdmUtc2l6ZSkgKiAxLjMpO1xuICAgICAgICBtaW4taGVpZ2h0OiBjYWxjKHZhcigtLW1pbi1pbnRlcmFjdGl2ZS1zaXplKSAqIDEuMyk7XG4gICAgfVxuXG4gICAgOmdsb2JhbCguYnRuOmZvY3VzKSB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEodmFyKC0tY29sb3ItYmxhY2spLCAwLjEpO1xuICAgIH1cblxuICAgIDpnbG9iYWwoLmJ0bjpob3Zlcikge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKHZhcigtLWNvbG9yLWJsYWNrKSwgMC4xKTtcbiAgICB9XG5cbiAgICA6Z2xvYmFsKC5idG46YWN0aXZlKSB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEodmFyKC0tY29sb3ItYmxhY2spLCAwLjEpO1xuICAgIH1cblxuICAgIC8qIHRoZW1lICovXG5cbiAgICA6Z2xvYmFsKC5idG4pLnRoZW1lIHtcbiAgICAgICAgY29sb3I6IHJnYmEodmFyKC0tdGhlbWUtZm9udC1jb2xvcikpO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKHZhcigtLXRoZW1lLWNvbG9yLXNlY29uZGFyeSkpO1xuICAgIH1cblxuICAgIDpnbG9iYWwoLmJ0bikudGhlbWU6Zm9jdXMge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKHZhcigtLXRoZW1lLWNvbG9yLXNlY29uZGFyeSksIC44NSk7XG4gICAgfVxuXG4gICAgOmdsb2JhbCguYnRuKS50aGVtZTpob3ZlciB7XG4gICAgICAgIGJveC1zaGFkb3c6IHZhcigtLXNoYWRvdy1wcmltYXJ5KTtcbiAgICB9XG5cbiAgICA6Z2xvYmFsKC5idG4pLnRoZW1lOmFjdGl2ZSB7XG4gICAgICAgIGJveC1zaGFkb3c6IHZhcigtLXNoYWRvdy1wcmltYXJ5KTtcbiAgICB9XG5cbiAgICAvKiB0aGVtZSAqL1xuXG4gICAgOmdsb2JhbCguYnRuKS50aGVtZS1ib3JkZXIge1xuICAgICAgICBjb2xvcjogcmdiYSh2YXIoLS10aGVtZS1mb250LWNvbG9yKSk7XG4gICAgICAgIGJvcmRlcjogMnB4IHNvbGlkIHJnYmEodmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeS1vcHBvc2l0ZSkpO1xuICAgIH1cblxuICAgIDpnbG9iYWwoLmJ0bikudGhlbWUtYm9yZGVyOmZvY3VzIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSh2YXIoLS10aGVtZS1jb2xvci1zZWNvbmRhcnkpLCAuODUpO1xuICAgIH1cblxuICAgIDpnbG9iYWwoLmJ0bikudGhlbS1ib3JkZXI6aG92ZXIge1xuICAgICAgICBib3gtc2hhZG93OiB2YXIoLS1zaGFkb3ctcHJpbWFyeSk7XG4gICAgfVxuXG4gICAgOmdsb2JhbCguYnRuKS50aGVtZS1ib3JkZXI6YWN0aXZlIHtcbiAgICAgICAgYm94LXNoYWRvdzogdmFyKC0tc2hhZG93LXByaW1hcnkpO1xuICAgIH1cblxuICAgIC8qIFdoaXRlICovXG5cbiAgICA6Z2xvYmFsKC5idG4pLndoaXRlIHtcbiAgICAgICAgY29sb3I6IHJnYmEodmFyKC0tY29sb3ItZm9udC1kYXJrKSk7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEodmFyKC0tY29sb3Itd2hpdGUpKTtcbiAgICB9XG5cbiAgICA6Z2xvYmFsKC5idG4pLndoaXRlOmZvY3VzIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSh2YXIoLS1jb2xvci13aGl0ZSksIC44NSk7XG4gICAgfVxuXG4gICAgOmdsb2JhbCguYnRuKS53aGl0ZTpob3ZlciB7XG4gICAgICAgIGJveC1zaGFkb3c6IHZhcigtLXNoYWRvdy1wcmltYXJ5KTtcbiAgICB9XG5cbiAgICA6Z2xvYmFsKC5idG4pLndoaXRlOmFjdGl2ZSB7XG4gICAgICAgIGJveC1zaGFkb3c6IHZhcigtLXNoYWRvdy1wcmltYXJ5KTtcbiAgICB9XG5cbiAgICAvKiBEYXJrICovXG5cbiAgICA6Z2xvYmFsKC5idG4pLmRhcmsge1xuICAgICAgICBjb2xvcjogcmdiYSh2YXIoLS1jb2xvci1mb250LWxpZ2h0KSk7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEodmFyKC0tY29sb3ItZGFyaykpO1xuICAgIH1cblxuICAgIDpnbG9iYWwoLmJ0bikuZGFyazpmb2N1cyB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEodmFyKC0tY29sb3ItZGFyayksIC44NSk7XG4gICAgfVxuXG4gICAgOmdsb2JhbCguYnRuKS5kYXJrOmhvdmVyIHtcbiAgICAgICAgYm94LXNoYWRvdzogdmFyKC0tc2hhZG93LXByaW1hcnkpO1xuICAgIH1cblxuICAgIDpnbG9iYWwoLmJ0bikuZGFyazphY3RpdmUge1xuICAgICAgICBib3gtc2hhZG93OiB2YXIoLS1zaGFkb3ctcHJpbWFyeSk7XG4gICAgfVxuXG4gICAgLyogRGFyay1ib3JkZXIgKi9cblxuICAgIDpnbG9iYWwoLmJ0bikuZGFyay1ib3JkZXIge1xuICAgICAgICBjb2xvcjogcmdiYSh2YXIoLS10aGVtZS1mb250LWNvbG9yKSk7XG4gICAgICAgIGJvcmRlcjogMnB4IHNvbGlkIHJnYmEodmFyKC0tdGhlbWUtZm9udC1jb2xvcikpO1xuICAgIH1cblxuICAgIDpnbG9iYWwoLmJ0bikuZGFyay1ib3JkZXI6Zm9jdXMge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKHZhcigtLWNvbG9yLWRhcmspLCAuODUpO1xuICAgIH1cblxuICAgIDpnbG9iYWwoLmJ0bikuZGFyay1ib3JkZXI6aG92ZXIge1xuICAgICAgICBib3gtc2hhZG93OiB2YXIoLS1zaGFkb3ctcHJpbWFyeSk7XG4gICAgfVxuXG4gICAgOmdsb2JhbCguYnRuKS5kYXJrLWJvcmRlcjphY3RpdmUge1xuICAgICAgICBib3gtc2hhZG93OiB2YXIoLS1zaGFkb3ctcHJpbWFyeSk7XG4gICAgfVxuXG4gICAgLyogU3VjY2VzcyAqL1xuXG4gICAgOmdsb2JhbCguYnRuKS5zdWNjZXNzIHtcbiAgICAgICAgY29sb3I6IHJnYmEodmFyKC0tY29sb3ItZm9udC1saWdodCkpO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKHZhcigtLWNvbG9yLXN1Y2Nlc3MpKTtcbiAgICB9XG5cbiAgICA6Z2xvYmFsKC5idG4pLnN1Y2Nlc3M6Zm9jdXMge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKHZhcigtLWNvbG9yLXN1Y2Nlc3MpLCAuODUpO1xuICAgIH1cblxuICAgIDpnbG9iYWwoLmJ0bikuc3VjY2Vzczpob3ZlciB7XG4gICAgICAgIGJveC1zaGFkb3c6IHZhcigtLXNoYWRvdy1wcmltYXJ5KTtcbiAgICB9XG5cbiAgICA6Z2xvYmFsKC5idG4pLnN1Y2Nlc3M6YWN0aXZlIHtcbiAgICAgICAgYm94LXNoYWRvdzogdmFyKC0tc2hhZG93LXByaW1hcnkpO1xuICAgIH1cblxuICAgIC8qIFdhcm5pbmcgKi9cblxuICAgIDpnbG9iYWwoLmJ0bikud2FybmluZyB7XG4gICAgICAgIGNvbG9yOiByZ2JhKHZhcigtLWNvbG9yLWZvbnQtbGlnaHQpKTtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSh2YXIoLS1jb2xvci13YXJuaW5nKSk7XG4gICAgfVxuXG4gICAgOmdsb2JhbCguYnRuKS53YXJuaW5nOmZvY3VzIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSh2YXIoLS1jb2xvci13YXJuaW5nKSwgLjg1KTtcbiAgICB9XG5cbiAgICA6Z2xvYmFsKC5idG4pLndhcm5pbmc6aG92ZXIge1xuICAgICAgICBib3gtc2hhZG93OiB2YXIoLS1zaGFkb3ctcHJpbWFyeSk7XG4gICAgfVxuXG4gICAgOmdsb2JhbCguYnRuKS53YXJuaW5nOmFjdGl2ZSB7XG4gICAgICAgIGJveC1zaGFkb3c6IHZhcigtLXNoYWRvdy1wcmltYXJ5KTtcbiAgICB9XG5cbiAgICAvKiBJbmZvICovXG5cbiAgICA6Z2xvYmFsKC5idG4pLmluZm8ge1xuICAgICAgICBjb2xvcjogcmdiYSh2YXIoLS1jb2xvci1mb250LWxpZ2h0KSk7XG4gICAgICAgIGJvcmRlcjogMnB4IHNvbGlkIHJnYmEodmFyKC0tY29sb3ItaW5mbykpO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKHZhcigtLWNvbG9yLWluZm8pKTtcbiAgICB9XG5cbiAgICA6Z2xvYmFsKC5idG4pLmluZm86Zm9jdXMge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKHZhcigtLWNvbG9yLWluZm8pLCAuODUpO1xuICAgIH1cblxuICAgIDpnbG9iYWwoLmJ0bikuaW5mbzpob3ZlciB7XG4gICAgICAgIGJveC1zaGFkb3c6IHZhcigtLXNoYWRvdy1wcmltYXJ5KTtcbiAgICB9XG5cbiAgICA6Z2xvYmFsKC5idG4pLmluZm86YWN0aXZlIHtcbiAgICAgICAgYm94LXNoYWRvdzogdmFyKC0tc2hhZG93LXByaW1hcnkpO1xuICAgIH1cblxuICAgIC8qIEluZm8tYm9yZGVyICAqL1xuXG4gICAgOmdsb2JhbCguYnRuKS5pbmZvLWJvcmRlciB7XG4gICAgICAgIGNvbG9yOiByZ2JhKHZhcigtLWNvbG9yLWluZm8pKTtcbiAgICAgICAgYm9yZGVyOiAycHggc29saWQgcmdiYSh2YXIoLS1jb2xvci1pbmZvKSk7XG4gICAgfVxuXG4gICAgOmdsb2JhbCguYnRuKS5pbmZvLWJvcmRlcjpmb2N1cyB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEodmFyKC0tY29sb3ItZGFyayksIC44NSk7XG4gICAgfVxuXG4gICAgOmdsb2JhbCguYnRuKS5pbmZvLWJvcmRlcjpob3ZlciB7XG4gICAgICAgIGJveC1zaGFkb3c6IHZhcigtLXNoYWRvdy1wcmltYXJ5KTtcbiAgICB9XG5cbiAgICA6Z2xvYmFsKC5idG4pLmluZm8tYm9yZGVyOmFjdGl2ZSB7XG4gICAgICAgIGJveC1zaGFkb3c6IHZhcigtLXNoYWRvdy1wcmltYXJ5KTtcbiAgICB9XG5cbiAgICAvKiBEYW5nZXIgKi9cblxuICAgIDpnbG9iYWwoLmJ0bikuZGFuZ2VyIHtcbiAgICAgICAgY29sb3I6IHJnYmEodmFyKC0tY29sb3ItZm9udC1saWdodCkpO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKHZhcigtLWNvbG9yLWRhbmdlcikpO1xuICAgIH1cblxuICAgIDpnbG9iYWwoLmJ0bikuZGFuZ2VyOmZvY3VzIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSh2YXIoLS1jb2xvci1kYW5nZXIpLCAuODUpO1xuICAgIH1cblxuICAgIDpnbG9iYWwoLmJ0bikuZGFuZ2VyOmhvdmVyIHtcbiAgICAgICAgYm94LXNoYWRvdzogdmFyKC0tc2hhZG93LXByaW1hcnkpO1xuICAgIH1cblxuICAgIDpnbG9iYWwoLmJ0bikuZGFuZ2VyOmFjdGl2ZSB7XG4gICAgICAgIGJveC1zaGFkb3c6IHZhcigtLXNoYWRvdy1wcmltYXJ5KTtcbiAgICB9XG48L3N0eWxlPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyB0b0NTU1N0cmluZywgY2xhc3NuYW1lcyB9IGZyb20gJ0B1dGlscydcblxuICAgIGV4cG9ydCBsZXQgaXMgPSAnaW5mbydcbiAgICBleHBvcnQgbGV0IHNpemUgPSAwXG4gICAgZXhwb3J0IGxldCB3aWR0aCA9IDJcblxuICAgICQ6IGNsYXNzUHJvcCA9IGNsYXNzbmFtZXMoJ2RpdmlkZXInLCBpcywgJCRwcm9wcy5jbGFzcylcbiAgICAkOiBzdHlsZVByb3AgPSB0b0NTU1N0cmluZyh7IHBhZGRpbmc6IGAke3NpemUgLyAyfXB4IDBgLCBoZWlnaHQ6IGAke3dpZHRofXB4YCB9KVxuPC9zY3JpcHQ+XG5cbjxociBjbGFzcz17Y2xhc3NQcm9wfSBzdHlsZT17c3R5bGVQcm9wfT5cblxuPHN0eWxlPlxuICAgIC5kaXZpZGVyIHtcbiAgICAgICAgbWFyZ2luOiAwO1xuICAgICAgICBib3JkZXI6IG5vbmU7XG4gICAgICAgIGJveC1zaXppbmc6IGNvbnRlbnQtYm94O1xuICAgICAgICBiYWNrZ3JvdW5kLWNsaXA6IGNvbnRlbnQtYm94O1xuICAgIH1cblxuICAgIC5pbmZvIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiKHZhcigtLWNvbG9yLWluZm8pKTtcbiAgICB9XG5cbiAgICAuc3VjY2VzcyB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYih2YXIoLS1jb2xvci1zdWNjZXNzKSk7XG4gICAgfVxuXG4gICAgLndhcm5pbmcge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IodmFyKC0tY29sb3Itd2FybmluZykpO1xuICAgIH1cblxuICAgIC5kYW5nZXIge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IodmFyKC0tY29sb3ItZGFuZ2VyKSk7XG4gICAgfVxuPC9zdHlsZT5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgY3JlYXRlRXZlbnREaXNwYXRjaGVyLCBvbk1vdW50IH0gZnJvbSAnc3ZlbHRlJ1xuICAgIGltcG9ydCB7IGNsYXNzbmFtZXMsIHNhZmVHZXQgfSBmcm9tICdAdXRpbHMnXG5cbiAgICBjb25zdCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpXG5cbiAgICBleHBvcnQgbGV0IGlkID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCB2YWx1ZSA9IDAgLy8gMCAtIDEwMFxuICAgIGV4cG9ydCBsZXQgc2l6ZSA9ICdtZWRpdW0nXG4gICAgZXhwb3J0IGxldCB0aXRsZSA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgYXJpYUxhYmVsID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCBib3JkZXJSYWRpdXMgPSB1bmRlZmluZWRcblxuICAgICQ6IHZhbCA9IE51bWJlci5pc0Zpbml0ZSgrdmFsdWUpID8gTWF0aC5tYXgoMCwgTWF0aC5taW4oK3ZhbHVlLCAxMDApKSA6IDBcbiAgICAkOiB0aXRsZVByb3AgPSB0aXRsZSB8fCBgUHJvZ3Jlc3MgLSAke3ZhbH0lYFxuICAgICQ6IGFyaWFMYWJlbFByb3AgPSBhcmlhTGFiZWwgfHwgYFByb2dyZXNzIC0gJHt2YWx9JWBcbiAgICAkOiBjbGFzc1Byb3AgPSBjbGFzc25hbWVzKCdwcm9ncmVzcycsIHNpemUsICQkcHJvcHMuY2xhc3MpXG5cbiAgICBmdW5jdGlvbiBnZXRCb3JkZXJSYWRpdXMoYm9yZGVycywgZGVmYXVsdHMgPSAnOTk5OTlweCcpIHtcbiAgICAgICAgY29uc3QgYnJEZWZhdWx0ID0gbmV3IEFycmF5KDQpLmZpbGwoZGVmYXVsdHMpXG4gICAgICAgIGNvbnN0IGJkcyA9IHNhZmVHZXQoKCkgPT4gYm9yZGVycy5zcGxpdCgnICcpLCBbXSwgdHJ1ZSlcbiAgICAgICAgY29uc3QgcnVsZSA9ICdib3JkZXItcmFkaXVzJ1xuICAgICAgICByZXR1cm4gYCR7cnVsZX06JHtickRlZmF1bHQubWFwKChkZWYsIGkpID0+IGAke2Jkc1tpXSB8fCBkZWZ9YCkuam9pbignICcpfWBcbiAgICB9XG48L3NjcmlwdD5cblxuXG48ZGl2XG4gICAgICAgIHtpZH1cbiAgICAgICAgY2xhc3M9e2NsYXNzUHJvcH1cbiAgICAgICAgdGl0bGU9e3RpdGxlUHJvcH1cbiAgICAgICAgYXJpYS1sYWJlbD17YXJpYUxhYmVsUHJvcH1cbiAgICAgICAgcm9sZT1cInByb2dyZXNzYmFyXCJcbiAgICAgICAgYXJpYS12YWx1ZW1pbj1cIjBcIlxuICAgICAgICBhcmlhLXZhbHVlbWF4PVwiMTAwXCJcbiAgICAgICAgYXJpYS12YWx1ZW5vdz17dmFsfVxuICAgICAgICBzdHlsZT17Z2V0Qm9yZGVyUmFkaXVzKGJvcmRlclJhZGl1cyl9XG4+XG4gICAgPGRpdiBjbGFzcz1cInByb2dyZXNzLWlubmVyLWZyYW1lXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJwcm9ncmVzcy1jb3JlXCIgc3R5bGU9e2B3aWR0aDoke3ZhbH0lYH0+PC9kaXY+XG4gICAgPC9kaXY+XG48L2Rpdj5cblxuPHN0eWxlPlxuICAgIC5wcm9ncmVzcy5tZWRpdW0ge1xuICAgICAgICAtLXByb2dyZXNzLWhlaWdodDogMTBweDtcbiAgICAgICAgLS1wcm9ncmVzcy1wYWRkaW5nLXBvaW50OiAxcHg7XG4gICAgfVxuXG4gICAgLnByb2dyZXNzIHtcbiAgICAgICAgZmxleDogMDtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDk5OTlweDtcbiAgICAgICAgaGVpZ2h0OiB2YXIoLS1wcm9ncmVzcy1oZWlnaHQpO1xuICAgIH1cblxuICAgIC5wcm9ncmVzcy1pbm5lci1mcmFtZSB7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogOTk5OXB4O1xuICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICBwYWRkaW5nOiB2YXIoLS1wcm9ncmVzcy1wYWRkaW5nLXBvaW50KSAwO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKHZhcigtLXRoZW1lLWNvbG9yLXByaW1hcnktb3Bwb3NpdGUpLCAuMSk7XG4gICAgICAgIGJhY2tncm91bmQtY2xpcDogY29udGVudC1ib3g7XG4gICAgfVxuXG4gICAgLnByb2dyZXNzLWNvcmUge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogMDtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICBmbGV4OiBub25lO1xuICAgICAgICBhbGlnbi1zZWxmOiBzdHJldGNoO1xuICAgICAgICB0cmFuc2l0aW9uOiAxcyBlYXNlLWluLW91dDtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogOTk5OXB4O1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKHZhcigtLWNvbG9yLWluZm8pKTtcbiAgICB9XG5cbiAgICAucHJvZ3Jlc3NbYXJpYS12YWx1ZW5vdz1cIjEwMFwiXSAucHJvZ3Jlc3MtY29yZSB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEodmFyKC0tY29sb3Itc3VjY2VzcykpO1xuICAgIH1cbjwvc3R5bGU+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciwgdGljayB9IGZyb20gJ3N2ZWx0ZSdcbiAgICBpbXBvcnQgeyBmbHkgfSBmcm9tICdzdmVsdGUvdHJhbnNpdGlvbidcbiAgICBpbXBvcnQgeyBTd2lwZSB9IGZyb20gJ0BzZXJ2aWNlcydcbiAgICBpbXBvcnQgeyBjbGFzc25hbWVzLCBkZWxheSwgYm9keVNjcm9sbCwgc2FmZUdldCB9IGZyb20gJ0B1dGlscydcbiAgICBpbXBvcnQgSWNvbiBmcm9tICdAY29tcG9uZW50cy9JY29uLnN2ZWx0ZSc7XG4gICAgaW1wb3J0IFBvcnRhbCBmcm9tICcuL1BvcnRhbC5zdmVsdGUnO1xuXG4gICAgY29uc3QgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXIoKVxuICAgIFxuICAgIGNvbnN0IERVUkFUSU9OID0gMjUwXG4gICAgY29uc3QgVEhSRVNIT0xEID0gNTBcbiAgICBjb25zdCBTV0lQRV9TUEVFRCA9IC41XG4gICAgY29uc3QgU1RBUlRfUE9TSVRJT04gPSB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDIwXG4gICAgfVxuXG4gICAgZXhwb3J0IGxldCByZWYgPSBudWxsXG4gICAgZXhwb3J0IGxldCBibG9ja0JvZHkgPSB0cnVlXG4gICAgZXhwb3J0IGxldCBzd2lwZSA9IFsnYWxsJ10gICAgICAgLy8gdXAgZG93biBsZWZ0IHJpZ2h0IGFsbFxuICAgIGV4cG9ydCBsZXQgZGlzYWJsZWQgPSBmYWxzZVxuICAgIGV4cG9ydCBsZXQgZXh0cmFMb2NrID0gZmFsc2VcbiAgICBleHBvcnQgbGV0IHN0YXJ0UG9zaXRpb24gPSBTVEFSVF9QT1NJVElPTlxuXG4gICAgbGV0IGFjdGl2ZSA9IG51bGxcbiAgICBsZXQgc2xvdHMgPSAkJHByb3BzLiQkc2xvdHMgfHwge31cblxuICAgIGFzeW5jIGZ1bmN0aW9uIG9uQ2xpY2soZSkge1xuICAgICAgICBpZiAoZGlzYWJsZWQpIHJldHVyblxuXG4gICAgICAgIGNvbnN0IG5ld0FjdGl2ZSA9ICFhY3RpdmVcblxuICAgICAgICBzZXRBY3RpdmUobmV3QWN0aXZlKVxuXG4gICAgICAgIGlmIChuZXdBY3RpdmUpIHtcbiAgICAgICAgICAgIGRyYXdUcmFuc2Zvcm0ocmVmLCAwLCAwKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZHJhd1RyYW5zZm9ybShyZWYsIHN0YXJ0UG9zaXRpb24ueCwgc3RhcnRQb3NpdGlvbi55KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gc2V0QWN0aXZlKGlzQWN0aXZlKSB7XG4gICAgICAgIGFjdGl2ZSA9IGlzQWN0aXZlXG5cbiAgICAgICAgYXdhaXQgdGljaygpXG5cbiAgICAgICAgaWYgKGFjdGl2ZSkge1xuICAgICAgICAgICAgc2V0RHVyYXRpb24ocmVmLCBEVVJBVElPTilcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gc2V0RHVyYXRpb24ocmVmLCAwKSwgRFVSQVRJT04pXG4gICAgICAgICAgICBibG9ja0JvZHkgJiYgYm9keVNjcm9sbC5kaXNhYmxlU2Nyb2xsKHJlZiwgeyBleHRyYUxvY2sgfSk7XG4gICAgICAgICAgICBkaXNwYXRjaCgnb3BlbicpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXREdXJhdGlvbihyZWYsIERVUkFUSU9OKVxuICAgICAgICAgICAgYmxvY2tCb2R5ICYmIGJvZHlTY3JvbGwuZW5hYmxlU2Nyb2xsKHJlZiwgeyBleHRyYUxvY2sgfSk7XG4gICAgICAgICAgICBkaXNwYXRjaCgnY2xvc2UnKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgJDogaXNTd2lwZSA9IHtcbiAgICAgICAgdXA6IHNhZmVHZXQoKCkgPT4gc3dpcGUuaW5jbHVkZXMoJ3VwJykgfHwgc3dpcGUuaW5jbHVkZXMoJ2FsbCcpKSxcbiAgICAgICAgZG93bjogc2FmZUdldCgoKSA9PiBzd2lwZS5pbmNsdWRlcygnZG93bicpIHx8IHN3aXBlLmluY2x1ZGVzKCdhbGwnKSksXG4gICAgICAgIGxlZnQ6IHNhZmVHZXQoKCkgPT4gc3dpcGUuaW5jbHVkZXMoJ2xlZnQnKSB8fCBzd2lwZS5pbmNsdWRlcygnYWxsJykpLFxuICAgICAgICByaWdodDogc2FmZUdldCgoKSA9PiBzd2lwZS5pbmNsdWRlcygncmlnaHQnKSB8fCBzd2lwZS5pbmNsdWRlcygnYWxsJykpLFxuICAgIH1cbiAgICAkOiBjbGFzc1Byb3AgPSBjbGFzc25hbWVzKCdmYW5jeS1ib3gtZ2hvc3QnLCB7IGFjdGl2ZSB9KVxuICAgICQ6IGNsYXNzUHJvcFdyYXAgPSBjbGFzc25hbWVzKCdmYW5jeS1ib3gnLCAkJHByb3BzLmNsYXNzKVxuXG4gICAgbGV0IHhTd2lwZSA9IDBcbiAgICBsZXQgeVN3aXBlID0gMFxuXG4gICAgZnVuY3Rpb24gYWRkU3dpcGUoZWwpIHtcbiAgICAgICAgbmV3IFN3aXBlKGVsKVxuICAgICAgICAgICAgICAgIC5ydW4oKVxuICAgICAgICAgICAgICAgIC5vblVwKGlzU3dpcGUudXAgPyBoYW5kbGVWZXJ0aWNhbFN3aXBlIDogbnVsbClcbiAgICAgICAgICAgICAgICAub25Eb3duKGlzU3dpcGUuZG93biA/IGhhbmRsZVZlcnRpY2FsU3dpcGUgOiBudWxsKVxuICAgICAgICAgICAgICAgIC5vbkxlZnQoaXNTd2lwZS5sZWZ0ID8gaGFuZGxlSG9yaXpvbnRhbFN3aXBlIDogbnVsbClcbiAgICAgICAgICAgICAgICAub25SaWdodChpc1N3aXBlLnJpZ2h0ID8gaGFuZGxlSG9yaXpvbnRhbFN3aXBlIDogbnVsbClcbiAgICAgICAgICAgICAgICAub25Ub3VjaEVuZChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh4U3dpcGUgPiBUSFJFU0hPTEQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldER1cmF0aW9uKHJlZiwgRFVSQVRJT04pXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHNldER1cmF0aW9uKHJlZiwgMCksIERVUkFUSU9OKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0QWN0aXZlKGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgZHJhd1RyYW5zZm9ybShlbCwgeFN3aXBlICsgNTAsIHlTd2lwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdPcGFjaXR5KGVsLCB4U3dpcGUgKyA1MCwgeVN3aXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgZGVsYXkoRFVSQVRJT04pXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoeFN3aXBlIDwgLVRIUkVTSE9MRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0RHVyYXRpb24ocmVmLCBEVVJBVElPTilcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gc2V0RHVyYXRpb24ocmVmLCAwKSwgRFVSQVRJT04pXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRBY3RpdmUoZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICBkcmF3VHJhbnNmb3JtKGVsLCB4U3dpcGUgLSA1MCwgeVN3aXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgZHJhd09wYWNpdHkoZWwsIHhTd2lwZSAtIDUwLCB5U3dpcGUpXG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBkZWxheShEVVJBVElPTilcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKHlTd2lwZSA+IFRIUkVTSE9MRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0RHVyYXRpb24ocmVmLCBEVVJBVElPTilcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gc2V0RHVyYXRpb24ocmVmLCAwKSwgRFVSQVRJT04pXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRBY3RpdmUoZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICBkcmF3VHJhbnNmb3JtKGVsLCB4U3dpcGUsIHlTd2lwZSArIDUwKVxuICAgICAgICAgICAgICAgICAgICAgICAgZHJhd09wYWNpdHkoZWwsIHhTd2lwZSwgeVN3aXBlICsgNTApXG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBkZWxheShEVVJBVElPTilcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh5U3dpcGUgPCAtVEhSRVNIT0xEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXREdXJhdGlvbihyZWYsIERVUkFUSU9OKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBzZXREdXJhdGlvbihyZWYsIDApLCBEVVJBVElPTilcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEFjdGl2ZShmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdUcmFuc2Zvcm0oZWwsIHhTd2lwZSwgeVN3aXBlIC0gNTApXG4gICAgICAgICAgICAgICAgICAgICAgICBkcmF3T3BhY2l0eShlbCwgeFN3aXBlLCB5U3dpcGUgLSA1MClcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGRlbGF5KERVUkFUSU9OKVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHhTd2lwZSA8PSBUSFJFU0hPTEQgJiYgeFN3aXBlID49IC1USFJFU0hPTEQgJiYgeVN3aXBlIDw9IFRIUkVTSE9MRCAmJiB5U3dpcGUgPj0gLVRIUkVTSE9MRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0RHVyYXRpb24ocmVmLCBEVVJBVElPTilcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gc2V0RHVyYXRpb24ocmVmLCAwKSwgRFVSQVRJT04pXG4gICAgICAgICAgICAgICAgICAgICAgICBkcmF3VHJhbnNmb3JtKGVsLCAwLCAwKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZHJhd1RyYW5zZm9ybShlbCwgc3RhcnRQb3NpdGlvbi54LCBzdGFydFBvc2l0aW9uLnkpXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB4U3dpcGUgPSAwXG4gICAgICAgICAgICAgICAgICAgIHlTd2lwZSA9IDBcbiAgICAgICAgICAgICAgICAgICAgZWwuc3R5bGUub3BhY2l0eSA9IG51bGxcbiAgICAgICAgICAgICAgICB9KVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZVZlcnRpY2FsU3dpcGUoeURvd24sIHlVcCwgZXZ0LCBlbCkge1xuICAgICAgICB5U3dpcGUgPSAoeVVwIC0geURvd24pICogU1dJUEVfU1BFRURcbiAgICAgICAgZHJhd1RyYW5zZm9ybShlbCwgeFN3aXBlLCB5U3dpcGUpXG4gICAgICAgIGRyYXdPcGFjaXR5KGVsLCB4U3dpcGUsIHlTd2lwZSlcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlSG9yaXpvbnRhbFN3aXBlKHhEb3duLCB4VXAsIGV2dCwgZWwpIHtcbiAgICAgICAgeFN3aXBlID0gKHhVcCAtIHhEb3duKSAqIFNXSVBFX1NQRUVEXG4gICAgICAgIGRyYXdUcmFuc2Zvcm0oZWwsIHhTd2lwZSwgeVN3aXBlKVxuICAgICAgICBkcmF3T3BhY2l0eShlbCwgeFN3aXBlLCB5U3dpcGUpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZHJhd1RyYW5zZm9ybShlbCwgeCwgeSkge1xuICAgICAgICBjb25zdCBkZWx0YSA9IE1hdGguYWJzKHgpID4gTWF0aC5hYnMoeSkgPyB4IDogeVxuICAgICAgICBsZXQgc2NhbGUgPSAxIC0gTWF0aC5hYnMoZGVsdGEgLyB3aW5kb3cuaW5uZXJIZWlnaHQpXG4gICAgICAgIGVsICYmIChlbC5zdHlsZS50cmFuc2Zvcm0gPSBgbWF0cml4KCR7c2NhbGV9LCAwLCAwLCAke3NjYWxlfSwgJHt4fSwgJHt5fSlgKVxuICAgIH1cbiAgICBmdW5jdGlvbiBzZXREdXJhdGlvbihlbCwgbXMpIHtcbiAgICAgICAgZWwgJiYgKGVsLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IGAke21zfW1zYClcbiAgICB9XG4gICAgZnVuY3Rpb24gZHJhd09wYWNpdHkoZWwsIHgsIHkpIHtcbiAgICAgICAgY29uc3QgZGVsdGEgPSBNYXRoLmFicyh4KSA+IE1hdGguYWJzKHkpID8geCA6IHlcbiAgICAgICAgZWwgJiYgKGVsLnN0eWxlLm9wYWNpdHkgPSAxIC0gTWF0aC5taW4oTWF0aC5hYnMoZGVsdGEgLyAoVEhSRVNIT0xEICogMS41KSksIDEpKVxuICAgIH1cbjwvc2NyaXB0PlxuXG48c2VjdGlvbiByb2xlPVwiYnV0dG9uXCIgY2xhc3M9e2NsYXNzUHJvcFdyYXB9IG9uOmNsaWNrPXtvbkNsaWNrfT5cbiAgICA8c2xvdCB7YWN0aXZlfT48L3Nsb3Q+XG48L3NlY3Rpb24+XG5cbnsjaWYgYWN0aXZlICE9PSBudWxsfVxuICAgIDxQb3J0YWw+XG4gICAgICAgIDxzZWN0aW9uXG4gICAgICAgICAgICBiaW5kOnRoaXM9e3JlZn1cbiAgICAgICAgICAgIHVzZTphZGRTd2lwZVxuICAgICAgICAgICAgY2xhc3M9e2NsYXNzUHJvcH1cbiAgICAgICAgPlxuICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgb246Y2xpY2s9e29uQ2xpY2t9PlxuICAgICAgICAgICAgICAgIDxJY29uIHR5cGU9XCJjbG9zZVwiIHNpemU9XCJiaWdcIiBpcz1cImxpZ2h0XCIvPlxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICB7I2lmIHNsb3RzLmJveH1cbiAgICAgICAgICAgICAgICA8c2xvdCBuYW1lPVwiYm94XCI+PC9zbG90PlxuICAgICAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgICAgIDxzbG90Pjwvc2xvdD5cbiAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgIDwvc2VjdGlvbj5cbiAgICA8L1BvcnRhbD5cbnsvaWZ9XG5cbjxzdHlsZT5cbiAgICAuZmFuY3ktYm94IHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgZmxleDogbm9uZTtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgYWxpZ24tc2VsZjogc3RyZXRjaDtcbiAgICAgICAgYWxpZ24taXRlbXM6IHN0cmV0Y2g7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogc3RyZXRjaDtcbiAgICB9XG5cbiAgICAuZmFuY3ktYm94LWdob3N0IHtcbiAgICAgICAgei1pbmRleDogMTA7XG4gICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgICAgdG9wOiAwO1xuICAgICAgICBsZWZ0OiAwO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICBhbGlnbi1pdGVtczogc3RyZXRjaDtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICAgIHVzZXItc2VsZWN0OiBub25lO1xuICAgICAgICB0b3VjaC1hY3Rpb246IG1hbmlwdWxhdGlvbjtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSh2YXIoLS1jb2xvci1ibGFjayksIC43NSk7XG4gICAgICAgIG91dGxpbmU6IDE1MHB4IHNvbGlkIHJnYmEodmFyKC0tY29sb3ItYmxhY2spLCAuNzUpO1xuICAgICAgICB0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjogbGluZWFyO1xuICAgICAgICBvcGFjaXR5OiAwO1xuICAgICAgICBwYWRkaW5nOiAwIHZhcigtLXNjcmVlbi1wYWRkaW5nKTtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLDMwcHgsMCk7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgICAgICB3aWxsLWNoYW5nZTogdHJhbnNmb3JtLCBvcGFjaXR5O1xuICAgIH1cblxuICAgIC5mYW5jeS1ib3gtZ2hvc3QgPiAqIHtcbiAgICAgICAgbWF4LXdpZHRoOiAxMDAlO1xuICAgICAgICBtYXgtaGVpZ2h0OiAxMDAlO1xuICAgIH1cblxuICAgIC5mYW5jeS1ib3gtZ2hvc3QuYWN0aXZlIHtcbiAgICAgICAgb3BhY2l0eTogMTtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLDAsMCk7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBhdXRvO1xuICAgIH1cblxuICAgIGJ1dHRvbiB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgdG9wOiAwO1xuICAgICAgICByaWdodDogMDtcbiAgICAgICAgZm9udC1zaXplOiAyNHB4O1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgd2lkdGg6IDYwcHg7XG4gICAgICAgIGhlaWdodDogNjBweDtcbiAgICAgICAgY29sb3I6IHJnYih2YXIoLS1jb2xvci13aGl0ZSkpO1xuICAgIH1cbjwvc3R5bGU+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJ3N2ZWx0ZSdcbiAgICBpbXBvcnQgeyB3YWl0VW50aWwsIGNsYXNzbmFtZXMgfSBmcm9tICdAdXRpbHMnXG4gICAgaW1wb3J0IFBpY3R1cmUgZnJvbSAnQGNvbXBvbmVudHMvUGljdHVyZS5zdmVsdGUnXG4gICAgaW1wb3J0IEZhbmN5Qm94IGZyb20gJ0Bjb21wb25lbnRzL0ZhbmN5Qm94LnN2ZWx0ZSdcblxuICAgIGNvbnN0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKClcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHR5cGUge251bWJlciB8IHtcbiAgICAgKiAgICAgc3JjOiBzdHJpbmcsXG4gICAgICogICAgIHNyY0JpZzogc3RyaW5nLFxuICAgICAqICAgICBhbHQ6IHN0cmluZyxcbiAgICAgKiAgICAgb25DbGljaz86IGZ1bmN0aW9uLFxuICAgICAqIH1bXX1cbiAgICAgKi9cbiAgICBleHBvcnQgbGV0IGl0ZW1zID0gW11cbiAgICBleHBvcnQgbGV0IGRvdHMgPSB0cnVlXG4gICAgZXhwb3J0IGxldCBkb3RzQmVsb3cgPSB0cnVlXG4gICAgZXhwb3J0IGxldCByb3VuZGVkID0gdHJ1ZVxuICAgIGV4cG9ydCBsZXQgc2l6ZSA9ICdzdHJldGNoJ1xuICAgIGV4cG9ydCBsZXQgaW5pdEluZGV4ID0gMFxuICAgIGV4cG9ydCBsZXQgZGlzYWJsZUZhbmN5ID0gZmFsc2VcbiAgICBleHBvcnQgbGV0IHN0b3BQcm9wYWdhdGlvbiA9IHVuZGVmaW5lZFxuXG4gICAgbGV0IHBhcmVudCA9IG51bGxcblxuICAgICQ6IGFjdGl2ZURvdCA9IGluaXRJbmRleFxuICAgICQ6IGNsYXNzUHJvcCA9IGNsYXNzbmFtZXMoJ2Nhcm91c2VsJywgc2l6ZSwgJCRwcm9wcy5jbGFzcywgeyBkb3RzLCBkb3RzQmVsb3csIHJvdW5kZWQsIGZpbGxlZDogaXRlbXMgJiYgaXRlbXMubGVuZ3RoIH0pXG4gICAgJDogc2V0U2Nyb2xsUG9zaXRpb24ocGFyZW50LCBpbml0SW5kZXgpXG5cbiAgICBmdW5jdGlvbiBjYXJvdXNlbChub2RlKSB7XG4gICAgICAgIG5vZGUub250b3VjaHN0YXJ0ID0gZSA9PiBzdG9wUHJvcGFnYXRpb24gJiYgKGUuc3RvcFByb3BhZ2F0aW9uKCkpXG4gICAgICAgIG5vZGUub250b3VjaG1vdmUgPSBlID0+IHN0b3BQcm9wYWdhdGlvbiAmJiAoZS5zdG9wUHJvcGFnYXRpb24oKSlcbiAgICAgICAgbm9kZS5vbnRvdWNoZW5kID0gZSA9PiBzdG9wUHJvcGFnYXRpb24gJiYgKGUuc3RvcFByb3BhZ2F0aW9uKCkpXG5cbiAgICAgICAgcGFyZW50ID0gbm9kZVxuICAgICAgICBzZXRTY3JvbGxQb3NpdGlvbihub2RlLCBhY3RpdmVEb3QpXG4gICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgb25TY3JvbGwpXG4gICAgICAgIHJldHVybiB7IFxuICAgICAgICAgICAgZGVzdHJveTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgb25TY3JvbGwpXG4gICAgICAgICAgICAgICAgbm9kZS5vbnRvdWNoc3RhcnQ9IG51bGxcbiAgICAgICAgICAgICAgICBub2RlLm9udG91Y2htb3ZlPSBudWxsXG4gICAgICAgICAgICAgICAgbm9kZS5vbnRvdWNoZW5kPSBudWxsXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvblNjcm9sbChlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBnZXRBY3RpdmVEb3QoZS50YXJnZXQpXG4gICAgICAgIH0gY2F0Y2ggKGVycikgeyBjb25zb2xlLndhcm4oJ0Nhcm91c2VsIGRvZXMgbm90IHdvcmsuJywgZXJyKSB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0QWN0aXZlRG90KHBhcmVudCkge1xuICAgICAgICBjb25zdCB7IHNjcm9sbExlZnQsIHNjcm9sbFdpZHRoLCBvZmZzZXRXaWR0aCB9ID0gcGFyZW50XG4gICAgICAgIGNvbnN0IGRvdEFtb3VudCA9IEFycmF5LmZyb20ocGFyZW50LmNoaWxkcmVuKS5sZW5ndGhcbiAgICAgICAgY29uc3Qgc2Nyb2xsWCA9IHNjcm9sbExlZnQgLyAoc2Nyb2xsV2lkdGggLSBvZmZzZXRXaWR0aClcbiAgICAgICAgY29uc3QgbmV3QWN0aXZlRG90ID0gTWF0aC5yb3VuZChzY3JvbGxYICogKGRvdEFtb3VudCAtIDEpKVxuICAgICAgICBpZiAoYWN0aXZlRG90ICE9PSBuZXdBY3RpdmVEb3QgJiYgIWlzTmFOKG5ld0FjdGl2ZURvdCkpIGFjdGl2ZURvdCA9IG5ld0FjdGl2ZURvdFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFNjcm9sbFBvc2l0aW9uKHBhcmVudCwgYWN0aXZlRG90KSB7XG4gICAgICAgIGlmICghcGFyZW50KSByZXR1cm5cbiAgICAgICAgY29uc3QgeyB3aWR0aCB9ID0gcGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICAgIHdhaXRVbnRpbCgoKSA9PiB7XG4gICAgICAgICAgICBwYXJlbnQuc2Nyb2xsTGVmdCA9IE1hdGgucm91bmQod2lkdGggKiBhY3RpdmVEb3QpXG4gICAgICAgICAgICBpZiAocGFyZW50LnNjcm9sbExlZnQgIT09IE1hdGgucm91bmQod2lkdGggKiBhY3RpdmVEb3QpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IHNldC4nKVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB7IGludGVydmFsOiA1MCB9KVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uQ2xpY2soaXRlbSwgaW5kZXgsIGUpIHtcbiAgICAgICAgZGlzcGF0Y2goJ2NsaWNrJywgeyBpdGVtLCBpbmRleCwgZSB9KVxuICAgICAgICBpZiAodHlwZW9mIGl0ZW0ub25DbGljayA9PT0gJ2Z1bmN0aW9uJykgaXRlbS5vbkNsaWNrKGl0ZW0sIGluZGV4LCBlKVxuICAgIH1cblxuPC9zY3JpcHQ+XG5cbjxzZWN0aW9uIGFyaWEtbGFiZWw9XCJjYXJvdXNlbFwiIGNsYXNzPXtjbGFzc1Byb3B9PlxuICAgIDx1bCBcbiAgICAgICAgdXNlOmNhcm91c2VsXG4gICAgICAgIGNsYXNzPVwiY2Fyb3VzZWwtaW5uZXIgc2Nyb2xsLXgtY2VudGVyXCJcbiAgICA+XG4gICAgICAgIHsjaWYgaXRlbXMgIT09IG51bGx9XG4gICAgICAgICAgICB7I2VhY2ggaXRlbXMgYXMgaXRlbSwgaW5kZXh9XG4gICAgICAgICAgICAgICAgPGxpIGNsYXNzPVwiZmx1aWRcIiByb2xlPVwiYnV0dG9uXCIgb246Y2xpY2s9e29uQ2xpY2suYmluZChudWxsLCBpdGVtLCBpbmRleCl9PlxuICAgICAgICAgICAgICAgICAgICA8c2xvdCB7aXRlbX0ge2luZGV4fT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxGYW5jeUJveCBkaXNhYmxlZD17ZGlzYWJsZUZhbmN5fT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8UGljdHVyZSBrZXk9XCJwaWN0dXJlXCIgey4uLml0ZW19IGFsdD17aXRlbS5hbHQgfHwgJ9Ck0L7RgtC+INGB0LvQsNC50LTRgyd9Lz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c2VjdGlvbiBzbG90PVwiYm94XCIgY2xhc3M9XCJmbGV4IGZ1bGwtd2lkdGhcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPFBpY3R1cmUga2V5PVwicGljdHVyZVwiIHsuLi5pdGVtfSBhbHQ9e2l0ZW0uYWx0IHx8ICfQpNC+0YLQviDRgdC70LDQudC00YMnfS8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zZWN0aW9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9GYW5jeUJveD5cbiAgICAgICAgICAgICAgICAgICAgPC9zbG90PlxuICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICB7L2VhY2h9XG4gICAgICAgIHsvaWZ9XG4gICAgPC91bD5cblxuXG4gICAgeyNpZiBkb3RzICYmIEFycmF5LmlzQXJyYXkoaXRlbXMpfVxuICAgICAgICA8dWwgY2xhc3M9XCJjYXJvdXNlbC1kb3RzXCI+XG4gICAgICAgICAgICB7I2VhY2ggaXRlbXMgYXMgX2l0ZW0sIGl9XG4gICAgICAgICAgICAgICAgPGxpIGNsYXNzPXtpID09PSBhY3RpdmVEb3QgPyAnYWN0aXZlJyA6ICcnfT48L2xpPlxuICAgICAgICAgICAgey9lYWNofVxuICAgICAgICA8L3VsPlxuICAgIHsvaWZ9XG48L3NlY3Rpb24+XG5cbjxzdHlsZT5cbiAgICAuY2Fyb3VzZWwucm91bmRlZCA+IC5jYXJvdXNlbC1pbm5lciB7XG4gICAgICAgYm9yZGVyLXJhZGl1czogdmFyKC0tYm9yZGVyLXJhZGl1cy1iaWcpO1xuICAgIH1cblxuICAgIC5jYXJvdXNlbCwgLmNhcm91c2VsLWlubmVyLCAuY2Fyb3VzZWwtaW5uZXIgPiBsaSB7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgZmxleDogbm9uZTtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgdGV4dC1hbGlnbjogbGVmdDtcbiAgICAgICAgYWxpZ24tc2VsZjogc3RyZXRjaDtcbiAgICAgICAgYWxpZ24taXRlbXM6IHN0cmV0Y2g7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogc3RyZXRjaDtcbiAgICB9XG5cbiAgICAuY2Fyb3VzZWwuZG90cy5kb3RzQmVsb3cuZmlsbGVkIHtcbiAgICAgICAgcGFkZGluZy1ib3R0b206IDQwcHg7XG4gICAgfVxuXG4gICAgLmNhcm91c2VsLmZpbGxlZCA+IC5jYXJvdXNlbC1pbm5lciB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuICAgIH1cblxuICAgIC5jYXJvdXNlbC5kb3RzQmVsb3cgLmNhcm91c2VsLWRvdHMge1xuICAgICAgICBib3R0b206IDA7XG4gICAgfVxuXG4gICAgLmNhcm91c2VsLmRvdHNCZWxvdyAuY2Fyb3VzZWwtZG90cyBsaSB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEodmFyKC0tdGhlbWUtYmctY29sb3Itb3Bwb3NpdGUpKTtcbiAgICB9XG5cbiAgICAuY2Fyb3VzZWwuc3RyZXRjaCA+IC5jYXJvdXNlbC1pbm5lciA+IC5mbHVpZCB7XG4gICAgICAgIGZsZXg6IG5vbmU7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgIH1cblxuICAgIC5jYXJvdXNlbC5hdXRvID4gLmNhcm91c2VsLWlubmVyID4gLmZsdWlkIHtcbiAgICAgICAgd2lkdGg6IGF1dG87XG4gICAgfVxuXG4gICAgLmNhcm91c2VsIHtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgfVxuXG4gICAgLyogM2Qgb3V0IGZvciBnb29kIGFjY2Vzc2liaWxpdHkgb2YgZGVza3RvcCBicm93cyBvZiBkZXNrdG9wIGJyb3dzZXJzICovXG4gICAgLyouY2Fyb3VzZWwtaW5uZXI6Oi13ZWJraXQtc2Nyb2xsYmFyIHsqL1xuICAgIC8qICAgIGRpc3BsYXk6IG5vbmU7Ki9cbiAgICAvKn0qL1xuXG4gICAgLmNhcm91c2VsID4gLmNhcm91c2VsLWlubmVyIHtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIG92ZXJmbG93LXk6IGhpZGRlbjtcbiAgICAgICAgb3ZlcmZsb3cteDogc2Nyb2xsO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKHZhcigtLXRoZW1lLWJnLWNvbG9yLW9wcG9zaXRlKSwgLjA0KTtcbiAgICB9XG5cbiAgICAuY2Fyb3VzZWwtZG90cyB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgICAgYm90dG9tOiAxMHB4O1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAganVzdGlmeS1pdGVtczogY2VudGVyO1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgfVxuXG4gICAgLmNhcm91c2VsLWRvdHMgbGkge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIHdpZHRoOiA4cHg7XG4gICAgICAgIGhlaWdodDogOHB4O1xuICAgICAgICBtYXJnaW46IDVweDtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogNTAlO1xuICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICBib3gtc2hhZG93OiB2YXIoLS1zaGFkb3ctcHJpbWFyeSk7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEodmFyKC0tY29sb3ItbGlnaHQpKTtcbiAgICB9XG5cbiAgICAuY2Fyb3VzZWwtZG90cyBsaTpub3QoLmFjdGl2ZSkge1xuICAgICAgICBvcGFjaXR5OiAuNTtcbiAgICB9XG5cbiAgICAuY2Fyb3VzZWwtZG90cyBsaS5hY3RpdmUge1xuICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDEuNSk7XG4gICAgfVxuPC9zdHlsZT5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgY3JlYXRlRXZlbnREaXNwYXRjaGVyIH0gZnJvbSAnc3ZlbHRlJ1xuICAgIGltcG9ydCB7IGNsYXNzbmFtZXMgfSBmcm9tICdAdXRpbHMnXG5cbiAgICBjb25zdCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpXG5cbiAgICBpbXBvcnQgQnIgZnJvbSAnLi9Cci5zdmVsdGUnXG4gICAgaW1wb3J0IEljb24gZnJvbSAnLi9JY29uLnN2ZWx0ZSdcbiAgICBpbXBvcnQgQnV0dG9uIGZyb20gJy4vQnV0dG9uLnN2ZWx0ZSdcblxuICAgIGV4cG9ydCBsZXQgb2ZmID0gZmFsc2VcblxuICAgICQ6IGNsYXNzUHJvcCA9IGNsYXNzbmFtZXMoJ2VkaXQtYXJlYScsICQkcHJvcHMuY2xhc3MsIHsgb2ZmIH0pXG5cbiAgICBmdW5jdGlvbiBvbkNsaWNrKGUpIHtcbiAgICAgICAgaWYgKCFvZmYpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoKCdjbGljaycsIGUpXG4gICAgICAgIH1cbiAgICB9XG48L3NjcmlwdD5cblxuPHNlY3Rpb24gcm9sZT1cImJ1dHRvblwiIGNsYXNzPXtjbGFzc1Byb3B9IG9uOmNsaWNrPXtvbkNsaWNrfT5cbiAgICA8c2xvdD48L3Nsb3Q+XG5cbiAgICB7I2lmICFvZmZ9XG4gICAgICAgIDxCciBzaXplPVwiMzBcIi8+XG4gICAgICAgIDxCdXR0b24gc2l6ZT1cInNtYWxsXCIgaXM9XCJpbmZvXCIgY2xhc3M9XCJuby1maWx0ZXJcIj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaDMgZm9udC1zZWNvbmRhcnkgZm9udC13LTUwMCBmbGV4IGZsZXgtYWxpZ24tY2VudGVyXCI+XG4gICAgICAgICAgICAgICAg0KDQtdC00LDQs9GD0LLQsNGC0LhcbiAgICAgICAgICAgICAgICA8cz48L3M+XG4gICAgICAgICAgICAgICAgPHM+PC9zPlxuICAgICAgICAgICAgICAgIDxJY29uIHR5cGU9XCJlZGl0XCIgc2l6ZT1cInNtYWxsXCIgaXM9XCJsaWdodFwiLz5cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgPC9CdXR0b24+XG4gICAgICAgIDxCciBzaXplPVwiNDBcIi8+XG4gICAgey9pZn1cbjwvc2VjdGlvbj5cblxuPHN0eWxlPlxuICAgIC5lZGl0LWFyZWEge1xuICAgICAgICAtLWNvbG9yLWJnOiByZ2JhKHZhcigtLXRoZW1lLWNvbG9yLXByaW1hcnktb3Bwb3NpdGUpLCAuMSk7XG4gICAgICAgIC0tY29sb3ItbGluZXM6IHJnYmEodmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeS1vcHBvc2l0ZSkpO1xuXG4gICAgICAgIHBhZGRpbmc6IDAgdmFyKC0tc2NyZWVuLXBhZGRpbmcpO1xuICAgICAgICBiYWNrZ3JvdW5kLWltYWdlOiBsaW5lYXItZ3JhZGllbnQodG8gcmlnaHQsIHZhcigtLWNvbG9yLWxpbmVzKSA1MCUsIHJnYmEodmFyKC0tY29sb3ItYmxhY2spLCAwKSAwJSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVhci1ncmFkaWVudCh0byByaWdodCwgdmFyKC0tY29sb3ItbGluZXMpIDUwJSwgcmdiYSh2YXIoLS1jb2xvci1ibGFjayksIDApIDAlKTtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tY29sb3ItYmcpO1xuICAgICAgICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiBjYWxjKDUwJSAtIDE1cHgpIHRvcCwgY2FsYyg1MCUgLSAxNXB4KSBib3R0b207XG4gICAgICAgIGJhY2tncm91bmQtc2l6ZTogMjBweCAxcHg7XG4gICAgICAgIGJhY2tncm91bmQtcmVwZWF0OiByZXBlYXQteDtcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICB9XG5cbiAgICAuZWRpdC1hcmVhOm5vdCgub2ZmKSA+IDpnbG9iYWwoKikge1xuICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICB9XG5cbiAgICAuZWRpdC1hcmVhLm9mZiB7XG4gICAgICAgIGJhY2tncm91bmQ6IG5vbmU7XG4gICAgfVxuXG4gICAgLmVkaXQtYXJlYTpub3QoLm9mZikgOmdsb2JhbCgqOm5vdCgubm8tZmlsdGVyKSkge1xuICAgICAgICBmaWx0ZXI6IGdyYXlzY2FsZSgxMDAlKTtcbiAgICB9XG48L3N0eWxlPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBjcmVhdGVFdmVudERpc3BhdGNoZXIgfSBmcm9tICdzdmVsdGUnXG4gICAgaW1wb3J0IHsgY2xhc3NuYW1lcyB9IGZyb20gJ0B1dGlscydcbiAgICBpbXBvcnQgQnIgZnJvbSAnLi9Cci5zdmVsdGUnXG4gICAgaW1wb3J0IENhcmQgZnJvbSAnLi9DYXJkLnN2ZWx0ZSdcbiAgICBpbXBvcnQgQnV0dG9uIGZyb20gJy4vQnV0dG9uLnN2ZWx0ZSdcblxuICAgIGNvbnN0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKClcblxuICAgIGV4cG9ydCBsZXQgZm9ybVxuXG4gICAgJDogY2xhc3NQcm9wID0gY2xhc3NuYW1lcygnZWRpdC1hcmVhLWNvbnRhaW5lciBjb250YWluZXInLCAkJHByb3BzLmNsYXNzKVxuXG4gICAgZnVuY3Rpb24gb25DYW5jZWwoZSkge1xuICAgICAgICBkaXNwYXRjaCgnY2FuY2VsJywgZSlcbiAgICB9XG48L3NjcmlwdD5cblxuPENhcmQgY2xhc3M9e2NsYXNzUHJvcH0+XG4gICAgPEJyIHNpemU9XCIzMFwiLz5cblxuICAgIDxzbG90Lz5cblxuICAgIDxCciBzaXplPVwiNDBcIi8+XG5cbiAgICA8c2VjdGlvbiBjbGFzcz1cImZsZXggZmxleC1hbGlnbi1jZW50ZXJcIj5cbiAgICAgICAgPGRpdiBzdHlsZT1cImZsZXg6IDEgMSA1MCVcIj5cbiAgICAgICAgICAgIDxCdXR0b24gc2l6ZT1cInNtYWxsXCIgaXM9XCJkYXJrLWJvcmRlclwiIG9uOmNsaWNrPXtvbkNhbmNlbH0+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJoMyBmb250LXNlY29uZGFyeSBmb250LXctNTAwIGZsZXggZmxleC1hbGlnbi1jZW50ZXJcIj5cbiAgICAgICAgICAgICAgICAgICAg0KHQutCw0YHRg9Cy0LDRgtC4XG4gICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8cz48L3M+XG4gICAgICAgIDxzPjwvcz5cbiAgICAgICAgPHM+PC9zPlxuICAgICAgICA8ZGl2IHN0eWxlPVwiZmxleDogMSAxIDUwJVwiPlxuICAgICAgICAgICAgPEJ1dHRvbiB7Zm9ybX0gc2l6ZT1cInNtYWxsXCIgdHlwZT1cInN1Ym1pdFwiIGlzPVwiaW5mb1wiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaDMgZm9udC1zZWNvbmRhcnkgZm9udC13LTUwMCBmbGV4IGZsZXgtYWxpZ24tY2VudGVyXCI+XG4gICAgICAgICAgICAgICAgICAgINCX0LHQtdGA0LXQs9GC0LhcbiAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9zZWN0aW9uPlxuXG4gICAgPEJyIHNpemU9XCI0MFwiLz5cbjwvQ2FyZD4gICAgIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBjbGFzc25hbWVzIH0gZnJvbSAnQHV0aWxzJ1xuXG4gICAgZXhwb3J0IGxldCBhY3RpdmUgPSBmYWxzZVxuICAgIGV4cG9ydCBsZXQgdmlzaWJsZSA9IHRydWVcbiAgICBleHBvcnQgbGV0IG1vdW50ZWQgPSBmYWxzZVxuXG4gICAgbGV0IGlzTW91bnRlZCA9IG1vdW50ZWRcblxuICAgICQ6IGNsYXNzUHJvcCA9IGNsYXNzbmFtZXMoJ2xhenktdG9nZ2xlIGZsZXgtMScsICQkcHJvcHMuY2xhc3MsIHsgaGlkZGVuOiAhYWN0aXZlLCBpbnZpc2libGU6ICF2aXNpYmxlIH0pXG4gICAgJDogaWYgKGFjdGl2ZSAmJiAhaXNNb3VudGVkKSBpc01vdW50ZWQgPSB0cnVlXG48L3NjcmlwdD5cblxuPHNlY3Rpb24gY2xhc3M9e2NsYXNzUHJvcH0+XG4gICAgeyNpZiBpc01vdW50ZWR9XG4gICAgICAgIDxzbG90Pjwvc2xvdD5cbiAgICB7L2lmfVxuPC9zZWN0aW9uPlxuXG48c3R5bGU+XG4gICAgLmxhenktdG9nZ2xlLmhpZGRlbiB7XG4gICAgICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgfVxuXG4gICAgLmxhenktdG9nZ2xlLmludmlzaWJsZSB7XG4gICAgICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcbiAgICB9XG48L3N0eWxlPiIsIjxzY3JpcHQ+XG4gICAgLy8gSG93IHRvIG1ha2UgYSBjdXN0b20gbG9hZGVyP1xuICAgIC8vIFNlZSBoZXJlIGZvciBnZW5lcmF0aW5nOiBodHRwczovL2Rhbmlsb3dvei5jb20vY3JlYXRlLWNvbnRlbnQtbG9hZGVyL1xuICAgIFxuICAgIGltcG9ydCB7IG9uTW91bnQgfSBmcm9tICdzdmVsdGUnXG4gICAgaW1wb3J0IHsgY2xhc3NuYW1lcywgdXVpZCB9IGZyb20gJ0B1dGlscydcbiAgICBpbXBvcnQgVGV4dCBmcm9tICcuL1RleHQuc3ZlbHRlJ1xuICAgIGltcG9ydCBDaXJjbGUgZnJvbSAnLi9DaXJjbGUuc3ZlbHRlJ1xuXG4gICAgZXhwb3J0IGxldCB3aWR0aCA9ICcxMDAlJyBcbiAgICBleHBvcnQgbGV0IGhlaWdodCA9ICcxMDAlJ1xuICAgIGV4cG9ydCBsZXQgbGlnaHQgPSAnIzk5OTk5OSc7XG4gICAgZXhwb3J0IGxldCBkYXJrID0gJyM1NTU1NTUnO1xuICAgIGV4cG9ydCBsZXQgb3BhY2l0eSA9IC4yO1xuICAgIGV4cG9ydCBsZXQgYm9yZGVyID0gZmFsc2U7XG4gICAgZXhwb3J0IGxldCBhYnNvbHV0ZSA9IGZhbHNlO1xuICAgIGV4cG9ydCBsZXQgdHlwZSA9IHVuZGVmaW5lZDsgLy8gaDEsIGgyLCBoMywgaDQsIGg1LCBoNiwgcCwgcHJlLCBhdmF0YXJcblxuICAgIGNvbnN0IHVpZCA9IHV1aWQoKVxuXG4gICAgbGV0IGhUeXBlcyA9IHtcbiAgICAgICAgcDogMjEsXG4gICAgICAgIGgxOiAzNSxcbiAgICAgICAgaDI6IDI5LFxuICAgICAgICBoMzogMjYsXG4gICAgICAgIGg0OiAyMSxcbiAgICAgICAgaDU6IDIxLFxuICAgICAgICBoNjogMjEsXG4gICAgICAgIHByZTogMjEsXG4gICAgfVxuXG4gICAgb25Nb3VudCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5ib2R5KTtcbiAgICAgICAgY29uc3QgbGggPSBOdW1iZXIucGFyc2VJbnQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnbGluZS1oZWlnaHQnKSlcbiAgICAgICAgY29uc3QgYmFsYW5jZSA9IDBcblxuICAgICAgICBoVHlwZXMgPSB7XG4gICAgICAgICAgICBwOiBsaCAqIDEuMTUgKyBiYWxhbmNlLFxuICAgICAgICAgICAgaDE6IGxoICogMS44NSArIGJhbGFuY2UsXG4gICAgICAgICAgICBoMjogbGggKiAxLjQgKyBiYWxhbmNlLFxuICAgICAgICAgICAgaDM6IGxoICogMS4zICsgYmFsYW5jZSxcbiAgICAgICAgICAgIGg0OiBsaCAqIDEuMTUgKyBiYWxhbmNlLFxuICAgICAgICAgICAgaDU6IGxoICogMS4xNSArIGJhbGFuY2UsXG4gICAgICAgICAgICBoNjogbGggKiAxLjE1ICsgYmFsYW5jZSxcbiAgICAgICAgICAgIHByZTogbGggKiAxLjE1ICsgYmFsYW5jZSxcbiAgICAgICAgfVxuICAgIH0pXG5cbiAgICAkOiBhcmVhV2lkdGggPSB3aWR0aC5yZXBsYWNlKCclJywgJycpXG4gICAgJDogYXJlYUhlaWdodCA9IGhUeXBlc1t0eXBlXSB8fCBoZWlnaHRcbiAgICAkOiBjbGFzc1Byb3AgPSBjbGFzc25hbWVzKCdsb2FkZXInLCB7IGJvcmRlciwgYWJzb2x1dGUgfSlcbjwvc2NyaXB0PlxuXG48c2VjdGlvbiBcbiAgICBjbGFzcz17Y2xhc3NQcm9wfVxuICAgIHN0eWxlPXtgb3BhY2l0eTogJHtvcGFjaXR5fTsgb3V0bGluZS1jb2xvcjogJHtsaWdodH07YH1cbj5cbiAgICA8c3ZnXG4gICAgICAgIHJvbGU9XCJpbWdcIlxuICAgICAgICB3aWR0aD1cIjEwMCVcIlxuICAgICAgICBoZWlnaHQ9e2FyZWFIZWlnaHR9XG4gICAgICAgIGFyaWEtbGFiZWxsZWRieT1cImxvYWRpbmctYXJpYVwiXG4gICAgICAgIHZpZXdCb3g9e2AwIDAgJHthcmVhV2lkdGh9IDEwMGB9XG4gICAgICAgIHByZXNlcnZlQXNwZWN0UmF0aW89XCJub25lXCJcbiAgICA+XG4gICAgICAgIDx0aXRsZSBpZD1cImxvYWRpbmctYXJpYVwiPkxvYWRpbmcuLi48L3RpdGxlPlxuICAgICAgICA8cmVjdFxuICAgICAgICAgICAgeD1cIjBcIlxuICAgICAgICAgICAgeT1cIjBcIlxuICAgICAgICAgICAgd2lkdGg9XCIxMDAlXCJcbiAgICAgICAgICAgIGhlaWdodD1cIjEwMCVcIlxuICAgICAgICAgICAgY2xpcC1wYXRoPXtgdXJsKCNjbGlwLXBhdGgtJHt1aWR9KWB9XG4gICAgICAgICAgICBzdHlsZT0nZmlsbDogdXJsKFwiI2xvYWRlci1maWxsXCIpOydcbiAgICAgICAgPjwvcmVjdD5cbiAgICAgICAgPGRlZnM+XG4gICAgICAgICAgICA8Y2xpcFBhdGggaWQ9e2BjbGlwLXBhdGgtJHt1aWR9YH0+XG4gICAgICAgICAgICAgICAgPHNsb3Q+XG4gICAgICAgICAgICAgICAgICAgIHsjaWYgJ2F2YXRhcicuaW5jbHVkZXModHlwZSl9XG4gICAgICAgICAgICAgICAgICAgICAgICA8Q2lyY2xlLz5cbiAgICAgICAgICAgICAgICAgICAgezplbHNlIGlmICdoMSxoMixoMyxoNCxoNSxoNixwLHByZScuaW5jbHVkZXModHlwZSl9XG4gICAgICAgICAgICAgICAgICAgICAgICA8VGV4dC8+XG4gICAgICAgICAgICAgICAgICAgIHs6ZWxzZX1cbiAgICAgICAgICAgICAgICAgICAgICAgIDxyZWN0IHg9XCIwXCIgeT1cIjBcIiByeD1cIjNcIiByeT1cIjNcIiB3aWR0aD1cIjEwMCVcIiBoZWlnaHQ9XCIxMDAlXCIgLz5cbiAgICAgICAgICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgICAgICA8L3Nsb3Q+XG4gICAgICAgICAgICA8L2NsaXBQYXRoPlxuICAgICAgICAgICAgPGxpbmVhckdyYWRpZW50IGlkPVwibG9hZGVyLWZpbGxcIj5cbiAgICAgICAgICAgICAgICA8c3RvcFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ9XCIwLjU5OTk2NFwiXG4gICAgICAgICAgICAgICAgICAgIHN0b3AtY29sb3I9e2xpZ2h0fVxuICAgICAgICAgICAgICAgICAgICBzdG9wLW9wYWNpdHk9XCIxXCJcbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIDxhbmltYXRlXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZU5hbWU9XCJvZmZzZXRcIlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXM9XCItMjsgLTI7IDFcIlxuICAgICAgICAgICAgICAgICAgICBrZXlUaW1lcz1cIjA7IDAuMjU7IDFcIlxuICAgICAgICAgICAgICAgICAgICBkdXI9XCIyc1wiXG4gICAgICAgICAgICAgICAgICAgIHJlcGVhdENvdW50PVwiaW5kZWZpbml0ZVwiXG4gICAgICAgICAgICAgICAgICAgID48L2FuaW1hdGU+XG4gICAgICAgICAgICAgICAgPC9zdG9wPlxuICAgICAgICAgICAgICAgIDxzdG9wXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldD1cIjEuNTk5OTZcIlxuICAgICAgICAgICAgICAgICAgICBzdG9wLWNvbG9yPXtkYXJrfVxuICAgICAgICAgICAgICAgICAgICBzdG9wLW9wYWNpdHk9XCIxXCJcbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIDxhbmltYXRlXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZU5hbWU9XCJvZmZzZXRcIlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXM9XCItMTsgLTE7IDJcIlxuICAgICAgICAgICAgICAgICAgICBrZXlUaW1lcz1cIjA7IDAuMjU7IDFcIlxuICAgICAgICAgICAgICAgICAgICBkdXI9XCIyc1wiXG4gICAgICAgICAgICAgICAgICAgIHJlcGVhdENvdW50PVwiaW5kZWZpbml0ZVwiXG4gICAgICAgICAgICAgICAgICAgID48L2FuaW1hdGU+XG4gICAgICAgICAgICAgICAgPC9zdG9wPlxuICAgICAgICAgICAgICAgIDxzdG9wXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldD1cIjIuNTk5OTZcIlxuICAgICAgICAgICAgICAgICAgICBzdG9wLWNvbG9yPXtsaWdodH1cbiAgICAgICAgICAgICAgICAgICAgc3RvcC1vcGFjaXR5PVwiMVwiXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICA8YW5pbWF0ZVxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVOYW1lPVwib2Zmc2V0XCJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzPVwiMDsgMDsgM1wiXG4gICAgICAgICAgICAgICAgICAgIGtleVRpbWVzPVwiMDsgMC4yNTsgMVwiXG4gICAgICAgICAgICAgICAgICAgIGR1cj1cIjJzXCJcbiAgICAgICAgICAgICAgICAgICAgcmVwZWF0Q291bnQ9XCJpbmRlZmluaXRlXCJcbiAgICAgICAgICAgICAgICAgICAgPjwvYW5pbWF0ZT5cbiAgICAgICAgICAgICAgICA8L3N0b3A+XG4gICAgICAgICAgICA8L2xpbmVhckdyYWRpZW50PlxuICAgICAgICA8L2RlZnM+XG4gICAgPC9zdmc+XG48L3NlY3Rpb24+XG5cbjxzdHlsZT5cbiAgICAubG9hZGVyIHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgZmxleDogMSAxIGF1dG87XG4gICAgICAgIGFsaWduLXNlbGY6IHN0cmV0Y2g7XG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWigwKTtcbiAgICB9XG5cbiAgICAubG9hZGVyIHN2ZyB7XG4gICAgICAgIGZsZXg6IDEgMSBhdXRvO1xuICAgICAgICBhbGlnbi1zZWxmOiBzdHJldGNoO1xuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVooMCk7XG4gICAgfVxuXG4gICAgLmxvYWRlci5hYnNvbHV0ZSB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgdG9wOiAwO1xuICAgICAgICBsZWZ0OiAwO1xuICAgICAgICByaWdodDogMDtcbiAgICAgICAgYm90dG9tOiAwO1xuICAgIH1cblxuICAgIC5sb2FkZXIuYm9yZGVyIHtcbiAgICAgICAgb3V0bGluZS13aWR0aDogMXB4O1xuICAgICAgICBvdXRsaW5lLXN0eWxlOiBzb2xpZDtcbiAgICB9XG48L3N0eWxlPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBzbGlkZSB9IGZyb20gJ3N2ZWx0ZS90cmFuc2l0aW9uJztcblxuICAgIGV4cG9ydCBsZXQgaXRlbXNcblxuICAgICQ6IGxpc3QgPSBbXS5jb25jYXQoaXRlbXMgfHwgW10pLnNsaWNlKDAsIDEpLmZpbHRlcihCb29sZWFuKVxuPC9zY3JpcHQ+XG5cbnsjaWYgbGlzdCAmJiBsaXN0Lmxlbmd0aH1cbiAgICA8c2xvdCBuYW1lPVwiYmVmb3JlXCI+PC9zbG90PlxuICAgIDx1bCBjbGFzcz17YGZvbnQtcHJpbWFyeSBmb250LXctNTAwIGg0IHRleHQtZGFuZ2VyIHRleHQtbGVmdCAkeyQkcHJvcHMuY2xhc3MgfHwgJyd9YH0+XG4gICAgICAgIHsjZWFjaCBsaXN0IGFzIGl0ZW19XG4gICAgICAgICAgICA8bGkgaW46c2xpZGU+KiB7aXRlbX08L2xpPlxuICAgICAgICB7L2VhY2h9XG4gICAgPC91bD5cbiAgICA8c2xvdCBuYW1lPVwiYWZ0ZXJcIj48L3Nsb3Q+XG57L2lmfVxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBjcmVhdGVFdmVudERpc3BhdGNoZXIgfSBmcm9tICdzdmVsdGUnXG4gICAgaW1wb3J0IHsgY2xhc3NuYW1lcywgdG9DU1NTdHJpbmcgfSBmcm9tICdAdXRpbHMnXG4gICAgaW1wb3J0IEJyIGZyb20gJ0Bjb21wb25lbnRzL0JyLnN2ZWx0ZSdcbiAgICBpbXBvcnQgSWNvbiBmcm9tICdAY29tcG9uZW50cy9JY29uLnN2ZWx0ZSdcbiAgICBpbXBvcnQgRmllbGRFcnJvcnMgZnJvbSAnQGNvbXBvbmVudHMvRmllbGRFcnJvcnMuc3ZlbHRlJ1xuXG4gICAgY29uc3QgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXIoKVxuXG4gICAgZXhwb3J0IGxldCBuYW1lXG4gICAgZXhwb3J0IGxldCB2YWx1ZSA9ICcnXG4gICAgZXhwb3J0IGxldCBzdHlsZSA9IHt9XG4gICAgZXhwb3J0IGxldCB0eXBlID0gJ3RleHQnXG4gICAgZXhwb3J0IGxldCBpZCA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgbWluID0gdW5kZWZpbmVkIC8vIFNwZWNpZmllcyBhIG1pbmltdW0gdmFsdWUgZm9yIGFuIDxpbnB1dD4gZWxlbWVudFxuICAgIGV4cG9ydCBsZXQgbWF4ID0gdW5kZWZpbmVkIC8vIFNwZWNpZmllcyB0aGUgbWF4aW11bSB2YWx1ZSBmb3IgYW4gPGlucHV0PiBlbGVtZW50XG4gICAgZXhwb3J0IGxldCBsaXN0ID0gdW5kZWZpbmVkIC8vIFJlZmVycyB0byBhIDxkYXRhbGlzdD4gZWxlbWVudCB0aGF0IGNvbnRhaW5zIHByZS1kZWZpbmVkIG9wdGlvbnMgZm9yIGFuIDxpbnB1dD4gZWxlbWVudFxuICAgIGV4cG9ydCBsZXQgZm9ybSA9IHVuZGVmaW5lZCAvLyBTcGVjaWZpZXMgdGhlIGZvcm0gdGhlIDxpbnB1dD4gZWxlbWVudCBiZWxvbmdzIHRvXG4gICAgZXhwb3J0IGxldCBtYXhsZW5ndGggPSAxMDAwXG4gICAgZXhwb3J0IGxldCBkaXNhYmxlZCA9IGZhbHNlXG4gICAgZXhwb3J0IGxldCByb3dzID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCBhbGlnbiA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgbGFiZWwgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IGVycm9ycyA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgaW52YWxpZCA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgcGF0dGVybiA9IHVuZGVmaW5lZCAvLyBTcGVjaWZpZXMgYSByZWd1bGFyIGV4cHJlc3Npb24gdGhhdCBhbiA8aW5wdXQ+IGVsZW1lbnQncyB2YWx1ZSBpcyBjaGVja2VkIGFnYWluc3QgKHJlZ2V4cClcbiAgICBleHBvcnQgbGV0IHJlYWRvbmx5ID0gdW5kZWZpbmVkIC8vIHVuZGVmaW5lZHxyZWFkb25seVxuICAgIGV4cG9ydCBsZXQgcmVxdWlyZWQgPSB1bmRlZmluZWQgLy8gdW5kZWZpbmVkfHJlcXVpcmVkXG4gICAgZXhwb3J0IGxldCBwb3N0SWNvbiA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgYXJpYUxhYmVsID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCBtaW5sZW5ndGggPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IHBsYWNlaG9sZGVyID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCBhdXRvY29tcGxldGUgPSB1bmRlZmluZWQvLyBvbnxvZmZcblxuICAgIC8qKlxuICAgICAqIGF1dG9jb21wbGV0ZSAtIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvQXR0cmlidXRlcy9hdXRvY29tcGxldGVcbiAgICAgKiBuYW1lcyAtIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3dlYi91cGRhdGVzLzIwMTUvMDYvY2hlY2tvdXQtZmFzdGVyLXdpdGgtYXV0b2ZpbGxcbiAgICAgKi9cbiAgICBjb25zdCBuYW1lVHlwZXMgPSB7XG4gICAgICAgICdzZXgnOiB7IGF1dG9jb21wbGV0ZTogJ3NleCcgfSxcbiAgICAgICAgJ2JkYXknOiB7IGF1dG9jb21wbGV0ZTogJ2JkYXknIH0sXG4gICAgICAgICduYW1lJzogeyBhdXRvY29tcGxldGU6ICduYW1lJyB9LFxuICAgICAgICAncGhvbmUnOiB7IGF1dG9jb21wbGV0ZTogJ3RlbCcgfSxcbiAgICAgICAgJ2ZuYW1lJzogeyBhdXRvY29tcGxldGU6ICduYW1lJyB9LFxuICAgICAgICAnbG5hbWUnOiB7IGF1dG9jb21wbGV0ZTogJ25hbWUnIH0sXG4gICAgICAgICdlbWFpbCc6IHsgYXV0b2NvbXBsZXRlOiAnZW1haWwnIH0sXG4gICAgICAgICdwYXNzd29yZCc6IHsgYXV0b2NvbXBsZXRlOiAnbmV3LXBhc3N3b3JkJyB9LFxuICAgICAgICBcbiAgICAgICAgJ2N2Yyc6IHsgYXV0b2NvbXBsZXRlOiAnY2MtY3NjJyB9LFxuICAgICAgICAnY2MtZXhwJzogeyBhdXRvY29tcGxldGU6ICdjYy1leHAnIH0sXG4gICAgICAgICdjY25hbWUnOiB7IGF1dG9jb21wbGV0ZTogJ2NjLW5hbWUnIH0sXG4gICAgICAgICdjYXJkbnVtYmVyJzogeyBhdXRvY29tcGxldGU6ICdjYy1udW1iZXInIH0sXG5cbiAgICAgICAgJ3NoaXAtc3RhdGUnOiB7IGF1dG9jb21wbGV0ZTogJ3NoaXBwaW5nIHJlZ2lvbicgfSxcbiAgICAgICAgJ3NoaXAtY2l0eSc6IHsgYXV0b2NvbXBsZXRlOiAnc2hpcHBpbmcgbG9jYWxpdHknIH0sXG4gICAgICAgICdzaGlwLXppcCc6IHsgYXV0b2NvbXBsZXRlOiAnc2hpcHBpbmcgcG9zdGFsLWNvZGUnIH0sXG4gICAgICAgICdzaGlwLWNvdW50cnknOiB7IGF1dG9jb21wbGV0ZTogJ3NoaXBwaW5nIGNvdW50cnknIH0sXG4gICAgICAgICdzaGlwLWFkZHJlc3MnOiB7IGF1dG9jb21wbGV0ZTogJ3NoaXBwaW5nIHN0cmVldC1hZGRyZXNzJyB9LFxuICAgIH1cblxuICAgIGNvbnN0IHR5cGVQb3N0SWNvbnMgPSB7XG4gICAgICBkYXRlOiAnY2FsZW5kYXInLFxuICAgICAgc2VhcmNoOiAnc2VhcmNoJyxcbiAgICB9XG5cbiAgICAkOiBpbnB1dFByZWRpY3QgPSBuYW1lVHlwZXNbbmFtZV0gfHwge31cbiAgICAkOiBpY29uVHlwZSA9IHBvc3RJY29uIHx8IHR5cGVQb3N0SWNvbnNbdHlwZV1cblxuICAgICQ6IGVycm9yID0gaW52YWxpZCAhPT0gdW5kZWZpbmVkID8gaW52YWxpZCA6ICEhKGVycm9ycyB8fCBbXSkubGVuZ3RoXG4gICAgJDogaWRQcm9wID0gaWQgfHwgaW5wdXRQcmVkaWN0LmlkIHx8IG5hbWVcbiAgICAkOiB0eXBlUHJvcCA9IHR5cGVcbiAgICAkOiB0aXRsZVByb3AgPSBsYWJlbCB8fCBhcmlhTGFiZWxcbiAgICAkOiBhcmlhTGFiZWxQcm9wID0gYXJpYUxhYmVsIHx8IGxhYmVsIHx8IHBsYWNlaG9sZGVyXG4gICAgJDogc3R5bGVQcm9wID0gdG9DU1NTdHJpbmcoeyAuLi5zdHlsZSwgdGV4dEFsaWduOiBhbGlnbiB9KVxuICAgICQ6IHBhdHRlcm5Qcm9wID0gdHlwZSA9PT0gJ251bWJlcicgJiYgIXBhdHRlcm4gPyAnWzAtOV0qJyA6IHBhdHRlcm5cbiAgICAkOiBjbGFzc1Byb3AgPSBjbGFzc25hbWVzKCdpbnAnLCAkJHByb3BzLmNsYXNzLCB7IGRpc2FibGVkLCByZWFkb25seSwgcmVxdWlyZWQsIGVycm9yLCBwb3N0SWNvbjogaWNvblR5cGUgfSlcbiAgICAkOiBhdXRvY29tcGxldGVQcm9wID0gYXV0b2NvbXBsZXRlIHx8IGlucHV0UHJlZGljdC5hdXRvY29tcGxldGVcblxuICAgIGZ1bmN0aW9uIG9uSW5wdXQoZSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGdldFZhbHVlKGUpXG4gICAgICAgIGRpc3BhdGNoKCdpbnB1dCcsIHsgZSwgdmFsdWUsIG5hbWUgfSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkNoYW5nZShlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZ2V0VmFsdWUoZSlcbiAgICAgICAgZGlzcGF0Y2goJ2NoYW5nZScsIHsgZSwgdmFsdWUsIG5hbWUgfSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRWYWx1ZShlKSB7XG4gICAgICAgIHJldHVybiBlLnRhcmdldC52YWx1ZVxuICAgIH1cbjwvc2NyaXB0PlxuXG48ZGl2IGNsYXNzPXtjbGFzc1Byb3B9PlxuICAgIHsjaWYgdGl0bGVQcm9wfVxuICAgICAgICA8bGFiZWwgZm9yPXtpZFByb3B9IGNsYXNzPVwiaW5wLWxhYmVsIGgyIGZvbnQtc2Vjb25kYXJ5IGZvbnQtdy02MDAgdGV4dC1sZWZ0XCI+XG4gICAgICAgICAgICB7IHRpdGxlUHJvcCB9XG4gICAgICAgICAgICA8QnIgc2l6ZT1cIjEwXCIvPlxuICAgICAgICA8L2xhYmVsPlxuICAgIHsvaWZ9XG5cbiAgICA8ZGl2IGNsYXNzPVwiaW5wLWlubmVyLXdyYXBcIj5cbiAgICAgICAgeyNpZiByb3dzIHx8IHR5cGUgPT09ICd0ZXh0YXJlYSd9XG4gICAgICAgICAgICA8dGV4dGFyZWFcbiAgICAgICAgICAgICAgICAgICAge21pbn1cbiAgICAgICAgICAgICAgICAgICAge21heH1cbiAgICAgICAgICAgICAgICAgICAge3Jvd3N9XG4gICAgICAgICAgICAgICAgICAgIHtuYW1lfVxuICAgICAgICAgICAgICAgICAgICB7Zm9ybX1cbiAgICAgICAgICAgICAgICAgICAge2FsaWdufVxuICAgICAgICAgICAgICAgICAgICB7cmVhZG9ubHl9XG4gICAgICAgICAgICAgICAgICAgIHtkaXNhYmxlZH1cbiAgICAgICAgICAgICAgICAgICAge3JlcXVpcmVkfVxuICAgICAgICAgICAgICAgICAgICB7bWlubGVuZ3RofVxuICAgICAgICAgICAgICAgICAgICB7bWF4bGVuZ3RofVxuICAgICAgICAgICAgICAgICAgICB7cGxhY2Vob2xkZXJ9XG4gICAgICAgICAgICAgICAgICAgIGlkPXtpZFByb3B9XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiaW5wLWlubmVyXCJcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU9e3RpdGxlUHJvcH1cbiAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3N0eWxlUHJvcH1cbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybj17cGF0dGVyblByb3B9XG4gICAgICAgICAgICAgICAgICAgIGFyaWEtbGFiZWw9e2FyaWFMYWJlbFByb3B9XG4gICAgICAgICAgICAgICAgICAgIGF1dG9jb21wbGV0ZT17YXV0b2NvbXBsZXRlUHJvcH1cbiAgICAgICAgICAgICAgICAgICAgey4uLnsgdHlwZTogdHlwZVByb3AgfX1cbiAgICAgICAgICAgICAgICAgICAgYmluZDp2YWx1ZT17dmFsdWV9XG4gICAgICAgICAgICAgICAgICAgIG9uOmlucHV0PXtvbklucHV0fVxuICAgICAgICAgICAgICAgICAgICBvbjpjaGFuZ2U9e29uQ2hhbmdlfVxuICAgICAgICAgICAgICAgICAgICBvbjpibHVyPSd7ZSA9PiAhZGlzYWJsZWQgJiYgZGlzcGF0Y2goXCJibHVyXCIsIGUpfSdcbiAgICAgICAgICAgICAgICAgICAgb246Zm9jdXM9J3tlID0+ICFkaXNhYmxlZCAmJiBkaXNwYXRjaChcImZvY3VzXCIsIGUpfSdcbiAgICAgICAgICAgID48L3RleHRhcmVhPlxuICAgICAgICB7OmVsc2V9XG4gICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICAgICAge21pbn1cbiAgICAgICAgICAgICAgICAgICAge21heH1cbiAgICAgICAgICAgICAgICAgICAge25hbWV9XG4gICAgICAgICAgICAgICAgICAgIHtsaXN0fVxuICAgICAgICAgICAgICAgICAgICB7Zm9ybX1cbiAgICAgICAgICAgICAgICAgICAge2FsaWdufVxuICAgICAgICAgICAgICAgICAgICB7cmVhZG9ubHl9XG4gICAgICAgICAgICAgICAgICAgIHtkaXNhYmxlZH1cbiAgICAgICAgICAgICAgICAgICAge3JlcXVpcmVkfVxuICAgICAgICAgICAgICAgICAgICB7bWlubGVuZ3RofVxuICAgICAgICAgICAgICAgICAgICB7bWF4bGVuZ3RofVxuICAgICAgICAgICAgICAgICAgICB7cGxhY2Vob2xkZXJ9XG4gICAgICAgICAgICAgICAgICAgIGlkPXtpZFByb3B9XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiaW5wLWlubmVyXCJcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU9e3RpdGxlUHJvcH1cbiAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3N0eWxlUHJvcH1cbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybj17cGF0dGVyblByb3B9XG4gICAgICAgICAgICAgICAgICAgIGFyaWEtbGFiZWw9e2FyaWFMYWJlbFByb3B9XG4gICAgICAgICAgICAgICAgICAgIGF1dG9jb21wbGV0ZT17YXV0b2NvbXBsZXRlUHJvcH1cbiAgICAgICAgICAgICAgICAgICAgey4uLnsgdHlwZTogdHlwZVByb3AgfX1cbiAgICAgICAgICAgICAgICAgICAgYmluZDp2YWx1ZT17dmFsdWV9XG4gICAgICAgICAgICAgICAgICAgIG9uOmlucHV0PXtvbklucHV0fVxuICAgICAgICAgICAgICAgICAgICBvbjpjaGFuZ2U9e29uQ2hhbmdlfVxuICAgICAgICAgICAgICAgICAgICBvbjpibHVyPSd7ZSA9PiAhZGlzYWJsZWQgJiYgZGlzcGF0Y2goXCJibHVyXCIsIGUpfSdcbiAgICAgICAgICAgICAgICAgICAgb246Zm9jdXM9J3tlID0+ICFkaXNhYmxlZCAmJiBkaXNwYXRjaChcImZvY3VzXCIsIGUpfSdcbiAgICAgICAgICAgID5cbiAgICAgICAgey9pZn1cblxuICAgICAgICA8bGFiZWwgZm9yPXtpZFByb3B9IGNsYXNzPVwiaW5wLXBvc3QtaWNvblwiPlxuICAgICAgICAgICAgPHNsb3QgbmFtZT1cInBvc3QtaWNvblwiPlxuICAgICAgICAgICAgICAgIHsjaWYgaWNvblR5cGV9XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaW5wLXBvc3QtaWNvbi1pbm5lclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPEljb24gdHlwZT17aWNvblR5cGV9IGlzPVwiaW5mb1wiIHNpemU9XCJtZWRpdW1cIi8+XG4gICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICB7L2lmfVxuICAgICAgICAgICAgPC9zbG90PlxuICAgICAgICA8L2xhYmVsPlxuICAgIDwvZGl2PlxuXG4gICAgPEZpZWxkRXJyb3JzIGl0ZW1zPXtlcnJvcnN9PlxuICAgICAgICA8ZGl2IHNsb3Q9XCJiZWZvcmVcIj5cbiAgICAgICAgICAgIDxCciBzaXplPVwiNVwiLz5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9GaWVsZEVycm9ycz5cbjwvZGl2PlxuXG48c3R5bGU+XG4gICAgLmlucCB7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBmbGV4OiAxIDEgYXV0bztcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICB9XG5cbiAgICAuaW5wIC5pbnAtaW5uZXItd3JhcCB7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgYWxpZ24tc2VsZjogc3RyZXRjaDtcbiAgICAgICAgYm94LXNoYWRvdzogdmFyKC0tc2hhZG93LWZpZWxkLWluc2V0KTtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogdmFyKC0tYm9yZGVyLXJhZGl1cy1zbWFsbCk7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEodmFyKC0tdGhlbWUtaW5wdXQtYmctY29sb3IpKTtcbiAgICB9XG5cbiAgICAuaW5wIC5pbnAtaW5uZXIge1xuICAgICAgICBmbGV4LWdyb3c6IDE7XG4gICAgICAgIGNvbG9yOiBpbmhlcml0O1xuICAgICAgICBvdmVyZmxvdy15OiBhdXRvO1xuICAgICAgICBvdmVyZmxvdy14OiBoaWRkZW47XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuICAgICAgICAtd2Via2l0LW92ZXJmbG93LXNjcm9sbGluZzogdG91Y2g7XG4gICAgICAgIG1pbi13aWR0aDogdmFyKC0tbWluLWludGVyYWN0aXZlLXNpemUpO1xuICAgICAgICBtaW4taGVpZ2h0OiB2YXIoLS1taW4taW50ZXJhY3RpdmUtc2l6ZSk7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IHZhcigtLWJvcmRlci1yYWRpdXMtc21hbGwpO1xuICAgIH1cblxuICAgIC5pbnAuZGlzYWJsZWQge1xuICAgICAgICBvcGFjaXR5OiAuNTtcbiAgICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgfVxuXG4gICAgLmlucC5wb3N0SWNvbiAuaW5wLWlubmVyIHtcbiAgICAgICAgcGFkZGluZy1yaWdodDogdmFyKC0tbWluLWludGVyYWN0aXZlLXNpemUpO1xuICAgIH1cblxuICAgIC5pbnAgLmlucC1pbm5lcjppbnZhbGlkLCAuaW5wLmVycm9yIC5pbnAtaW5uZXIge1xuICAgICAgICBib3gtc2hhZG93OiAwIDAgMCAxcHggcmdiKHZhcigtLWNvbG9yLWRhbmdlcikpO1xuICAgICAgICBjb2xvcjogcmdiKHZhcigtLWNvbG9yLWRhbmdlcikpO1xuICAgIH1cblxuICAgIC5pbnAgLmlucC1pbm5lcjpmb2N1cyB7XG4gICAgICAgIGJveC1zaGFkb3c6IDAgMCAwIDFweCByZ2IodmFyKC0tY29sb3ItaW5mbykpO1xuICAgICAgICBjb2xvcjogcmdiKHZhcigtLWNvbG9yLWluZm8pKTtcbiAgICB9XG5cblxuICAgIC5pbnAgLmlucC1pbm5lcjppbnZhbGlkICsgLmlucC1wb3N0LWljb24gOmdsb2JhbCguaWNvKSxcbiAgICAuaW5wLmVycm9yIC5pbnAtcG9zdC1pY29uIDpnbG9iYWwoLmljbykge1xuICAgICAgICBjb2xvcjogcmdiKHZhcigtLWNvbG9yLWRhbmdlcikpICFpbXBvcnRhbnQ7XG4gICAgfVxuXG4gICAgLmlucCAuaW5wLWlubmVyOmZvY3VzICsgLmlucC1wb3N0LWljb24gOmdsb2JhbCguaWNvKSB7XG4gICAgICAgIGNvbG9yOiByZ2IodmFyKC0tY29sb3ItaW5mbykpICFpbXBvcnRhbnQ7XG4gICAgfVxuXG4gICAgLmlucCAuaW5wLXBvc3QtaWNvbi1pbm5lciB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICB3aWR0aDogdmFyKC0tbWluLWludGVyYWN0aXZlLXNpemUpO1xuICAgIH1cblxuICAgIC5pbnAgLmlucC1wb3N0LWljb24ge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogMDtcbiAgICAgICAgcmlnaHQ6IDA7XG4gICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgICAgd2lkdGg6IHZhcigtLW1pbi1pbnRlcmFjdGl2ZS1zaXplKTtcbiAgICAgICAgZmxleDogbm9uZTtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgfVxuXG4gICAgLmlucCAuaW5wLWlubmVyOjpwbGFjZWhvbGRlciB7XG4gICAgICAgIGNvbG9yOiByZ2JhKHZhcigtLXRoZW1lLWNvbG9yLXByaW1hcnktb3Bwb3NpdGUpKTtcbiAgICAgICAgb3BhY2l0eTogLjI7XG4gICAgfVxuPC9zdHlsZT5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgY3JlYXRlRXZlbnREaXNwYXRjaGVyIH0gZnJvbSAnc3ZlbHRlJ1xuICAgIGltcG9ydCB7IGNsYXNzbmFtZXMsIHRvQ1NTU3RyaW5nIH0gZnJvbSAnQHV0aWxzJ1xuICAgIGltcG9ydCBCciBmcm9tICdAY29tcG9uZW50cy9Cci5zdmVsdGUnXG4gICAgaW1wb3J0IEljb24gZnJvbSAnQGNvbXBvbmVudHMvSWNvbi5zdmVsdGUnXG4gICAgaW1wb3J0IEZpZWxkRXJyb3JzIGZyb20gJ0Bjb21wb25lbnRzL0ZpZWxkRXJyb3JzLnN2ZWx0ZSdcblxuICAgIGNvbnN0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKClcblxuICAgIGV4cG9ydCBsZXQgbmFtZVxuICAgIGV4cG9ydCBsZXQgc3R5bGUgPSB7fVxuICAgIGV4cG9ydCBsZXQgdHlwZSA9ICdzZWxlY3QnXG4gICAgZXhwb3J0IGxldCB2YWx1ZSA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgaWQgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IGFsaWduID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCBkaXNhYmxlZCA9IGZhbHNlXG4gICAgZXhwb3J0IGxldCBsYWJlbCA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgaW52YWxpZCA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgZm9ybSA9IHVuZGVmaW5lZCAvLyBTcGVjaWZpZXMgdGhlIGZvcm0gdGhlIDxpbnB1dD4gZWxlbWVudCBiZWxvbmdzIHRvXG4gICAgZXhwb3J0IGxldCByZWFkb25seSA9IHVuZGVmaW5lZCAvLyB1bmRlZmluZWR8cmVhZG9ubHlcbiAgICBleHBvcnQgbGV0IHJlcXVpcmVkID0gdW5kZWZpbmVkIC8vIHVuZGVmaW5lZHxyZXF1aXJlZFxuICAgIGV4cG9ydCBsZXQgYXJpYUxhYmVsID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCBwbGFjZWhvbGRlciA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgYXV0b2NvbXBsZXRlID0gJ29uJ1xuICAgIGV4cG9ydCBsZXQgcG9zdEljb24gPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IGVycm9ycyA9IHVuZGVmaW5lZFxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHR5cGUge3tcbiAgICAgKiAgICAgdmFsdWU6IHN0cmluZyxcbiAgICAgKiAgICAgbGFiZWw6IHN0cmluZyxcbiAgICAgKiB9W119XG4gICAgICovXG4gICAgZXhwb3J0IGxldCBvcHRpb25zID0gW11cblxuICAgICQ6IGljb25UeXBlID0gcG9zdEljb24gfHwgJ2NhcmV0LWRvd24nXG4gICAgJDogZXJyb3IgPSBpbnZhbGlkIHx8ICEhKGVycm9ycyB8fCBbXSkubGVuZ3RoXG4gICAgJDogaWRQcm9wID0gaWQgfHwgbmFtZVxuICAgICQ6IHRpdGxlUHJvcCA9IGxhYmVsIHx8IGFyaWFMYWJlbFxuICAgICQ6IGFyaWFMYWJlbFByb3AgPSBhcmlhTGFiZWwgfHwgbGFiZWwgfHwgcGxhY2Vob2xkZXJcbiAgICAkOiBzdHlsZVByb3AgPSB0b0NTU1N0cmluZyh7IC4uLnN0eWxlLCB0ZXh0QWxpZ246IGFsaWduIH0pXG4gICAgJDogY2xhc3NQcm9wID0gY2xhc3NuYW1lcygnc2VsZWN0JywgJCRwcm9wcy5jbGFzcywgeyBkaXNhYmxlZCwgcmVhZG9ubHksIHJlcXVpcmVkLCBlcnJvciwgbnVsbDogdmFsdWUgPT09IHVuZGVmaW5lZCB9KVxuXG4gICAgZnVuY3Rpb24gb25DaGFuZ2UoZSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGdldFZhbHVlKGUpXG4gICAgICAgIGRpc3BhdGNoKCdjaGFuZ2UnLCB7IGUsIHZhbHVlLCBuYW1lIH0pXG4gICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIGdldFZhbHVlKGUpIHtcbiAgICAgICAgcmV0dXJuIGUudGFyZ2V0LnZhbHVlXG4gICAgfVxuPC9zY3JpcHQ+XG5cbjxkaXYgY2xhc3M9e2NsYXNzUHJvcH0+XG4gICAgeyNpZiB0aXRsZVByb3B9XG4gICAgICAgIDxsYWJlbCBmb3I9e2lkUHJvcH0gY2xhc3M9XCJibG9jayBoMiBmb250LXctNTAwIGZ1bGwtd2lkdGggdGV4dC1sZWZ0XCI+XG4gICAgICAgICAgICB7IHRpdGxlUHJvcCB9XG4gICAgICAgIDwvbGFiZWw+XG4gICAgICAgIDxCciBzaXplPVwiMTBcIi8+XG4gICAgey9pZn1cblxuICAgIDxkaXYgY2xhc3M9XCJpbnAtaW5uZXItd3JhcFwiPlxuICAgICAgICA8c2VsZWN0XG4gICAgICAgICAgICAgICAge25hbWV9XG4gICAgICAgICAgICAgICAge3R5cGV9XG4gICAgICAgICAgICAgICAge2Zvcm19XG4gICAgICAgICAgICAgICAge2FsaWdufVxuICAgICAgICAgICAgICAgIHtyZWFkb25seX1cbiAgICAgICAgICAgICAgICB7ZGlzYWJsZWR9XG4gICAgICAgICAgICAgICAge3JlcXVpcmVkfVxuICAgICAgICAgICAgICAgIHtwbGFjZWhvbGRlcn1cbiAgICAgICAgICAgICAgICB7YXV0b2NvbXBsZXRlfVxuICAgICAgICAgICAgICAgIGlkPXtpZFByb3B9XG4gICAgICAgICAgICAgICAgY2xhc3M9XCJpbnAtaW5uZXJcIlxuICAgICAgICAgICAgICAgIHRpdGxlPXt0aXRsZVByb3B9XG4gICAgICAgICAgICAgICAgc3R5bGU9e3N0eWxlUHJvcH1cbiAgICAgICAgICAgICAgICBhcmlhLWxhYmVsPXthcmlhTGFiZWxQcm9wfVxuICAgICAgICAgICAgICAgIGJpbmQ6dmFsdWVcbiAgICAgICAgICAgICAgICBvbjpjaGFuZ2U9e29uQ2hhbmdlfVxuICAgICAgICAgICAgICAgIG9uOmJsdXI9J3tlID0+ICFkaXNhYmxlZCAmJiBkaXNwYXRjaChcImJsdXJcIiwgZSl9J1xuICAgICAgICAgICAgICAgIG9uOmZvY3VzPSd7ZSA9PiAhZGlzYWJsZWQgJiYgZGlzcGF0Y2goXCJmb2N1c1wiLCBlKX0nXG4gICAgICAgID5cbiAgICAgICAgICAgIHsjaWYgIXJlcXVpcmVkfVxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9e3VuZGVmaW5lZH0+e3BsYWNlaG9sZGVyIHx8ICcnfTwvb3B0aW9uPlxuICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgIHsjZWFjaCBvcHRpb25zIGFzIHsgbGFiZWw6IHRleHQsIC4uLm9wdGlvbiB9fVxuICAgICAgICAgICAgICAgIHsjaWYgb3B0aW9uLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgdGV4dCAhPT0gdW5kZWZpbmVkfVxuICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPXtvcHRpb24udmFsdWV9PlxuICAgICAgICAgICAgICAgICAgICAgICAge3RleHR9XG4gICAgICAgICAgICAgICAgICAgIDwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICB7L2VhY2h9XG4gICAgICAgIDwvc2VsZWN0PlxuXG4gICAgICAgIDxsYWJlbCBmb3I9e2lkUHJvcH0gY2xhc3M9XCJpbnAtcG9zdC1pY29uXCI+XG4gICAgICAgICAgICA8c2xvdCBuYW1lPVwicG9zdC1pY29uXCI+XG4gICAgICAgICAgICAgICAgeyNpZiBpY29uVHlwZX1cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpbnAtcG9zdC1pY29uLWlubmVyXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8SWNvbiB0eXBlPXtpY29uVHlwZX0gaXM9XCJpbmZvXCIgc2l6ZT1cIm1lZGl1bVwiLz5cbiAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICA8L3Nsb3Q+XG4gICAgICAgIDwvbGFiZWw+XG4gICAgPC9kaXY+XG5cbiAgICA8RmllbGRFcnJvcnMgaXRlbXM9e2Vycm9yc30vPlxuPC9kaXY+XG5cbjxzdHlsZT5cbiAgICAuc2VsZWN0IHtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIGZsZXg6IDEgMSBhdXRvO1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIH1cblxuICAgIC5zZWxlY3QuZGlzYWJsZWQge1xuICAgICAgICBvcGFjaXR5OiAuNTtcbiAgICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgfVxuICAgIFxuICAgIC5zZWxlY3QubnVsbCAuaW5wLWlubmVyIHtcbiAgICAgICAgY29sb3I6IHJnYmEodmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeS1vcHBvc2l0ZSksIC4yKSAhaW1wb3J0YW50O1xuICAgIH1cblxuICAgIC5zZWxlY3QgLmlucC1pbm5lci13cmFwIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBhbGlnbi1zZWxmOiBzdHJldGNoO1xuICAgICAgICBib3gtc2hhZG93OiB2YXIoLS1zaGFkb3ctZmllbGQtaW5zZXQpO1xuICAgICAgICBib3JkZXItcmFkaXVzOiB2YXIoLS1ib3JkZXItcmFkaXVzLXNtYWxsKTtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSh2YXIoLS10aGVtZS1iZy1jb2xvcikpO1xuICAgIH1cblxuICAgIC5zZWxlY3QgLmlucC1pbm5lciB7XG4gICAgICAgIGZsZXgtZ3JvdzogMTtcbiAgICAgICAgY29sb3I6IGluaGVyaXQ7XG4gICAgICAgIG92ZXJmbG93LXk6IGF1dG87XG4gICAgICAgIG92ZXJmbG93LXg6IGhpZGRlbjtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG4gICAgICAgIC13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nOiB0b3VjaDtcbiAgICAgICAgbWluLXdpZHRoOiB2YXIoLS1taW4taW50ZXJhY3RpdmUtc2l6ZSk7XG4gICAgICAgIG1pbi1oZWlnaHQ6IHZhcigtLW1pbi1pbnRlcmFjdGl2ZS1zaXplKTtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogdmFyKC0tYm9yZGVyLXJhZGl1cy1zbWFsbCk7XG4gICAgfVxuXG4gICAgLnNlbGVjdCAuaW5wLXBvc3QtaWNvbiB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgdG9wOiAwO1xuICAgICAgICByaWdodDogMDtcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICB3aWR0aDogdmFyKC0tbWluLWludGVyYWN0aXZlLXNpemUpO1xuICAgICAgICBmbGV4OiBub25lO1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICB9XG5cbiAgICAuc2VsZWN0IC5pbnAtcG9zdC1pY29uLWlubmVyIHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgIHdpZHRoOiB2YXIoLS1taW4taW50ZXJhY3RpdmUtc2l6ZSk7XG4gICAgfVxuXG4gICAgLnNlbGVjdCAuaW5wLWlubmVyIG9wdGlvbltkZWZhdWx0XSxcbiAgICAuc2VsZWN0IC5pbnAtaW5uZXI6OnBsYWNlaG9sZGVyIHtcbiAgICAgICAgY29sb3I6IHJnYmEodmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeS1vcHBvc2l0ZSkpO1xuICAgICAgICBvcGFjaXR5OiAuMjtcbiAgICB9XG5cbiAgICAuc2VsZWN0LnBvc3RJY29uIC5pbnAtaW5uZXIge1xuICAgICAgICBwYWRkaW5nLXJpZ2h0OiB2YXIoLS1taW4taW50ZXJhY3RpdmUtc2l6ZSk7XG4gICAgfVxuXG4gICAgLnNlbGVjdCAuaW5wLWlubmVyOmludmFsaWQsXG4gICAgLnNlbGVjdC5lcnJvciAuaW5wLWlubmVyIHtcbiAgICAgICAgYm94LXNoYWRvdzogMCAwIDAgMXB4IHJnYih2YXIoLS1jb2xvci1kYW5nZXIpKTtcbiAgICAgICAgY29sb3I6IHJnYih2YXIoLS1jb2xvci1kYW5nZXIpKTtcbiAgICB9XG5cbiAgICAuc2VsZWN0IC5pbnAtaW5uZXI6aW52YWxpZCArIC5pbnAtcG9zdC1pY29uIDpnbG9iYWwoLmljbyksXG4gICAgLnNlbGVjdC5lcnJvciAuaW5wLXBvc3QtaWNvbiA6Z2xvYmFsKC5pY28pIHtcbiAgICAgICAgY29sb3I6IHJnYih2YXIoLS1jb2xvci1kYW5nZXIpKSAhaW1wb3J0YW50O1xuICAgIH1cblxuICAgIC5zZWxlY3QgLmlucC1pbm5lcjpmb2N1cyB7XG4gICAgICAgIGJveC1zaGFkb3c6IDAgMCAwIDFweCByZ2IodmFyKC0tY29sb3ItaW5mbykpO1xuICAgICAgICBjb2xvcjogcmdiKHZhcigtLWNvbG9yLWluZm8pKTtcbiAgICB9XG5cbiAgICAuc2VsZWN0IC5pbnAtaW5uZXI6Zm9jdXMgKyAuaW5wLXBvc3QtaWNvbiA6Z2xvYmFsKC5pY28pIHtcbiAgICAgICAgY29sb3I6IHJnYih2YXIoLS1jb2xvci1pbmZvKSkgIWltcG9ydGFudDtcbiAgICB9XG5cbjwvc3R5bGU+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IGNsYXNzbmFtZXMsIHRvQ1NTU3RyaW5nIH0gZnJvbSAnQHV0aWxzJ1xuICAgIGltcG9ydCBCciBmcm9tICdAY29tcG9uZW50cy9Cci5zdmVsdGUnXG5cbiAgICBleHBvcnQgbGV0IHZhbHVlID0gJydcbiAgICBleHBvcnQgbGV0IHN0eWxlID0ge31cbiAgICBleHBvcnQgbGV0IGlkID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCBsYWJlbCA9IHVuZGVmaW5lZFxuXG4gICAgJDogc3R5bGVQcm9wID0gdG9DU1NTdHJpbmcoeyAuLi5zdHlsZSB9KVxuICAgICQ6IGNsYXNzUHJvcCA9IGNsYXNzbmFtZXMoJ2Jsb2NrIGZ1bGwtd2lkdGggdGV4dC1sZWZ0JywgJCRwcm9wcy5jbGFzcylcbjwvc2NyaXB0PlxuXG48ZGl2IHtpZH0gY2xhc3M9e2NsYXNzUHJvcH0gc3R5bGU9e3N0eWxlUHJvcH0+XG4gICAgeyNpZiBsYWJlbH1cbiAgICAgICAgPGgyIGNsYXNzPVwiYmxvY2sgZnVsbC13aWR0aFwiPntsYWJlbH08L2gyPlxuICAgICAgICA8QnIgc2l6ZT1cIjEwXCIvPlxuICAgIHsvaWZ9XG4gICAgPHAgY2xhc3M9XCJibG9jayBmdWxsLXdpZHRoXCI+e3ZhbHVlIHx8ICfigJQnfTwvcD5cbjwvZGl2PlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBjcmVhdGVFdmVudERpc3BhdGNoZXIgfSBmcm9tICdzdmVsdGUnXG4gICAgaW1wb3J0IHsgY2xhc3NuYW1lcywgdG9DU1NTdHJpbmcgfSBmcm9tICdAdXRpbHMnXG4gICAgaW1wb3J0IEJyIGZyb20gJ0Bjb21wb25lbnRzL0JyLnN2ZWx0ZSdcbiAgICBpbXBvcnQgSWNvbiBmcm9tICdAY29tcG9uZW50cy9JY29uLnN2ZWx0ZSdcbiAgICBpbXBvcnQgQnV0dG9uIGZyb20gJ0Bjb21wb25lbnRzL0J1dHRvbi5zdmVsdGUnXG4gICAgaW1wb3J0IEZpZWxkRXJyb3JzIGZyb20gJ0Bjb21wb25lbnRzL0ZpZWxkRXJyb3JzLnN2ZWx0ZSdcblxuICAgIGNvbnN0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKClcblxuICAgIGV4cG9ydCBsZXQgbmFtZVxuICAgIGV4cG9ydCBsZXQgc3R5bGUgPSB7fVxuICAgIGV4cG9ydCBsZXQgaWQgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IGZvcm0gPSB1bmRlZmluZWQgLy8gU3BlY2lmaWVzIHRoZSBmb3JtIHRoZSA8aW5wdXQ+IGVsZW1lbnQgYmVsb25ncyB0b1xuICAgIGV4cG9ydCBsZXQgdmFsdWUgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IGxhYmVsID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCBhbGlnbiA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgb3B0aW9ucyA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgaW52YWxpZCA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgZGlzYWJsZWQgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IHJlcXVpcmVkID0gdW5kZWZpbmVkIC8vIHVuZGVmaW5lZHxyZXF1aXJlZFxuICAgIGV4cG9ydCBsZXQgZXJyb3JzID0gdW5kZWZpbmVkXG5cbiAgICAkOiBpZFByb3AgPSBpZCB8fCBuYW1lXG4gICAgJDogZXJyb3IgPSBpbnZhbGlkIHx8ICEhKGVycm9ycyB8fCBbXSkubGVuZ3RoXG4gICAgJDogc3R5bGVQcm9wID0gdG9DU1NTdHJpbmcoeyAuLi5zdHlsZSwgdGV4dEFsaWduOiBhbGlnbiB9KVxuICAgICQ6IGNsYXNzUHJvcCA9IGNsYXNzbmFtZXMoJ3JhZGlvLXJlY3QnLCAkJHByb3BzLmNsYXNzLCB7IGRpc2FibGVkLCByZXF1aXJlZCwgZXJyb3IgfSlcblxuICAgIGZ1bmN0aW9uIG9uQ2hhbmdlKHZhbCwgZSkge1xuICAgICAgICBkaXNwYXRjaCgnY2hhbmdlJywgeyBlLCBuYW1lLCB2YWx1ZTogdmFsIH0pXG4gICAgfVxuPC9zY3JpcHQ+XG5cbjxkaXYgaWQ9e2lkUHJvcH0gY2xhc3M9e2NsYXNzUHJvcH0gc3R5bGU9e3N0eWxlUHJvcH0+XG4gICAgeyNpZiBsYWJlbH1cbiAgICAgICAgPGgyIGNsYXNzPVwidGV4dC1sZWZ0XCI+XG4gICAgICAgICAgICB7IGxhYmVsIH1cbiAgICAgICAgICAgIDxCciBzaXplPVwiMTBcIi8+XG4gICAgICAgIDwvaDI+XG4gICAgey9pZn1cblxuICAgIDx1bCBzdHlsZT1cIm1hcmdpbjogLTVweFwiIGNsYXNzPVwiZmxleCBmbGV4LXdyYXBcIj5cbiAgICAgICAgeyNlYWNoIG9wdGlvbnMgYXMgcmFkaW8sIGl9XG4gICAgICAgICAgICA8bGkgc3R5bGU9XCJwYWRkaW5nOiA1cHhcIj5cbiAgICAgICAgICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgICAgICAgICAgIGF1dG9cbiAgICAgICAgICAgICAgICAgICAgaHRtbEZvcj17YCR7aWRQcm9wfV8ke2l9YH1cbiAgICAgICAgICAgICAgICAgICAgaXM9e3ZhbHVlID09PSByYWRpby52YWx1ZSA/ICdpbmZvJyA6ICdpbmZvLWJvcmRlcid9XG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICA8aW5wdXQgXG4gICAgICAgICAgICAgICAgICAgICAgICB7Zm9ybX1cbiAgICAgICAgICAgICAgICAgICAgICAgIGhpZGRlblxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT1cImNoZWNrYm94XCIgXG4gICAgICAgICAgICAgICAgICAgICAgICBpZD17YCR7aWRQcm9wfV8ke2l9YH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtyYWRpby52YWx1ZX1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uOmNoYW5nZT17b25DaGFuZ2UuYmluZChudWxsLCByYWRpby52YWx1ZSl9XG4gICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgPHNsb3QgaXRlbT17cmFkaW99IGNoZWNrZWQ9e3ZhbHVlID09PSByYWRpby52YWx1ZX0+XG4gICAgICAgICAgICAgICAgICAgICAgICA8cCBjbGFzcz1cImZsZXggZmxleC1hbGlnbi1jZW50ZXJcIiBzdHlsZT1cInBhZGRpbmc6IDEwcHggMjBweFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsjaWYgcmFkaW8ucHJlSWNvbn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPEljb24gdHlwZT17cmFkaW8ucHJlSWNvbn0gc2l6ZT1cIm1lZGl1bVwiIGlzPXt2YWx1ZSA9PT0gcmFkaW8udmFsdWUgPyAnbGlnaHQnIDogJ2luZm8nfS8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzPjwvcz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7L2lmfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZm9udC13LTUwMCBoMyBmbGV4IGZsZXgtYWxpZ24tY2VudGVyIGZsZXgtanVzdGlmeS1jZW50ZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3JhZGlvLmxhYmVsfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7I2lmIHJhZGlvLnBvc3RJY29ufVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cz48L3M+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxJY29uIHR5cGU9e3JhZGlvLnBvc3RJY29ufSBzaXplPVwibWVkaXVtXCIgaXM9e3ZhbHVlID09PSByYWRpby52YWx1ZSA/ICdsaWdodCcgOiAnaW5mbyd9Lz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7L2lmfVxuICAgICAgICAgICAgICAgICAgICAgICAgPC9wPlxuICAgICAgICAgICAgICAgICAgICA8L3Nsb3Q+XG4gICAgICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgICA8L2xpPlxuICAgICAgICB7L2VhY2h9XG4gICAgPC91bD5cblxuPC9kaXY+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJ3N2ZWx0ZSdcbiAgICBpbXBvcnQgeyBjbGFzc25hbWVzLCB0b0NTU1N0cmluZyB9IGZyb20gJ0B1dGlscydcbiAgICBpbXBvcnQgQnIgZnJvbSAnQGNvbXBvbmVudHMvQnIuc3ZlbHRlJ1xuICAgIGltcG9ydCBJY29uIGZyb20gJ0Bjb21wb25lbnRzL0ljb24uc3ZlbHRlJ1xuICAgIGltcG9ydCBTcXVhcmUgZnJvbSAnQGNvbXBvbmVudHMvU3F1YXJlLnN2ZWx0ZSdcbiAgICBpbXBvcnQgUGljdHVyZSBmcm9tICdAY29tcG9uZW50cy9QaWN0dXJlLnN2ZWx0ZSdcblxuICAgIGNvbnN0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKClcblxuICAgIGV4cG9ydCBsZXQgaWQgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IHNyYyA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgbmFtZSA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgaWNvbiA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgbGFiZWwgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IHZhbHVlID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCByb3VuZCA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgc3R5bGUgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IGljb25JcyA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgZXJyb3JzID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCBpbnZhbGlkID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCBtdWx0aXBsZSA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgZGlzYWJsZWQgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IGFjY2VwdCA9IFwiaW1hZ2UvcG5nLCBpbWFnZS9qcGVnXCJcblxuICAgIGxldCB2YWxpZFNyY1xuXG4gICAgJDogZXJyb3IgPSBpbnZhbGlkICE9PSB1bmRlZmluZWQgPyBpbnZhbGlkIDogISEoZXJyb3JzIHx8IFtdKS5sZW5ndGhcbiAgICAkOiBpY29uVHlwZSA9IGljb24gfHwgJ3VwbG9hZCdcbiAgICAkOiBpZFByb3AgPSBpZCB8fCBuYW1lXG4gICAgJDogc2V0VmFsaWRTcmMoc3JjKVxuICAgICQ6IGNsYXNzUHJvcCA9IGNsYXNzbmFtZXMoJ2lucC11cGxvYWQnLCB7IGVycm9yLCBkaXNhYmxlZCwgcHJldmlldzogc3JjIH0pXG4gICAgJDogc3R5bGVQcm9wID0gdG9DU1NTdHJpbmcoeyAuLi5zdHlsZSwgYm9yZGVyUmFkaXVzOiByb3VuZCA/ICc1MCUnIDogbnVsbCB9KVxuXG4gICAgZnVuY3Rpb24gc2V0VmFsaWRTcmMoZmlsZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmaWxlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHZhbGlkU3JjID0gZmlsZVxuICAgICAgICAgICAgfSBlbHNlIGlmIChmaWxlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZiA9IEFycmF5LmlzQXJyYXkoZmlsZSkgPyBmaWxlWzBdIDogZmlsZVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgICAgICAgICAgcmVhZGVyLm9ubG9hZCA9IGUgPT4gdmFsaWRTcmMgPSBlLnRhcmdldC5yZXN1bHRcbiAgICAgICAgICAgICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChmKTsgLy8gY29udmVydCB0byBiYXNlNjQgc3RyaW5nXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFmaWxlKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRTcmMgPSB1bmRlZmluZWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdVcGxvYWRCb3gvZ2V0VmFsaWRTcmMgZXJyb3I6ICcsIGVycilcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBmdW5jdGlvbiBvbkNoYW5nZShlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gQXJyYXkuZnJvbShlLnRhcmdldC5maWxlcylcbiAgICAgICAgaWYgKCF2YWx1ZSB8fCAhdmFsdWUubGVuZ3RoKSByZXR1cm5cbiAgICAgICAgZGlzcGF0Y2goJ2NoYW5nZScsIHsgdmFsdWUsIG5hbWUsIGUgfSlcbiAgICB9XG48L3NjcmlwdD5cblxueyNpZiBsYWJlbH1cbiAgICA8aDIgY2xhc3M9XCJ0ZXh0LWxlZnRcIj57bGFiZWx9PC9oMj5cbiAgICA8QnIgc2l6ZT1cIjEwXCIvPlxuey9pZn1cbjxTcXVhcmUgY2xhc3M9eyQkcHJvcHMuY2xhc3N9IHN0eWxlPXtzdHlsZVByb3B9PlxuICAgIDxpbnB1dFxuICAgICAgICB7bmFtZX1cbiAgICAgICAge2FjY2VwdH1cbiAgICAgICAge211bHRpcGxlfVxuICAgICAgICBoaWRkZW4gXG4gICAgICAgIHR5cGU9XCJmaWxlXCIgXG4gICAgICAgIGlkPXtpZFByb3B9XG4gICAgICAgIGJpbmQ6dmFsdWVcbiAgICAgICAgb246Y2hhbmdlPXtvbkNoYW5nZX1cbiAgICA+XG4gICAgPGxhYmVsIGZvcj17aWRQcm9wfSBjbGFzcz17Y2xhc3NQcm9wfT5cbiAgICAgICAgPGRpdiBjbGFzcz1cImZsZXggZnVsbC1hYnNvbHV0ZVwiPlxuICAgICAgICAgICAgPFBpY3R1cmUgc3JjPXt2YWxpZFNyY30gYWx0PVwi0JfQsNCy0LDQvdGC0LDQttC10L3QtSDRhNC+0YLQvlwiLz4gXG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwiaWNvbiBmbGV4IHJlbGF0aXZlXCIgc3R5bGU9XCJmbGV4OiAwIDAgNzVweFwiPlxuICAgICAgICAgICAgPEljb24gdHlwZT17aWNvblR5cGV9IGlzPXtpY29uSXN9Lz5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9sYWJlbD5cbjwvU3F1YXJlPlxuXG48c3R5bGU+XG4gICAgLmlucC11cGxvYWQge1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgZmxleC1ncm93OiAxO1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgYWxpZ24tc2VsZjogc3RyZXRjaDtcbiAgICAgICAganVzdGlmeS1zZWxmOiBzdHJldGNoO1xuICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICBib3JkZXItcmFkaXVzOiB2YXIoLS1ib3JkZXItcmFkaXVzLW1lZGl1bSk7XG4gICAgICAgIGNvbG9yOiByZ2JhKHZhcigtLXRoZW1lLWNvbG9yLXByaW1hcnktb3Bwb3NpdGUpLCAuNSk7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEodmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeS1vcHBvc2l0ZSksIC4wNyk7XG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWigwKTtcbiAgICB9XG5cbiAgICAuaW5wLXVwbG9hZC5wcmV2aWV3IC5pY29uIHtcbiAgICAgICAgb3BhY2l0eTogLjU7XG4gICAgfVxuXG4gICAgLmlucC11cGxvYWQgLmljb24ge1xuICAgICAgICBvcGFjaXR5OiAuNztcbiAgICB9XG5cbiAgICAuaW5wLXVwbG9hZC5kaXNhYmxlZCB7XG4gICAgICAgIG9wYWNpdHk6IC41O1xuICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICB9XG5cbiAgICAuaW5wLXVwbG9hZC5lcnJvcixcbiAgICBpbnB1dDppbnZhbGlkICsgLmlucC11cGxvYWQge1xuICAgICAgICBjb2xvcjogcmdiYSh2YXIoLS1jb2xvci1kYW5nZXIpLCAuNSk7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEodmFyKC0tY29sb3ItZGFuZ2VyKSwgLjA3KTtcbiAgICB9XG5cbiAgICBpbnB1dDpmb2N1cyArIC5pbnAtdXBsb2FkIHtcbiAgICAgICAgY29sb3I6IHJnYmEodmFyKC0tY29sb3ItaW5mbyksIC41KTtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSh2YXIoLS1jb2xvci1pbmZvKSwgLjA3KTtcbiAgICB9XG48L3N0eWxlPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBjcmVhdGVFdmVudERpc3BhdGNoZXIgfSBmcm9tICdzdmVsdGUnXG4gICAgaW1wb3J0IHsgXywgY2xhc3NuYW1lcyB9IGZyb20gJ0B1dGlscydcbiAgICBpbXBvcnQgQnIgZnJvbSAnQGNvbXBvbmVudHMvQnIuc3ZlbHRlJ1xuICAgIGltcG9ydCBJY29uIGZyb20gJ0Bjb21wb25lbnRzL0ljb24uc3ZlbHRlJ1xuICAgIGltcG9ydCBVcGxvYWRCb3ggZnJvbSAnLi9VcGxvYWRCb3guc3ZlbHRlJ1xuXG4gICAgY29uc3QgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXIoKVxuXG4gICAgZXhwb3J0IGxldCBuYW1lXG4gICAgZXhwb3J0IGxldCBpZCA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgbGFiZWwgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IHZhbHVlID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCBhY2NlcHQgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IGVycm9ycyA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgaW52YWxpZCA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgbXVsdGlwbGUgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IGRpc2FibGVkID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCBpbmZvSW5kZXggPSBbMF1cblxuICAgIGNvbnN0IEJPWF9BTU9VTlQgPSA0XG5cbiAgICAkOiB2YWx1ZXMgPSB2YWx1ZSB8fCBbXVxuICAgICQ6IGVycm9yID0gaW52YWxpZCAhPT0gdW5kZWZpbmVkID8gaW52YWxpZCA6ICEhKGVycm9ycyB8fCBbXSkubGVuZ3RoXG4gICAgJDogaWRQcm9wID0gaWQgfHwgbmFtZVxuICAgICQ6IGl0ZW1zTGlzdCA9IGdldENlbGxzKHZhbHVlcylcbiAgICAkOiBjbGFzc1Byb3AgPSBjbGFzc25hbWVzKCdpbnAtdXBsb2FkLWdyb3VwJywgJCRwcm9wcy5jbGFzcywgeyBlcnJvciwgZGlzYWJsZWQgfSlcblxuICAgIGZ1bmN0aW9uIGdldENlbGxzKGxpc3QpIHtcbiAgICAgICAgY29uc3QgZGVmYXVsdExpc3QgPSBuZXcgQXJyYXkoQk9YX0FNT1VOVCAtIDEpLmZpbGwodW5kZWZpbmVkKVxuICAgICAgICBjb25zdCBsaXN0QXJyID0gW10uY29uY2F0KGxpc3QgfHwgW10pXG4gICAgICAgIGNvbnN0IGJpZ2dlckxpc3QgPSBsaXN0QXJyLmxlbmd0aCA+IGRlZmF1bHRMaXN0Lmxlbmd0aCA/IGxpc3RBcnIgOiBkZWZhdWx0TGlzdFxuICAgICAgICBiaWdnZXJMaXN0LnB1c2godW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gYmlnZ2VyTGlzdC5tYXAoKChfLCBpKSA9PiBsaXN0QXJyW2ldIHx8IGRlZmF1bHRMaXN0W2ldKSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkNoYW5nZShpLCB7IGRldGFpbDogeyBlLCB2YWx1ZSB9IH0pIHtcbiAgICAgICAgY29uc3QgdmFsID0gWy4uLnZhbHVlc11cbiAgICAgICAgdmFsLnNwbGljZShpLCAwLCAuLi52YWx1ZSlcbiAgICAgICAgdmFsdWVzID0gdmFsXG4gICAgICAgIGRpc3BhdGNoKCdjaGFuZ2UnLCB7IGUsIG5hbWUsIHZhbHVlOiB2YWx1ZXMgfSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvblJlbW92ZShpLCBlKSB7XG4gICAgICAgIHZhbHVlcyA9IFsuLi52YWx1ZXMuZmlsdGVyKChfLCBpbmQpID0+IGluZCAhPT0gaSldXG4gICAgICAgIGRpc3BhdGNoKCdjaGFuZ2UnLCB7IGUsIG5hbWUsIHZhbHVlOiB2YWx1ZXMgfSlcbiAgICB9XG48L3NjcmlwdD5cblxueyNpZiBsYWJlbH1cbiAgICA8aDIgY2xhc3M9XCJ0ZXh0LWxlZnRcIj57bGFiZWx9PC9oMj5cbiAgICA8QnIgc2l6ZT1cIjEwXCIvPlxuey9pZn1cbjx1bCBpZD17aWRQcm9wfSBjbGFzcz17Y2xhc3NQcm9wfT5cbiAgICB7I2VhY2ggaXRlbXNMaXN0IGFzIGl0ZW0sIGl9XG4gICAgICAgIDxsaSBjbGFzcz1cInJlbGF0aXZlXCI+XG4gICAgICAgICAgICA8VXBsb2FkQm94XG4gICAgICAgICAgICAgICAga2V5PXtpfVxuICAgICAgICAgICAgICAgIHthY2NlcHR9XG4gICAgICAgICAgICAgICAge2ludmFsaWR9XG4gICAgICAgICAgICAgICAge2Rpc2FibGVkfVxuICAgICAgICAgICAgICAgIHttdWx0aXBsZX1cbiAgICAgICAgICAgICAgICBuYW1lPXtgJHtuYW1lIHx8ICcnfVske2l9XWB9XG4gICAgICAgICAgICAgICAgc3JjPXsodmFsdWVzW2ldIHx8IHt9KS5zcmMgfHwgdmFsdWVzW2ldfVxuICAgICAgICAgICAgICAgIGVycm9ycz17Xy5nZXQoZXJyb3JzLCBpKX1cbiAgICAgICAgICAgICAgICBzdHlsZT17eyBtYXhIZWlnaHQ6ICcxNjBweCcgfX1cbiAgICAgICAgICAgICAgICBpY29uSXM9e2luZm9JbmRleC5pbmNsdWRlcyhpKSA/ICdpbmZvJyA6IHVuZGVmaW5lZH1cbiAgICAgICAgICAgICAgICBvbjpjaGFuZ2U9e29uQ2hhbmdlLmJpbmQobnVsbCwgaSl9XG4gICAgICAgICAgICAvPlxuXG4gICAgICAgICAgICB7I2lmIHZhbHVlc1tpXX1cbiAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBvbjpjbGljaz17b25SZW1vdmUuYmluZChudWxsLCBpKX0+XG4gICAgICAgICAgICAgICAgICAgIDxJY29uIHNpemU9XCJiaWdcIiB0eXBlPVwiY2xvc2VcIi8+ICAgIFxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgey9pZn1cbiAgICAgICAgPC9saT5cbiAgICB7L2VhY2h9XG48L3VsPlxuXG48c3R5bGU+XG4gICAgdWwge1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgZGlzcGxheTogZ3JpZDtcbiAgICAgICAgZ3JpZC10ZW1wbGF0ZTogYXV0byAvIC41ZnIgLjVmcjtcbiAgICAgICAgZ3JpZC1nYXA6IHZhcigtLXNjcmVlbi1wYWRkaW5nKTtcbiAgICB9XG5cbiAgICB1bC5kaXNhYmxlZCB7XG4gICAgICAgIG9wYWNpdHk6IC41O1xuICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICB9XG5cbiAgICBidXR0b24ge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogMDtcbiAgICAgICAgcmlnaHQ6IDA7XG4gICAgICAgIGZvbnQtc2l6ZTogMjRweDtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgIHdpZHRoOiA0MHB4O1xuICAgICAgICBoZWlnaHQ6IDQwcHg7XG4gICAgfVxuPC9zdHlsZT5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgY3JlYXRlRXZlbnREaXNwYXRjaGVyIH0gZnJvbSAnc3ZlbHRlJ1xuICAgIGltcG9ydCB7IGNsYXNzbmFtZXMsIHRvQ1NTU3RyaW5nIH0gZnJvbSAnQHV0aWxzJ1xuICAgIGltcG9ydCB7IFVwbG9hZEJveCB9IGZyb20gJy4vdXBsb2FkRmlsZXMnXG4gICAgaW1wb3J0IEJyIGZyb20gJ0Bjb21wb25lbnRzL0JyLnN2ZWx0ZSdcbiAgICBpbXBvcnQgRmllbGRFcnJvcnMgZnJvbSAnQGNvbXBvbmVudHMvRmllbGRFcnJvcnMuc3ZlbHRlJ1xuXG4gICAgY29uc3QgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXIoKVxuXG4gICAgZXhwb3J0IGxldCBuYW1lXG4gICAgZXhwb3J0IGxldCBzdHlsZSA9IHt9XG4gICAgZXhwb3J0IGxldCByb3VuZCA9IHRydWVcbiAgICBleHBvcnQgbGV0IGlkID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCB2YWx1ZSA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgbGFiZWwgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IGFsaWduID0gJ2NlbnRlcidcbiAgICBleHBvcnQgbGV0IGludmFsaWQgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IGRpc2FibGVkID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCByZXF1aXJlZCA9IHVuZGVmaW5lZCAvLyB1bmRlZmluZWR8cmVxdWlyZWRcbiAgICBleHBvcnQgbGV0IGVycm9ycyA9IHVuZGVmaW5lZFxuXG4gICAgJDogZXJyb3IgPSBpbnZhbGlkIHx8ICEhKGVycm9ycyB8fCBbXSkubGVuZ3RoXG4gICAgJDogc3R5bGVQcm9wID0geyB3aWR0aDogJzE0NXB4JywgLi4uc3R5bGUgfVxuICAgICQ6IGNsYXNzUHJvcCA9IGNsYXNzbmFtZXMoJ2F2YXRhci11cGxvYWQnLCAkJHByb3BzLmNsYXNzLCBgdGV4dC0ke2FsaWdufWAseyBkaXNhYmxlZCwgcmVxdWlyZWQsIGVycm9yIH0pXG5cbiAgICBmdW5jdGlvbiBvbkNoYW5nZSh7IGRldGFpbCB9KSB7XG4gICAgICAgIGRpc3BhdGNoKCdjaGFuZ2UnLCBkZXRhaWwpXG4gICAgfVxuPC9zY3JpcHQ+XG5cbjxkaXYge2lkfSBjbGFzcz17Y2xhc3NQcm9wfT5cbiAgICB7I2lmIGxhYmVsfVxuICAgICAgICA8aDIgY2xhc3M9XCJ0ZXh0LWxlZnRcIj5cbiAgICAgICAgICAgIHsgbGFiZWwgfVxuICAgICAgICAgICAgPEJyIHNpemU9XCIxMFwiLz5cbiAgICAgICAgPC9oMj5cbiAgICB7L2lmfVxuXG4gICAgPHNlY3Rpb24gY2xhc3M9XCJpbmxpbmUtZmxleCBmbGV4LWp1c3RpZnktY2VudGVyXCIgc3R5bGU9XCJwYWRkaW5nOiAxMHB4IDBcIj5cbiAgICAgICAgPFVwbG9hZEJveCBcbiAgICAgICAgICAgIHtuYW1lfVxuICAgICAgICAgICAge3JvdW5kfVxuICAgICAgICAgICAgc3JjPXt2YWx1ZX1cbiAgICAgICAgICAgIHN0eWxlPXtzdHlsZVByb3B9XG4gICAgICAgICAgICBvbjpjaGFuZ2U9e29uQ2hhbmdlfSBcbiAgICAgICAgLz4gIFxuICAgIDwvc2VjdGlvbj5cblxuICAgIDxkaXYgY2xhc3M9XCJ0ZXh0LWNlbnRlclwiPlxuICAgICAgICA8RmllbGRFcnJvcnMgaXRlbXM9e2Vycm9yc30vPlxuICAgIDwvZGl2PlxuPC9kaXY+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJ3N2ZWx0ZSdcbiAgICBpbXBvcnQgeyBjbGFzc25hbWVzLCB0b0NTU1N0cmluZyB9IGZyb20gJ0B1dGlscydcbiAgICBpbXBvcnQgQnIgZnJvbSAnQGNvbXBvbmVudHMvQnIuc3ZlbHRlJ1xuICAgIGltcG9ydCBJY29uIGZyb20gJ0Bjb21wb25lbnRzL0ljb24uc3ZlbHRlJ1xuICAgIGltcG9ydCBGaWVsZEVycm9ycyBmcm9tICdAY29tcG9uZW50cy9GaWVsZEVycm9ycy5zdmVsdGUnXG5cbiAgICBjb25zdCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpXG5cbiAgICBleHBvcnQgbGV0IG5hbWVcbiAgICBleHBvcnQgbGV0IHN0eWxlID0ge31cbiAgICBleHBvcnQgbGV0IGNoZWNrZWQgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IHZhbHVlID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCBpZCA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgYWxpZ24gPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IGRpc2FibGVkID0gZmFsc2VcbiAgICBleHBvcnQgbGV0IGxhYmVsID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCB0ZXh0ID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCBpbnZhbGlkID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCBmb3JtID0gdW5kZWZpbmVkIC8vIFNwZWNpZmllcyB0aGUgZm9ybSB0aGUgPGlucHV0PiBlbGVtZW50IGJlbG9uZ3MgdG9cbiAgICBleHBvcnQgbGV0IHJlcXVpcmVkID0gdW5kZWZpbmVkIC8vIHVuZGVmaW5lZHxyZXF1aXJlZFxuICAgIGV4cG9ydCBsZXQgZXJyb3JzID0gdW5kZWZpbmVkXG5cbiAgICAkOiBpZFByb3AgPSBpZCB8fCBuYW1lIHx8IHZhbHVlXG4gICAgJDogZXJyb3IgPSBpbnZhbGlkIHx8ICEhKGVycm9ycyB8fCBbXSkubGVuZ3RoXG4gICAgJDogc3R5bGVQcm9wID0gdG9DU1NTdHJpbmcoeyAuLi5zdHlsZSwgdGV4dEFsaWduOiBhbGlnbiB9KVxuICAgICQ6IGNsYXNzUHJvcCA9IGNsYXNzbmFtZXMoJ2NoZWNrYm94JywgJCRwcm9wcy5jbGFzcywgeyBkaXNhYmxlZCwgcmVxdWlyZWQsIGVycm9yIH0pXG5cbiAgICBmdW5jdGlvbiBvbkNoYW5nZShlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZ2V0VmFsdWUoZSlcbiAgICAgICAgZGlzcGF0Y2goJ2NoYW5nZScsIHsgZSwgbmFtZSwgdmFsdWUsIGNoZWNrZWQ6IGUudGFyZ2V0LmNoZWNrZWQgfSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRWYWx1ZShlKSB7XG4gICAgICAgIHJldHVybiBlLnRhcmdldC52YWx1ZVxuICAgIH1cbjwvc2NyaXB0PlxuXG48ZGl2IGNsYXNzPXtjbGFzc1Byb3B9PlxuICAgIHsjaWYgbGFiZWx9XG4gICAgICAgIDxoMiBjbGFzcz1cInRleHQtbGVmdFwiPlxuICAgICAgICAgICAgeyBsYWJlbCB9XG4gICAgICAgICAgICA8QnIgc2l6ZT1cIjEwXCIvPlxuICAgICAgICA8L2gyPlxuICAgIHsvaWZ9XG5cbiAgICA8aW5wdXRcbiAgICAgICAgICAgIGhpZGRlblxuICAgICAgICAgICAgdHlwZT1cImNoZWNrYm94XCJcbiAgICAgICAgICAgIGlkPXtpZFByb3B9XG4gICAgICAgICAgICB7bmFtZX1cbiAgICAgICAgICAgIHtmb3JtfVxuICAgICAgICAgICAge2FsaWdufVxuICAgICAgICAgICAge3ZhbHVlfVxuICAgICAgICAgICAge2NoZWNrZWR9XG4gICAgICAgICAgICB7ZGlzYWJsZWR9XG4gICAgICAgICAgICB7cmVxdWlyZWR9XG4gICAgICAgICAgICBjbGFzcz1cImlucC1pbm5lclwiXG4gICAgICAgICAgICBvbjpjaGFuZ2U9e29uQ2hhbmdlfVxuICAgID5cblxuICAgIDxsYWJlbCBmb3I9e2lkUHJvcH0gY2xhc3M9XCJpbnAtbGFiZWxcIj5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJpbnAtYm94LXdyYXBcIj5cbiAgICAgICAgICAgIDxJY29uIHR5cGU9XCJib3hcIiBzaXplPVwiYmlnXCIgaXM9XCJpbmZvXCIgY2xhc3M9XCJ1bmNoZWNrZWRcIi8+XG4gICAgICAgICAgICA8SWNvbiB0eXBlPVwiYm94LWNoZWNrZWRcIiBzaXplPVwiYmlnXCIgaXM9XCJpbmZvXCIgY2xhc3M9XCJjaGVja2VkXCIvPlxuICAgICAgICA8L3NwYW4+XG4gICAgICAgIHsjaWYgdGV4dH1cbiAgICAgICAgICAgIDxzPjwvcz5cbiAgICAgICAgICAgIDxzPjwvcz5cbiAgICAgICAgICAgIDxoMyBjbGFzcz1cImZvbnQtdy01MDAgdGV4dC1sZWZ0XCIgc3R5bGU9XCJwYWRkaW5nLXRvcDogNHB4XCI+eyB0ZXh0IH08L2gzPlxuICAgICAgICB7L2lmfVxuICAgIDwvbGFiZWw+XG5cbiAgICA8RmllbGRFcnJvcnMgaXRlbXM9e2Vycm9yc30+XG4gICAgICAgIDxkaXYgc2xvdD1cImJlZm9yZVwiPlxuICAgICAgICAgICAgPEJyIHNpemU9XCI1XCIvPlxuICAgICAgICA8L2Rpdj5cbiAgICA8L0ZpZWxkRXJyb3JzPlxuPC9kaXY+XG5cbjxzdHlsZT5cbiAgICAuY2hlY2tib3gge1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICB9XG5cbiAgICAuY2hlY2tib3ggaW5wdXQge1xuICAgICAgICBhcHBlYXJhbmNlOiBjaGVja2JveDtcbiAgICB9XG5cbiAgICAuY2hlY2tib3ggLmlucC1ib3gtd3JhcCB7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgZGlzcGxheTogaW5saW5lLWZsZXg7XG4gICAgfVxuICAgIC5jaGVja2JveCAuaW5wLWlubmVyOmNoZWNrZWQgKyAuaW5wLWxhYmVsIDpnbG9iYWwoLmNoZWNrZWQpIHtcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgfVxuXG4gICAgLmNoZWNrYm94IC5pbnAtbGFiZWwge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBhbGlnbi1pdGVtczogZmxleC1zdGFydDtcbiAgICB9XG5cbiAgICAuY2hlY2tib3ggLmlucC1sYWJlbCA6Z2xvYmFsKC5jaGVja2VkKSB7XG4gICAgICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgdG9wOiAwO1xuICAgICAgICBsZWZ0OiAwO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgIH1cbjwvc3R5bGU+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJ3N2ZWx0ZSdcbiAgICBpbXBvcnQgeyBjbGFzc25hbWVzLCB0b0NTU1N0cmluZywgXyB9IGZyb20gJ0B1dGlscydcbiAgICBpbXBvcnQgQnIgZnJvbSAnQGNvbXBvbmVudHMvQnIuc3ZlbHRlJ1xuICAgIGltcG9ydCBDaGVja2JveCBmcm9tICcuL0NoZWNrYm94LnN2ZWx0ZSdcblxuICAgIGNvbnN0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKClcblxuICAgIGV4cG9ydCBsZXQgbmFtZVxuICAgIGV4cG9ydCBsZXQgdmFsdWUgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IHN0eWxlID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCBpZCA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgYWxpZ24gPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IGRpc2FibGVkID0gZmFsc2VcbiAgICBleHBvcnQgbGV0IGxhYmVsID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCBvcHRpb25zID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCBlcnJvcnMgPSB7fVxuXG4gICAgJDogc3R5bGVQcm9wID0gdG9DU1NTdHJpbmcoeyAuLi5zdHlsZSwgdGV4dEFsaWduOiBhbGlnbiB9KVxuICAgICQ6IGNsYXNzUHJvcCA9IGNsYXNzbmFtZXMoJ2NoZWNrYm94LWdyb3VwJywgJCRwcm9wcy5jbGFzcywgeyBkaXNhYmxlZCwgZXJyb3I6ICFfLmlzRW1wdHkoZXJyb3JzKSB9KVxuXG4gICAgY29uc3Qgb25DaGFuZ2UgPSAoeyBkZXRhaWw6IHsgZSwgbmFtZTogY3Vyck5hbWUsIHZhbHVlOiBjdXJyVmFsdWUsIGNoZWNrZWQgfSB9KSA9PiB7XG4gICAgICAgIGxldCBuZXdWYWx1ZSA9IF8uY2xvbmVEZWVwKHZhbHVlKVxuXG4gICAgICAgIGlmICghY3Vyck5hbWUgJiYgY3VyclZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobmV3VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBbXVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoZWNrZWQgJiYgIW5ld1ZhbHVlLmluY2x1ZGVzKGN1cnJWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IFsuLi5uZXdWYWx1ZSwgY3VyclZhbHVlXVxuICAgICAgICAgICAgfSBlbHNlIGlmICghY2hlY2tlZCAmJiBuZXdWYWx1ZS5pbmNsdWRlcyhjdXJyVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSB2YWx1ZS5maWx0ZXIodiA9PiB2ICE9PSBjdXJyVmFsdWUpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoY3Vyck5hbWUpIHtcbiAgICAgICAgICAgIGlmICghbmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IHt9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdWYWx1ZVtjdXJyTmFtZV0gPSBjdXJyVmFsdWUgfHwgY2hlY2tlZFxuICAgICAgICB9XG5cbiAgICAgICAgZGlzcGF0Y2goJ2NoYW5nZScsIHsgZSwgbmFtZSwgdmFsdWU6IG5ld1ZhbHVlIH0pXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Q2hlY2tlZChjdXJyTmFtZSwgY3VyclZhbHVlKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmluY2x1ZGVzKGN1cnJWYWx1ZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAhIXZhbHVlICYmIHZhbHVlW2N1cnJOYW1lXVxuICAgICAgICB9XG4gICAgfVxuPC9zY3JpcHQ+XG5cbjxkaXYge2lkfSBjbGFzcz17Y2xhc3NQcm9wfSBzdHlsZVByb3A9e3N0eWxlUHJvcH0+XG4gICAgeyNpZiBsYWJlbH1cbiAgICAgICAgPGgyIGNsYXNzPVwidGV4dC1sZWZ0XCI+XG4gICAgICAgICAgICB7IGxhYmVsIH1cbiAgICAgICAgICAgIDxCciBzaXplPVwiMTBcIi8+XG4gICAgICAgIDwvaDI+XG4gICAgey9pZn1cblxuICAgIHsjZWFjaCBvcHRpb25zIGFzIGNoZWNrYm94LCBpfVxuICAgICAgICB7I2lmIGl9XG4gICAgICAgICAgICA8QnIgc2l6ZT1cIjE1XCIvPlxuICAgICAgICB7L2lmfVxuICAgICAgICA8Q2hlY2tib3ggXG4gICAgICAgICAgICB7Li4uY2hlY2tib3h9XG4gICAgICAgICAgICBlcnJvcnM9e2Vycm9yc1tjaGVja2JveC5uYW1lXX1cbiAgICAgICAgICAgIGNoZWNrZWQ9e3ZhbHVlICYmIGdldENoZWNrZWQoY2hlY2tib3gubmFtZSwgY2hlY2tib3gudmFsdWUpfVxuICAgICAgICAgICAgb246Y2hhbmdlPXtvbkNoYW5nZX1cbiAgICAgICAgLz5cbiAgICB7L2VhY2h9XG48L2Rpdj5cblxuPHN0eWxlPlxuXG48L3N0eWxlPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBjcmVhdGVFdmVudERpc3BhdGNoZXIgfSBmcm9tICdzdmVsdGUnXG4gICAgaW1wb3J0IHsgQVBJIH0gZnJvbSAnQHNlcnZpY2VzJ1xuICAgIGltcG9ydCB7IGNsYXNzbmFtZXMsIF8gfSBmcm9tICdAdXRpbHMnXG4gICAgaW1wb3J0IEJyIGZyb20gJ0Bjb21wb25lbnRzL0JyLnN2ZWx0ZSdcbiAgICBpbXBvcnQgRm9ybSBmcm9tICdAY29tcG9uZW50cy9Gb3JtLnN2ZWx0ZSdcbiAgICBpbXBvcnQgTG9hZGVyIGZyb20gJ0Bjb21wb25lbnRzL2xvYWRlcidcbiAgICBpbXBvcnQgeyBcbiAgICAgICAgSW5wdXQsXG4gICAgICAgIFNlbGVjdCxcbiAgICAgICAgUmVhZEZpZWxkLFxuICAgICAgICBVcGxvYWRCb3gsXG4gICAgICAgIFJhZGlvUmVjdCxcbiAgICAgICAgQXZhdGFyVXBsb2FkLFxuICAgICAgICBDaGVja2JveEdyb3VwLFxuICAgICAgICBVcGxvYWRCb3hHcm91cCxcbiAgICB9IGZyb20gJ0Bjb21wb25lbnRzL2ZpZWxkcydcblxuICAgIGNvbnN0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKClcblxuICAgIGV4cG9ydCBsZXQgaWQgPSB1bmRlZmluZWRcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7e1xuICAgICAqICAgIG5hbWU6IHN0cmluZyxcbiAgICAgKiAgICB0eXBlOiBzdHJpbmcsICgnZmlsZXMnLCAncmFkaW8tcmVjdCcgYW5kIHR5cGVzIG9mIG5hdGl2ZSBpbnB1dDogaHR0cHM6Ly93d3cudzNzY2hvb2xzLmNvbS90YWdzL2F0dF9pbnB1dF90eXBlLmFzcClcbiAgICAgKiAgICBsYWJlbDogc3RyaW5nLFxuICAgICAqICAgIG1ldGE6IHtcbiAgICAgKiAgICAgICAgcmVxdWlyZWQ6IGJvb2xlYW4sXG4gICAgICogICAgICAgIGRpc2FibGVkOiBib29sZWFuLFxuICAgICAqICAgICAgICAuLi5yZXN0IHRoYXQgY2FuIGJlIGFwcGxpZWQgdG8gYSBmaWVsZC5cbiAgICAgKiAgICB9XG4gICAgICogfVtdfVxuICAgICAqL1xuICAgIGV4cG9ydCBsZXQgaXRlbXMgPSBbXVxuICAgIGV4cG9ydCBsZXQgZGF0YSA9IHt9XG4gICAgZXhwb3J0IGxldCBlcnJvcnMgPSB7fVxuICAgIGV4cG9ydCBsZXQgc3VibWl0ID0gYXN5bmMgKCkgPT4ge31cbiAgICBleHBvcnQgbGV0IGJlZm9yZUNoYW5nZSA9IHZhbHVlcyA9PiB2YWx1ZXNcblxuICAgIGxldCBzdWJtaXR0aW5nID0gZmFsc2VcblxuICAgICQ6IHZhbHVlcyA9IF8uY2xvbmVEZWVwKGRhdGEpXG4gICAgJDogY2xhc3NQcm9wID0gY2xhc3NuYW1lcygnZm9ybS1idWlsZGVyJywgeyBzdWJtaXR0aW5nIH0pXG5cbiAgICBmdW5jdGlvbiBvbkNoYW5nZSh7IGRldGFpbDogeyBlLCBuYW1lLCB2YWx1ZSB9IH0pIHtcbiAgICAgICAgdmFsdWVzID0gYmVmb3JlQ2hhbmdlKF8uc2V0KHZhbHVlcywgbmFtZSwgdmFsdWUpKVxuICAgICAgICBkaXNwYXRjaCgnY2hhbmdlJywgeyBlLCBuYW1lLCB2YWx1ZSwgdmFsdWVzIH0pXG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gb25EZWZhdWx0SW1hZ2VDaGFuZ2UoeyBkZXRhaWw6IHsgZSwgbmFtZSwgdmFsdWU6IHJhd1ZhbHVlIH0gfSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IFtdXG4gICAgICAgIGNvbnN0IGltZ01hcHBlciA9IGltZyA9PiBpbWcgaW5zdGFuY2VvZiBGaWxlID8gQVBJLnVwbG9hZEltYWdlKGltZykuY2F0Y2goKCkgPT4gbnVsbCkgOiBQcm9taXNlLnJlc29sdmUoaW1nKVxuICAgICAgICBjb25zdCBpbWdQcm9taXNlcyA9IHJhd1ZhbHVlLm1hcChpbWdNYXBwZXIpXG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgaW1hZ2Ugb2YgaW1nUHJvbWlzZXMpIGltYWdlICYmIHZhbHVlLnB1c2goaW1hZ2UpXG4gICAgICAgIHZhbHVlcyA9IGJlZm9yZUNoYW5nZShfLnNldCh2YWx1ZXMsIG5hbWUsIHZhbHVlKSlcbiAgICAgICAgZGlzcGF0Y2goJ2NoYW5nZScsIHsgZSwgbmFtZSwgdmFsdWUsIHZhbHVlcywgcmF3VmFsdWUgfSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRPbkNoYW5nZShpdGVtKSB7XG4gICAgICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgICAgICAgY2FzZSBbJ2ZpbGUnLCAnZmlsZXMnLCAnYXZhdGFyJ10uaW5jbHVkZXMoaXRlbS50eXBlKTpcbiAgICAgICAgICAgICAgICByZXR1cm4gb25EZWZhdWx0SW1hZ2VDaGFuZ2VcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9uQ2hhbmdlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRWYWx1ZSh2YWx1ZXMsIG5hbWUpIHtcbiAgICAgIGNvbnN0IHZhbCA9IF8uZ2V0KHZhbHVlcywgbmFtZSlcbiAgICAgIHJldHVybiB2YWwgPT09IHVuZGVmaW5lZCA/ICcnIDogdmFsXG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gb25TdWJtaXQoKSB7XG4gICAgICAgIHN1Ym1pdHRpbmcgPSB0cnVlXG4gICAgICAgIGF3YWl0IHN1Ym1pdCh2YWx1ZXMpLmNhdGNoKChlcnIpID0+IGNvbnNvbGUud2FybignRm9ybUJ1aWxkZXIvc3VibWl0IGVycm9yOiAnLCBlcnIpKVxuICAgICAgICBzdWJtaXR0aW5nID0gZmFsc2VcbiAgICB9XG48L3NjcmlwdD5cblxuPEZvcm0ge2lkfSBvbjpzdWJtaXQ9e29uU3VibWl0fSBjbGFzcz17Y2xhc3NQcm9wfT5cbiAgICB7I2VhY2ggaXRlbXMgYXMgaXRlbSwgaX1cbiAgICAgICAgeyNpZiBpfVxuICAgICAgICAgICAgPEJyIHNpemU9XCIzMFwiLz5cbiAgICAgICAgey9pZn1cbiAgICAgICAgeyNpZiBbJ3RleHQnLCAnbnVtYmVyJywgJ3RleHRhcmVhJywgJ2VtYWlsJywgJ3Bhc3N3b3JkJywgJ3NlYXJjaCcsICd0ZWwnLCAndXJsJywgJ2RhdGUnLCAnZGF0ZXRpbWUtbG9jYWwnLCAndGltZSddLmluY2x1ZGVzKGl0ZW0udHlwZSl9XG4gICAgICAgICAgICB7I2lmIHZhbHVlc1tpdGVtLm5hbWVdICE9PSBudWxsfVxuICAgICAgICAgICAgICAgIDxJbnB1dFxuICAgICAgICAgICAgICAgICAgICB7Li4uaXRlbS5tZXRhfVxuICAgICAgICAgICAgICAgICAgICBuYW1lPXtpdGVtLm5hbWV9XG4gICAgICAgICAgICAgICAgICAgIHR5cGU9e2l0ZW0udHlwZX1cbiAgICAgICAgICAgICAgICAgICAgbGFiZWw9e2l0ZW0ubGFiZWx9XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlPXtnZXRWYWx1ZSh2YWx1ZXMsIGl0ZW0ubmFtZSl9XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycz17ZXJyb3JzW2l0ZW0ubmFtZV19XG4gICAgICAgICAgICAgICAgICAgIG9uOmlucHV0PXtvbkNoYW5nZX1cbiAgICAgICAgICAgICAgICAgICAgb246Y2hhbmdlPXtnZXRPbkNoYW5nZShpdGVtKX1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgICAgIDxMb2FkZXIgdHlwZT1cImgyXCIgLz5cbiAgICAgICAgICAgICAgICAgICAgPExvYWRlciBoZWlnaHQ9XCI1MFwiLz5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgIHs6ZWxzZSBpZiBbJ2NoZWNrYm94J10uaW5jbHVkZXMoaXRlbS50eXBlKX1cbiAgICAgICAgICAgIDxDaGVja2JveEdyb3VwXG4gICAgICAgICAgICAgICAgICAgIHsuLi5pdGVtLm1ldGF9XG4gICAgICAgICAgICAgICAgICAgIG5hbWU9e2l0ZW0ubmFtZX1cbiAgICAgICAgICAgICAgICAgICAgbGFiZWw9e2l0ZW0ubGFiZWx9XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlPXtnZXRWYWx1ZSh2YWx1ZXMsIGl0ZW0ubmFtZSl9XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycz17ZXJyb3JzW2l0ZW0ubmFtZV19XG4gICAgICAgICAgICAgICAgICAgIG9uOmNoYW5nZT17Z2V0T25DaGFuZ2UoaXRlbSl9XG4gICAgICAgICAgICAvPlxuICAgICAgICB7OmVsc2UgaWYgWydzZWxlY3QnXS5pbmNsdWRlcyhpdGVtLnR5cGUpfVxuICAgICAgICAgICAgeyNpZiB2YWx1ZXNbaXRlbS5uYW1lXSAhPT0gbnVsbH1cbiAgICAgICAgICAgICAgICA8U2VsZWN0XG4gICAgICAgICAgICAgICAgICAgIHsuLi5pdGVtLm1ldGF9XG4gICAgICAgICAgICAgICAgICAgIG5hbWU9e2l0ZW0ubmFtZX1cbiAgICAgICAgICAgICAgICAgICAgdHlwZT17aXRlbS50eXBlfVxuICAgICAgICAgICAgICAgICAgICBsYWJlbD17aXRlbS5sYWJlbH1cbiAgICAgICAgICAgICAgICAgICAgdmFsdWU9e2dldFZhbHVlKHZhbHVlcywgaXRlbS5uYW1lKX1cbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzPXtlcnJvcnNbaXRlbS5uYW1lXX1cbiAgICAgICAgICAgICAgICAgICAgb246Y2hhbmdlPXtnZXRPbkNoYW5nZShpdGVtKX1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgICAgIDxMb2FkZXIgdHlwZT1cImgyXCIgLz5cbiAgICAgICAgICAgICAgICAgICAgPExvYWRlciBoZWlnaHQ9XCI1MFwiLz5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgIHs6ZWxzZSBpZiBbJ2ZpbGUnXS5pbmNsdWRlcyhpdGVtLnR5cGUpfVxuICAgICAgICAgICAgPFVwbG9hZEJveFxuICAgICAgICAgICAgICAgICAgICB7Li4uaXRlbS5tZXRhfVxuICAgICAgICAgICAgICAgICAgICBuYW1lPXtpdGVtLm5hbWV9XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsPXtpdGVtLmxhYmVsfVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZT17Z2V0VmFsdWUodmFsdWVzLCBpdGVtLm5hbWUpfVxuICAgICAgICAgICAgICAgICAgICBlcnJvcnM9e2Vycm9yc1tpdGVtLm5hbWVdfVxuICAgICAgICAgICAgICAgICAgICBvbjpjaGFuZ2U9e2dldE9uQ2hhbmdlKGl0ZW0pfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgezplbHNlIGlmIFsnZmlsZXMnXS5pbmNsdWRlcyhpdGVtLnR5cGUpfVxuICAgICAgICAgICAgPFVwbG9hZEJveEdyb3VwXG4gICAgICAgICAgICAgICAgICAgIHsuLi5pdGVtLm1ldGF9XG4gICAgICAgICAgICAgICAgICAgIG5hbWU9e2l0ZW0ubmFtZX1cbiAgICAgICAgICAgICAgICAgICAgbGFiZWw9e2l0ZW0ubGFiZWx9XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlPXtnZXRWYWx1ZSh2YWx1ZXMsIGl0ZW0ubmFtZSl9XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycz17ZXJyb3JzW2l0ZW0ubmFtZV19XG4gICAgICAgICAgICAgICAgICAgIG9uOmNoYW5nZT17Z2V0T25DaGFuZ2UoaXRlbSl9XG4gICAgICAgICAgICAvPlxuICAgICAgICB7OmVsc2UgaWYgWydhdmF0YXInXS5pbmNsdWRlcyhpdGVtLnR5cGUpfVxuICAgICAgICAgICAgPEF2YXRhclVwbG9hZFxuICAgICAgICAgICAgICAgICAgICB7Li4uaXRlbS5tZXRhfVxuICAgICAgICAgICAgICAgICAgICBuYW1lPXtpdGVtLm5hbWV9XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsPXtpdGVtLmxhYmVsfVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZT17Z2V0VmFsdWUodmFsdWVzLCBpdGVtLm5hbWUpfVxuICAgICAgICAgICAgICAgICAgICBlcnJvcnM9e2Vycm9yc1tpdGVtLm5hbWVdfVxuICAgICAgICAgICAgICAgICAgICBvbjpjaGFuZ2U9e2dldE9uQ2hhbmdlKGl0ZW0pfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgezplbHNlIGlmIFsncmFkaW8tcmVjdCddLmluY2x1ZGVzKGl0ZW0udHlwZSl9XG4gICAgICAgICAgICA8UmFkaW9SZWN0XG4gICAgICAgICAgICAgICAgICAgIHsuLi5pdGVtLm1ldGF9XG4gICAgICAgICAgICAgICAgICAgIG5hbWU9e2l0ZW0ubmFtZX1cbiAgICAgICAgICAgICAgICAgICAgbGFiZWw9e2l0ZW0ubGFiZWx9XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlPXtnZXRWYWx1ZSh2YWx1ZXMsIGl0ZW0ubmFtZSl9XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycz17ZXJyb3JzW2l0ZW0ubmFtZV19XG4gICAgICAgICAgICAgICAgICAgIG9uOmNoYW5nZT17Z2V0T25DaGFuZ2UoaXRlbSl9XG4gICAgICAgICAgICAvPlxuICAgICAgICB7OmVsc2V9XG4gICAgICAgICAgICA8c2xvdCB7aXRlbX0ge3ZhbHVlc30ge2Vycm9yc30ge29uQ2hhbmdlfSB2YWx1ZT17dmFsdWVzW2l0ZW0ubmFtZV19PlxuICAgICAgICAgICAgICAgIHsjaWYgdmFsdWVzW2l0ZW0ubmFtZV0gIT09IG51bGx9XG4gICAgICAgICAgICAgICAgICAgIDxSZWFkRmllbGRcbiAgICAgICAgICAgICAgICAgICAgICAgIHsuLi5pdGVtLm1ldGF9XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbD17aXRlbS5sYWJlbH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtnZXRWYWx1ZSh2YWx1ZXMsIGl0ZW0ubmFtZSl9XG4gICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPExvYWRlciB0eXBlPVwiaDJcIiAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgPExvYWRlciB0eXBlPVwicFwiIC8+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICA8L3Nsb3Q+XG4gICAgICAgIHsvaWZ9XG4gICAgey9lYWNofVxuPC9Gb3JtPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSAnc3ZlbHRlJ1xuICAgIGltcG9ydCB7IFN0b3JhZ2VzIH0gZnJvbSAnQHNlcnZpY2VzJ1xuICAgIGltcG9ydCB7IGNsYXNzbmFtZXMsIHNhZmVHZXQgfSBmcm9tICdAdXRpbHMnXG4gICAgaW1wb3J0IEljb24gZnJvbSAnQGNvbXBvbmVudHMvSWNvbi5zdmVsdGUnXG4gICAgaW1wb3J0IEJ1dHRvbiBmcm9tICdAY29tcG9uZW50cy9CdXR0b24uc3ZlbHRlJ1xuICAgIGltcG9ydCBBdmF0YXIgZnJvbSAnQGNvbXBvbmVudHMvQXZhdGFyLnN2ZWx0ZSdcblxuICAgIGV4cG9ydCBsZXQgc2VnbWVudFxuXG4gICAgbGV0IHZhbHVlID0gJ3VhJ1xuXG4gICAgY29uc3QgZ2FwID0gNTBcbiAgICBsZXQgaXNIZWFkZXJWaXNpYmxlID0gdHJ1ZVxuICAgIGxldCBvblNjcm9sbCA9IG51bGxcbiAgICBsZXQgbGFzdFkgPSAwXG4gICAgJDogY2xhc3NQcm9wID0gY2xhc3NuYW1lcygnY29udGFpbmVyJywgeyBhY3RpdmU6IGlzSGVhZGVyVmlzaWJsZSB9KVxuICAgIG9uTW91bnQoKCkgPT4ge1xuICAgICAgICBvblNjcm9sbCA9ICgpID0+IHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRZID0gd2luZG93LnBhZ2VZT2Zmc2V0O1xuICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uID0gY3VycmVudFkgLSBsYXN0WVxuICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA8IC1nYXAgfHwgY3VycmVudFkgPCA1MCkgeyAvLyB1cCAoNTAgLSBtYXggc2Nyb2xsVG9wIGZvciBkaXNwbGF5aW5nIGhlYWRlcilcbiAgICAgICAgICAgICAgICBpZiAoIWlzSGVhZGVyVmlzaWJsZSkgaXNIZWFkZXJWaXNpYmxlID0gdHJ1ZVxuICAgICAgICAgICAgICAgIGxhc3RZID0gY3VycmVudFkgKyBnYXA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA+IGdhcCkgeyAvLyBkb3duXG4gICAgICAgICAgICAgICAgaWYgKGlzSGVhZGVyVmlzaWJsZSkgaXNIZWFkZXJWaXNpYmxlID0gZmFsc2VcbiAgICAgICAgICAgICAgICBsYXN0WSA9IGN1cnJlbnRZIC0gZ2FwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH0pXG5cbiAgICBsZXQgdGhlbWVOYW1lID0gc2FmZUdldCgoKSA9PiBTdG9yYWdlcy5jb29raWVTdG9yYWdlLmdldCgndGhlbWUnKSB8fCBTdG9yYWdlcy5sb2NhbFN0b3JhZ2UuZ2V0KCd0aGVtZScpKVxuICAgIGZ1bmN0aW9uIGNoYW5nZVRoZW1lKHRoZW1lKSB7XG4gICAgICAgIHRoZW1lTmFtZSA9IHRoZW1lXG4gICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZSgndGhlbWUtZGFyaycpXG4gICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZSgndGhlbWUtbGlnaHQnKVxuICAgICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQodGhlbWUpXG5cbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21haW4nKS5jbGFzc0xpc3QucmVtb3ZlKCd0aGVtZS1kYXJrJylcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21haW4nKS5jbGFzc0xpc3QucmVtb3ZlKCd0aGVtZS1saWdodCcpXG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtYWluJykuY2xhc3NMaXN0LmFkZCh0aGVtZSlcblxuICAgICAgICBTdG9yYWdlcy5jb29raWVTdG9yYWdlLnNldCgndGhlbWUnLCB0aGVtZSlcbiAgICAgICAgU3RvcmFnZXMubG9jYWxTdG9yYWdlLnNldCgndGhlbWUnLCB0aGVtZSlcbiAgICB9XG5cbiAgICBvbk1vdW50KCgpID0+IHtcbiAgICAgICAgY2hhbmdlVGhlbWUodGhlbWVOYW1lKVxuICAgIH0pXG48L3NjcmlwdD5cblxuPHN2ZWx0ZTp3aW5kb3cgb246c2Nyb2xsPXtvblNjcm9sbH0vPlxuPG5hdiBjbGFzcz17Y2xhc3NQcm9wfT5cbiAgICA8dWwgY2xhc3M9XCJuYXYtcGFnZXMgZmxleFwiPlxuICAgICAgICA8bGk+PGEgcmVsPXByZWZldGNoIGhyZWY9Jy4nIGNsYXNzOnNlbGVjdGVkPSd7c2VnbWVudCA9PT0gdW5kZWZpbmVkfSc+aG9tZTwvYT48L2xpPlxuICAgICAgICA8bGk+PGEgcmVsPXByZWZldGNoIGhyZWY9J2xpc3RzL2Z1bmRzJyBjbGFzczpzZWxlY3RlZD0ne3NlZ21lbnQgPT09IFwibGlzdHNcIn0nPmxpc3RzPC9hPjwvbGk+XG4gICAgICAgIDxsaT48YSBocmVmPSdtYXAnIGNsYXNzOnNlbGVjdGVkPSd7c2VnbWVudCA9PT0gXCJtYXBcIn0nPm1hcDwvYT48L2xpPlxuICAgIDwvdWw+XG5cbiAgICA8dWwgY2xhc3M9XCJuYXYtYWN0aW9uc1wiPlxuICAgICAgICA8bGk+XG4gICAgICAgICAgICA8c2VsZWN0IHt2YWx1ZX0gbmFtZT1cImxhbmdcIiBpZD1cImxhbmdcIiBjbGFzcz1cImJ0biBzbWFsbCBsYW5nLXNlbGVjdFwiPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJ1YVwiPlVhPC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJ1XCI+UnU8L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiZW5cIj5Fbjwvb3B0aW9uPlxuICAgICAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgIDwvbGk+XG5cbiAgICAgICAgPGxpPlxuICAgICAgICAgICAgPEJ1dHRvbiBvbjpjbGljaz17KCkgPT4gY2hhbmdlVGhlbWUodGhlbWVOYW1lID09PSAndGhlbWUtbGlnaHQnID8gJ3RoZW1lLWRhcmsnIDogJ3RoZW1lLWxpZ2h0Jyl9IGF1dG8gc2l6ZT1cInNtYWxsXCI+XG4gICAgICAgICAgICAgICAgPEljb24gdHlwZT1cIm1vb25cIiBzaXplPVwibWVkaXVtXCIgY2xhc3M9XCJ0aGVtZS1zdmctZmlsbC1vcHBvc2l0ZVwiIGlzPVwibGlnaHRcIi8+XG4gICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgPC9saT5cblxuICAgICAgICA8bGk+XG4gICAgICAgICAgICA8YSBjbGFzcz1cImJ0biBzbWFsbFwiIGhyZWY9XCJ1c2Vycy9tZVwiPlxuICAgICAgICAgICAgICAgIDxBdmF0YXIgc2l6ZT1cInNtYWxsXCIgc3JjPVwiaHR0cHM6Ly9wbGFjZWltZy5jb20vMzAvMzAvcGVvcGxlXCIgYWx0PVwiYXZhdGFyXCIvPlxuICAgICAgICAgICAgPC9hPlxuICAgICAgICA8L2xpPlxuICAgIDwvdWw+XG48L25hdj5cblxuPHN0eWxlPlxuICAgIG5hdiB7XG4gICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgICAgdG9wOiAwO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgaGVpZ2h0OiB2YXIoLS1oZWFkZXItaGVpZ2h0KTtcbiAgICAgICAgei1pbmRleDogNztcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC0xMDAlKTtcbiAgICAgICAgdHJhbnNpdGlvbjogLjJzIGVhc2UtaW4tb3V0O1xuICAgICAgICBjb2xvcjogcmdiYSh2YXIoLS1jb2xvci1mb250LWxpZ2h0KSk7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgICAgICAgYm94LXNoYWRvdzogdmFyKC0tc2hhZG93LXNlY29uZGFyeSk7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEodmFyKC0tY29sb3ItZGFyay1zZWNvbmQpKTtcbiAgICB9XG5cbiAgICBuYXYuYWN0aXZlIHtcbiAgICAgICAgdHJhbnNmb3JtOiBub25lXG4gICAgfVxuXG4gICAgLnNlbGVjdGVkIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgfVxuXG4gICAgLnNlbGVjdGVkOjphZnRlciB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgY29udGVudDogXCJcIjtcbiAgICAgICAgd2lkdGg6IGNhbGMoMTAwJSAtIDFlbSk7XG4gICAgICAgIGhlaWdodDogMnB4O1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IodmFyKC0tY29sb3ItZGFuZ2VyKSk7XG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICBib3R0b206IC0xcHg7XG4gICAgfVxuXG4gICAgLm5hdi1wYWdlcyBhIHtcbiAgICAgICAgcGFkZGluZzogMC44ZW0gMC41ZW07XG4gICAgfVxuXG4gICAgLm5hdi1hY3Rpb25zIHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgbWFyZ2luOiAtM3B4O1xuICAgIH1cblxuICAgIC5uYXYtYWN0aW9ucyBsaSB7XG4gICAgICAgIHBhZGRpbmc6IDNweDtcbiAgICB9XG5cbiAgICAubmF2LWFjdGlvbnMgYSB7XG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgIH1cblxuICAgIC5sYW5nLXNlbGVjdCB7XG4gICAgICAgIHBhZGRpbmc6IDVweDtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG4gICAgICAgIGNvbG9yOiByZ2JhKHZhcigtLWNvbG9yLWZvbnQtbGlnaHQpKTtcbiAgICB9XG5cbiAgICAubGFuZy1zZWxlY3Q6aG92ZXIsXG4gICAgLmxhbmctc2VsZWN0OmZvY3VzIHtcbiAgICAgICAgYm94LXNoYWRvdzogbm9uZTtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSh2YXIoLS1jb2xvci1ibGFjayksIDAuMSk7XG4gICAgfVxuPC9zdHlsZT5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IEJ1dHRvbiBmcm9tICdAY29tcG9uZW50cy9CdXR0b24uc3ZlbHRlJ1xuPC9zY3JpcHQ+XG5cbjxmb290ZXI+XG4gICAgPHA+wqkge25ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKX08L3A+XG4gICAgPHVsPlxuICAgICAgICA8bGk+XG4gICAgICAgICAgICA8QnV0dG9uIHNpemU9XCJzbWFsbFwiIGlzPVwic3VjY2Vzc1wiPkFjdGlvbjwvQnV0dG9uPlxuICAgICAgICA8L2xpPlxuICAgIDwvdWw+XG48L2Zvb3Rlcj5cblxuPHN0eWxlPlxuICAgIGZvb3RlciB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgICAgICAgcGFkZGluZzogdmFyKC0tc2NyZWVuLXBhZGRpbmcpO1xuICAgICAgICBib3gtc2hhZG93OiBpbnNldCB2YXIoLS1zaGFkb3ctcHJpbWFyeSk7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEodmFyKC0tdGhlbWUtYmctY29sb3IpKTtcbiAgICB9XG5cbiAgICB1bCB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIG1hcmdpbjogLTNweDtcbiAgICB9XG5cbiAgICBsaSB7XG4gICAgICAgIHBhZGRpbmc6IDNweDtcbiAgICB9XG48L3N0eWxlPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgSWNvbiBmcm9tICcuLi9JY29uLnN2ZWx0ZSdcbiAgICBpbXBvcnQgTG9hZGVyIGZyb20gJy4uL2xvYWRlci9Mb2FkZXIuc3ZlbHRlJ1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge3tcbiAgICAgKiAgaHJlZjogc3RyaW5nLFxuICAgICAqICB0aXRsZTogc3RyaW5nLFxuICAgICAqICB0eXBlOiBDb25maWcuSWNvbnMsXG4gICAgICogfVtdfVxuICAgICAqL1xuICAgIGV4cG9ydCBsZXQgaXRlbXNcblxuICAgICQ6IGxpc3QgPSBpdGVtcyA9PT0gbnVsbCA/IFtudWxsLCBudWxsLCBudWxsXSA6IGl0ZW1zIHx8IFtdXG48L3NjcmlwdD5cblxuPHVsIGNsYXNzPVwiZmxleCBmbGV4LWp1c3RpZnktY2VudGVyIHNvY2lhbC1pY29uc1wiPlxuICAgIHsjZWFjaCBsaXN0IGFzIGl0ZW19XG4gICAgICAgIHsjaWYgaXRlbSAhPT0gbnVsbH1cbiAgICAgICAgICAgIDxsaSBjbGFzcz17aXRlbS50eXBlfT5cbiAgICAgICAgICAgICAgICA8c2xvdCB7aXRlbX0+XG4gICAgICAgICAgICAgICAgICAgIHsjaWYgaXRlbS5ocmVmfVxuICAgICAgICAgICAgICAgICAgICAgICAgPGEgaHJlZj17aXRlbS5ocmVmfSB0YXJnZXQ9XCJfYmxhbmtcIiB0aXRsZT17aXRlbS50aXRsZX0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPEljb24gdHlwZT17aXRlbS50eXBlfSBpcz1cImxpZ2h0XCIgc2l6ZT1cIm1lZGl1bVwiLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvYT5cbiAgICAgICAgICAgICAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gb246Y2xpY2s+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPEljb24gdHlwZT17aXRlbS50eXBlfSBpcz1cImxpZ2h0XCIgc2l6ZT1cIm1lZGl1bVwiLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgICAgICA8L3Nsb3Q+XG4gICAgICAgICAgICA8L2xpPlxuICAgICAgICB7OmVsc2V9XG4gICAgICAgICAgICA8bGkgc3R5bGU9XCJwYWRkaW5nOiAwIDEwcHg7IHdpZHRoOiA2MHB4OyBoZWlnaHQ6IDQ1cHg7IG92ZXJmbG93OiBoaWRkZW5cIj5cbiAgICAgICAgICAgICAgICA8TG9hZGVyIHR5cGU9XCJhdmF0YXJcIi8+XG4gICAgICAgICAgICA8L2xpPlxuICAgICAgICB7L2lmfVxuICAgIHsvZWFjaH1cbjwvdWw+XG5cbjxzdHlsZT5cbiAgICAuc29jaWFsLWljb25zIGxpIHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgIHdpZHRoOiA0MHB4O1xuICAgICAgICBoZWlnaHQ6IDQwcHg7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgbWFyZ2luOiAwIDEwcHg7XG4gICAgfVxuXG4gICAgLnNvY2lhbC1pY29ucyAudGVsZWdyYW0ge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMjE5N0QyO1xuICAgIH1cbiAgICAuc29jaWFsLWljb25zIC5mYWNlYm9vayB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICM0MjY3QjI7XG4gICAgfVxuICAgIC5zb2NpYWwtaWNvbnMgLnZpYmVyIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogIzY2NUNBQztcbiAgICB9XG48L3N0eWxlPlxuIiwiXG48c2NyaXB0PlxuICAgIGltcG9ydCBJY29uIGZyb20gJy4uL0ljb24uc3ZlbHRlJ1xuICAgIGltcG9ydCBMb2FkZXIgZnJvbSAnLi4vbG9hZGVyL0xvYWRlci5zdmVsdGUnXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7e1xuICAgICAqICBocmVmOiBzdHJpbmcsXG4gICAgICogIHRpdGxlOiBzdHJpbmcsXG4gICAgICogIHR5cGU6IENvbmZpZy5JY29ucyxcbiAgICAgKiB9W119XG4gICAgICovXG4gICAgZXhwb3J0IGxldCBpdGVtc1xuXG4gICAgJDogbGlzdCA9IGl0ZW1zID09PSBudWxsID8gW251bGwsIG51bGwsIG51bGxdIDogaXRlbXMgfHwgW11cbjwvc2NyaXB0PlxuXG48dWwgY2xhc3M9XCJzb2NpYWwtaWNvbnNcIj5cbiAgICB7I2VhY2ggbGlzdCBhcyBpdGVtfVxuICAgICAgICA8bGk+XG4gICAgICAgICAgICB7I2lmIGl0ZW0gIT09IG51bGx9XG4gICAgICAgICAgICAgICAgPHNsb3Qge2l0ZW19PlxuICAgICAgICAgICAgICAgICAgICB7I2lmIGl0ZW0uaHJlZn1cbiAgICAgICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9e2l0ZW0uaHJlZn0gdGFyZ2V0PVwiX2JsYW5rXCIgY2xhc3M9XCJpbm5lclwiIHRpdGxlPXtpdGVtLnRpdGxlfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImljb24td3JhcFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8SWNvbiB0eXBlPXtpdGVtLnR5cGV9IGlzPVwibGlnaHRcIiBzaXplPVwidGlueVwiLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHM+PC9zPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzPjwvcz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cz48L3M+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHAgY2xhc3M9XCJoM1wiPntpdGVtLnRpdGxlfTwvcD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvYT5cbiAgICAgICAgICAgICAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBvbjpjbGljayBjbGFzcz1cImlubmVyXCIgdGl0bGU9e2l0ZW0udGl0bGV9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaWNvbi13cmFwXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxJY29uIHR5cGU9e2l0ZW0udHlwZX0gaXM9XCJsaWdodFwiIHNpemU9XCJ0aW55XCIvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cz48L3M+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHM+PC9zPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzPjwvcz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cCBjbGFzcz1cImgzXCI+e2l0ZW0udGl0bGV9PC9wPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICAgICAgPC9zbG90PlxuICAgICAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZmxleCBmbGV4LWFsaWduLWNlbnRlclwiIHN0eWxlPVwicGFkZGluZzogN3B4IDBcIj5cbiAgICAgICAgICAgICAgICAgICAgPExvYWRlciB0eXBlPVwiaDNcIi8+XG4gICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgey9pZn1cbiAgICAgICAgPC9saT5cbiAgICB7L2VhY2h9XG48L3VsPlxuXG48c3R5bGU+XG4gICAgLnNvY2lhbC1pY29ucyBsaSB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICAgIG1hcmdpbjogN3B4IDA7XG4gICAgfVxuXG4gICAgLnNvY2lhbC1pY29ucyAuaW5uZXIge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIH1cblxuICAgIC5zb2NpYWwtaWNvbnMgLmljb24td3JhcCB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICB3aWR0aDogMjZweDtcbiAgICAgICAgaGVpZ2h0OiAyNnB4O1xuICAgICAgICBib3JkZXItcmFkaXVzOiA1MCU7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEodmFyKC0tY29sb3ItZGFyaykpO1xuICAgIH1cbjwvc3R5bGU+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IGNsYXNzbmFtZXMgfSBmcm9tICdAdXRpbHMnXG4gICAgaW1wb3J0IENhcmQgZnJvbSAnQGNvbXBvbmVudHMvQ2FyZC5zdmVsdGUnXG4gICAgaW1wb3J0IFBpY3R1cmUgZnJvbSAnQGNvbXBvbmVudHMvUGljdHVyZS5zdmVsdGUnXG4gICAgaW1wb3J0IEZhbmN5Qm94IGZyb20gJ0Bjb21wb25lbnRzL0ZhbmN5Qm94LnN2ZWx0ZSdcbiAgICBpbXBvcnQgQ2Fyb3VzZWwgZnJvbSAnQGNvbXBvbmVudHMvQ2Fyb3VzZWwuc3ZlbHRlJ1xuXG4gICAgZXhwb3J0IGxldCBpdGVtcyA9IG5ldyBBcnJheSg1KS5maWxsKHt9KVxuXG4gICAgbGV0IGFjdGl2ZSA9IGZhbHNlXG48L3NjcmlwdD5cblxuPENhcm91c2VsIGl0ZW1zPXtpdGVtc30gc2l6ZT1cImF1dG9cIiBkb3RzPXtmYWxzZX0gbGV0Oml0ZW09e2l0ZW19IGxldDppbmRleD17aW5kZXh9IGNsYXNzPXtjbGFzc25hbWVzKCdkb2N1bWVudHMnLCB7IGFjdGl2ZSB9KX0+XG4gICAgPGRpdiBjbGFzcz17IWluZGV4ID8gJ3N0YXJ0JyA6IGluZGV4ID09PSBpdGVtcy5sZW5ndGggLSAxID8gJ2VuZCcgOiAnJ30+XG4gICAgICAgIDxGYW5jeUJveCBvbjpvcGVuPXsoKSA9PiBhY3RpdmUgPSB0cnVlfSBvbjpjbG9zZT17KCkgPT4gYWN0aXZlID0gZmFsc2V9PlxuICAgICAgICAgICAgPENhcmQgY2xhc3M9XCJmbGV4XCI+XG4gICAgICAgICAgICAgICAgPFBpY3R1cmUgc3JjPXtpdGVtLnNyY30gYWx0PXtpdGVtLnRpdGxlfSBzaXplPVwiY29udGFpblwiLz5cbiAgICAgICAgICAgIDwvQ2FyZD5cbiAgICAgICAgICAgIDxzZWN0aW9uIHNsb3Q9XCJib3hcIiBjbGFzcz1cImZsZXggZnVsbC1jb250YWluZXJcIj5cbiAgICAgICAgICAgICAgICA8Q2FyZCBjbGFzcz1cImZsZXhcIj5cbiAgICAgICAgICAgICAgICAgICAgPFBpY3R1cmUgc3JjPXtpdGVtLnNyY30gc3JjQmlnPXtpdGVtLnNyYzJ4fSBhbHQ9e2l0ZW0udGl0bGV9IHNpemU9XCJjb250YWluXCIvPlxuICAgICAgICAgICAgICAgIDwvQ2FyZD5cbiAgICAgICAgICAgIDwvc2VjdGlvbj5cbiAgICAgICAgPC9GYW5jeUJveD5cbiAgICA8L2Rpdj5cbjwvQ2Fyb3VzZWw+XG5cbjxzdHlsZT5cbiAgICA6Z2xvYmFsKC5kb2N1bWVudHMuYWN0aXZlIC5zY3JvbGwteC1jZW50ZXIgPiAqKSB7XG4gICAgICAgIHRyYW5zZm9ybTogbm9uZVxuICAgIH1cblxuICAgIHNlY3Rpb24ge1xuICAgICAgICBoZWlnaHQ6IGNhbGMoKDEwMHZ3IC0gdmFyKC0tc2NyZWVuLXBhZGRpbmcpICogMikgKiAxLjQyOCk7XG4gICAgICAgIHBhZGRpbmc6IDAgdmFyKC0tc2NyZWVuLXBhZGRpbmcpO1xuICAgIH1cbiAgICBcbiAgICBkaXYge1xuICAgICAgICBmbGV4OiBub25lO1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBhbGlnbi1zZWxmOiBzdHJldGNoO1xuICAgICAgICBoZWlnaHQ6IDE4MHB4O1xuICAgICAgICB3aWR0aDogMTI2cHg7XG4gICAgICAgIHBhZGRpbmc6IDE1cHggNXB4O1xuICAgICAgICBib3gtc2l6aW5nOiBjb250ZW50LWJveDtcbiAgICB9XG5cbiAgICBkaXYuc3RhcnQge1xuICAgICAgICBwYWRkaW5nLWxlZnQ6IHZhcigtLXNjcmVlbi1wYWRkaW5nKTtcbiAgICB9XG5cbiAgICBkaXYuZW5kIHtcbiAgICAgICAgcGFkZGluZy1yaWdodDogdmFyKC0tc2NyZWVuLXBhZGRpbmcpO1xuICAgIH1cbjwvc3R5bGU+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCBBdmF0YXIgZnJvbSAnLi4vQXZhdGFyLnN2ZWx0ZSdcbiAgICBpbXBvcnQgeyBzYWZlR2V0IH0gZnJvbSAnQHV0aWxzJ1xuXG4gICAgZXhwb3J0IGxldCBpdGVtcyA9IFtdXG4gICAgZXhwb3J0IGxldCBiYXNlUGF0aCA9ICcnXG5cbiAgICAkOiBjb25zb2xlLmxvZyhpdGVtcylcbjwvc2NyaXB0PlxuXG57I2VhY2ggaXRlbXMgYXMgaXRlbX1cbiAgICA8YSBjbGFzcz1cIml0ZW0gY29udGFpbmVyXCIgaHJlZj17YCR7YmFzZVBhdGh9LyR7aXRlbS5pZH1gfT5cbiAgICAgICAgPEF2YXRhciBzcmM9e3NhZmVHZXQoKCkgPT4gaXRlbS5hdmF0YXJzWzBdLnNyYyl9IHNpemU9XCJtZWRpdW1cIiBhbHQ9e2l0ZW0udGl0bGV9Lz5cblxuICAgICAgICA8c3Bhbj5cbiAgICAgICAgICAgIDxoND57aXRlbS50aXRsZSB8fCAnaW5jb2duaXRvJ308L2g0PlxuICAgICAgICAgICAgPHN1Yj57aXRlbS5zdWJ0aXRsZX08L3N1Yj5cbiAgICAgICAgPC9zcGFuPlxuICAgIDwvYT5cbiAgICA8YnI+XG57OmVsc2V9XG4gICAgPHNlY3Rpb24gY2xhc3M9XCJpdGVtIGNvbnRhaW5lclwiPlxuICAgICAgICA8cCBjbGFzcz1cInRleHQtY2VudGVyXCI+Tm8gb3JnYW5pemF0aW9uczwvcD5cbiAgICA8L3NlY3Rpb24+XG57L2VhY2h9XG5cbjxzdHlsZT5cbiAgICAuaXRlbSB7XG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICBmbGV4OiAxIDEgYXV0bztcbiAgICAgICAgcGFkZGluZzogMjBweDtcbiAgICAgICAgYm94LXNoYWRvdzogdmFyKC0tc2hhZG93LXByaW1hcnkpO1xuICAgICAgICBib3JkZXItcmFkaXVzOiB2YXIoLS1ib3JkZXItcmFkaXVzLWJpZyk7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEodmFyKC0tdGhlbWUtYmctY29sb3IpKTtcbiAgICB9XG5cbiAgICBzcGFuIHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICAgIHBhZGRpbmc6IDAgMTVweDtcbiAgICB9XG5cbiAgICBzcGFuIGg0LFxuICAgIHNwYW4gc3ViIHtcbiAgICAgICAgbWF4LXdpZHRoOiAxMDAlO1xuICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICB3aGl0ZS1zcGFjZTogbm93cmFwO1xuICAgICAgICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcbiAgICB9XG48L3N0eWxlPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBjcmVhdGVFdmVudERpc3BhdGNoZXIgfSBmcm9tICdzdmVsdGUnXG4gICAgaW1wb3J0IHsgY2xhc3NuYW1lcywgdG9DU1NTdHJpbmcgfSBmcm9tICdAdXRpbHMnXG4gICAgaW1wb3J0IEJyIGZyb20gJ0Bjb21wb25lbnRzL0JyLnN2ZWx0ZSdcbiAgICBpbXBvcnQgSWNvbiBmcm9tICdAY29tcG9uZW50cy9JY29uLnN2ZWx0ZSdcbiAgICBpbXBvcnQgTW9kYWwgZnJvbSAnQGNvbXBvbmVudHMvTW9kYWwuc3ZlbHRlJ1xuICAgIGltcG9ydCBMb2FkZXIgZnJvbSAnQGNvbXBvbmVudHMvbG9hZGVyJ1xuICAgIGltcG9ydCBCdXR0b24gZnJvbSAnQGNvbXBvbmVudHMvQnV0dG9uLnN2ZWx0ZSdcbiAgICBpbXBvcnQgRm9ybUJ1aWxkZXIgZnJvbSAnQGNvbXBvbmVudHMvRm9ybUJ1aWxkZXIuc3ZlbHRlJ1xuXG4gICAgY29uc3QgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXIoKVxuXG4gICAgZXhwb3J0IGxldCBpZCA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgbmFtZSA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgbGFiZWwgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IHZhbHVlID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCBzdHlsZSA9IHVuZGVmaW5lZFxuICAgIGV4cG9ydCBsZXQgcmVhZG9ubHkgPSB1bmRlZmluZWRcblxuICAgIGxldCBvcGVuID0gZmFsc2VcbiAgICBsZXQgZm9ybUVycm9ycyA9IFtdXG4gICAgbGV0IGZvcm1GaWVsZHMgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxhYmVsOiAn0JTQsNGC0LA6JyxcbiAgICAgICAgICAgIHR5cGU6ICdkYXRlJyxcbiAgICAgICAgICAgIG5hbWU6ICdkYXRlJyxcbiAgICAgICAgICAgIG1ldGE6IHtcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogJzE4LjAzLjIwMTkuLi4nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbGFiZWw6ICfQlNC+0LHQsNCy0YLQtSDQvdCw0LfQstGDINC/0L7QtNGW0Zc6JyxcbiAgICAgICAgICAgIHR5cGU6ICd0ZXh0YXJlYScsXG4gICAgICAgICAgICBuYW1lOiAndGl0bGUnLFxuICAgICAgICAgICAgbWV0YToge1xuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiAn0JfQsNCx0YDQsNC70Lgg0LIg0L/RgNC40YLRg9C70L7Qui4uLicsXG4gICAgICAgICAgICAgICAgcm93czogMyxcbiAgICAgICAgICAgICAgICBtYXhsZW5ndGg6IDc1XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIF1cblxuICAgICQ6IGlkUHJvcCA9IGlkIHx8IG5hbWVcbiAgICAkOiBjbGFzc1Byb3AgPSBjbGFzc25hbWVzKCdzdG9yeS1saXN0JywgJCRwcm9wcy5jbGFzcylcbiAgICAkOiBzdHlsZVByb3AgPSB0b0NTU1N0cmluZyh7IC4uLnN0eWxlIH0pXG5cbiAgICBmdW5jdGlvbiBvblJlbW92ZSh7IGluZGV4IH0sIGUpIHtcbiAgICAgICAgY29uc3QgdmFsID0gWy4uLnZhbHVlLmZpbHRlcigoXywgaW5kKSA9PiBpbmQgIT09IGluZGV4KV1cbiAgICAgICAgZGlzcGF0Y2goJ2NoYW5nZScsIHsgZSwgbmFtZSwgdmFsdWU6IHZhbCB9KVxuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIG9uU3VibWl0KHZhbHVlcywgZSkge1xuICAgICAgICBjb25zdCB2YWwgPSBbLi4udmFsdWUsIHZhbHVlc11cbiAgICAgICAgZGlzcGF0Y2goJ2NoYW5nZScsIHsgZSwgbmFtZSwgdmFsdWU6IHZhbCB9KVxuICAgICAgICBvcGVuID0gZmFsc2VcbiAgICB9XG48L3NjcmlwdD5cblxuPHN0eWxlPlxuICAgIHRhYmxlIHRyOm5vdCg6bGFzdC1jaGlsZCkgdGQge1xuICAgICAgICBwYWRkaW5nLWJvdHRvbTogMTZweDtcbiAgICB9XG5cbiAgICB0YWJsZSB0ZDpsYXN0LWNoaWxkIHtcbiAgICAgICAgZm9udC13ZWlnaHQ6IDMwMDtcbiAgICB9XG48L3N0eWxlPlxuXG48c2VjdGlvbiBjbGFzcz17Y2xhc3NQcm9wfSBzdHlsZT17c3R5bGVQcm9wfT5cbiAgICB7I2lmIGxhYmVsfVxuICAgICAgICA8aDIgY2xhc3M9XCJ0ZXh0LWxlZnRcIj57bGFiZWx9PC9oMj5cbiAgICAgICAgPEJyIHNpemU9XCIxMFwiLz5cbiAgICB7L2lmfVxuXG4gICAgPHRhYmxlPlxuICAgICAgICA8dGJvZHk+XG4gICAgICAgICAgICB7I2lmIHZhbHVlICE9PSBudWxsICYmIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aH1cbiAgICAgICAgICAgICAgICB7I2VhY2ggdmFsdWUuZmlsdGVyKEJvb2xlYW4pIGFzIHZhbCwgaX1cbiAgICAgICAgICAgICAgICAgICAgPHRyPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHRkPnt2YWwuZGF0ZX08L3RkPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHRkPuKAlDwvdGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGQ+e3ZhbC50aXRsZX08L3RkPlxuICAgICAgICAgICAgICAgICAgICAgICAgeyNpZiAhcmVhZG9ubHl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8QnV0dG9uIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0byBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPVwidmVydGljYWwtYWxpZ246IG1pZGRsZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbjpjbGljaz17b25SZW1vdmUuYmluZChudWxsLCB7IGlkOiB2YWwuaWQsIGluZGV4OiBpIH0pfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8SWNvbiB0eXBlPVwiY2xvc2VcIiBzaXplPVwibWVkaXVtXCIvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgICAgICAgICAgPC90cj5cbiAgICAgICAgICAgICAgICB7L2VhY2h9XG4gICAgICAgICAgICB7OmVsc2UgaWYgdmFsdWUgPT09IG51bGx9XG4gICAgICAgICAgICAgICAgPHRyPlxuICAgICAgICAgICAgICAgICAgICA8dGQ+PExvYWRlciB0eXBlPVwicFwiLz48L3RkPlxuICAgICAgICAgICAgICAgICAgICA8dGQ+4oCUPC90ZD5cbiAgICAgICAgICAgICAgICAgICAgPHRkPlxuICAgICAgICAgICAgICAgICAgICAgICAgPExvYWRlciB0eXBlPVwicFwiLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxMb2FkZXIgdHlwZT1cInBcIi8+XG4gICAgICAgICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICAgICAgPC90cj5cbiAgICAgICAgICAgICAgICA8dHI+XG4gICAgICAgICAgICAgICAgICAgIDx0ZD48TG9hZGVyIHR5cGU9XCJwXCIvPjwvdGQ+XG4gICAgICAgICAgICAgICAgICAgIDx0ZD7igJQ8L3RkPlxuICAgICAgICAgICAgICAgICAgICA8dGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICA8TG9hZGVyIHR5cGU9XCJwXCIvPlxuICAgICAgICAgICAgICAgICAgICAgICAgPExvYWRlciB0eXBlPVwicFwiLz5cbiAgICAgICAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgICAgICA8L3RyPlxuICAgICAgICAgICAgICAgIDx0cj5cbiAgICAgICAgICAgICAgICAgICAgPHRkPjxMb2FkZXIgdHlwZT1cInBcIi8+PC90ZD5cbiAgICAgICAgICAgICAgICAgICAgPHRkPuKAlDwvdGQ+XG4gICAgICAgICAgICAgICAgICAgIDx0ZD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxMb2FkZXIgdHlwZT1cInBcIi8+XG4gICAgICAgICAgICAgICAgICAgICAgICA8TG9hZGVyIHR5cGU9XCJwXCIvPlxuICAgICAgICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgICAgIDwvdHI+XG4gICAgICAgICAgICB7L2lmfVxuICAgICAgICA8L3Rib2R5PlxuICAgIDwvdGFibGU+XG5cbiAgICB7I2lmICFyZWFkb25seX1cbiAgICAgICAgPEJyIHNpemU9XCIyNVwiLz5cbiAgICAgICAgPEJ1dHRvbiBhdXRvIGlzPVwiaW5mb1wiIG9uOmNsaWNrPXsoKSA9PiBvcGVuID0gdHJ1ZX0+XG4gICAgICAgICAgICA8aDMgc3R5bGU9XCJwYWRkaW5nOiAxMHB4IDI1cHhcIiBjbGFzcz1cImZvbnQtdy01MDBcIj5cbiAgICAgICAgICAgICAgICDQlNC+0LTQsNGC0Lgg0L/QvtC00ZbRjlxuICAgICAgICAgICAgPC9oMz5cbiAgICAgICAgPC9CdXR0b24+XG4gICAgey9pZn1cbjwvc2VjdGlvbj5cblxuPE1vZGFsIFxuICAgIHtvcGVufVxuICAgIHN3aXBlPVwiYWxsXCJcbiAgICBpZD1cInN0b3J5LWxpZmUtbW9kYWxcIlxuICAgIHNpemU9XCJtZWRpdW1cIlxuICAgIHRpdGxlPVwi0KHRgtCy0L7RgNC10L3QvdGPINC/0L7QtNGW0ZdcIlxuICAgIG9uOmNsb3NlPXsoKSA9PiBvcGVuID0gZmFsc2V9XG4+XG4gICAgPGRpdiBjbGFzcz1cImNvbnRhaW5lclwiPlxuICAgICAgICA8QnIgc2l6ZT1cIjIwXCIvPlxuICAgICAgICA8Rm9ybUJ1aWxkZXJcbiAgICAgICAgICAgICAgICBpZD1cInN0b3J5LWZvcm1cIlxuICAgICAgICAgICAgICAgIGl0ZW1zPXtmb3JtRmllbGRzfVxuICAgICAgICAgICAgICAgIGVycm9ycz17Zm9ybUVycm9yc31cbiAgICAgICAgICAgICAgICBzdWJtaXQ9e29uU3VibWl0fVxuICAgICAgICAvPlxuICAgICAgICA8QnIgc2l6ZT1cIjQwXCIvPlxuICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgICAgICAgaXM9XCJpbmZvXCJcbiAgICAgICAgICAgICAgICBzaXplPVwibWVkaXVtXCJcbiAgICAgICAgICAgICAgICB0eXBlPVwic3VibWl0XCJcbiAgICAgICAgICAgICAgICBmb3JtPVwic3RvcnktZm9ybVwiXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJmdWxsLXdpZHRoXCJcbiAgICAgICAgPlxuICAgICAgICAgICAgPGgzPtCX0LHQtdGA0LXQs9GC0Lg8L2gzPlxuICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgPEJyIHNpemU9XCIyMFwiLz5cbiAgICA8L2Rpdj5cbjwvTW9kYWw+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJ3N2ZWx0ZSdcbiAgICBpbXBvcnQgeyBjbGFzc25hbWVzIH0gZnJvbSAnQHV0aWxzJ1xuICAgIGltcG9ydCBJY29uIGZyb20gJ0Bjb21wb25lbnRzL0ljb24uc3ZlbHRlJ1xuXG4gICAgY29uc3QgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXIoKVxuXG4gICAgZXhwb3J0IGxldCBpc0FjdGl2ZSA9IG51bGxcbiAgICBleHBvcnQgbGV0IG9uQXN5bmNDbGljayA9IG51bGxcblxuICAgIGxldCBpc0FjdGl2ZUxvY2FsID0gISFpc0FjdGl2ZVxuXG4gICAgJDogaXNBY3RpdmVTdGF0ZSA9IGlzQWN0aXZlID09PSBudWxsID8gaXNBY3RpdmVMb2NhbCA6IGlzQWN0aXZlXG4gICAgJDogY2xhc3NQcm9wID0gY2xhc3NuYW1lcygndHJ1c3QtYnRuJywgJCRwcm9wcy5jbGFzcywgeyBpc0FjdGl2ZTogaXNBY3RpdmVTdGF0ZSB9KVxuXG4gICAgZnVuY3Rpb24gb25DbGlja0hhbmRsZXIoZSkge1xuICAgICAgICBvbkNsaWNrRXZlbnQoZSlcbiAgICAgICAgb25DbGlja1Byb21pc2UoZSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkNsaWNrRXZlbnQoZSkge1xuICAgICAgICBkaXNwYXRjaCgnY2xpY2snLCBlKVxuICAgIH1cblxuICAgIGNvbnN0IG9uQ2xpY2tQcm9taXNlID0gYXN5bmMgKGUpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBvbkFzeW5jQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaXNBY3RpdmVMb2NhbCA9ICFpc0FjdGl2ZUxvY2FsXG4gICAgICAgICAgICAgICAgYXdhaXQgb25Bc3luY0NsaWNrKGUpXG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpc0FjdGl2ZUxvY2FsID0gIWlzQWN0aXZlTG9jYWxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbjwvc2NyaXB0PlxuXG48YnV0dG9uIHR5cGU9XCJidXR0b25cIiB0aXRsZT1cIkkgdHJ1c3RcIiBjbGFzcz17Y2xhc3NQcm9wfSBvbjpjbGljaz17b25DbGlja0hhbmRsZXJ9PlxuICAgIDxkaXYgY2xhc3M9XCJmdWxsLWFic29sdXRlXCI+XG4gICAgICAgIDxzcGFuPlxuICAgICAgICAgICAgPEljb24gdHlwZT1cImhlYXJ0XCIgaXM9e2lzQWN0aXZlID8gJ2xpZ2h0JyA6ICdkYW5nZXInfS8+XG4gICAgICAgIDwvc3Bhbj5cbiAgICA8L2Rpdj5cbjwvYnV0dG9uPlxuXG48c3R5bGU+XG4gICAgLnRydXN0LWJ0biB7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBoZWlnaHQ6IDA7XG4gICAgICAgIHBhZGRpbmctYm90dG9tOiAxMDAlO1xuICAgICAgICBib3JkZXItcmFkaXVzOiA1MCU7XG4gICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgfVxuXG4gICAgZGl2IHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcbiAgICAgICAgYm9yZGVyOiA0cHggc29saWQgcmdiYSh2YXIoLS1jb2xvci1kYW5nZXIpKTtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSh2YXIoLS1jb2xvci1kYW5nZXIpLCAuMik7XG4gICAgfVxuXG4gICAgLnRydXN0LWJ0bi5pc0FjdGl2ZSBkaXYge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKHZhcigtLWNvbG9yLWRhbmdlciksIDEpO1xuICAgIH1cblxuICAgIC50cnVzdC1idG4uaXNBY3RpdmUgc3BhbiB7XG4gICAgICAgIGNvbG9yOiByZ2JhKHZhcigtLWNvbG9yLXdoaXRlKSk7XG4gICAgICAgIGFuaW1hdGlvbjogbm9uZTtcbiAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgxLjEpXG4gICAgfVxuXG4gICAgc3BhbiB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIHdpZHRoOiA1MCU7XG4gICAgICAgIGhlaWdodDogNTAlO1xuICAgICAgICBtYXJnaW4tdG9wOiAzcHg7XG4gICAgICAgIG1heC13aWR0aDogY2FsYygxMDAlIC0gMTBweCk7XG4gICAgICAgIG1heC1oZWlnaHQ6IGNhbGMoMTAwJSAtIDEwcHgpO1xuICAgICAgICBjb2xvcjogcmdiYSh2YXIoLS1jb2xvci1kYW5nZXIpKTtcbiAgICAgICAgYW5pbWF0aW9uOiBwdWxzZSAycyBpbmZpbml0ZTtcbiAgICB9XG5cbiAgICBAa2V5ZnJhbWVzIHB1bHNlIHtcbiAgICAgICAgMTAlIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMS4xKVxuICAgICAgICB9XG4gICAgICAgIDIwJSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDEuMDUpXG4gICAgICAgIH1cbiAgICAgICAgMzAlIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMS4xNSlcbiAgICAgICAgfVxuICAgIH1cbjwvc3R5bGU+XG4iLCI8c2NyaXB0PlxuICAgIGV4cG9ydCBsZXQgdGl0bGUgPSAnVGhlIG1haW4gdGl0bGUgdGhhdCBleHBsYWlucyB0aGUgY2hhcml0eSdcbiAgICBleHBvcnQgbGV0IHN1YnRpdGxlID0gJ0FuZCBiaWdnZXIgZGVzY3JpcHRpb24gdGhhdCBkZXNjcmliZXMgaW4gc2hvcnQga2V5d29yZHMgYSBjaGFyaXR5LCB0aXRsZSBhYm92ZSBhbmQganVzdCBtYWtlcyB0ZXh0IGxvbmdlcidcbjwvc2NyaXB0PlxuXG48c2VjdGlvbj5cbiAgICA8aDE+e3RpdGxlfTwvaDE+XG4gICAgPGJyPlxuICAgIDxoMj57c3VidGl0bGV9PC9oMj5cbjwvc2VjdGlvbj5cblxuPHN0eWxlPlxuICAgIHNlY3Rpb24ge1xuICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgICAgIHBhZGRpbmc6IDAgM3Z3O1xuICAgIH1cblxuICAgIGgyIHtcbiAgICAgICAgZm9udC13ZWlnaHQ6IDQwMDtcbiAgICB9XG48L3N0eWxlPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSAnc3ZlbHRlJ1xuICAgIGltcG9ydCB7IGNsYXNzbmFtZXMgfSBmcm9tICdAdXRpbHMnXG4gICAgaW1wb3J0IEljb24gZnJvbSAnQGNvbXBvbmVudHMvSWNvbi5zdmVsdGUnXG5cbiAgICBsZXQgYWN0aXZlRG9uYXRlQnRuID0gZmFsc2VcblxuICAgIG9uTW91bnQoKCkgPT4gc2V0VGltZW91dCgoKSA9PiBhY3RpdmVEb25hdGVCdG4gPSB0cnVlLCA1MDApKVxuXG4gICAgJDogY2xhc3NQcm9wRG9uYXRlQnRuID0gY2xhc3NuYW1lcygnZG9uYXRlLWJ0bicsIHsgYWN0aXZlOiBhY3RpdmVEb25hdGVCdG4gfSlcblxuICAgIGZ1bmN0aW9uIG9uRG9uYXRlKCkge1xuICAgICAgICBhbGVydCgn0JTRj9C60YPRjiEg8J+lsCcpXG4gICAgfVxuPC9zY3JpcHQ+XG5cbjxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPXtjbGFzc1Byb3BEb25hdGVCdG59IG9uOmNsaWNrPXtvbkRvbmF0ZX0+XG4gICAgPHNwYW4+XG4gICAgICAgIDxJY29uIHR5cGU9XCJjb2luXCIgc2l6ZT1cIm1lZGl1bVwiIGlzPVwicHJpbWFyeVwiLz5cbiAgICA8L3NwYW4+XG4gICAgPHM+PC9zPlxuICAgIDxzPjwvcz5cbiAgICDQlNC+0L/QvtC80L7Qs9GC0LhcbjwvYnV0dG9uPlxuXG48c3R5bGU+XG4gICAgLmRvbmF0ZS1idG4ge1xuICAgICAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIGJvdHRvbTogZW52KHNhZmUtYXJlYS1pbnNldC1ib3R0b20pO1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiA2MDA7XG4gICAgICAgIGZvbnQtc2l6ZTogMS44NWVtO1xuICAgICAgICBsaW5lLWhlaWdodDogMS4yNjtcbiAgICAgICAgY29sb3I6IHJnYmEodmFyKC0tY29sb3Itd2hpdGUpKTtcbiAgICAgICAgcGFkZGluZzogMjBweDtcbiAgICAgICAgei1pbmRleDogOTtcbiAgICAgICAgdG91Y2gtYWN0aW9uOiBtYW5pcHVsYXRpb247XG4gICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgdHJhbnNpdGlvbjogLjNzIGVhc2UtaW4tb3V0O1xuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMTAwJSk7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEodmFyKC0tY29sb3Itc3VjY2VzcykpO1xuICAgIH1cblxuICAgIHNwYW4ge1xuICAgICAgICBmbGV4OiBub25lO1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgaGVpZ2h0OiAzMnB4O1xuICAgICAgICB3aWR0aDogMzJweDtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogNTAlO1xuICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKHZhcigtLWNvbG9yLXdoaXRlKSk7XG4gICAgfVxuXG4gICAgLmRvbmF0ZS1idG4uYWN0aXZlIHtcbiAgICAgICAgdHJhbnNmb3JtOiBub25lXG4gICAgfVxuPC9zdHlsZT5cbiIsIjxzY3JpcHQ+XG4gICAgY29uc3QgaXRlbXMgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRpdGxlOiAnQ29tZm9ydCBpcyB0aGUgbWFpbiBmZWF0dXJlJyxcbiAgICAgICAgICAgIHRleHQ6ICdKdXN0IGltYWdpbmcsIHlvdSBkbyBzb21ldGhpbmcgc2ltcGxlIGFuZCB5b3UgY2FuIHNlZSB0aGUgcmVzdWx0IG9mIHlvdXIgc2hvcnQgd2F5LicsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRpdGxlOiAnQ29tZm9ydCBpcyB0aGUgbWFpbiBmZWF0dXJlJyxcbiAgICAgICAgICAgIHRleHQ6ICdKdXN0IGltYWdpbmcsIHlvdSBkbyBzb21ldGhpbmcgc2ltcGxlIGFuZCB5b3UgY2FuIHNlZSB0aGUgcmVzdWx0IG9mIHlvdXIgc2hvcnQgd2F5LicsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRpdGxlOiAnQ29tZm9ydCBpcyB0aGUgbWFpbiBmZWF0dXJlJyxcbiAgICAgICAgICAgIHRleHQ6ICdKdXN0IGltYWdpbmcsIHlvdSBkbyBzb21ldGhpbmcgc2ltcGxlIGFuZCB5b3UgY2FuIHNlZSB0aGUgcmVzdWx0IG9mIHlvdXIgc2hvcnQgd2F5LicsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRpdGxlOiAnQ29tZm9ydCBpcyB0aGUgbWFpbiBmZWF0dXJlJyxcbiAgICAgICAgICAgIHRleHQ6ICdKdXN0IGltYWdpbmcsIHlvdSBkbyBzb21ldGhpbmcgc2ltcGxlIGFuZCB5b3UgY2FuIHNlZSB0aGUgcmVzdWx0IG9mIHlvdXIgc2hvcnQgd2F5LicsXG4gICAgICAgIH0sXG4gICAgXVxuPC9zY3JpcHQ+XG5cbjx1bD5cbiAgICB7I2VhY2ggaXRlbXMgYXMgaXRlbX1cbiAgICAgICAgPGxpPlxuICAgICAgICAgICAgPGgzPntpdGVtLnRpdGxlfTwvaDM+XG4gICAgICAgICAgICA8cD57aXRlbS50ZXh0fTwvcD5cbiAgICAgICAgICAgIDxicj5cbiAgICAgICAgPC9saT5cbiAgICB7L2VhY2h9XG48L3VsPlxuXG48c3R5bGU+XG4gICAgdWwge1xuICAgICAgICBsaXN0LXN0eWxlOiBkaXNjIG91dHNpZGUgbm9uZTtcbiAgICAgICAgcGFkZGluZzogMCBjYWxjKHZhcigtLXNjcmVlbi1wYWRkaW5nKSAqIDUpO1xuICAgICAgICAvKmxpc3Qtc3R5bGUtaW1hZ2U6IHVybChcImRhdGE6aW1hZ2Uvc3ZnK3htbDt1dGY4LDxzdmcgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB3aWR0aD0nMTAnIGhlaWdodD0nMTAnIHZpZXdCb3g9Jy0xIC0xIDIgMic+PGNpcmNsZSByPScxJyAvPjwvc3ZnPlwiKTsqL1xuICAgIH1cblxuICAgIGxpIHtcbiAgICAgICAgZGlzcGxheTogbGlzdC1pdGVtO1xuICAgIH1cblxuICAgIHVsLCBsaSwgaDMsIHAge1xuICAgICAgICBtYXgtd2lkdGg6IDEwMCU7XG4gICAgICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XG4gICAgfVxuXG4gICAgaDMsIHAge1xuICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgICAgIHdvcmQtYnJlYWs6IGJyZWFrLXdvcmQ7XG4gICAgICAgIHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xuICAgIH1cbjwvc3R5bGU+XG4iLCJjb25zdCBjb250ZXh0TWFwYm94ID0ge31cblxuZXhwb3J0IHsgY29udGV4dE1hcGJveCB9XG4iLCI8c3R5bGU+XG4gICAgc2VjdGlvbiB7XG4gICAgICAgIGZsZXgtZ3JvdzogMTtcbiAgICAgICAgYWxpZ24tc2VsZjogc3RyZXRjaDtcbiAgICB9XG48L3N0eWxlPlxuXG48c2NyaXB0PlxuICAgIGltcG9ydCB7IG9uTW91bnQsIG9uRGVzdHJveSwgc2V0Q29udGV4dCwgY3JlYXRlRXZlbnREaXNwYXRjaGVyIH0gZnJvbSAnc3ZlbHRlJ1xuICAgIGltcG9ydCB7IGNvbnRleHRNYXBib3ggfSBmcm9tICcuL2NvbnRleHQnXG5cbiAgICBjb25zdCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpXG5cbiAgICBleHBvcnQgbGV0IGNlbnRlciA9IFszMS4xNjU2LCA0OC4zNzk0XVxuICAgIGV4cG9ydCBsZXQgem9vbSA9IDMuNzVcblxuICAgIGxldCBtYXBcbiAgICBsZXQgY29udGFpbmVyXG5cbiAgICBzZXRDb250ZXh0KGNvbnRleHRNYXBib3gsIHtcbiAgICAgICAgZ2V0TWFwOiAoKSA9PiBtYXAsXG4gICAgICAgIGdldE1hcGJveDogKCkgPT4gd2luZG93Lm1hcGJveGdsXG4gICAgfSlcblxuICAgIGZ1bmN0aW9uIG9uQ3JlYXRlTWFwKCkge1xuICAgICAgICBtYXAgPSBuZXcgbWFwYm94Z2wuTWFwKHtcbiAgICAgICAgICAgIHpvb20sXG4gICAgICAgICAgICBjZW50ZXIsXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBzdHlsZTogJ21hcGJveDovL3N0eWxlcy9tYXBib3gvc3RyZWV0cy12MTEnLFxuICAgICAgICB9KVxuXG4gICAgICAgIG1hcC5vbignZHJhZ2VuZCcsICgpID0+IGRpc3BhdGNoKCdyZWNlbnRyZScsIHsgbWFwLCBjZW50ZXI6IG1hcC5nZXRDZW50ZXIoKSB9KSlcbiAgICAgICAgbWFwLm9uKCdsb2FkJywgKCkgPT4gZGlzcGF0Y2goJ3JlYWR5JywgbWFwKSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVNYXAoKSB7XG4gICAgICAgIGNvbnN0IHNjcmlwdFRhZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpXG4gICAgICAgIHNjcmlwdFRhZy50eXBlID0gJ3RleHQvamF2YXNjcmlwdCdcbiAgICAgICAgc2NyaXB0VGFnLnNyYyA9ICdodHRwczovL2FwaS5tYXBib3guY29tL21hcGJveC1nbC1qcy92MS43LjAvbWFwYm94LWdsLmpzJ1xuXG4gICAgICAgIGNvbnN0IGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaW5rJylcbiAgICAgICAgbGluay5yZWwgPSAnc3R5bGVzaGVldCdcbiAgICAgICAgbGluay5ocmVmID0gJ2h0dHBzOi8vYXBpLm1hcGJveC5jb20vbWFwYm94LWdsLWpzL3YxLjcuMC9tYXBib3gtZ2wuY3NzJ1xuXG4gICAgICAgIHNjcmlwdFRhZy5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0b2tlbiA9ICdway5leUoxSWpvaVluVmliR2xySWl3aVlTSTZJbU5yTlhweGR6Z3hiVEF3Tm5jemJHeHdlRzB3Y1RWM2NqQWlmUS5ydDFwZUxqQ1FIWlVrck00QVd6NU13J1xuICAgICAgICAgICAgbWFwYm94Z2wuYWNjZXNzVG9rZW4gPSB0b2tlblxuXG4gICAgICAgICAgICBsaW5rLm9ubG9hZCA9IG9uQ3JlYXRlTWFwXG5cbiAgICAgICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQobGluaylcbiAgICAgICAgfVxuXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc2NyaXB0VGFnKVxuICAgIH1cblxuICAgIG9uTW91bnQoKCkgPT4ge1xuICAgICAgICBpZiAoJ21hcGJveGdsJyBpbiB3aW5kb3cpIHtcbiAgICAgICAgICAgIG9uQ3JlYXRlTWFwKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNyZWF0ZU1hcCgpXG4gICAgICAgIH1cbiAgICB9KVxuXG4gICAgb25EZXN0cm95KCgpID0+IHtcbiAgICAgICAgbWFwICYmIG1hcC5yZW1vdmUoKVxuICAgIH0pXG48L3NjcmlwdD5cblxuPHNlY3Rpb24gYmluZDp0aGlzPXtjb250YWluZXJ9PlxuICAgIHsjaWYgbWFwfVxuICAgICAgICA8c2xvdD48L3Nsb3Q+XG4gICAgey9pZn1cbjwvc2VjdGlvbj5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgZ2V0Q29udGV4dCwgY3JlYXRlRXZlbnREaXNwYXRjaGVyIH0gZnJvbSAnc3ZlbHRlJ1xuICAgIGltcG9ydCB7IGNvbnRleHRNYXBib3ggfSBmcm9tICcuL2NvbnRleHQnXG5cbiAgICBjb25zdCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpXG5cbiAgICBjb25zdCB7IGdldE1hcCwgZ2V0TWFwYm94IH0gPSBnZXRDb250ZXh0KGNvbnRleHRNYXBib3gpXG5cbiAgICBjb25zdCBtYXAgPSBnZXRNYXAoKVxuICAgIGNvbnN0IG1hcGJveCA9IGdldE1hcGJveCgpXG5cbiAgICBleHBvcnQgbGV0IGxuZ1xuICAgIGV4cG9ydCBsZXQgbGF0XG4gICAgLy8gZXhwb3J0IGxldCBsYWJlbCA9ICdsYWJlbCdcblxuICAgIC8vIGNvbnN0IHBvcHVwID0gbmV3IG1hcGJveC5Qb3B1cCh7IG9mZnNldDogMjUgfSkuc2V0VGV4dChsYWJlbClcblxuICAgIGNvbnN0IG1hcmtlckVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgbWFya2VyRWwuc3R5bGUuZm9udFNpemUgPSAnNTBweCc7XG4gICAgbWFya2VyRWwuc3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInO1xuICAgIG1hcmtlckVsLmlubmVySFRNTCA9ICfwn5ONJztcblxuICAgIGNvbnN0IG1hcmtlciA9IG5ldyBtYXBib3guTWFya2VyKG1hcmtlckVsLCB7IG9mZnNldDogWzAsIC0yNV0gfSlcbiAgICAgICAgICAgIC5zZXRMbmdMYXQoW2xuZywgbGF0XSlcbiAgICAgICAgICAgIC8vIC5zZXRQb3B1cChwb3B1cClcbiAgICAgICAgICAgIC5hZGRUbyhtYXApXG5cbiAgICBtYXJrZXJFbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGRpc3BhdGNoLmJpbmQobnVsbCwgJ2NsaWNrJykpXG48L3NjcmlwdD5cblxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBjbGFzc25hbWVzIH0gZnJvbSAnQHV0aWxzJ1xuICAgIGltcG9ydCBCciBmcm9tICdAY29tcG9uZW50cy9Cci5zdmVsdGUnXG4gICAgaW1wb3J0IEljb24gZnJvbSAnQGNvbXBvbmVudHMvSWNvbi5zdmVsdGUnXG4gICAgaW1wb3J0IENhcmQgZnJvbSAnQGNvbXBvbmVudHMvQ2FyZC5zdmVsdGUnXG4gICAgaW1wb3J0IEF2YXRhciBmcm9tICdAY29tcG9uZW50cy9BdmF0YXIuc3ZlbHRlJ1xuICAgIGltcG9ydCBGYW5jeUJveCBmcm9tICdAY29tcG9uZW50cy9GYW5jeUJveC5zdmVsdGUnXG4gICAgaW1wb3J0IExvYWRlciBmcm9tICdAY29tcG9uZW50cy9sb2FkZXInXG5cbiAgICBleHBvcnQgbGV0IHNyYyA9IG51bGxcbiAgICBleHBvcnQgbGV0IGRhdGUgPSBudWxsXG4gICAgZXhwb3J0IGxldCB0aXRsZSA9IG51bGxcbiAgICBleHBvcnQgbGV0IGFtb3VudCA9IG51bGxcbiAgICBleHBvcnQgbGV0IGNoZWNrZWQgPSBudWxsXG5cbiAgICAkOiBjbGFzc1Byb3AgPSBjbGFzc25hbWVzKCQkcHJvcHMuY2xhc3MpXG48L3NjcmlwdD5cblxuPENhcmQgY2xhc3M9e2NsYXNzUHJvcH0+XG4gICAgPHNlY3Rpb24gY2xhc3M9XCJjb21tZW50IGZsZXggZmxleC1hbGlnbi1zdGFydFwiIHN0eWxlPVwicGFkZGluZzogMjBweFwiPlxuXG4gICAgICAgIDxkaXYgY2xhc3M9XCJmbGV4IHJlbGF0aXZlXCI+XG4gICAgICAgICAgICA8RmFuY3lCb3g+XG4gICAgICAgICAgICAgICAgPEF2YXRhciBzcmM9e3NyY30gYWx0PXt0aXRsZX0gc2l6ZT1cIm1lZGl1bVwiLz5cbiAgICAgICAgICAgICAgICA8c2VjdGlvbiBzbG90PVwiYm94XCIgY2xhc3M9XCJmbGV4IGZ1bGwtd2lkdGggZnVsbC1oZWlnaHRcIiBzdHlsZT1cImhlaWdodDogMTAwdndcIj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZsZXggZmxleC1zZWxmLXN0cmV0Y2ggZmxleC0xIG92ZXJmbG93LWhpZGRlbiBmbGV4LWp1c3RpZnktc3RyZXRjaFwiIHN0eWxlPVwicGFkZGluZzogdmFyKC0tc2NyZWVuLXBhZGRpbmcpIDBcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxBdmF0YXIgc3JjPXtzcmN9IGFsdD17dGl0bGV9Lz5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9zZWN0aW9uPlxuICAgICAgICAgICAgPC9GYW5jeUJveD5cblxuICAgICAgICAgICAgeyNpZiBjaGVja2VkfVxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImFic29sdXRlIGZsZXhcIiBzdHlsZT1cInRvcDogLTFweDsgcmlnaHQ6IC0xcHg7IHdpZHRoOiAyMHB4OyBoZWlnaHQ6IDIwcHg7IG92ZXJmbG93OiBoaWRkZW5cIj5cbiAgICAgICAgICAgICAgICA8SWNvbiB0eXBlPVwicG9seWdvblwiIGlzPVwiaW5mb1wiLz5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiYWJzb2x1dGUtY2VudGVyIGZsZXhcIiBzdHlsZT1cIndpZHRoOiAxMHB4OyBoZWlnaHQ6IDEwcHg7XCI+XG4gICAgICAgICAgICAgICAgICAgIDxJY29uIHR5cGU9XCJjaGVjay1mbGFnXCIgaXM9XCJsaWdodFwiLz5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgey9pZn1cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPHM+PC9zPlxuICAgICAgICA8cz48L3M+XG4gICAgICAgIDxzPjwvcz5cbiAgICAgICAgPHM+PC9zPlxuXG4gICAgICAgIDxkaXYgY2xhc3M9XCJmbGV4IGZsZXgtY29sdW1uIGZsZXgtMVwiIHN0eWxlPVwib3ZlcmZsb3c6IGhpZGRlblwiPlxuXG4gICAgICAgICAgICB7I2lmIHRpdGxlICE9PSBudWxsfVxuICAgICAgICAgICAgICAgIDxoMyBjbGFzcz1cInRleHQtZWxsaXBzaXMgZm9udC13LTUwMFwiPnsgdGl0bGUgfTwvaDM+XG4gICAgICAgICAgICB7OmVsc2V9XG4gICAgICAgICAgICAgICAgPGRpdiBzdHlsZT1cIndpZHRoOiA2MCVcIj48TG9hZGVyIHR5cGU9XCJoM1wiIC8+PC9kaXY+XG4gICAgICAgICAgICB7L2lmfVxuXG4gICAgICAgICAgICA8QnIgc2l6ZT1cIjVcIi8+XG5cbiAgICAgICAgICAgIDxwcmUgY2xhc3M9XCJoNCBmb250LXctMzAwXCIgc3R5bGU9XCJsaW5lLWhlaWdodDogMS40NjtcIj5cbiAgICAgICAgICAgICAgICA8c2xvdD5cbiAgICAgICAgICAgICAgICAgICAgIFtObyBjb21tZW50XVxuICAgICAgICAgICAgICAgIDwvc2xvdD5cbiAgICAgICAgICAgIDwvcHJlPlxuXG4gICAgICAgICAgICA8QnIgc2l6ZT1cIjEwXCIvPlxuXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZmxleCBmbGV4LWFsaWduLWNlbnRlciBmbGV4LWp1c3RpZnktYmV0d2VlblwiPlxuICAgICAgICAgICAgICAgIDxwIGNsYXNzPVwiZmxleCBmbGV4LWFsaWduLWNlbnRlciBmbGV4LWp1c3RpZnktYmV0d2VlblwiPlxuICAgICAgICAgICAgICAgICAgICB7I2lmIGRhdGUgIT09IG51bGx9XG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImg0XCIgc3R5bGU9XCJvcGFjaXR5OiAuM1wiPnsgZGF0ZSB9PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHM+PC9zPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHM+PC9zPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHM+PC9zPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHM+PC9zPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJoNFwiIHN0eWxlPVwib3BhY2l0eTogLjdcIj7QktGW0LTQv9C+0LLRltGB0YLQuDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzPjwvcz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzPjwvcz5cbiAgICAgICAgICAgICAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBzdHlsZT1cIndpZHRoOiA4MCVcIj48TG9hZGVyIHR5cGU9XCJoNFwiIC8+PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICAgICAgPC9wPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaDUgZmxleCBmbGV4LWFsaWduLWNlbnRlciBmb250LXNlY29uZGFyeVwiIHN0eWxlPVwibWluLXdpZHRoOiA0ZW1cIj5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gc3R5bGU9e2BvcGFjaXR5OiAke2Ftb3VudCA+IDIgPyAxIDogLjV9YH0+XG4gICAgICAgICAgICAgICAgICAgICAgICA8SWNvbiB0eXBlPVwiaGVhcnRcIiBpcz1cImRhbmdlclwiIHNpemU9XCJzbWFsbFwiLz5cbiAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICA8cz48L3M+XG4gICAgICAgICAgICAgICAgICAgIDxzPjwvcz5cbiAgICAgICAgICAgICAgICAgICAgeyNpZiBhbW91bnQgIT09IG51bGx9XG4gICAgICAgICAgICAgICAgICAgICAgICA8aDQ+eyBhbW91bnQgfTwvaDQ+XG4gICAgICAgICAgICAgICAgICAgIHs6ZWxzZX1cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaDQgcmVsYXRpdmUgZmxleC1zZWxmLXN0YXJ0XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gc3R5bGU9XCJ2aXNpYmlsaXR5OiBoaWRkZW5cIj4xOTk8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPExvYWRlciB0eXBlPVwiaDRcIiBhYnNvbHV0ZS8+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+ICBcbiAgICAgICAgICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG5cbiAgICA8L3NlY3Rpb24+XG48L0NhcmQ+XG5cbjxzdHlsZT5cbjwvc3R5bGU+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJ3N2ZWx0ZSdcblxuICAgIGltcG9ydCBCciBmcm9tICdAY29tcG9uZW50cy9Cci5zdmVsdGUnXG4gICAgaW1wb3J0IEljb24gZnJvbSAnQGNvbXBvbmVudHMvSWNvbi5zdmVsdGUnXG4gICAgaW1wb3J0IEZvcm0gZnJvbSAnQGNvbXBvbmVudHMvRm9ybS5zdmVsdGUnXG4gICAgaW1wb3J0IElucHV0IGZyb20gJ0Bjb21wb25lbnRzL2ZpZWxkcy9JbnB1dC5zdmVsdGUnXG4gICAgaW1wb3J0IEJ1dHRvbiBmcm9tICdAY29tcG9uZW50cy9CdXR0b24uc3ZlbHRlJ1xuICAgIGltcG9ydCBMb2FkZXIgZnJvbSAnQGNvbXBvbmVudHMvbG9hZGVyJ1xuICAgIGltcG9ydCBDb21tZW50IGZyb20gJy4vQ29tbWVudC5zdmVsdGUnXG5cbiAgICBjb25zdCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpXG5cbiAgICAvKipcbiAgICAgKiBcbiAgICAgKiBAZXZlbnQ6IHN1Ym1pdCAtIHN1Ym1pdCB2YWx1ZXMgb2YgYSBuZXcgY29tbWVudCBcbiAgICAgKiBcbiAgICAgKi9cbiAgICBcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBleHBvcnQgbGV0IHdpdGhGb3JtID0gdHJ1ZVxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge3tcbiAgICAgKiAgICAgIGxpa2VzOiBudW1iZXIsXG4gICAgICogICAgICBhdmF0YXI6IHN0cmluZyxcbiAgICAgKiAgICAgIGF1dGhvcjogc3RyaW5nLFxuICAgICAqICAgICAgY29tbWVudDogc3RyaW5nLFxuICAgICAqICAgICAgY2hlY2tlZDogYm9vbGVhbixcbiAgICAgKiAgICAgIGNyZWF0ZWRfYXQ6IHN0cmluZyxcbiAgICAgKiB9fVxuICAgICAqL1xuICAgIGV4cG9ydCBsZXQgaXRlbXMgPSBuZXcgQXJyYXkoNCkuZmlsbCh7IGNvbW1lbnQ6IG51bGwgfSlcbjwvc2NyaXB0PlxuXG48c2VjdGlvbiBjbGFzcz1cImNvbW1lbnRzXCI+XG4gICAgPHVsIGNsYXNzPVwiY29tbWVudHMtd3JhcFwiPlxuICAgICAgICB7I2VhY2ggaXRlbXMgYXMgY29tbWVudH1cbiAgICAgICAgICAgIDxsaT5cbiAgICAgICAgICAgICAgICA8Q29tbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgc3JjPXtjb21tZW50LmF2YXRhcn1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlPXtjb21tZW50LmF1dGhvcn1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGU9e2NvbW1lbnQuY3JlYXRlZF9hdCAmJiBuZXcgRGF0ZShjb21tZW50LmNyZWF0ZWRfYXQpLnRvTG9jYWxlRGF0ZVN0cmluZygpfVxuICAgICAgICAgICAgICAgICAgICAgICAgYW1vdW50PXtjb21tZW50Lmxpa2VzfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tlZD17Y29tbWVudC5jaGVja2VkfVxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgeyNpZiBjb21tZW50LmNvbW1lbnQgIT09IG51bGx9XG4gICAgICAgICAgICAgICAgICAgICAgICB7Y29tbWVudC5jb21tZW50fVxuICAgICAgICAgICAgICAgICAgICB7OmVsc2V9XG4gICAgICAgICAgICAgICAgICAgICAgICA8TG9hZGVyIHR5cGU9XCJoNFwiLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxMb2FkZXIgdHlwZT1cImg0XCIvPlxuICAgICAgICAgICAgICAgICAgICB7L2lmfVxuICAgICAgICAgICAgICAgIDwvQ29tbWVudD5cbiAgICAgICAgICAgIDwvbGk+XG4gICAgICAgIHsvZWFjaH1cbiAgICA8L3VsPlxuXG4gICAgPEJyIHNpemU9XCIyMFwiLz4gIFxuXG4gICAgPHAgY2xhc3M9XCJoMyBmb250LXctNTAwIGZvbnQtc2Vjb25kYXJ5IHVuZGVybGluZSB0ZXh0LWNlbnRlclwiPlxuICAgICAgICA8c3Bhbj7QktGB0ZYg0LrQvtC80LXQvdGC0LDRgNGWPC9zcGFuPlxuICAgICAgICA8SWNvbiB0eXBlPVwiY2FyZXQtZG93blwiIHNpemU9XCJzbWFsbFwiLz5cbiAgICA8L3A+XG5cbiAgICB7I2lmIHdpdGhGb3JtfVxuICAgICAgICA8QnIgc2l6ZT1cIjQwXCIvPiAgXG4gICAgICAgIDxkaXYgY2xhc3M9XCJjb21tZW50cy1mb3JtIGZvbnQtc2Vjb25kYXJ5IGgzXCI+XG4gICAgICAgICAgICA8Rm9ybSBjbGFzcz1cImZsZXhcIiBuYW1lPVwiY29tbWVudC1mb3JtXCIgb246c3VibWl0PXt2YWx1ZXMgPT4gZGlzcGF0Y2goJ3N1bWJpdCcsIHZhbHVlcyl9PlxuICAgICAgICAgICAgICAgIDxJbnB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT1cInRleHRhcmVhXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU9XCJjb21tZW50XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd3M9XCIxXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiY29tbWVudC1maWVsZCBmbGV4LXNlbGYtc3RyZXRjaFwiXG4gICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cItCX0LDQu9C40YjRgtC1INGB0LLRltC5INC60L7QvNC10L3RgtCw0YBcIlxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8L0Zvcm0+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZmxleCBhYnNvbHV0ZVwiIHN0eWxlPVwidG9wOiAwOyByaWdodDogMDsgaGVpZ2h0OiAxMDAlOyB3aWR0aDogNTBweFwiPlxuICAgICAgICAgICAgICAgIDxCdXR0b24gdHlwZT1cInN1Ym1pdFwiIGNsYXNzPVwiZmxleCBmdWxsLXdpZHRoIGZsZXgtc2VsZi1zdHJldGNoIGZsZXgtanVzdGlmeS1zdGFydFwiPlxuICAgICAgICAgICAgICAgICAgICA8SWNvbiB0eXBlPVwic2VuZFwiIGlzPVwiaW5mb1wiIHNpemU9XCJtZWRpdW1cIi8+XG4gICAgICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgey9pZn1cbjwvc2VjdGlvbj5cblxuPHN0eWxlPlxuICAgIC5jb21tZW50cyB7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBmbGV4LWdyb3c6IDE7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIG92ZXJmbG93LXk6IGF1dG87XG4gICAgICAgIG92ZXJmbG93LXg6IGhpZGRlbjtcbiAgICAgICAgYWxpZ24tc2VsZjogc3RyZXRjaDtcbiAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAgcGFkZGluZzogMTVweDtcbiAgICB9XG5cbiAgICAuY29tbWVudHMtZm9ybSB7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgZmxleDogbm9uZTtcbiAgICB9XG5cbiAgICAuY29tbWVudHMtd3JhcCB7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBtYXJnaW46IC01cHggMDtcbiAgICB9XG5cbiAgICAuY29tbWVudHMtd3JhcCBsaSB7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBwYWRkaW5nOiA1cHggMDtcbiAgICB9XG48L3N0eWxlPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgSWNvbiBmcm9tICdAY29tcG9uZW50cy9JY29uLnN2ZWx0ZSdcbiAgICBpbXBvcnQgQ2FyZCBmcm9tICdAY29tcG9uZW50cy9DYXJkLnN2ZWx0ZSdcbiAgICBpbXBvcnQgQXZhdGFyIGZyb20gJ0Bjb21wb25lbnRzL0F2YXRhci5zdmVsdGUnXG4gICAgaW1wb3J0IExvYWRlciBmcm9tICdAY29tcG9uZW50cy9sb2FkZXInXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7e1xuICAgICAqICBpZDogc3RyaW5nLFxuICAgICAqICBzcmM6IHN0cmluZyxcbiAgICAgKiAgdGl0bGU6IHN0cmluZyxcbiAgICAgKiAgc3VidGl0bGU6IHN0cmluZyxcbiAgICAgKiAgY2hlY2tlZDogYm9vbGVhbixcbiAgICAgKiB9fVxuICAgICAqL1xuICAgIGV4cG9ydCBsZXQgaXRlbXNcbjwvc2NyaXB0PlxuXG57I2lmIEFycmF5LmlzQXJyYXkoaXRlbXMpICYmIGl0ZW1zLmxlbmd0aH1cbiAgICA8Q2FyZD5cbiAgICAgICAgPHVsIGNsYXNzPVwiZnVsbC13aWR0aFwiPlxuICAgICAgICAgICAgeyNlYWNoIGl0ZW1zIGFzIGl0ZW19XG4gICAgICAgICAgICAgICAgPGxpIGtleT17aXRlbS5pZH0+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJyZWxhdGl2ZVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPEF2YXRhciBzcmM9e2l0ZW0uc3JjfSBzaXplPVwibWVkaXVtXCIgYWx0PXtpdGVtLnN1YnRpdGxlfS8+XG4gICAgICAgICAgICAgICAgICAgICAgICB7I2lmIGl0ZW0uY2hlY2tlZH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiYWJzb2x1dGUgZmxleFwiIHN0eWxlPVwidG9wOiAtMXB4OyByaWdodDogLTFweDsgd2lkdGg6IDIwcHg7IGhlaWdodDogMjBweDsgb3ZlcmZsb3c6IGhpZGRlblwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8SWNvbiB0eXBlPVwicG9seWdvblwiIGlzPVwiaW5mb1wiLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImFic29sdXRlLWNlbnRlciBmbGV4XCIgc3R5bGU9XCJ3aWR0aDogMTBweDsgaGVpZ2h0OiAxMHB4O1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPEljb24gdHlwZT1cImNoZWNrLWZsYWdcIiBpcz1cImxpZ2h0XCIvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8cz48L3M+XG4gICAgICAgICAgICAgICAgICAgIDxzPjwvcz5cbiAgICAgICAgICAgICAgICAgICAgPHM+PC9zPlxuICAgICAgICAgICAgICAgICAgICA8cz48L3M+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9XCJvdmVyZmxvdzogaGlkZGVuO1wiIGNsYXNzPVwiZmxleCBmbGV4LWNvbHVtbiBmbGV4LWp1c3RpZnktY2VudGVyXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICB7I2lmIGl0ZW0udGl0bGUgIT09IG51bGx9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGgyIGNsYXNzPVwidGV4dC1lbGxpcHNpc1wiPnsgaXRlbS50aXRsZSB9PC9oMj5cbiAgICAgICAgICAgICAgICAgICAgICAgIHs6ZWxzZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImgyIHJlbGF0aXZlIGZsZXgtc2VsZi1zdGFydFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBzdHlsZT1cInZpc2liaWxpdHk6IGhpZGRlblwiPuKCtCAxMDAwPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8TG9hZGVyIHR5cGU9XCJoMlwiIGFic29sdXRlLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+ICBcbiAgICAgICAgICAgICAgICAgICAgICAgIHsvaWZ9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHsjaWYgaXRlbS5zdWJ0aXRsZSAhPT0gbnVsbH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImg0IGZvbnQtdy0zMDAgdGV4dC1lbGxpcHNpc1wiPnsgaXRlbS5zdWJ0aXRsZSB9PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxMb2FkZXIgdHlwZT1cImg0XCIvPlxuICAgICAgICAgICAgICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgIHsvZWFjaH1cbiAgICAgICAgPC91bD5cbiAgICA8L0NhcmQ+XG57L2lmfVxuXG48c3R5bGU+XG4gICAgbGkge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICBwYWRkaW5nOiAyMHB4O1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICB9XG5cbiAgICBsaTpub3QoOmxhc3QtY2hpbGQpIHtcbiAgICAgICAgYmFja2dyb3VuZC1pbWFnZTogbGluZWFyLWdyYWRpZW50KHRvIHJpZ2h0LCByZ2JhKHZhcigtLXRoZW1lLWNvbG9yLXByaW1hcnktb3Bwb3NpdGUpLCAwLjEpIDUwJSwgcmdiYSh2YXIoLS10aGVtZS1jb2xvci1wcmltYXJ5LW9wcG9zaXRlKSwgMCkgMCUpO1xuICAgICAgICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiBib3R0b207XG4gICAgICAgIGJhY2tncm91bmQtc2l6ZTogMjBweCAxcHg7XG4gICAgICAgIGJhY2tncm91bmQtcmVwZWF0OiByZXBlYXQteDtcbiAgICB9XG48L3N0eWxlPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyB0aWNrIH0gZnJvbSAnc3ZlbHRlJ1xuICAgIGltcG9ydCBEb25hdG9yc0NhcmQgZnJvbSAnLi9Eb25hdG9yc0NhcmQuc3ZlbHRlJ1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge3tcbiAgICAgKiAgaWQ6IHN0cmluZyxcbiAgICAgKiAgc3JjOiBzdHJpbmcsXG4gICAgICogIHRpdGxlOiBzdHJpbmcsXG4gICAgICogIHN1YnRpdGxlOiBzdHJpbmcsXG4gICAgICogIGNoZWNrZWQ6IGJvb2xlYW4sXG4gICAgICogfVtdfVxuICAgICAqL1xuICAgIGV4cG9ydCBsZXQgaXRlbXMgPSBuZXcgQXJyYXkoOCkuZmlsbCh7IHRpdGxlOiBudWxsLCBzdWJ0aXRsZTogbnVsbCB9KVxuXG4gICAgbGV0IGl0ZW1zUHJldiA9IFtdXG4gICAgbGV0IGNvbnRhaW5lciA9IG51bGxcbiAgICBsZXQgZ3JvdXBlZCA9IFtdXG4gICAgXG4gICAgJDogZ3JvdXBlZCA9IGl0ZW1zLnJldmVyc2UoKS5yZWR1Y2UoKGFjYywgaXRlbSkgPT4ge1xuICAgICAgICBjb25zdCBsYXN0SW5kID0gTWF0aC5tYXgoYWNjLmxlbmd0aCAtIDEsIDApXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhY2NbbGFzdEluZF0pKSB7XG4gICAgICAgICAgICBhY2NbbGFzdEluZF0gPSBbXVxuICAgICAgICB9XG4gICAgICAgIGlmIChhY2NbbGFzdEluZF0ubGVuZ3RoIDwgMykge1xuICAgICAgICAgICAgYWNjW2xhc3RJbmRdLnB1c2goaXRlbSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFjYy5wdXNoKFtdKVxuICAgICAgICAgICAgYWNjW2xhc3RJbmQgKyAxXS5wdXNoKGl0ZW0pXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjY1xuICAgIH0sIFtdKS5yZXZlcnNlKClcblxuICAgICQ6IG9uSXRlbXNDaGFuZ2UoaXRlbXMsIGNvbnRhaW5lcilcblxuICAgIGFzeW5jIGZ1bmN0aW9uIG9uSXRlbXNDaGFuZ2UoaXRlbXMsIGNvbnRhaW5lcikge1xuICAgICAgICBpZiAoaXRlbXMgJiYgaXRlbXMubGVuZ3RoICYmICEoaXRlbXNQcmV2ICYmIGl0ZW1zUHJldi5sZW5ndGgpKSB7XG4gICAgICAgICAgICBhd2FpdCB0aWNrKClcbiAgICAgICAgICAgIHNjcm9sbEVuZChjb250YWluZXIpXG4gICAgICAgIH1cbiAgICAgICAgaXRlbXNQcmV2ID0gaXRlbXNcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY3JvbGxFbmQobm9kZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbm9kZSAmJiBub2RlLnNjcm9sbFRvKG5vZGUuc2Nyb2xsV2lkdGgsIDApXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBUaGUgTWFnaWMgdG9sZCBtZSBcIiR7ZXJyLm1lc3NhZ2V9XCIuIEl0J3MgYSB3ZWlyZCByZWFzb24sIEkga25vdywgYnV0IEkgY291bGRuJ3Qgc2Nyb2xsIHRvIHRoZSBlbmQgb2YgJHtub2RlfSB3aXRoIGl0OiBgLCBlcnIpXG4gICAgICAgIH1cbiAgICB9XG48L3NjcmlwdD5cblxuPHVsIGNsYXNzPVwiZG9uYXRvcnMgc2Nyb2xsLXgtY2VudGVyXCIgYmluZDp0aGlzPXtjb250YWluZXJ9PlxuICAgIHsjZWFjaCBncm91cGVkIGFzIGNhcmRzfVxuICAgICAgICA8bGk+XG4gICAgICAgICAgICA8RG9uYXRvcnNDYXJkIGl0ZW1zPXtjYXJkc30vPlxuICAgICAgICA8L2xpPlxuICAgIHsvZWFjaH1cbjwvdWw+XG5cbjxzdHlsZT5cbiAgICB1bCB7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBhbGlnbi1pdGVtczogZmxleC1zdGFydDtcbiAgICAgICAgbWF4LXdpZHRoOiAxMDAlO1xuICAgICAgICBvdmVyZmxvdy15OiBoaWRkZW47XG4gICAgICAgIG92ZXJmbG93LXg6IGF1dG87XG4gICAgICAgIHBhZGRpbmc6IHZhcigtLXNjcmVlbi1wYWRkaW5nKSAwO1xuICAgIH1cblxuICAgIGxpIHtcbiAgICAgICAgZmxleDogbm9uZTtcbiAgICAgICAgYWxpZ24tc2VsZjogc3RyZXRjaDtcbiAgICAgICAgd2lkdGg6IDI2MHB4O1xuICAgICAgICBwYWRkaW5nOiAwIDVweDtcbiAgICB9XG5cbiAgICBsaTpmaXJzdC1jaGlsZCB7XG4gICAgICAgIHBhZGRpbmctbGVmdDogMTVweDtcbiAgICB9XG5cbiAgICBsaTpsYXN0LWNoaWxkIHtcbiAgICAgICAgcGFkZGluZy1yaWdodDogMTVweDtcbiAgICB9XG48L3N0eWxlPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBjcmVhdGVFdmVudERpc3BhdGNoZXIgfSBmcm9tICdzdmVsdGUnXG4gICAgaW1wb3J0IHsgY2xhc3NuYW1lcyB9IGZyb20gJ0B1dGlscydcbiAgICBpbXBvcnQgQnIgZnJvbSAnQGNvbXBvbmVudHMvQnIuc3ZlbHRlJ1xuICAgIGltcG9ydCBJY29uIGZyb20gJ0Bjb21wb25lbnRzL0ljb24uc3ZlbHRlJ1xuICAgIGltcG9ydCBDYXJkIGZyb20gJ0Bjb21wb25lbnRzL0NhcmQuc3ZlbHRlJ1xuICAgIGltcG9ydCBCdXR0b24gZnJvbSAnQGNvbXBvbmVudHMvQnV0dG9uLnN2ZWx0ZSdcbiAgICBpbXBvcnQgUGljdHVyZSBmcm9tICdAY29tcG9uZW50cy9QaWN0dXJlLnN2ZWx0ZSdcbiAgICBpbXBvcnQgTG9hZGVyIGZyb20gJ0Bjb21wb25lbnRzL2xvYWRlcidcblxuICAgIGNvbnN0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKClcblxuICAgIGV4cG9ydCBsZXQgc3JjID0gbnVsbFxuICAgIGV4cG9ydCBsZXQgZGF0ZSA9IG51bGxcbiAgICBleHBvcnQgbGV0IHRpdGxlID0gbnVsbFxuICAgIGV4cG9ydCBsZXQgbGlrZXMgPSBudWxsXG4gICAgZXhwb3J0IGxldCBpc0xpa2VkID0gbnVsbFxuICAgIGV4cG9ydCBsZXQgc3VidGl0bGUgPSBudWxsXG5cbiAgICAkOiBjbGFzc1Byb3AgPSBjbGFzc25hbWVzKCQkcHJvcHMuY2xhc3MpXG48L3NjcmlwdD5cblxuPENhcmQgY2xhc3M9e2NsYXNzUHJvcH0+XG4gICAgPHNlY3Rpb24gY2xhc3M9XCJuZXdzLWl0ZW0gZmxleFwiPlxuXG4gICAgICAgIDxkaXYgY2xhc3M9XCJmbGV4IGZsZXgtbm9uZSByZWxhdGl2ZVwiIHN0eWxlPVwid2lkdGg6IDExMHB4XCI+XG4gICAgICAgICAgICA8UGljdHVyZSBzcmM9e3NyY30gYWx0PXt0aXRsZX0vPlxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8ZGl2IGNsYXNzPVwiZmxleCBmbGV4LWNvbHVtbiBmbGV4LTEgY29udGFpbmVyIG92ZXJmbG93LWhpZGRlblwiIHN0eWxlPVwicGFkZGluZy10b3A6IDIwcHg7IHBhZGRpbmctYm90dG9tOiA1cHhcIj5cblxuICAgICAgICAgICAgeyNpZiB0aXRsZSAhPT0gbnVsbH1cbiAgICAgICAgICAgICAgICA8aDMgY2xhc3M9XCJmb250LXctNTAwIHRleHQtZWxsaXBzaXMtbXVsdGlsaW5lXCIgc3R5bGU9XCItLW1heC1saW5lczogMlwiPnsgdGl0bGUgfTwvaDM+XG4gICAgICAgICAgICB7OmVsc2V9XG4gICAgICAgICAgICAgICAgPGRpdiBzdHlsZT1cIndpZHRoOiA4MCVcIj48TG9hZGVyIHR5cGU9XCJoM1wiLz48L2Rpdj5cbiAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPVwid2lkdGg6IDgwJVwiPjxMb2FkZXIgdHlwZT1cImgzXCIvPjwvZGl2PlxuICAgICAgICAgICAgey9pZn1cblxuICAgICAgICAgICAgPEJyIHNpemU9XCIxMFwiLz5cblxuICAgICAgICAgICAgeyNpZiBzdWJ0aXRsZSAhPT0gbnVsbH1cbiAgICAgICAgICAgICAgICA8cCBjbGFzcz1cImZvbnQtdy0zMDAgdGV4dC1lbGxpcHNpcy1tdWx0aWxpbmVcIiBzdHlsZT1cIi0tbWF4LWxpbmVzOiAzXCI+eyBzdWJ0aXRsZSB9PC9wPlxuICAgICAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9XCJ3aWR0aDogMTAwJVwiPjxMb2FkZXIgdHlwZT1cInBcIi8+PC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdiBzdHlsZT1cIndpZHRoOiAxMDAlXCI+PExvYWRlciB0eXBlPVwicFwiLz48L2Rpdj5cbiAgICAgICAgICAgIHsvaWZ9XG5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmbGV4IGZsZXgtYWxpZ24tY2VudGVyIGZsZXgtanVzdGlmeS1iZXR3ZWVuXCI+XG4gICAgICAgICAgICAgICAgPHA+XG4gICAgICAgICAgICAgICAgICAgIHsjaWYgZGF0ZSAhPT0gbnVsbH1cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaDRcIiBzdHlsZT1cIm9wYWNpdHk6IC4zXCI+eyBkYXRlIH08L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgIHs6ZWxzZX1cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9XCJ3aWR0aDogNjAlXCI+PExvYWRlciB0eXBlPVwiaDRcIi8+PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICAgICAgPC9wPlxuICAgICAgICAgICAgICAgIDxzPjwvcz5cbiAgICAgICAgICAgICAgICA8cz48L3M+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJoNSBmbGV4IGZsZXgtYWxpZ24tY2VudGVyIGZvbnQtc2Vjb25kYXJ5XCIgc3R5bGU9XCJtaW4td2lkdGg6IDRlbVwiPlxuICAgICAgICAgICAgICAgICAgICA8QnV0dG9uIHNpemU9XCJtZWRpdW1cIiBvbjpjbGljaz17KGUpID0+IGRpc3BhdGNoKCdvbkxpa2UnLCAhaXNMaWtlZCl9PlxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gc3R5bGU9e2BvcGFjaXR5OiAke2lzTGlrZWQgPyAxIDogLjV9YH0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPEljb24gdHlwZT1cImhlYXJ0XCIgaXM9XCJkYW5nZXJcIiBzaXplPVwic21hbGxcIi8+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICA8cz48L3M+XG4gICAgICAgICAgICAgICAgICAgICAgICA8cz48L3M+XG4gICAgICAgICAgICAgICAgICAgICAgICB7I2lmIGxpa2VzICE9PSBudWxsfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxoND57IGxpa2VzIH08L2g0PlxuICAgICAgICAgICAgICAgICAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaDQgcmVsYXRpdmVcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gc3R5bGU9XCJ2aXNpYmlsaXR5OiBoaWRkZW5cIj4xOTk8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxMb2FkZXIgdHlwZT1cImg0XCIgYWJzb2x1dGUvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj4gIFxuICAgICAgICAgICAgICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgPC9zZWN0aW9uPlxuPC9DYXJkPlxuXG48c3R5bGU+XG48L3N0eWxlPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBjcmVhdGVFdmVudERpc3BhdGNoZXIgfSBmcm9tICdzdmVsdGUnXG4gICAgaW1wb3J0IHsgb25Nb3VudCB9IGZyb20gJ3N2ZWx0ZSdcbiAgICBpbXBvcnQgeyBBUEksIERhdGVzIH0gZnJvbSAnQHNlcnZpY2VzJ1xuICAgIFxuICAgIGltcG9ydCBCciBmcm9tICdAY29tcG9uZW50cy9Cci5zdmVsdGUnXG4gICAgaW1wb3J0IEljb24gZnJvbSAnQGNvbXBvbmVudHMvSWNvbi5zdmVsdGUnXG4gICAgaW1wb3J0IEJ1dHRvbiBmcm9tICdAY29tcG9uZW50cy9CdXR0b24uc3ZlbHRlJ1xuICAgIGltcG9ydCBOZXdzSXRlbSBmcm9tICcuL05ld3NJdGVtLnN2ZWx0ZSdcblxuICAgIGNvbnN0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKClcbiAgIFxuICAgLyoqXG4gICAgKiBAdHlwZSB7e1xuICAgICogICBpZDogc3RyaW5nLFxuICAgICogICBzcmM6IHN0cmluZyxcbiAgICAqICAgbGlrZXM6IG51bWJlcixcbiAgICAqICAgdGl0bGU6IHN0cmluZyxcbiAgICAqICAgc3VidGl0bGU6IHN0cmluZyxcbiAgICAqICAgY3JlYXRlZF9hdDogc3RyaW5nLFxuICAgICogfX1cbiAgICAqL1xuICAgIGV4cG9ydCBsZXQgaXRlbXMgPSBuZXcgQXJyYXkoMykuZmlsbCh7IHRpdGxlOiBudWxsLCBzdWJ0aXRsZTogbnVsbCwgY3JlYXRlZF9hdDogbnVsbCwgbGlrZXM6IG51bGwgfSlcbjwvc2NyaXB0PlxuXG48c2VjdGlvbiBjbGFzcz1cIm5ld3MtbGlzdFwiPlxuICAgIDx1bCBjbGFzcz1cIm5ld3MtbGlzdC13cmFwXCI+XG4gICAgICAgIHsjZWFjaCBpdGVtcyBhcyBpdGVtLCBpbmRleH1cbiAgICAgICAgICAgIDxsaSByb2xlPVwiYnV0dG9uXCIgb246Y2xpY2s9eygpID0+IGRpc3BhdGNoKCdjbGljaycsIHsgaXRlbSwgaW5kZXggfSl9IGtleT17aXRlbS5pZH0+XG4gICAgICAgICAgICAgICAgPE5ld3NJdGVtXG4gICAgICAgICAgICAgICAgICAgICAgICBzcmM9e2l0ZW0uc3JjfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU9e2l0ZW0udGl0bGV9XG4gICAgICAgICAgICAgICAgICAgICAgICBsaWtlcz17aXRlbS5saWtlc31cbiAgICAgICAgICAgICAgICAgICAgICAgIGlzTGlrZWQ9e2l0ZW0uaXNMaWtlZH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnRpdGxlPXtpdGVtLnN1YnRpdGxlfVxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZT17aXRlbS5jcmVhdGVkX2F0ID09PSBudWxsID8gbnVsbCA6IERhdGVzKGl0ZW0uY3JlYXRlZF9hdCkuZnJvbU5vdygpfVxuICAgICAgICAgICAgICAgIC8+XG5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImFycm93XCI+XG4gICAgICAgICAgICAgICAgICAgIDxJY29uIHR5cGU9XCJhcnJvdy1yaWdodFwiIHNpemU9XCJzbWFsbFwiIGlzPVwiaW5mb1wiLz5cbiAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICA8L2xpPlxuICAgICAgICB7L2VhY2h9XG4gICAgPC91bD5cblxuICAgIDxCciBzaXplPVwiMjBcIi8+ICBcblxuICAgIDxwIGNsYXNzPVwiaDMgZm9udC13LTUwMCBmb250LXNlY29uZGFyeSB1bmRlcmxpbmUgdGV4dC1jZW50ZXJcIj5cbiAgICAgICAgPHNwYW4+0JLRgdGWINC90L7QstC40L3QuDwvc3Bhbj5cbiAgICAgICAgPEljb24gdHlwZT1cImNhcmV0LWRvd25cIiBzaXplPVwic21hbGxcIi8+XG4gICAgPC9wPlxuPC9zZWN0aW9uPlxuXG48c3R5bGU+XG4gICAgLm5ld3MtbGlzdCB7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBmbGV4LWdyb3c6IDE7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIG92ZXJmbG93LXk6IGF1dG87XG4gICAgICAgIG92ZXJmbG93LXg6IGhpZGRlbjtcbiAgICAgICAgYWxpZ24tc2VsZjogc3RyZXRjaDtcbiAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICB9XG5cbiAgICAubmV3cy1saXN0LXdyYXAge1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgbWFyZ2luOiAtNXB4IDA7XG4gICAgfVxuXG4gICAgLm5ld3MtbGlzdC13cmFwIGxpIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgcGFkZGluZzogNXB4IDA7XG4gICAgfVxuXG4gICAgLmFycm93IHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IDhweDtcbiAgICAgICAgcmlnaHQ6IDE1cHg7XG4gICAgICAgIGNvbG9yOiByZ2JhKHZhcigtLWNvbG9yLWluZm8pKTtcbiAgICB9XG48L3N0eWxlPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgQnIgZnJvbSAnQGNvbXBvbmVudHMvQnIuc3ZlbHRlJ1xuICAgIGltcG9ydCBJY29uIGZyb20gJ0Bjb21wb25lbnRzL0ljb24uc3ZlbHRlJ1xuICAgIGltcG9ydCBDYXJkIGZyb20gJ0Bjb21wb25lbnRzL0NhcmQuc3ZlbHRlJ1xuICAgIGltcG9ydCBMb2FkZXIgZnJvbSAnQGNvbXBvbmVudHMvbG9hZGVyJ1xuICAgIGltcG9ydCBCdXR0b24gZnJvbSAnQGNvbXBvbmVudHMvQnV0dG9uLnN2ZWx0ZSdcbiAgICBpbXBvcnQgUHJvZ3Jlc3MgZnJvbSAnQGNvbXBvbmVudHMvUHJvZ3Jlc3Muc3ZlbHRlJ1xuICAgIGltcG9ydCBGYW5jeUJveCBmcm9tICdAY29tcG9uZW50cy9GYW5jeUJveC5zdmVsdGUnXG4gICAgaW1wb3J0IENhcm91c2VsIGZyb20gJ0Bjb21wb25lbnRzL0Nhcm91c2VsLnN2ZWx0ZSdcblxuICAgIGV4cG9ydCBsZXQgc3JjID0gbnVsbFxuICAgIGV4cG9ydCBsZXQgY2l0eSA9IG51bGxcbiAgICBleHBvcnQgbGV0IHRpdGxlID0gbnVsbFxuICAgIGV4cG9ydCBsZXQgdG90YWwgPSBudWxsXG4gICAgZXhwb3J0IGxldCBjdXJyZW50ID0gbnVsbFxuICAgIGV4cG9ydCBsZXQgY3VycmVuY3kgPSBudWxsXG48L3NjcmlwdD5cblxuPENhcmQgY2xhc3M9XCJmbGV4IGZsZXgtY29sdW1uXCI+XG4gICAgXG4gICAgPGRpdiBzdHlsZT1cImhlaWdodDogMTYwcHhcIiBjbGFzcz1cImZsZXggZmxleC1ub25lXCI+XG4gICAgICAgIDxDYXJvdXNlbCBcbiAgICAgICAgICAgIGl0ZW1zPXtbeyBzcmMsIGFsdDogdGl0bGUgfSwgeyBzcmMsIGFsdDogdGl0bGUgfSwgeyBzcmMsIGFsdDogdGl0bGUgfV19XG4gICAgICAgICAgICBkaXNhYmxlRmFuY3k9e3RydWV9XG4gICAgICAgICAgICBkb3RzQmVsb3c9e2ZhbHNlfVxuICAgICAgICAgICAgcm91bmRlZD17ZmFsc2V9XG4gICAgICAgICAgICBzdG9wUHJvcGFnYXRpb249e3RydWV9XG4gICAgICAgIC8+ICAgIFxuICAgIDwvZGl2PlxuXG4gICAgPHNlY3Rpb24gY2xhc3M9XCJjb250YWluZXIgZmxleCBmbGV4LWNvbHVtbiBmbGV4LWp1c3RpZnktYmV0d2VlbiBmbGV4LTFcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImZsZXgtbm9uZSBvdmVyZmxvdy1oaWRkZW5cIiBzdHlsZT1cImhlaWdodDogY2FsYygyICogdmFyKC0tZm9udC1saW5lLWhlaWdodC1oMikgKyB2YXIoLS1mb250LWxpbmUtaGVpZ2h0KSArIDIwcHggKyA1cHggKyAxMHB4KVwiPlxuICAgICAgICAgICAgPEJyIHNpemU9XCIyMFwiLz4gICAgIFxuXG4gICAgICAgICAgICB7I2lmIHRpdGxlICE9PSBudWxsfVxuICAgICAgICAgICAgICAgIDxoMiBjbGFzcz1cInRleHQtZWxsaXBzaXMtbXVsdGlsaW5lXCIgc3R5bGU9XCItLW1heC1saW5lczogMlwiPlxuICAgICAgICAgICAgICAgICAgICB7dGl0bGV9XG4gICAgICAgICAgICAgICAgPC9oMj5cbiAgICAgICAgICAgIHs6ZWxzZX1cbiAgICAgICAgICAgICAgICA8TG9hZGVyIHR5cGU9XCJoMlwiIC8+XG4gICAgICAgICAgICAgICAgPExvYWRlciB0eXBlPVwiaDJcIiAvPlxuICAgICAgICAgICAgey9pZn1cblxuICAgICAgICAgICAgPEJyIHNpemU9XCI1XCIvPiAgICAgXG5cbiAgICAgICAgICAgIHsjaWYgY2l0eSAhPT0gbnVsbH1cbiAgICAgICAgICAgICAgICA8cCBjbGFzcz1cImZsZXggZmxleC1hbGlnbi1jZW50ZXIgZm9udC1zZWNvbmRhcnkgZm9udC13LTUwMFwiIHN0eWxlPVwib3BhY2l0eTogLjc7IG1hcmdpbi1sZWZ0OiAtMnB4XCI+XG4gICAgICAgICAgICAgICAgICAgIDxJY29uIHR5cGU9XCJsb2NhdGlvblwiIHNpemU9XCJzbWFsbFwiLz5cbiAgICAgICAgICAgICAgICAgICAgPHM+PC9zPlxuICAgICAgICAgICAgICAgICAgICA8c3Bhbj57Y2l0eX08L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9wPlxuICAgICAgICAgICAgICAgIDxCciBzaXplPVwiMTBcIi8+ICAgICBcbiAgICAgICAgICAgIHs6ZWxzZX1cbiAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPVwid2lkdGg6IDQwJVwiPjxMb2FkZXIgdHlwZT1cInBcIiAvPjwvZGl2PlxuICAgICAgICAgICAgey9pZn1cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPGRpdj5cbiAgICAgICAgICAgIDxwIGNsYXNzPVwiZm9udC1zZWNvbmRhcnkgZmxleCBmbGV4LXdyYXAgZmxleC1hbGlnbi1lbmRcIiBzdHlsZT1cImxldHRlci1zcGFjaW5nOiAtMC41cHhcIj5cbiAgICAgICAgICAgICAgICB7I2lmIGN1cnJlbnQgIT09IG51bGwgJiYgdG90YWwgIT09IG51bGx9XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaDEgZm9udC13LTUwMFwiPntjdXJyZW5jeX0ge2N1cnJlbnR9PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICA8cz48L3M+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaDRcIj4vIHtjdXJyZW5jeX0ge3RvdGFsfTwvc3Bhbj5cbiAgICAgICAgICAgICAgICB7OmVsc2V9XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9XCJ3aWR0aDogODAlOyBmbGV4OiBub25lXCI+PExvYWRlciB0eXBlPVwiaDFcIiAvPjwvZGl2PlxuICAgICAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICA8L3A+XG5cbiAgICAgICAgICAgIDxCciBzaXplPVwiMjBcIi8+ICBcbiAgICAgICAgICAgIDxQcm9ncmVzcyB2YWx1ZT17TWF0aC5mbG9vcihjdXJyZW50IC8gdG90YWwgKiAxMDApfS8+XG4gICAgICAgICAgICA8QnIgc2l6ZT1cIjQwXCIvPiAgXG5cbiAgICAgICAgICAgIDxzbG90IG5hbWU9XCJidXR0b25cIj48L3Nsb3Q+XG5cbiAgICAgICAgICAgIDxCciBzaXplPVwiMzBcIi8+ICAgICBcbiAgICAgICAgPC9kaXY+XG4gICAgPC9zZWN0aW9uPlxuPC9DYXJkPlxuXG48c3R5bGU+XG48L3N0eWxlPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgQ2Fyb3VzZWwgZnJvbSAnQGNvbXBvbmVudHMvQ2Fyb3VzZWwuc3ZlbHRlJ1xuICAgIGltcG9ydCBCdXR0b24gZnJvbSAnQGNvbXBvbmVudHMvQnV0dG9uLnN2ZWx0ZSdcbiAgICBpbXBvcnQgRnVuZENhcmQgZnJvbSAnLi9GdW5kQ2FyZC5zdmVsdGUnXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7e1xuICAgICAqICBpZDogc3RyaW5nLFxuICAgICAqICBzcmM6IHN0cmluZyxcbiAgICAgKiAgdG90YWw6IG51bWJlcixcbiAgICAgKiAgY3VycmVudDogbnVtYmVyLFxuICAgICAqICBjdXJyZW5jeTogc3RyaW5nLFxuICAgICAqICBjaXR5OiBzdHJpbmcsXG4gICAgICogIHRpdGxlOiBzdHJpbmcsXG4gICAgICogfX1cbiAgICAgKi9cbiAgICBleHBvcnQgbGV0IGl0ZW1zID0gW3t9LCB7fSwge31dXG48L3NjcmlwdD5cblxuPENhcm91c2VsIHtpdGVtc30gc2l6ZT1cImF1dG9cIiBsZXQ6aW5kZXg9e2luZGV4fSBsZXQ6aXRlbT17aXRlbX0gY2xhc3M9XCJjaGFyaXRpZXNcIj5cbiAgICA8ZGl2IGNsYXNzPXshaW5kZXggPyAnc3RhcnQnIDogaW5kZXggPT09IGl0ZW1zLmxlbmd0aCAtIDEgPyAnZW5kJyA6ICcnfSBrZXk9e2l0ZW0uaWR9PlxuICAgICAgICA8RnVuZENhcmRcbiAgICAgICAgICAgIHNyYz17aXRlbS5zcmN9XG4gICAgICAgICAgICB0b3RhbD17aXRlbS50b3RhbH1cbiAgICAgICAgICAgIGN1cnJlbnQ9e2l0ZW0uY3VycmVudH1cbiAgICAgICAgICAgIGN1cnJlbmN5PXtpdGVtLmN1cnJlbmN5fVxuICAgICAgICAgICAgY2l0eT17aXRlbS5jaXR5fVxuICAgICAgICAgICAgdGl0bGU9e2l0ZW0udGl0bGV9XG4gICAgICAgID5cbiAgICAgICAgICAgIDxzcGFuIHNsb3Q9XCJidXR0b25cIiBsZXQ6aWQ9e2lkfT5cbiAgICAgICAgICAgICAgICA8c2xvdCBuYW1lPVwiYnV0dG9uXCI+XG4gICAgICAgICAgICAgICAgICAgIDxCdXR0b24gc2l6ZT1cImJpZ1wiIGlzPVwic3VjY2Vzc1wiIGhyZWY9e2lkfT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaDIgZm9udC1zZWNvbmRhcnkgZm9udC13LTYwMFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgINCU0L7Qv9C+0LzQvtCz0YLQuFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgICAgICAgICA8L3Nsb3Q+XG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgIDwvRnVuZENhcmQ+XG4gICAgPC9kaXY+XG48L0Nhcm91c2VsPlxuXG48c3R5bGU+XG4gICAgOmdsb2JhbCguY2hhcml0aWVzLmFjdGl2ZSAuc2Nyb2xsLXgtY2VudGVyID4gKikge1xuICAgICAgICB0cmFuc2Zvcm06IG5vbmVcbiAgICB9XG4gICAgZGl2IHtcbiAgICAgICAgZmxleDogbm9uZTtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgYWxpZ24tc2VsZjogc3RyZXRjaDtcbiAgICAgICAgaGVpZ2h0OiA1MDBweDtcbiAgICAgICAgd2lkdGg6IDc3dnc7XG4gICAgICAgIG1heC13aWR0aDogMzUwcHg7XG4gICAgICAgIHBhZGRpbmc6IDE1cHggNXB4O1xuICAgICAgICBib3gtc2l6aW5nOiBjb250ZW50LWJveDtcbiAgICB9XG5cbiAgICBkaXYuc3RhcnQge1xuICAgICAgICBwYWRkaW5nLWxlZnQ6IHZhcigtLXNjcmVlbi1wYWRkaW5nKTtcbiAgICB9XG5cbiAgICBkaXYuZW5kIHtcbiAgICAgICAgcGFkZGluZy1yaWdodDogdmFyKC0tc2NyZWVuLXBhZGRpbmcpO1xuICAgIH1cbjwvc3R5bGU+XG4iLCI8c2NyaXB0PlxuXHRpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSAnc3ZlbHRlJztcblx0aW1wb3J0IHsgSGVhZGVyLCBPZmZsaW5lTWVzc2FnZSB9IGZyb20gJ0Bjb21wb25lbnRzJztcblx0aW1wb3J0IHsgU3RvcmFnZXMgfSBmcm9tICdAc2VydmljZXMnXG5cdGltcG9ydCB7IHNhZmVHZXQsIGRpc2FibGVEb3VibGVUYXBab29tLCBjbGFzc25hbWVzIH0gZnJvbSAnQHV0aWxzJ1xuXG5cdGV4cG9ydCBsZXQgc2VnbWVudDtcblxuXHRsZXQgdGhlbWUgPSBzYWZlR2V0KCgpID0+IFN0b3JhZ2VzLmNvb2tpZVN0b3JhZ2UuZ2V0KCd0aGVtZScpIHx8IFN0b3JhZ2VzLmxvY2FsU3RvcmFnZS5nZXQoJ3RoZW1lJykpXG5cblx0JDogY2xhc3NQcm9wID0gY2xhc3NuYW1lcygndGhlbWUtYmctY29sb3Itc2Vjb25kYXJ5JywgdGhlbWUpXG5cblx0b25Nb3VudCgoKSA9PiB7XG5cdFx0ZGlzYWJsZURvdWJsZVRhcFpvb20oW2RvY3VtZW50XSlcblx0fSlcbjwvc2NyaXB0PlxuXG48bWFpbiBpZD1cIm1haW5cIiBjbGFzcz17Y2xhc3NQcm9wfT5cblx0PEhlYWRlciB7c2VnbWVudH0vPlxuXG5cdDxzZWN0aW9uIGNsYXNzPVwicGFnZXNcIj5cblx0XHQ8c2xvdD48L3Nsb3Q+XG5cdDwvc2VjdGlvbj5cblxuXHQ8T2ZmbGluZU1lc3NhZ2UvPlxuPC9tYWluPlxuXG5cbiIsIjxzY3JpcHQ+XG5cdGV4cG9ydCBsZXQgc3RhdHVzO1xuXHRleHBvcnQgbGV0IGVycm9yO1xuXG5cdGNvbnN0IGRldiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnO1xuPC9zY3JpcHQ+XG5cbjxzdHlsZT5cbjwvc3R5bGU+XG5cbjxzdmVsdGU6aGVhZD5cblx0PHRpdGxlPkVycm9yOiB7c3RhdHVzfTwvdGl0bGU+XG48L3N2ZWx0ZTpoZWFkPlxuXG48YnI+XG48YnI+XG48YnI+XG48YnI+XG48ZGl2IGNsYXNzPVwidGV4dC1jZW50ZXJcIj5cblx0PGgxPtC+0Lkg8J+ZgzwvaDE+XG48L2Rpdj5cbjxkaXYgaGlkZGVuIGNsYXNzPVwidGV4dC1jZW50ZXJcIj5cblx0PGgxPkVycm9yOiB7c3RhdHVzfTwvaDE+XG5cdDxicj5cblx0PHA+UmVhc29uOiB7ZXJyb3IubWVzc2FnZX08L3A+XG48L2Rpdj5cbjxicj5cbjxicj5cbiIsIjwhLS0gVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBieSBTYXBwZXIg4oCUIGRvIG5vdCBlZGl0IGl0ISAtLT5cbjxzY3JpcHQ+XG5cdGltcG9ydCB7IHNldENvbnRleHQsIGFmdGVyVXBkYXRlIH0gZnJvbSAnc3ZlbHRlJztcblx0aW1wb3J0IHsgQ09OVEVYVF9LRVkgfSBmcm9tICcuL3NoYXJlZCc7XG5cdGltcG9ydCBMYXlvdXQgZnJvbSAnLi4vLi4vLi4vcm91dGVzL19sYXlvdXQuc3ZlbHRlJztcblx0aW1wb3J0IEVycm9yIGZyb20gJy4uLy4uLy4uL3JvdXRlcy9fZXJyb3Iuc3ZlbHRlJztcblxuXHRleHBvcnQgbGV0IHN0b3Jlcztcblx0ZXhwb3J0IGxldCBlcnJvcjtcblx0ZXhwb3J0IGxldCBzdGF0dXM7XG5cdGV4cG9ydCBsZXQgc2VnbWVudHM7XG5cdGV4cG9ydCBsZXQgbGV2ZWwwO1xuXHRleHBvcnQgbGV0IGxldmVsMSA9IG51bGw7XG5cdGV4cG9ydCBsZXQgbGV2ZWwyID0gbnVsbDtcblx0ZXhwb3J0IGxldCBub3RpZnk7XG5cblx0YWZ0ZXJVcGRhdGUobm90aWZ5KTtcblx0c2V0Q29udGV4dChDT05URVhUX0tFWSwgc3RvcmVzKTtcbjwvc2NyaXB0PlxuXG48TGF5b3V0IHNlZ21lbnQ9XCJ7c2VnbWVudHNbMF19XCIgey4uLmxldmVsMC5wcm9wc30+XG5cdHsjaWYgZXJyb3J9XG5cdFx0PEVycm9yIHtlcnJvcn0ge3N0YXR1c30vPlxuXHR7OmVsc2V9XG5cdFx0PHN2ZWx0ZTpjb21wb25lbnQgdGhpcz1cIntsZXZlbDEuY29tcG9uZW50fVwiIHNlZ21lbnQ9XCJ7c2VnbWVudHNbMV19XCIgey4uLmxldmVsMS5wcm9wc30+XG5cdFx0XHR7I2lmIGxldmVsMn1cblx0XHRcdFx0PHN2ZWx0ZTpjb21wb25lbnQgdGhpcz1cIntsZXZlbDIuY29tcG9uZW50fVwiIHsuLi5sZXZlbDIucHJvcHN9Lz5cblx0XHRcdHsvaWZ9XG5cdFx0PC9zdmVsdGU6Y29tcG9uZW50PlxuXHR7L2lmfVxuPC9MYXlvdXQ+IiwiLy8gVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBieSBTYXBwZXIg4oCUIGRvIG5vdCBlZGl0IGl0IVxuZXhwb3J0IHsgZGVmYXVsdCBhcyBSb290IH0gZnJvbSAnLi4vLi4vLi4vcm91dGVzL19sYXlvdXQuc3ZlbHRlJztcbmV4cG9ydCB7IHByZWxvYWQgYXMgcm9vdF9wcmVsb2FkIH0gZnJvbSAnLi9zaGFyZWQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBFcnJvckNvbXBvbmVudCB9IGZyb20gJy4uLy4uLy4uL3JvdXRlcy9fZXJyb3Iuc3ZlbHRlJztcblxuZXhwb3J0IGNvbnN0IGlnbm9yZSA9IFsvXlxcL29yZ2FuaXphdGlvbnNcXC9jb21wb25lbnRzXFwvPyQvLCAvXlxcL29yZ2FuaXphdGlvbnNcXC9lZGl0XFwvPyQvLCAvXlxcL29yZ2FuaXphdGlvbnNcXC92aWV3XFwvPyQvLCAvXlxcL2Z1bmRzXFwvY29tcG9uZW50c1xcLz8kLywgL15cXC9mdW5kc1xcL2VkaXRcXC8/JC8sIC9eXFwvZnVuZHNcXC92aWV3XFwvPyQvLCAvXlxcL2xpc3RzXFwvY29tcG9uZW50c1xcLz8kL107XG5cbmV4cG9ydCBjb25zdCBjb21wb25lbnRzID0gW1xuXHR7XG5cdFx0anM6ICgpID0+IGltcG9ydChcIi4uLy4uLy4uL3JvdXRlcy9pbmRleC5zdmVsdGVcIiksXG5cdFx0Y3NzOiBcIl9fU0FQUEVSX0NTU19QTEFDRUhPTERFUjppbmRleC5zdmVsdGVfX1wiXG5cdH0sXG5cdHtcblx0XHRqczogKCkgPT4gaW1wb3J0KFwiLi4vLi4vLi4vcm91dGVzL29yZ2FuaXphdGlvbnMvW2lkXS5zdmVsdGVcIiksXG5cdFx0Y3NzOiBcIl9fU0FQUEVSX0NTU19QTEFDRUhPTERFUjpvcmdhbml6YXRpb25zL1tpZF0uc3ZlbHRlX19cIlxuXHR9LFxuXHR7XG5cdFx0anM6ICgpID0+IGltcG9ydChcIi4uLy4uLy4uL3JvdXRlcy9mdW5kcy9baWRdLnN2ZWx0ZVwiKSxcblx0XHRjc3M6IFwiX19TQVBQRVJfQ1NTX1BMQUNFSE9MREVSOmZ1bmRzL1tpZF0uc3ZlbHRlX19cIlxuXHR9LFxuXHR7XG5cdFx0anM6ICgpID0+IGltcG9ydChcIi4uLy4uLy4uL3JvdXRlcy9saXN0cy9fbGF5b3V0LnN2ZWx0ZVwiKSxcblx0XHRjc3M6IFwiX19TQVBQRVJfQ1NTX1BMQUNFSE9MREVSOmxpc3RzL19sYXlvdXQuc3ZlbHRlX19cIlxuXHR9LFxuXHR7XG5cdFx0anM6ICgpID0+IGltcG9ydChcIi4uLy4uLy4uL3JvdXRlcy9saXN0cy9pbmRleC5zdmVsdGVcIiksXG5cdFx0Y3NzOiBcIl9fU0FQUEVSX0NTU19QTEFDRUhPTERFUjpsaXN0cy9pbmRleC5zdmVsdGVfX1wiXG5cdH0sXG5cdHtcblx0XHRqczogKCkgPT4gaW1wb3J0KFwiLi4vLi4vLi4vcm91dGVzL2xpc3RzL29yZ2FuaXphdGlvbnMuc3ZlbHRlXCIpLFxuXHRcdGNzczogXCJfX1NBUFBFUl9DU1NfUExBQ0VIT0xERVI6bGlzdHMvb3JnYW5pemF0aW9ucy5zdmVsdGVfX1wiXG5cdH0sXG5cdHtcblx0XHRqczogKCkgPT4gaW1wb3J0KFwiLi4vLi4vLi4vcm91dGVzL2xpc3RzL2Z1bmRzLnN2ZWx0ZVwiKSxcblx0XHRjc3M6IFwiX19TQVBQRVJfQ1NTX1BMQUNFSE9MREVSOmxpc3RzL2Z1bmRzLnN2ZWx0ZV9fXCJcblx0fSxcblx0e1xuXHRcdGpzOiAoKSA9PiBpbXBvcnQoXCIuLi8uLi8uLi9yb3V0ZXMvdXNlcnMvaW5kZXguc3ZlbHRlXCIpLFxuXHRcdGNzczogXCJfX1NBUFBFUl9DU1NfUExBQ0VIT0xERVI6dXNlcnMvaW5kZXguc3ZlbHRlX19cIlxuXHR9LFxuXHR7XG5cdFx0anM6ICgpID0+IGltcG9ydChcIi4uLy4uLy4uL3JvdXRlcy91c2Vycy9tZS5zdmVsdGVcIiksXG5cdFx0Y3NzOiBcIl9fU0FQUEVSX0NTU19QTEFDRUhPTERFUjp1c2Vycy9tZS5zdmVsdGVfX1wiXG5cdH0sXG5cdHtcblx0XHRqczogKCkgPT4gaW1wb3J0KFwiLi4vLi4vLi4vcm91dGVzL3VzZXJzL1tpZF0uc3ZlbHRlXCIpLFxuXHRcdGNzczogXCJfX1NBUFBFUl9DU1NfUExBQ0VIT0xERVI6dXNlcnMvW2lkXS5zdmVsdGVfX1wiXG5cdH0sXG5cdHtcblx0XHRqczogKCkgPT4gaW1wb3J0KFwiLi4vLi4vLi4vcm91dGVzL21hcC9pbmRleC5zdmVsdGVcIiksXG5cdFx0Y3NzOiBcIl9fU0FQUEVSX0NTU19QTEFDRUhPTERFUjptYXAvaW5kZXguc3ZlbHRlX19cIlxuXHR9LFxuXHR7XG5cdFx0anM6ICgpID0+IGltcG9ydChcIi4uLy4uLy4uL3JvdXRlcy9tYXAvW2lkXS5zdmVsdGVcIiksXG5cdFx0Y3NzOiBcIl9fU0FQUEVSX0NTU19QTEFDRUhPTERFUjptYXAvW2lkXS5zdmVsdGVfX1wiXG5cdH1cbl07XG5cbmV4cG9ydCBjb25zdCByb3V0ZXMgPSAoZCA9PiBbXG5cdHtcblx0XHQvLyBpbmRleC5zdmVsdGVcblx0XHRwYXR0ZXJuOiAvXlxcLyQvLFxuXHRcdHBhcnRzOiBbXG5cdFx0XHR7IGk6IDAgfVxuXHRcdF1cblx0fSxcblxuXHR7XG5cdFx0Ly8gb3JnYW5pemF0aW9ucy9baWRdLnN2ZWx0ZVxuXHRcdHBhdHRlcm46IC9eXFwvb3JnYW5pemF0aW9uc1xcLyhbXlxcL10rPylcXC8/JC8sXG5cdFx0cGFydHM6IFtcblx0XHRcdG51bGwsXG5cdFx0XHR7IGk6IDEsIHBhcmFtczogbWF0Y2ggPT4gKHsgaWQ6IGQobWF0Y2hbMV0pIH0pIH1cblx0XHRdXG5cdH0sXG5cblx0e1xuXHRcdC8vIGZ1bmRzL1tpZF0uc3ZlbHRlXG5cdFx0cGF0dGVybjogL15cXC9mdW5kc1xcLyhbXlxcL10rPylcXC8/JC8sXG5cdFx0cGFydHM6IFtcblx0XHRcdG51bGwsXG5cdFx0XHR7IGk6IDIsIHBhcmFtczogbWF0Y2ggPT4gKHsgaWQ6IGQobWF0Y2hbMV0pIH0pIH1cblx0XHRdXG5cdH0sXG5cblx0e1xuXHRcdC8vIGxpc3RzL2luZGV4LnN2ZWx0ZVxuXHRcdHBhdHRlcm46IC9eXFwvbGlzdHNcXC8/JC8sXG5cdFx0cGFydHM6IFtcblx0XHRcdHsgaTogMyB9LFxuXHRcdFx0eyBpOiA0IH1cblx0XHRdXG5cdH0sXG5cblx0e1xuXHRcdC8vIGxpc3RzL29yZ2FuaXphdGlvbnMuc3ZlbHRlXG5cdFx0cGF0dGVybjogL15cXC9saXN0c1xcL29yZ2FuaXphdGlvbnNcXC8/JC8sXG5cdFx0cGFydHM6IFtcblx0XHRcdHsgaTogMyB9LFxuXHRcdFx0eyBpOiA1IH1cblx0XHRdXG5cdH0sXG5cblx0e1xuXHRcdC8vIGxpc3RzL2Z1bmRzLnN2ZWx0ZVxuXHRcdHBhdHRlcm46IC9eXFwvbGlzdHNcXC9mdW5kc1xcLz8kLyxcblx0XHRwYXJ0czogW1xuXHRcdFx0eyBpOiAzIH0sXG5cdFx0XHR7IGk6IDYgfVxuXHRcdF1cblx0fSxcblxuXHR7XG5cdFx0Ly8gdXNlcnMvaW5kZXguc3ZlbHRlXG5cdFx0cGF0dGVybjogL15cXC91c2Vyc1xcLz8kLyxcblx0XHRwYXJ0czogW1xuXHRcdFx0eyBpOiA3IH1cblx0XHRdXG5cdH0sXG5cblx0e1xuXHRcdC8vIHVzZXJzL21lLnN2ZWx0ZVxuXHRcdHBhdHRlcm46IC9eXFwvdXNlcnNcXC9tZVxcLz8kLyxcblx0XHRwYXJ0czogW1xuXHRcdFx0bnVsbCxcblx0XHRcdHsgaTogOCB9XG5cdFx0XVxuXHR9LFxuXG5cdHtcblx0XHQvLyB1c2Vycy9baWRdLnN2ZWx0ZVxuXHRcdHBhdHRlcm46IC9eXFwvdXNlcnNcXC8oW15cXC9dKz8pXFwvPyQvLFxuXHRcdHBhcnRzOiBbXG5cdFx0XHRudWxsLFxuXHRcdFx0eyBpOiA5LCBwYXJhbXM6IG1hdGNoID0+ICh7IGlkOiBkKG1hdGNoWzFdKSB9KSB9XG5cdFx0XVxuXHR9LFxuXG5cdHtcblx0XHQvLyBtYXAvaW5kZXguc3ZlbHRlXG5cdFx0cGF0dGVybjogL15cXC9tYXBcXC8/JC8sXG5cdFx0cGFydHM6IFtcblx0XHRcdHsgaTogMTAgfVxuXHRcdF1cblx0fSxcblxuXHR7XG5cdFx0Ly8gbWFwL1tpZF0uc3ZlbHRlXG5cdFx0cGF0dGVybjogL15cXC9tYXBcXC8oW15cXC9dKz8pXFwvPyQvLFxuXHRcdHBhcnRzOiBbXG5cdFx0XHRudWxsLFxuXHRcdFx0eyBpOiAxMSwgcGFyYW1zOiBtYXRjaCA9PiAoeyBpZDogZChtYXRjaFsxXSkgfSkgfVxuXHRcdF1cblx0fVxuXSkoZGVjb2RlVVJJQ29tcG9uZW50KTtcblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG5cdGltcG9ydChcIi9Vc2Vycy9tYWNib29rL0RvY3VtZW50cy9CdWJsaWsvQ2hhcml0aWZ5L2NoYXJpdGlmeS9ub2RlX21vZHVsZXMvc2FwcGVyL3NhcHBlci1kZXYtY2xpZW50LmpzXCIpLnRoZW4oY2xpZW50ID0+IHtcblx0XHRjbGllbnQuY29ubmVjdCgxMDAwMCk7XG5cdH0pO1xufSIsImltcG9ydCB7IGdldENvbnRleHQgfSBmcm9tICdzdmVsdGUnO1xuaW1wb3J0IHsgQ09OVEVYVF9LRVkgfSBmcm9tICcuL2ludGVybmFsL3NoYXJlZCc7XG5pbXBvcnQgeyB3cml0YWJsZSB9IGZyb20gJ3N2ZWx0ZS9zdG9yZSc7XG5pbXBvcnQgQXBwIGZyb20gJy4vaW50ZXJuYWwvQXBwLnN2ZWx0ZSc7XG5pbXBvcnQgeyBpZ25vcmUsIHJvdXRlcywgcm9vdF9wcmVsb2FkLCBjb21wb25lbnRzLCBFcnJvckNvbXBvbmVudCB9IGZyb20gJy4vaW50ZXJuYWwvbWFuaWZlc3QtY2xpZW50JztcblxuZnVuY3Rpb24gZ290byhocmVmLCBvcHRzID0geyByZXBsYWNlU3RhdGU6IGZhbHNlIH0pIHtcblx0Y29uc3QgdGFyZ2V0ID0gc2VsZWN0X3RhcmdldChuZXcgVVJMKGhyZWYsIGRvY3VtZW50LmJhc2VVUkkpKTtcblxuXHRpZiAodGFyZ2V0KSB7XG5cdFx0X2hpc3Rvcnlbb3B0cy5yZXBsYWNlU3RhdGUgPyAncmVwbGFjZVN0YXRlJyA6ICdwdXNoU3RhdGUnXSh7IGlkOiBjaWQgfSwgJycsIGhyZWYpO1xuXHRcdHJldHVybiBuYXZpZ2F0ZSh0YXJnZXQsIG51bGwpLnRoZW4oKCkgPT4ge30pO1xuXHR9XG5cblx0bG9jYXRpb24uaHJlZiA9IGhyZWY7XG5cdHJldHVybiBuZXcgUHJvbWlzZShmID0+IHt9KTsgLy8gbmV2ZXIgcmVzb2x2ZXNcbn1cblxuLyoqIENhbGxiYWNrIHRvIGluZm9ybSBvZiBhIHZhbHVlIHVwZGF0ZXMuICovXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbmZ1bmN0aW9uIHBhZ2Vfc3RvcmUodmFsdWUpIHtcblx0Y29uc3Qgc3RvcmUgPSB3cml0YWJsZSh2YWx1ZSk7XG5cdGxldCByZWFkeSA9IHRydWU7XG5cblx0ZnVuY3Rpb24gbm90aWZ5KCkge1xuXHRcdHJlYWR5ID0gdHJ1ZTtcblx0XHRzdG9yZS51cGRhdGUodmFsID0+IHZhbCk7XG5cdH1cblxuXHRmdW5jdGlvbiBzZXQobmV3X3ZhbHVlKSB7XG5cdFx0cmVhZHkgPSBmYWxzZTtcblx0XHRzdG9yZS5zZXQobmV3X3ZhbHVlKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHN1YnNjcmliZShydW4pIHtcblx0XHRsZXQgb2xkX3ZhbHVlO1xuXHRcdHJldHVybiBzdG9yZS5zdWJzY3JpYmUoKHZhbHVlKSA9PiB7XG5cdFx0XHRpZiAob2xkX3ZhbHVlID09PSB1bmRlZmluZWQgfHwgKHJlYWR5ICYmIHZhbHVlICE9PSBvbGRfdmFsdWUpKSB7XG5cdFx0XHRcdHJ1bihvbGRfdmFsdWUgPSB2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxuXHRyZXR1cm4geyBub3RpZnksIHNldCwgc3Vic2NyaWJlIH07XG59XG5cbmNvbnN0IGluaXRpYWxfZGF0YSA9IHR5cGVvZiBfX1NBUFBFUl9fICE9PSAndW5kZWZpbmVkJyAmJiBfX1NBUFBFUl9fO1xuXG5sZXQgcmVhZHkgPSBmYWxzZTtcbmxldCByb290X2NvbXBvbmVudDtcbmxldCBjdXJyZW50X3Rva2VuO1xubGV0IHJvb3RfcHJlbG9hZGVkO1xubGV0IGN1cnJlbnRfYnJhbmNoID0gW107XG5sZXQgY3VycmVudF9xdWVyeSA9ICd7fSc7XG5cbmNvbnN0IHN0b3JlcyA9IHtcblx0cGFnZTogcGFnZV9zdG9yZSh7fSksXG5cdHByZWxvYWRpbmc6IHdyaXRhYmxlKG51bGwpLFxuXHRzZXNzaW9uOiB3cml0YWJsZShpbml0aWFsX2RhdGEgJiYgaW5pdGlhbF9kYXRhLnNlc3Npb24pXG59O1xuXG5sZXQgJHNlc3Npb247XG5sZXQgc2Vzc2lvbl9kaXJ0eTtcblxuc3RvcmVzLnNlc3Npb24uc3Vic2NyaWJlKGFzeW5jIHZhbHVlID0+IHtcblx0JHNlc3Npb24gPSB2YWx1ZTtcblxuXHRpZiAoIXJlYWR5KSByZXR1cm47XG5cdHNlc3Npb25fZGlydHkgPSB0cnVlO1xuXG5cdGNvbnN0IHRhcmdldCA9IHNlbGVjdF90YXJnZXQobmV3IFVSTChsb2NhdGlvbi5ocmVmKSk7XG5cblx0Y29uc3QgdG9rZW4gPSBjdXJyZW50X3Rva2VuID0ge307XG5cdGNvbnN0IHsgcmVkaXJlY3QsIHByb3BzLCBicmFuY2ggfSA9IGF3YWl0IGh5ZHJhdGVfdGFyZ2V0KHRhcmdldCk7XG5cdGlmICh0b2tlbiAhPT0gY3VycmVudF90b2tlbikgcmV0dXJuOyAvLyBhIHNlY29uZGFyeSBuYXZpZ2F0aW9uIGhhcHBlbmVkIHdoaWxlIHdlIHdlcmUgbG9hZGluZ1xuXG5cdGF3YWl0IHJlbmRlcihyZWRpcmVjdCwgYnJhbmNoLCBwcm9wcywgdGFyZ2V0LnBhZ2UpO1xufSk7XG5cbmxldCBwcmVmZXRjaGluZ1xuXG5cbiA9IG51bGw7XG5mdW5jdGlvbiBzZXRfcHJlZmV0Y2hpbmcoaHJlZiwgcHJvbWlzZSkge1xuXHRwcmVmZXRjaGluZyA9IHsgaHJlZiwgcHJvbWlzZSB9O1xufVxuXG5sZXQgdGFyZ2V0O1xuZnVuY3Rpb24gc2V0X3RhcmdldChlbGVtZW50KSB7XG5cdHRhcmdldCA9IGVsZW1lbnQ7XG59XG5cbmxldCB1aWQgPSAxO1xuZnVuY3Rpb24gc2V0X3VpZChuKSB7XG5cdHVpZCA9IG47XG59XG5cbmxldCBjaWQ7XG5mdW5jdGlvbiBzZXRfY2lkKG4pIHtcblx0Y2lkID0gbjtcbn1cblxuY29uc3QgX2hpc3RvcnkgPSB0eXBlb2YgaGlzdG9yeSAhPT0gJ3VuZGVmaW5lZCcgPyBoaXN0b3J5IDoge1xuXHRwdXNoU3RhdGU6IChzdGF0ZSwgdGl0bGUsIGhyZWYpID0+IHt9LFxuXHRyZXBsYWNlU3RhdGU6IChzdGF0ZSwgdGl0bGUsIGhyZWYpID0+IHt9LFxuXHRzY3JvbGxSZXN0b3JhdGlvbjogJydcbn07XG5cbmNvbnN0IHNjcm9sbF9oaXN0b3J5ID0ge307XG5cbmZ1bmN0aW9uIGV4dHJhY3RfcXVlcnkoc2VhcmNoKSB7XG5cdGNvbnN0IHF1ZXJ5ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0aWYgKHNlYXJjaC5sZW5ndGggPiAwKSB7XG5cdFx0c2VhcmNoLnNsaWNlKDEpLnNwbGl0KCcmJykuZm9yRWFjaChzZWFyY2hQYXJhbSA9PiB7XG5cdFx0XHRsZXQgWywga2V5LCB2YWx1ZSA9ICcnXSA9IC8oW149XSopKD86PSguKikpPy8uZXhlYyhkZWNvZGVVUklDb21wb25lbnQoc2VhcmNoUGFyYW0ucmVwbGFjZSgvXFwrL2csICcgJykpKTtcblx0XHRcdGlmICh0eXBlb2YgcXVlcnlba2V5XSA9PT0gJ3N0cmluZycpIHF1ZXJ5W2tleV0gPSBbcXVlcnlba2V5XV07XG5cdFx0XHRpZiAodHlwZW9mIHF1ZXJ5W2tleV0gPT09ICdvYmplY3QnKSAocXVlcnlba2V5XSApLnB1c2godmFsdWUpO1xuXHRcdFx0ZWxzZSBxdWVyeVtrZXldID0gdmFsdWU7XG5cdFx0fSk7XG5cdH1cblx0cmV0dXJuIHF1ZXJ5O1xufVxuXG5mdW5jdGlvbiBzZWxlY3RfdGFyZ2V0KHVybCkge1xuXHRpZiAodXJsLm9yaWdpbiAhPT0gbG9jYXRpb24ub3JpZ2luKSByZXR1cm4gbnVsbDtcblx0aWYgKCF1cmwucGF0aG5hbWUuc3RhcnRzV2l0aChpbml0aWFsX2RhdGEuYmFzZVVybCkpIHJldHVybiBudWxsO1xuXG5cdGxldCBwYXRoID0gdXJsLnBhdGhuYW1lLnNsaWNlKGluaXRpYWxfZGF0YS5iYXNlVXJsLmxlbmd0aCk7XG5cblx0aWYgKHBhdGggPT09ICcnKSB7XG5cdFx0cGF0aCA9ICcvJztcblx0fVxuXG5cdC8vIGF2b2lkIGFjY2lkZW50YWwgY2xhc2hlcyBiZXR3ZWVuIHNlcnZlciByb3V0ZXMgYW5kIHBhZ2Ugcm91dGVzXG5cdGlmIChpZ25vcmUuc29tZShwYXR0ZXJuID0+IHBhdHRlcm4udGVzdChwYXRoKSkpIHJldHVybjtcblxuXHRmb3IgKGxldCBpID0gMDsgaSA8IHJvdXRlcy5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdGNvbnN0IHJvdXRlID0gcm91dGVzW2ldO1xuXG5cdFx0Y29uc3QgbWF0Y2ggPSByb3V0ZS5wYXR0ZXJuLmV4ZWMocGF0aCk7XG5cblx0XHRpZiAobWF0Y2gpIHtcblx0XHRcdGNvbnN0IHF1ZXJ5ID0gZXh0cmFjdF9xdWVyeSh1cmwuc2VhcmNoKTtcblx0XHRcdGNvbnN0IHBhcnQgPSByb3V0ZS5wYXJ0c1tyb3V0ZS5wYXJ0cy5sZW5ndGggLSAxXTtcblx0XHRcdGNvbnN0IHBhcmFtcyA9IHBhcnQucGFyYW1zID8gcGFydC5wYXJhbXMobWF0Y2gpIDoge307XG5cblx0XHRcdGNvbnN0IHBhZ2UgPSB7IGhvc3Q6IGxvY2F0aW9uLmhvc3QsIHBhdGgsIHF1ZXJ5LCBwYXJhbXMgfTtcblxuXHRcdFx0cmV0dXJuIHsgaHJlZjogdXJsLmhyZWYsIHJvdXRlLCBtYXRjaCwgcGFnZSB9O1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBoYW5kbGVfZXJyb3IodXJsKSB7XG5cdGNvbnN0IHsgaG9zdCwgcGF0aG5hbWUsIHNlYXJjaCB9ID0gbG9jYXRpb247XG5cdGNvbnN0IHsgc2Vzc2lvbiwgcHJlbG9hZGVkLCBzdGF0dXMsIGVycm9yIH0gPSBpbml0aWFsX2RhdGE7XG5cblx0aWYgKCFyb290X3ByZWxvYWRlZCkge1xuXHRcdHJvb3RfcHJlbG9hZGVkID0gcHJlbG9hZGVkICYmIHByZWxvYWRlZFswXTtcblx0fVxuXG5cdGNvbnN0IHByb3BzID0ge1xuXHRcdGVycm9yLFxuXHRcdHN0YXR1cyxcblx0XHRzZXNzaW9uLFxuXHRcdGxldmVsMDoge1xuXHRcdFx0cHJvcHM6IHJvb3RfcHJlbG9hZGVkXG5cdFx0fSxcblx0XHRsZXZlbDE6IHtcblx0XHRcdHByb3BzOiB7XG5cdFx0XHRcdHN0YXR1cyxcblx0XHRcdFx0ZXJyb3Jcblx0XHRcdH0sXG5cdFx0XHRjb21wb25lbnQ6IEVycm9yQ29tcG9uZW50XG5cdFx0fSxcblx0XHRzZWdtZW50czogcHJlbG9hZGVkXG5cblx0fTtcblx0Y29uc3QgcXVlcnkgPSBleHRyYWN0X3F1ZXJ5KHNlYXJjaCk7XG5cdHJlbmRlcihudWxsLCBbXSwgcHJvcHMsIHsgaG9zdCwgcGF0aDogcGF0aG5hbWUsIHF1ZXJ5LCBwYXJhbXM6IHt9IH0pO1xufVxuXG5mdW5jdGlvbiBzY3JvbGxfc3RhdGUoKSB7XG5cdHJldHVybiB7XG5cdFx0eDogcGFnZVhPZmZzZXQsXG5cdFx0eTogcGFnZVlPZmZzZXRcblx0fTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gbmF2aWdhdGUodGFyZ2V0LCBpZCwgbm9zY3JvbGwsIGhhc2gpIHtcblx0aWYgKGlkKSB7XG5cdFx0Ly8gcG9wc3RhdGUgb3IgaW5pdGlhbCBuYXZpZ2F0aW9uXG5cdFx0Y2lkID0gaWQ7XG5cdH0gZWxzZSB7XG5cdFx0Y29uc3QgY3VycmVudF9zY3JvbGwgPSBzY3JvbGxfc3RhdGUoKTtcblxuXHRcdC8vIGNsaWNrZWQgb24gYSBsaW5rLiBwcmVzZXJ2ZSBzY3JvbGwgc3RhdGVcblx0XHRzY3JvbGxfaGlzdG9yeVtjaWRdID0gY3VycmVudF9zY3JvbGw7XG5cblx0XHRpZCA9IGNpZCA9ICsrdWlkO1xuXHRcdHNjcm9sbF9oaXN0b3J5W2NpZF0gPSBub3Njcm9sbCA/IGN1cnJlbnRfc2Nyb2xsIDogeyB4OiAwLCB5OiAwIH07XG5cdH1cblxuXHRjaWQgPSBpZDtcblxuXHRpZiAocm9vdF9jb21wb25lbnQpIHN0b3Jlcy5wcmVsb2FkaW5nLnNldCh0cnVlKTtcblxuXHRjb25zdCBsb2FkZWQgPSBwcmVmZXRjaGluZyAmJiBwcmVmZXRjaGluZy5ocmVmID09PSB0YXJnZXQuaHJlZiA/XG5cdFx0cHJlZmV0Y2hpbmcucHJvbWlzZSA6XG5cdFx0aHlkcmF0ZV90YXJnZXQodGFyZ2V0KTtcblxuXHRwcmVmZXRjaGluZyA9IG51bGw7XG5cblx0Y29uc3QgdG9rZW4gPSBjdXJyZW50X3Rva2VuID0ge307XG5cdGNvbnN0IHsgcmVkaXJlY3QsIHByb3BzLCBicmFuY2ggfSA9IGF3YWl0IGxvYWRlZDtcblx0aWYgKHRva2VuICE9PSBjdXJyZW50X3Rva2VuKSByZXR1cm47IC8vIGEgc2Vjb25kYXJ5IG5hdmlnYXRpb24gaGFwcGVuZWQgd2hpbGUgd2Ugd2VyZSBsb2FkaW5nXG5cblx0YXdhaXQgcmVuZGVyKHJlZGlyZWN0LCBicmFuY2gsIHByb3BzLCB0YXJnZXQucGFnZSk7XG5cdGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50KSBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmJsdXIoKTtcblxuXHRpZiAoIW5vc2Nyb2xsKSB7XG5cdFx0bGV0IHNjcm9sbCA9IHNjcm9sbF9oaXN0b3J5W2lkXTtcblxuXHRcdGlmIChoYXNoKSB7XG5cdFx0XHQvLyBzY3JvbGwgaXMgYW4gZWxlbWVudCBpZCAoZnJvbSBhIGhhc2gpLCB3ZSBuZWVkIHRvIGNvbXB1dGUgeS5cblx0XHRcdGNvbnN0IGRlZXBfbGlua2VkID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaGFzaC5zbGljZSgxKSk7XG5cblx0XHRcdGlmIChkZWVwX2xpbmtlZCkge1xuXHRcdFx0XHRzY3JvbGwgPSB7XG5cdFx0XHRcdFx0eDogMCxcblx0XHRcdFx0XHR5OiBkZWVwX2xpbmtlZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgKyBzY3JvbGxZXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0c2Nyb2xsX2hpc3RvcnlbY2lkXSA9IHNjcm9sbDtcblx0XHRpZiAoc2Nyb2xsKSBzY3JvbGxUbyhzY3JvbGwueCwgc2Nyb2xsLnkpO1xuXHR9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlbmRlcihyZWRpcmVjdCwgYnJhbmNoLCBwcm9wcywgcGFnZSkge1xuXHRpZiAocmVkaXJlY3QpIHJldHVybiBnb3RvKHJlZGlyZWN0LmxvY2F0aW9uLCB7IHJlcGxhY2VTdGF0ZTogdHJ1ZSB9KTtcblxuXHRzdG9yZXMucGFnZS5zZXQocGFnZSk7XG5cdHN0b3Jlcy5wcmVsb2FkaW5nLnNldChmYWxzZSk7XG5cblx0aWYgKHJvb3RfY29tcG9uZW50KSB7XG5cdFx0cm9vdF9jb21wb25lbnQuJHNldChwcm9wcyk7XG5cdH0gZWxzZSB7XG5cdFx0cHJvcHMuc3RvcmVzID0ge1xuXHRcdFx0cGFnZTogeyBzdWJzY3JpYmU6IHN0b3Jlcy5wYWdlLnN1YnNjcmliZSB9LFxuXHRcdFx0cHJlbG9hZGluZzogeyBzdWJzY3JpYmU6IHN0b3Jlcy5wcmVsb2FkaW5nLnN1YnNjcmliZSB9LFxuXHRcdFx0c2Vzc2lvbjogc3RvcmVzLnNlc3Npb25cblx0XHR9O1xuXHRcdHByb3BzLmxldmVsMCA9IHtcblx0XHRcdHByb3BzOiBhd2FpdCByb290X3ByZWxvYWRlZFxuXHRcdH07XG5cdFx0cHJvcHMubm90aWZ5ID0gc3RvcmVzLnBhZ2Uubm90aWZ5O1xuXG5cdFx0Ly8gZmlyc3QgbG9hZCDigJQgcmVtb3ZlIFNTUidkIDxoZWFkPiBjb250ZW50c1xuXHRcdGNvbnN0IHN0YXJ0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3NhcHBlci1oZWFkLXN0YXJ0Jyk7XG5cdFx0Y29uc3QgZW5kID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3NhcHBlci1oZWFkLWVuZCcpO1xuXG5cdFx0aWYgKHN0YXJ0ICYmIGVuZCkge1xuXHRcdFx0d2hpbGUgKHN0YXJ0Lm5leHRTaWJsaW5nICE9PSBlbmQpIGRldGFjaChzdGFydC5uZXh0U2libGluZyk7XG5cdFx0XHRkZXRhY2goc3RhcnQpO1xuXHRcdFx0ZGV0YWNoKGVuZCk7XG5cdFx0fVxuXG5cdFx0cm9vdF9jb21wb25lbnQgPSBuZXcgQXBwKHtcblx0XHRcdHRhcmdldCxcblx0XHRcdHByb3BzLFxuXHRcdFx0aHlkcmF0ZTogdHJ1ZVxuXHRcdH0pO1xuXHR9XG5cblx0Y3VycmVudF9icmFuY2ggPSBicmFuY2g7XG5cdGN1cnJlbnRfcXVlcnkgPSBKU09OLnN0cmluZ2lmeShwYWdlLnF1ZXJ5KTtcblx0cmVhZHkgPSB0cnVlO1xuXHRzZXNzaW9uX2RpcnR5ID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHBhcnRfY2hhbmdlZChpLCBzZWdtZW50LCBtYXRjaCwgc3RyaW5naWZpZWRfcXVlcnkpIHtcblx0Ly8gVE9ETyBvbmx5IGNoZWNrIHF1ZXJ5IHN0cmluZyBjaGFuZ2VzIGZvciBwcmVsb2FkIGZ1bmN0aW9uc1xuXHQvLyB0aGF0IGRvIGluIGZhY3QgZGVwZW5kIG9uIGl0ICh1c2luZyBzdGF0aWMgYW5hbHlzaXMgb3Jcblx0Ly8gcnVudGltZSBpbnN0cnVtZW50YXRpb24pXG5cdGlmIChzdHJpbmdpZmllZF9xdWVyeSAhPT0gY3VycmVudF9xdWVyeSkgcmV0dXJuIHRydWU7XG5cblx0Y29uc3QgcHJldmlvdXMgPSBjdXJyZW50X2JyYW5jaFtpXTtcblxuXHRpZiAoIXByZXZpb3VzKSByZXR1cm4gZmFsc2U7XG5cdGlmIChzZWdtZW50ICE9PSBwcmV2aW91cy5zZWdtZW50KSByZXR1cm4gdHJ1ZTtcblx0aWYgKHByZXZpb3VzLm1hdGNoKSB7XG5cdFx0aWYgKEpTT04uc3RyaW5naWZ5KHByZXZpb3VzLm1hdGNoLnNsaWNlKDEsIGkgKyAyKSkgIT09IEpTT04uc3RyaW5naWZ5KG1hdGNoLnNsaWNlKDEsIGkgKyAyKSkpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0fVxufVxuXG5hc3luYyBmdW5jdGlvbiBoeWRyYXRlX3RhcmdldCh0YXJnZXQpXG5cblxuXG4ge1xuXHRjb25zdCB7IHJvdXRlLCBwYWdlIH0gPSB0YXJnZXQ7XG5cdGNvbnN0IHNlZ21lbnRzID0gcGFnZS5wYXRoLnNwbGl0KCcvJykuZmlsdGVyKEJvb2xlYW4pO1xuXG5cdGxldCByZWRpcmVjdCA9IG51bGw7XG5cblx0Y29uc3QgcHJvcHMgPSB7IGVycm9yOiBudWxsLCBzdGF0dXM6IDIwMCwgc2VnbWVudHM6IFtzZWdtZW50c1swXV0gfTtcblxuXHRjb25zdCBwcmVsb2FkX2NvbnRleHQgPSB7XG5cdFx0ZmV0Y2g6ICh1cmwsIG9wdHMpID0+IGZldGNoKHVybCwgb3B0cyksXG5cdFx0cmVkaXJlY3Q6IChzdGF0dXNDb2RlLCBsb2NhdGlvbikgPT4ge1xuXHRcdFx0aWYgKHJlZGlyZWN0ICYmIChyZWRpcmVjdC5zdGF0dXNDb2RlICE9PSBzdGF0dXNDb2RlIHx8IHJlZGlyZWN0LmxvY2F0aW9uICE9PSBsb2NhdGlvbikpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBDb25mbGljdGluZyByZWRpcmVjdHNgKTtcblx0XHRcdH1cblx0XHRcdHJlZGlyZWN0ID0geyBzdGF0dXNDb2RlLCBsb2NhdGlvbiB9O1xuXHRcdH0sXG5cdFx0ZXJyb3I6IChzdGF0dXMsIGVycm9yKSA9PiB7XG5cdFx0XHRwcm9wcy5lcnJvciA9IHR5cGVvZiBlcnJvciA9PT0gJ3N0cmluZycgPyBuZXcgRXJyb3IoZXJyb3IpIDogZXJyb3I7XG5cdFx0XHRwcm9wcy5zdGF0dXMgPSBzdGF0dXM7XG5cdFx0fVxuXHR9O1xuXG5cdGlmICghcm9vdF9wcmVsb2FkZWQpIHtcblx0XHRyb290X3ByZWxvYWRlZCA9IGluaXRpYWxfZGF0YS5wcmVsb2FkZWRbMF0gfHwgcm9vdF9wcmVsb2FkLmNhbGwocHJlbG9hZF9jb250ZXh0LCB7XG5cdFx0XHRob3N0OiBwYWdlLmhvc3QsXG5cdFx0XHRwYXRoOiBwYWdlLnBhdGgsXG5cdFx0XHRxdWVyeTogcGFnZS5xdWVyeSxcblx0XHRcdHBhcmFtczoge31cblx0XHR9LCAkc2Vzc2lvbik7XG5cdH1cblxuXHRsZXQgYnJhbmNoO1xuXHRsZXQgbCA9IDE7XG5cblx0dHJ5IHtcblx0XHRjb25zdCBzdHJpbmdpZmllZF9xdWVyeSA9IEpTT04uc3RyaW5naWZ5KHBhZ2UucXVlcnkpO1xuXHRcdGNvbnN0IG1hdGNoID0gcm91dGUucGF0dGVybi5leGVjKHBhZ2UucGF0aCk7XG5cblx0XHRsZXQgc2VnbWVudF9kaXJ0eSA9IGZhbHNlO1xuXG5cdFx0YnJhbmNoID0gYXdhaXQgUHJvbWlzZS5hbGwocm91dGUucGFydHMubWFwKGFzeW5jIChwYXJ0LCBpKSA9PiB7XG5cdFx0XHRjb25zdCBzZWdtZW50ID0gc2VnbWVudHNbaV07XG5cblx0XHRcdGlmIChwYXJ0X2NoYW5nZWQoaSwgc2VnbWVudCwgbWF0Y2gsIHN0cmluZ2lmaWVkX3F1ZXJ5KSkgc2VnbWVudF9kaXJ0eSA9IHRydWU7XG5cblx0XHRcdHByb3BzLnNlZ21lbnRzW2xdID0gc2VnbWVudHNbaSArIDFdOyAvLyBUT0RPIG1ha2UgdGhpcyBsZXNzIGNvbmZ1c2luZ1xuXHRcdFx0aWYgKCFwYXJ0KSByZXR1cm4geyBzZWdtZW50IH07XG5cblx0XHRcdGNvbnN0IGogPSBsKys7XG5cblx0XHRcdGlmICghc2Vzc2lvbl9kaXJ0eSAmJiAhc2VnbWVudF9kaXJ0eSAmJiBjdXJyZW50X2JyYW5jaFtpXSAmJiBjdXJyZW50X2JyYW5jaFtpXS5wYXJ0ID09PSBwYXJ0LmkpIHtcblx0XHRcdFx0cmV0dXJuIGN1cnJlbnRfYnJhbmNoW2ldO1xuXHRcdFx0fVxuXG5cdFx0XHRzZWdtZW50X2RpcnR5ID0gZmFsc2U7XG5cblx0XHRcdGNvbnN0IHsgZGVmYXVsdDogY29tcG9uZW50LCBwcmVsb2FkIH0gPSBhd2FpdCBsb2FkX2NvbXBvbmVudChjb21wb25lbnRzW3BhcnQuaV0pO1xuXG5cdFx0XHRsZXQgcHJlbG9hZGVkO1xuXHRcdFx0aWYgKHJlYWR5IHx8ICFpbml0aWFsX2RhdGEucHJlbG9hZGVkW2kgKyAxXSkge1xuXHRcdFx0XHRwcmVsb2FkZWQgPSBwcmVsb2FkXG5cdFx0XHRcdFx0PyBhd2FpdCBwcmVsb2FkLmNhbGwocHJlbG9hZF9jb250ZXh0LCB7XG5cdFx0XHRcdFx0XHRob3N0OiBwYWdlLmhvc3QsXG5cdFx0XHRcdFx0XHRwYXRoOiBwYWdlLnBhdGgsXG5cdFx0XHRcdFx0XHRxdWVyeTogcGFnZS5xdWVyeSxcblx0XHRcdFx0XHRcdHBhcmFtczogcGFydC5wYXJhbXMgPyBwYXJ0LnBhcmFtcyh0YXJnZXQubWF0Y2gpIDoge31cblx0XHRcdFx0XHR9LCAkc2Vzc2lvbilcblx0XHRcdFx0XHQ6IHt9O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHJlbG9hZGVkID0gaW5pdGlhbF9kYXRhLnByZWxvYWRlZFtpICsgMV07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAocHJvcHNbYGxldmVsJHtqfWBdID0geyBjb21wb25lbnQsIHByb3BzOiBwcmVsb2FkZWQsIHNlZ21lbnQsIG1hdGNoLCBwYXJ0OiBwYXJ0LmkgfSk7XG5cdFx0fSkpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdHByb3BzLmVycm9yID0gZXJyb3I7XG5cdFx0cHJvcHMuc3RhdHVzID0gNTAwO1xuXHRcdGJyYW5jaCA9IFtdO1xuXHR9XG5cblx0cmV0dXJuIHsgcmVkaXJlY3QsIHByb3BzLCBicmFuY2ggfTtcbn1cblxuZnVuY3Rpb24gbG9hZF9jc3MoY2h1bmspIHtcblx0Y29uc3QgaHJlZiA9IGBjbGllbnQvJHtjaHVua31gO1xuXHRpZiAoZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgbGlua1tocmVmPVwiJHtocmVmfVwiXWApKSByZXR1cm47XG5cblx0cmV0dXJuIG5ldyBQcm9taXNlKChmdWxmaWwsIHJlamVjdCkgPT4ge1xuXHRcdGNvbnN0IGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaW5rJyk7XG5cdFx0bGluay5yZWwgPSAnc3R5bGVzaGVldCc7XG5cdFx0bGluay5ocmVmID0gaHJlZjtcblxuXHRcdGxpbmsub25sb2FkID0gKCkgPT4gZnVsZmlsKCk7XG5cdFx0bGluay5vbmVycm9yID0gcmVqZWN0O1xuXG5cdFx0ZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChsaW5rKTtcblx0fSk7XG59XG5cbmZ1bmN0aW9uIGxvYWRfY29tcG9uZW50KGNvbXBvbmVudClcblxuXG4ge1xuXHQvLyBUT0RPIHRoaXMgaXMgdGVtcG9yYXJ5IOKAlCBvbmNlIHBsYWNlaG9sZGVycyBhcmVcblx0Ly8gYWx3YXlzIHJld3JpdHRlbiwgc2NyYXRjaCB0aGUgdGVybmFyeVxuXHRjb25zdCBwcm9taXNlcyA9ICh0eXBlb2YgY29tcG9uZW50LmNzcyA9PT0gJ3N0cmluZycgPyBbXSA6IGNvbXBvbmVudC5jc3MubWFwKGxvYWRfY3NzKSk7XG5cdHByb21pc2VzLnVuc2hpZnQoY29tcG9uZW50LmpzKCkpO1xuXHRyZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4odmFsdWVzID0+IHZhbHVlc1swXSk7XG59XG5cbmZ1bmN0aW9uIGRldGFjaChub2RlKSB7XG5cdG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbn1cblxuZnVuY3Rpb24gcHJlZmV0Y2goaHJlZikge1xuXHRjb25zdCB0YXJnZXQgPSBzZWxlY3RfdGFyZ2V0KG5ldyBVUkwoaHJlZiwgZG9jdW1lbnQuYmFzZVVSSSkpO1xuXG5cdGlmICh0YXJnZXQpIHtcblx0XHRpZiAoIXByZWZldGNoaW5nIHx8IGhyZWYgIT09IHByZWZldGNoaW5nLmhyZWYpIHtcblx0XHRcdHNldF9wcmVmZXRjaGluZyhocmVmLCBoeWRyYXRlX3RhcmdldCh0YXJnZXQpKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcHJlZmV0Y2hpbmcucHJvbWlzZTtcblx0fVxufVxuXG5mdW5jdGlvbiBzdGFydChvcHRzXG5cbikge1xuXHRpZiAoJ3Njcm9sbFJlc3RvcmF0aW9uJyBpbiBfaGlzdG9yeSkge1xuXHRcdF9oaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uID0gJ21hbnVhbCc7XG5cdH1cblx0XG5cdC8vIEFkb3B0ZWQgZnJvbSBOdXh0LmpzXG5cdC8vIFJlc2V0IHNjcm9sbFJlc3RvcmF0aW9uIHRvIGF1dG8gd2hlbiBsZWF2aW5nIHBhZ2UsIGFsbG93aW5nIHBhZ2UgcmVsb2FkXG5cdC8vIGFuZCBiYWNrLW5hdmlnYXRpb24gZnJvbSBvdGhlciBwYWdlcyB0byB1c2UgdGhlIGJyb3dzZXIgdG8gcmVzdG9yZSB0aGVcblx0Ly8gc2Nyb2xsaW5nIHBvc2l0aW9uLlxuXHRhZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCAoKSA9PiB7XG5cdFx0X2hpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSAnYXV0byc7XG5cdH0pO1xuXG5cdC8vIFNldHRpbmcgc2Nyb2xsUmVzdG9yYXRpb24gdG8gbWFudWFsIGFnYWluIHdoZW4gcmV0dXJuaW5nIHRvIHRoaXMgcGFnZS5cblx0YWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcblx0XHRfaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbiA9ICdtYW51YWwnO1xuXHR9KTtcblxuXHRzZXRfdGFyZ2V0KG9wdHMudGFyZ2V0KTtcblxuXHRhZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZV9jbGljayk7XG5cdGFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgaGFuZGxlX3BvcHN0YXRlKTtcblxuXHQvLyBwcmVmZXRjaFxuXHRhZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdHJpZ2dlcl9wcmVmZXRjaCk7XG5cdGFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGhhbmRsZV9tb3VzZW1vdmUpO1xuXG5cdHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcblx0XHRjb25zdCB7IGhhc2gsIGhyZWYgfSA9IGxvY2F0aW9uO1xuXG5cdFx0X2hpc3RvcnkucmVwbGFjZVN0YXRlKHsgaWQ6IHVpZCB9LCAnJywgaHJlZik7XG5cblx0XHRjb25zdCB1cmwgPSBuZXcgVVJMKGxvY2F0aW9uLmhyZWYpO1xuXG5cdFx0aWYgKGluaXRpYWxfZGF0YS5lcnJvcikgcmV0dXJuIGhhbmRsZV9lcnJvcigpO1xuXG5cdFx0Y29uc3QgdGFyZ2V0ID0gc2VsZWN0X3RhcmdldCh1cmwpO1xuXHRcdGlmICh0YXJnZXQpIHJldHVybiBuYXZpZ2F0ZSh0YXJnZXQsIHVpZCwgdHJ1ZSwgaGFzaCk7XG5cdH0pO1xufVxuXG5sZXQgbW91c2Vtb3ZlX3RpbWVvdXQ7XG5cbmZ1bmN0aW9uIGhhbmRsZV9tb3VzZW1vdmUoZXZlbnQpIHtcblx0Y2xlYXJUaW1lb3V0KG1vdXNlbW92ZV90aW1lb3V0KTtcblx0bW91c2Vtb3ZlX3RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcblx0XHR0cmlnZ2VyX3ByZWZldGNoKGV2ZW50KTtcblx0fSwgMjApO1xufVxuXG5mdW5jdGlvbiB0cmlnZ2VyX3ByZWZldGNoKGV2ZW50KSB7XG5cdGNvbnN0IGEgPSBmaW5kX2FuY2hvcihldmVudC50YXJnZXQpO1xuXHRpZiAoIWEgfHwgYS5yZWwgIT09ICdwcmVmZXRjaCcpIHJldHVybjtcblxuXHRwcmVmZXRjaChhLmhyZWYpO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVfY2xpY2soZXZlbnQpIHtcblx0Ly8gQWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS92aXNpb25tZWRpYS9wYWdlLmpzXG5cdC8vIE1JVCBsaWNlbnNlIGh0dHBzOi8vZ2l0aHViLmNvbS92aXNpb25tZWRpYS9wYWdlLmpzI2xpY2Vuc2Vcblx0aWYgKHdoaWNoKGV2ZW50KSAhPT0gMSkgcmV0dXJuO1xuXHRpZiAoZXZlbnQubWV0YUtleSB8fCBldmVudC5jdHJsS2V5IHx8IGV2ZW50LnNoaWZ0S2V5KSByZXR1cm47XG5cdGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSByZXR1cm47XG5cblx0Y29uc3QgYSA9IGZpbmRfYW5jaG9yKGV2ZW50LnRhcmdldCk7XG5cdGlmICghYSkgcmV0dXJuO1xuXG5cdGlmICghYS5ocmVmKSByZXR1cm47XG5cblx0Ly8gY2hlY2sgaWYgbGluayBpcyBpbnNpZGUgYW4gc3ZnXG5cdC8vIGluIHRoaXMgY2FzZSwgYm90aCBocmVmIGFuZCB0YXJnZXQgYXJlIGFsd2F5cyBpbnNpZGUgYW4gb2JqZWN0XG5cdGNvbnN0IHN2ZyA9IHR5cGVvZiBhLmhyZWYgPT09ICdvYmplY3QnICYmIGEuaHJlZi5jb25zdHJ1Y3Rvci5uYW1lID09PSAnU1ZHQW5pbWF0ZWRTdHJpbmcnO1xuXHRjb25zdCBocmVmID0gU3RyaW5nKHN2ZyA/IChhKS5ocmVmLmJhc2VWYWwgOiBhLmhyZWYpO1xuXG5cdGlmIChocmVmID09PSBsb2NhdGlvbi5ocmVmKSB7XG5cdFx0aWYgKCFsb2NhdGlvbi5oYXNoKSBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIElnbm9yZSBpZiB0YWcgaGFzXG5cdC8vIDEuICdkb3dubG9hZCcgYXR0cmlidXRlXG5cdC8vIDIuIHJlbD0nZXh0ZXJuYWwnIGF0dHJpYnV0ZVxuXHRpZiAoYS5oYXNBdHRyaWJ1dGUoJ2Rvd25sb2FkJykgfHwgYS5nZXRBdHRyaWJ1dGUoJ3JlbCcpID09PSAnZXh0ZXJuYWwnKSByZXR1cm47XG5cblx0Ly8gSWdub3JlIGlmIDxhPiBoYXMgYSB0YXJnZXRcblx0aWYgKHN2ZyA/IChhKS50YXJnZXQuYmFzZVZhbCA6IGEudGFyZ2V0KSByZXR1cm47XG5cblx0Y29uc3QgdXJsID0gbmV3IFVSTChocmVmKTtcblxuXHQvLyBEb24ndCBoYW5kbGUgaGFzaCBjaGFuZ2VzXG5cdGlmICh1cmwucGF0aG5hbWUgPT09IGxvY2F0aW9uLnBhdGhuYW1lICYmIHVybC5zZWFyY2ggPT09IGxvY2F0aW9uLnNlYXJjaCkgcmV0dXJuO1xuXG5cdGNvbnN0IHRhcmdldCA9IHNlbGVjdF90YXJnZXQodXJsKTtcblx0aWYgKHRhcmdldCkge1xuXHRcdGNvbnN0IG5vc2Nyb2xsID0gYS5oYXNBdHRyaWJ1dGUoJ3NhcHBlci1ub3Njcm9sbCcpO1xuXHRcdG5hdmlnYXRlKHRhcmdldCwgbnVsbCwgbm9zY3JvbGwsIHVybC5oYXNoKTtcblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdF9oaXN0b3J5LnB1c2hTdGF0ZSh7IGlkOiBjaWQgfSwgJycsIHVybC5ocmVmKTtcblx0fVxufVxuXG5mdW5jdGlvbiB3aGljaChldmVudCkge1xuXHRyZXR1cm4gZXZlbnQud2hpY2ggPT09IG51bGwgPyBldmVudC5idXR0b24gOiBldmVudC53aGljaDtcbn1cblxuZnVuY3Rpb24gZmluZF9hbmNob3Iobm9kZSkge1xuXHR3aGlsZSAobm9kZSAmJiBub2RlLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgIT09ICdBJykgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTsgLy8gU1ZHIDxhPiBlbGVtZW50cyBoYXZlIGEgbG93ZXJjYXNlIG5hbWVcblx0cmV0dXJuIG5vZGU7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZV9wb3BzdGF0ZShldmVudCkge1xuXHRzY3JvbGxfaGlzdG9yeVtjaWRdID0gc2Nyb2xsX3N0YXRlKCk7XG5cblx0aWYgKGV2ZW50LnN0YXRlKSB7XG5cdFx0Y29uc3QgdXJsID0gbmV3IFVSTChsb2NhdGlvbi5ocmVmKTtcblx0XHRjb25zdCB0YXJnZXQgPSBzZWxlY3RfdGFyZ2V0KHVybCk7XG5cdFx0aWYgKHRhcmdldCkge1xuXHRcdFx0bmF2aWdhdGUodGFyZ2V0LCBldmVudC5zdGF0ZS5pZCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxvY2F0aW9uLmhyZWYgPSBsb2NhdGlvbi5ocmVmO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHQvLyBoYXNoY2hhbmdlXG5cdFx0c2V0X3VpZCh1aWQgKyAxKTtcblx0XHRzZXRfY2lkKHVpZCk7XG5cdFx0X2hpc3RvcnkucmVwbGFjZVN0YXRlKHsgaWQ6IGNpZCB9LCAnJywgbG9jYXRpb24uaHJlZik7XG5cdH1cbn1cblxuZnVuY3Rpb24gcHJlZmV0Y2hSb3V0ZXMocGF0aG5hbWVzKSB7XG5cdHJldHVybiByb3V0ZXNcblx0XHQuZmlsdGVyKHBhdGhuYW1lc1xuXHRcdFx0PyByb3V0ZSA9PiBwYXRobmFtZXMuc29tZShwYXRobmFtZSA9PiByb3V0ZS5wYXR0ZXJuLnRlc3QocGF0aG5hbWUpKVxuXHRcdFx0OiAoKSA9PiB0cnVlXG5cdFx0KVxuXHRcdC5yZWR1Y2UoKHByb21pc2UsIHJvdXRlKSA9PiBwcm9taXNlLnRoZW4oKCkgPT4ge1xuXHRcdFx0cmV0dXJuIFByb21pc2UuYWxsKHJvdXRlLnBhcnRzLm1hcChwYXJ0ID0+IHBhcnQgJiYgbG9hZF9jb21wb25lbnQoY29tcG9uZW50c1twYXJ0LmldKSkpO1xuXHRcdH0pLCBQcm9taXNlLnJlc29sdmUoKSk7XG59XG5cbmNvbnN0IHN0b3JlcyQxID0gKCkgPT4gZ2V0Q29udGV4dChDT05URVhUX0tFWSk7XG5cbmV4cG9ydCB7IGdvdG8sIHByZWZldGNoLCBwcmVmZXRjaFJvdXRlcywgc3RhcnQsIHN0b3JlcyQxIGFzIHN0b3JlcyB9O1xuIiwiaW1wb3J0ICogYXMgc2FwcGVyIGZyb20gJ0BzYXBwZXIvYXBwJztcblxuc2FwcGVyLnN0YXJ0KHtcblx0dGFyZ2V0OiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjc2FwcGVyJylcbn0pOyJdLCJuYW1lcyI6WyJTeW1ib2wiLCJvYmplY3RQcm90byIsIm5hdGl2ZU9iamVjdFRvU3RyaW5nIiwic3ltVG9TdHJpbmdUYWciLCJmdW5jUHJvdG8iLCJmdW5jVG9TdHJpbmciLCJoYXNPd25Qcm9wZXJ0eSIsIkhBU0hfVU5ERUZJTkVEIiwiTWFwIiwiSU5GSU5JVFkiLCJVaW50OEFycmF5IiwiQ09NUEFSRV9QQVJUSUFMX0ZMQUciLCJDT01QQVJFX1VOT1JERVJFRF9GTEFHIiwic3ltYm9sVGFnIiwic3ltYm9sUHJvdG8iLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIkJ1ZmZlciIsIk1BWF9TQUZFX0lOVEVHRVIiLCJhcmdzVGFnIiwiYm9vbFRhZyIsImRhdGVUYWciLCJlcnJvclRhZyIsImZ1bmNUYWciLCJtYXBUYWciLCJudW1iZXJUYWciLCJyZWdleHBUYWciLCJzZXRUYWciLCJzdHJpbmdUYWciLCJhcnJheUJ1ZmZlclRhZyIsImRhdGFWaWV3VGFnIiwiZnJlZUV4cG9ydHMiLCJmcmVlTW9kdWxlIiwibW9kdWxlRXhwb3J0cyIsIkRhdGFWaWV3IiwiUHJvbWlzZSIsIlNldCIsIm9iamVjdFRhZyIsIndlYWtNYXBUYWciLCJhcnJheVRhZyIsImdldFRhZyIsImlkZW50aXR5Iiwia2V5c0luIiwibmF0aXZlR2V0U3ltYm9scyIsInN5bWJvbFZhbHVlT2YiLCJmbG9hdDMyVGFnIiwiZmxvYXQ2NFRhZyIsImludDhUYWciLCJpbnQxNlRhZyIsImludDMyVGFnIiwidWludDhUYWciLCJ1aW50OENsYW1wZWRUYWciLCJ1aW50MTZUYWciLCJ1aW50MzJUYWciLCJnZW5UYWciLCJDTE9ORV9ERUVQX0ZMQUciLCJDTE9ORV9TWU1CT0xTX0ZMQUciLCJ0aGlzIiwicmVxdWlyZSQkMSIsInpsRmV0Y2giLCJyZXF1aXJlJCQwIiwiZGF5anMiLCJTdG9yYWdlcyIsIkNvb2tpZXMiLCJ3cml0YWJsZSIsIndyaXRhYmxlJDEiLCJnZXQkMSIsImdldCIsIkRVUkFUSU9OIiwiYm9keVNjcm9sbC5kaXNhYmxlU2Nyb2xsIiwiYm9keVNjcm9sbC5lbmFibGVTY3JvbGwiLCJUSFJFU0hPTEQiLCJTV0lQRV9TUEVFRCIsImRyYXdUcmFuc2Zvcm0iLCJzZXREdXJhdGlvbiIsImRyYXdPcGFjaXR5IiwidXVpZCIsImdldFZhbHVlIiwiXy5nZXQiLCJfLmNsb25lRGVlcCIsIl8uaXNFbXB0eSIsIl8uc2V0IiwiU3RvcmFnZXMuY29va2llU3RvcmFnZSIsIlN0b3JhZ2VzLmxvY2FsU3RvcmFnZSIsIkRhdGVzIiwiRXJyb3JDb21wb25lbnQiLCJkZXRhY2giLCJyb290X3ByZWxvYWQiLCJzYXBwZXIuc3RhcnQiXSwibWFwcGluZ3MiOiJBQUFBLFNBQVMsSUFBSSxHQUFHLEdBQUc7QUFDbkIsTUFBTSxRQUFRLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUN4QixTQUFTLE1BQU0sQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFO0FBQzFCO0FBQ0EsSUFBSSxLQUFLLE1BQU0sQ0FBQyxJQUFJLEdBQUc7QUFDdkIsUUFBUSxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3hCLElBQUksT0FBTyxHQUFHLENBQUM7QUFDZixDQUFDO0FBSUQsU0FBUyxZQUFZLENBQUMsT0FBTyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRTtBQUN6RCxJQUFJLE9BQU8sQ0FBQyxhQUFhLEdBQUc7QUFDNUIsUUFBUSxHQUFHLEVBQUUsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUU7QUFDekMs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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxRQUFRLENBQUMsS0FBSyxFQUFFO0FBQ3pCLEVBQUUsSUFBSSxDQUFDLEtBQUssRUFBRTtBQUNkLElBQUksT0FBTyxLQUFLLEtBQUssQ0FBQyxHQUFHLEtBQUssR0FBRyxDQUFDLENBQUM7QUFDbkMsR0FBRztBQUNILEVBQUUsS0FBSyxHQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUMxQixFQUFFLElBQUksS0FBSyxLQUFLQSxVQUFRLElBQUksS0FBSyxLQUFLLENBQUNBLFVBQVEsRUFBRTtBQUNqRCxJQUFJLElBQUksSUFBSSxJQUFJLEtBQUssR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDcEMsSUFBSSxPQUFPLElBQUksR0FBRyxXQUFXLENBQUM7QUFDOUIsR0FBRztBQUNILEVBQUUsT0FBTyxLQUFLLEtBQUssS0FBSyxHQUFHLEtBQUssR0FBRyxDQUFDLENBQUM7QUFDckMsQ0FBQzs7QUNyQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsU0FBUyxDQUFDLEtBQUssRUFBRTtBQUMxQixFQUFFLElBQUksTUFBTSxHQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUM7QUFDOUIsTUFBTSxTQUFTLEdBQUcsTUFBTSxHQUFHLENBQUMsQ0FBQztBQUM3QjtBQUNBLEVBQUUsT0FBTyxNQUFNLEtBQUssTUFBTSxJQUFJLFNBQVMsR0FBRyxNQUFNLEdBQUcsU0FBUyxHQUFHLE1BQU0sSUFBSSxDQUFDLENBQUM7QUFDM0UsQ0FBQzs7QUM3QkQ7QUFDQSxJQUFJLFNBQVMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7dUVDQVQsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUdBQVAsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUVDQUwsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUdBQVAsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7dUVDQVQsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUdBQVAsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUVDQUwsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUdBQVAsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUVDQVAsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUdBQVAsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUVDQVAsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUdBQVAsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7dUVDQVQsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUdBQVAsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUVDQUwsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUdBQVAsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUVDQVAsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUdBQVAsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7dUVDQVQsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUdBQVAsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUVDQUwsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUdBQVAsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUVDQVAsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUdBQVAsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUVDQVAsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUdBQVAsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUVDQVAsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUdBQVAsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7dUVDQVQsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUdBQVAsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUVDQUwsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUdBQVAsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUVDQVAsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUdBQVAsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUVDQVAsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUdBQVAsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7dUVDQVQsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUdBQVAsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7dUVDQVAsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUdBQVAsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUVDQUwsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUdBQVAsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUVDQVAsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUdBQVAsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUVDQVAsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUdBQVAsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUVDQVAsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUdBQVAsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUVDQVAsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUdBQVAsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUVDQVAsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUdBQVAsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7dUVDQVQsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUdBQVAsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7dUVDQVAsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUdBQVAsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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LEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLE1BQU0sR0FBRSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxVQUFVLENBQUMsTUFBTSxJQUFJLFNBQVMsQ0FBQyxzREFBc0QsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxFQUFFLFNBQVMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTSxVQUFVLEVBQUUsT0FBTyxNQUFNLEVBQUUsUUFBUSxFQUFFLE9BQU8sTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLE9BQU8sT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxFQUFFLFVBQVUsRUFBRSxPQUFPLE1BQU0sRUFBRSxDQUFDLENBQUMsV0FBVyxHQUFHLE1BQU0sRUFBRSxDQUFDLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxFQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLEdBQUcsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQUFBNkQsSUFBSSxDQUFDLENBQUMsSUFBSSxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLGNBQWMsQ0FBQyxFQUFFLEtBQUssR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxjQUFjLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxRQUFRLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxNQUFNLElBQUksS0FBSyxDQUFDLDRDQUE0QyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxNQUFNLElBQUksS0FBSyxDQUFDLDRDQUE0QyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDQyxNQUFlLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxlQUFlLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxlQUFlLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsT0FBTyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDLGtCQUFrQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDLGtCQUFrQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTSxFQUFFLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsR0FBRyxLQUFLLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLGNBQWMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLFFBQVEsQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLE1BQU0sR0FBRSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxVQUFVLEVBQUUsT0FBTyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUMsQ0FBQyxPQUFPLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLGNBQWMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLE1BQU0sSUFBSSxLQUFLLENBQUMsd0NBQXdDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsT0FBTSxpQkFBaUIsR0FBRyxDQUFDLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQUFBMkQsSUFBSSxJQUFJLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLEdBQUcsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEVBQUU7OztBQ0dwb0gsTUFBTSxVQUFVLENBQUM7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFD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QyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxPQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxPQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLE9BQU8sS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQywwREFBMEQsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDLHVGQUF1RixDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQUcsUUFBUSxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxPQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxRQUFRLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxHQUFHLENBQUMsQ0FBQyxPQUFPLElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxZQUFZLElBQUksQ0FBQyxPQUFPLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsUUFBUSxFQUFFLE9BQU8sQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLEdBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsVUFBVSxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsVUFBVSxFQUFFLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsZUFBZSxHQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLE9BQU0sRUFBRSxjQUFjLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsT0FBTyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsT0FBTyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsT0FBTyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsT0FBTyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsT0FBTyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsT0FBTyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsT0FBTyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsT0FBTyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsT0FBTyxJQUFJLENBQUMsRUFBRSxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQyxTQUFTLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLE9BQU8sSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsY0FBYyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFFLENBQUMsS0FBSyxDQUFDLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsT0FBTyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQyxPQUFNLGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsc0JBQXNCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLGlCQUFpQixFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLFNBQVMsRUFBRSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsVUFBVSxDQUFDLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsT0FBTyxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsT0FBTyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLE9BQU8sSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLFVBQVUsQ0FBQyxPQUFPLElBQUksQ0FBQyxFQUFFLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxPQUFPLElBQUksQ0FBQyxFQUFFLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7Ozs7QUNBOTZNLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQUFBcUQsY0FBYyxDQUFDLENBQUMsRUFBRSxDQUFnRixDQUFDLENBQUNBLGNBQUksQ0FBQyxVQUFVLENBQUMsQUFBYSxPQUFPLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsRUFBRSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxZQUFZLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLE9BQU8sSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsQ0FBQzs7OztBQ0FydUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxBQUFxRCxjQUFjLENBQUMsQ0FBQyxFQUFFLENBQXVFLENBQUMsQ0FBQ0EsY0FBSSxDQUFDLFVBQVUsQ0FBQyxBQUFhLE9BQU8sU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxJQUFJLEVBQUUsaUJBQWlCLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsT0FBTyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxjQUFjLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxVQUFVLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxTQUFTLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxhQUFhLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxhQUFhLEVBQUUsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxrQkFBa0IsR0FBRSxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsd0JBQXdCLENBQUMsRUFBRSxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxPQUFPLElBQUksQ0FBQyxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLE9BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLFVBQVUsQ0FBQyxPQUFPLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLE9BQU8sSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsT0FBTSxHQUFHLEdBQUcsQ0FBQyxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMseUJBQXlCLENBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUMsQ0FBQyxDQUFDLENBQUM7Ozs7QUNBN2pELENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQUFBcUQsY0FBYyxDQUFDLENBQUMsRUFBRSxDQUEyRSxDQUFDLENBQUNBLGNBQUksQ0FBQyxVQUFVLENBQUMsQUFBYSxPQUFPLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDLFNBQVMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsT0FBTyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxFQUFDLENBQUMsQ0FBQyxDQUFDOzs7O0FDQXBYLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQUFBcUQsY0FBYyxDQUFDLENBQUMsRUFBRSxDQUFzRSxDQUFDLENBQUNBLGNBQUksQ0FBQyxVQUFVLENBQUMsQUFBYSxPQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsMERBQTBELENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyx1RkFBdUYsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDOzs7O0FDQXZZLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQUFBcUQsY0FBYyxDQUFDLENBQUMsQ0FBQ0csU0FBZ0IsQ0FBQyxDQUF1RixDQUFDLENBQUNILGNBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEFBQWEsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsY0FBYyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLG1GQUFtRixDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsaUZBQWlGLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQywrREFBK0QsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLCtEQUErRCxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsOEJBQThCLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTSxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMscUJBQXFCLENBQUMscUJBQXFCLENBQUMsRUFBRSxDQUFDLGdCQUFnQixDQUFDLEVBQUUsQ0FBQyxlQUFlLENBQUMsRUFBRSxDQUFDLHNCQUFzQixDQUFDLEVBQUUsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLCtEQUErRCxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxhQUFhLENBQUMsNkJBQTZCLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxzQkFBc0IsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUMsRUFBRSxDQUFDLGdCQUFnQixDQUFDLEdBQUcsQ0FBQyxzQkFBc0IsQ0FBQyxJQUFJLENBQUMsNEJBQTRCLENBQUMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLGtCQUFrQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzs7OztBQ0E1bkQsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxBQUFxRCxjQUFjLENBQUMsQ0FBQyxDQUFDRyxTQUFnQixDQUFDLENBQXVGLENBQUMsQ0FBQ0gsY0FBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQUFBYSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxjQUFjLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsd0ZBQXdGLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxnR0FBZ0csQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLDhCQUE4QixDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU0sR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsd0JBQXdCLENBQUMsd0JBQXdCLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyx3QkFBd0IsQ0FBQyx3QkFBd0IsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLHFCQUFxQixDQUFDLHFCQUFxQixDQUFDLEVBQUUsQ0FBQyxlQUFlLENBQUMsRUFBRSxDQUFDLHVCQUF1QixDQUFDLEVBQUUsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFD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
