import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, B as Br, C as Carousel, v as validate_slots, e as element, t as text, f as space, g as create_component, k as claim_element, l as children, n as claim_text, h as detach_dev, j as claim_space, m as claim_component, p as add_location, o as attr_dev, G as set_style, r as insert_dev, a as append_dev, u as mount_component, x as transition_in, y as transition_out, z as destroy_component, H as Button, I as Icon, w as noop, A as TrustButton, E as createEventDispatcher, c as Comments, J as DonatorsList, O as Loader, R as group_outros, U as check_outros, aj as validate_each_argument, Q as empty, ak as destroy_each, N as set_data_dev, $ as Documents$1, a0 as Card, aa as options, al as _, _ as FancyBox, a1 as Avatar, am as StoryList, an as find, ao as vaccinations, P as Progress, a4 as Picture, a7 as EditCard, Z as safeGet, a8 as FormBuilder, a9 as bubble, ap as formatTextToBullets, aq as Square, ar as RadioRect, as as assign, at as is_function, au as get_spread_update, av as get_spread_object, aw as DonationButton, ab as LazyToggle, F as Footer, ac as stores$1, ad as validate_store, ae as component_subscribe, W as onMount, af as API, ag as delay, ah as EditArea, ai as globals, q as query_selector_all } from './client.02b1df94.js';

/* src/routes/funds/components/_Media.svelte generated by Svelte v3.24.0 */
const file = "src/routes/funds/components/_Media.svelte";

function create_fragment(ctx) {
	let h1;
	let t0;
	let t1;
	let br;
	let t2;
	let section;
	let carousel;
	let current;
	br = new Br({ props: { size: "20" }, $$inline: true });

	carousel = new Carousel({
			props: { items: /*items*/ ctx[0] },
			$$inline: true
		});

	const block = {
		c: function create() {
			h1 = element("h1");
			t0 = text("Відео про Волтера");
			t1 = space();
			create_component(br.$$.fragment);
			t2 = space();
			section = element("section");
			create_component(carousel.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			h1 = claim_element(nodes, "H1", {});
			var h1_nodes = children(h1);
			t0 = claim_text(h1_nodes, "Відео про Волтера");
			h1_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			claim_component(br.$$.fragment, nodes);
			t2 = claim_space(nodes);
			section = claim_element(nodes, "SECTION", { class: true, style: true });
			var section_nodes = children(section);
			claim_component(carousel.$$.fragment, section_nodes);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(h1, file, 6, 0, 94);
			attr_dev(section, "class", "flex");
			set_style(section, "height", "280px");
			add_location(section, file, 8, 0, 137);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h1, anchor);
			append_dev(h1, t0);
			insert_dev(target, t1, anchor);
			mount_component(br, target, anchor);
			insert_dev(target, t2, anchor);
			insert_dev(target, section, anchor);
			mount_component(carousel, section, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const carousel_changes = {};
			if (dirty & /*items*/ 1) carousel_changes.items = /*items*/ ctx[0];
			carousel.$set(carousel_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(br.$$.fragment, local);
			transition_in(carousel.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br.$$.fragment, local);
			transition_out(carousel.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h1);
			if (detaching) detach_dev(t1);
			destroy_component(br, detaching);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(section);
			destroy_component(carousel);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { items = [] } = $$props;
	const writable_props = ["items"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Media> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Media", $$slots, []);

	$$self.$set = $$props => {
		if ("items" in $$props) $$invalidate(0, items = $$props.items);
	};

	$$self.$capture_state = () => ({ Br, Carousel, items });

	$$self.$inject_state = $$props => {
		if ("items" in $$props) $$invalidate(0, items = $$props.items);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [items];
}

class Media extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, { items: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Media",
			options,
			id: create_fragment.name
		});
	}

	get items() {
		throw new Error("<Media>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set items(value) {
		throw new Error("<Media>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/funds/components/_Share.svelte generated by Svelte v3.24.0 */
const file$1 = "src/routes/funds/components/_Share.svelte";

// (6:4) <Button class="flex flex-align-center" auto size="small">
function create_default_slot_1(ctx) {
	let icon;
	let t0;
	let s0;
	let t1;
	let s1;
	let t2;
	let p;
	let t3;
	let current;

	icon = new Icon({
			props: {
				type: "share",
				size: "medium",
				class: "theme-svg-fill"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
			t0 = space();
			s0 = element("s");
			t1 = space();
			s1 = element("s");
			t2 = space();
			p = element("p");
			t3 = text("Поділитись");
			this.h();
		},
		l: function claim(nodes) {
			claim_component(icon.$$.fragment, nodes);
			t0 = claim_space(nodes);
			s0 = claim_element(nodes, "S", {});
			children(s0).forEach(detach_dev);
			t1 = claim_space(nodes);
			s1 = claim_element(nodes, "S", {});
			children(s1).forEach(detach_dev);
			t2 = claim_space(nodes);
			p = claim_element(nodes, "P", { class: true });
			var p_nodes = children(p);
			t3 = claim_text(p_nodes, "Поділитись");
			p_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(s0, file$1, 7, 8, 220);
			add_location(s1, file$1, 8, 8, 236);
			attr_dev(p, "class", "font-w-500");
			add_location(p, file$1, 9, 8, 252);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, s0, anchor);
			insert_dev(target, t1, anchor);
			insert_dev(target, s1, anchor);
			insert_dev(target, t2, anchor);
			insert_dev(target, p, anchor);
			append_dev(p, t3);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(s0);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(s1);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1.name,
		type: "slot",
		source: "(6:4) <Button class=\\\"flex flex-align-center\\\" auto size=\\\"small\\\">",
		ctx
	});

	return block;
}

// (17:4) <Button class="flex flex-align-center" auto size="small">
function create_default_slot(ctx) {
	let icon;
	let t0;
	let s0;
	let t1;
	let s1;
	let t2;
	let p;
	let t3;
	let current;

	icon = new Icon({
			props: {
				type: "link",
				size: "medium",
				class: "theme-svg-fill"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
			t0 = space();
			s0 = element("s");
			t1 = space();
			s1 = element("s");
			t2 = space();
			p = element("p");
			t3 = text("Скопіювати");
			this.h();
		},
		l: function claim(nodes) {
			claim_component(icon.$$.fragment, nodes);
			t0 = claim_space(nodes);
			s0 = claim_element(nodes, "S", {});
			children(s0).forEach(detach_dev);
			t1 = claim_space(nodes);
			s1 = claim_element(nodes, "S", {});
			children(s1).forEach(detach_dev);
			t2 = claim_space(nodes);
			p = claim_element(nodes, "P", { class: true });
			var p_nodes = children(p);
			t3 = claim_text(p_nodes, "Скопіювати");
			p_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(s0, file$1, 18, 8, 498);
			add_location(s1, file$1, 19, 8, 514);
			attr_dev(p, "class", "font-w-500");
			add_location(p, file$1, 20, 8, 530);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, s0, anchor);
			insert_dev(target, t1, anchor);
			insert_dev(target, s1, anchor);
			insert_dev(target, t2, anchor);
			insert_dev(target, p, anchor);
			append_dev(p, t3);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(s0);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(s1);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(17:4) <Button class=\\\"flex flex-align-center\\\" auto size=\\\"small\\\">",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let p;
	let button0;
	let t0;
	let s0;
	let t1;
	let s1;
	let t2;
	let s2;
	let t3;
	let s3;
	let t4;
	let s4;
	let t5;
	let button1;
	let current;

	button0 = new Button({
			props: {
				class: "flex flex-align-center",
				auto: true,
				size: "small",
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button1 = new Button({
			props: {
				class: "flex flex-align-center",
				auto: true,
				size: "small",
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			p = element("p");
			create_component(button0.$$.fragment);
			t0 = space();
			s0 = element("s");
			t1 = space();
			s1 = element("s");
			t2 = space();
			s2 = element("s");
			t3 = space();
			s3 = element("s");
			t4 = space();
			s4 = element("s");
			t5 = space();
			create_component(button1.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			p = claim_element(nodes, "P", { class: true });
			var p_nodes = children(p);
			claim_component(button0.$$.fragment, p_nodes);
			t0 = claim_space(p_nodes);
			s0 = claim_element(p_nodes, "S", {});
			children(s0).forEach(detach_dev);
			t1 = claim_space(p_nodes);
			s1 = claim_element(p_nodes, "S", {});
			children(s1).forEach(detach_dev);
			t2 = claim_space(p_nodes);
			s2 = claim_element(p_nodes, "S", {});
			children(s2).forEach(detach_dev);
			t3 = claim_space(p_nodes);
			s3 = claim_element(p_nodes, "S", {});
			children(s3).forEach(detach_dev);
			t4 = claim_space(p_nodes);
			s4 = claim_element(p_nodes, "S", {});
			children(s4).forEach(detach_dev);
			t5 = claim_space(p_nodes);
			claim_component(button1.$$.fragment, p_nodes);
			p_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(s0, file$1, 11, 4, 307);
			add_location(s1, file$1, 12, 4, 319);
			add_location(s2, file$1, 13, 4, 331);
			add_location(s3, file$1, 14, 4, 343);
			add_location(s4, file$1, 15, 4, 355);
			attr_dev(p, "class", "flex");
			add_location(p, file$1, 4, 0, 67);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			mount_component(button0, p, null);
			append_dev(p, t0);
			append_dev(p, s0);
			append_dev(p, t1);
			append_dev(p, s1);
			append_dev(p, t2);
			append_dev(p, s2);
			append_dev(p, t3);
			append_dev(p, s3);
			append_dev(p, t4);
			append_dev(p, s4);
			append_dev(p, t5);
			mount_component(button1, p, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const button0_changes = {};

			if (dirty & /*$$scope*/ 1) {
				button0_changes.$$scope = { dirty, ctx };
			}

			button0.$set(button0_changes);
			const button1_changes = {};

			if (dirty & /*$$scope*/ 1) {
				button1_changes.$$scope = { dirty, ctx };
			}

			button1.$set(button1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
			destroy_component(button0);
			destroy_component(button1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Share> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Share", $$slots, []);
	$$self.$capture_state = () => ({ Button, Icon });
	return [];
}

class Share extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Share",
			options,
			id: create_fragment$1.name
		});
	}
}

/* src/routes/funds/components/_Trust.svelte generated by Svelte v3.24.0 */
const file$2 = "src/routes/funds/components/_Trust.svelte";

function create_fragment$2(ctx) {
	let section;
	let div;
	let trustbutton;
	let t0;
	let br;
	let t1;
	let h2;
	let t2;
	let current;

	trustbutton = new TrustButton({
			props: { isActive: /*active*/ ctx[0] },
			$$inline: true
		});

	trustbutton.$on("click", /*click_handler*/ ctx[2]);
	br = new Br({ props: { size: "10" }, $$inline: true });

	const block = {
		c: function create() {
			section = element("section");
			div = element("div");
			create_component(trustbutton.$$.fragment);
			t0 = space();
			create_component(br.$$.fragment);
			t1 = space();
			h2 = element("h2");
			t2 = text("Я довіряю");
			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { class: true });
			var section_nodes = children(section);
			div = claim_element(section_nodes, "DIV", { style: true });
			var div_nodes = children(div);
			claim_component(trustbutton.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			t0 = claim_space(section_nodes);
			claim_component(br.$$.fragment, section_nodes);
			t1 = claim_space(section_nodes);
			h2 = claim_element(section_nodes, "H2", {});
			var h2_nodes = children(h2);
			t2 = claim_text(h2_nodes, "Я довіряю");
			h2_nodes.forEach(detach_dev);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_style(div, "width", "100px");
			set_style(div, "max-width", "100%");
			add_location(div, file$2, 10, 4, 275);
			add_location(h2, file$2, 14, 4, 438);
			attr_dev(section, "class", "flex flex-column flex-align-center flex-justify-center");
			add_location(section, file$2, 9, 0, 198);
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			append_dev(section, div);
			mount_component(trustbutton, div, null);
			append_dev(section, t0);
			mount_component(br, section, null);
			append_dev(section, t1);
			append_dev(section, h2);
			append_dev(h2, t2);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const trustbutton_changes = {};
			if (dirty & /*active*/ 1) trustbutton_changes.isActive = /*active*/ ctx[0];
			trustbutton.$set(trustbutton_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(trustbutton.$$.fragment, local);
			transition_in(br.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(trustbutton.$$.fragment, local);
			transition_out(br.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			destroy_component(trustbutton);
			destroy_component(br);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	const dispatch = createEventDispatcher();
	let { active = false } = $$props;
	const writable_props = ["active"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Trust> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Trust", $$slots, []);
	const click_handler = e => dispatch("click", !active);

	$$self.$set = $$props => {
		if ("active" in $$props) $$invalidate(0, active = $$props.active);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		TrustButton,
		Br,
		dispatch,
		active
	});

	$$self.$inject_state = $$props => {
		if ("active" in $$props) $$invalidate(0, active = $$props.active);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [active, dispatch, click_handler];
}

class Trust extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, { active: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Trust",
			options,
			id: create_fragment$2.name
		});
	}

	get active() {
		throw new Error("<Trust>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set active(value) {
		throw new Error("<Trust>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/funds/components/_Comments.svelte generated by Svelte v3.24.0 */
const file$3 = "src/routes/funds/components/_Comments.svelte";

function create_fragment$3(ctx) {
	let h1;
	let t0;
	let t1;
	let br;
	let t2;
	let div;
	let comments;
	let current;
	br = new Br({ props: { size: "5" }, $$inline: true });

	comments = new Comments({
			props: { items: /*items*/ ctx[0] },
			$$inline: true
		});

	const block = {
		c: function create() {
			h1 = element("h1");
			t0 = text("Коментарі");
			t1 = space();
			create_component(br.$$.fragment);
			t2 = space();
			div = element("div");
			create_component(comments.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			h1 = claim_element(nodes, "H1", {});
			var h1_nodes = children(h1);
			t0 = claim_text(h1_nodes, "Коментарі");
			h1_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			claim_component(br.$$.fragment, nodes);
			t2 = claim_space(nodes);
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			claim_component(comments.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(h1, file$3, 6, 0, 89);
			attr_dev(div, "class", "full-container");
			add_location(div, file$3, 8, 0, 123);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h1, anchor);
			append_dev(h1, t0);
			insert_dev(target, t1, anchor);
			mount_component(br, target, anchor);
			insert_dev(target, t2, anchor);
			insert_dev(target, div, anchor);
			mount_component(comments, div, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const comments_changes = {};
			if (dirty & /*items*/ 1) comments_changes.items = /*items*/ ctx[0];
			comments.$set(comments_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(br.$$.fragment, local);
			transition_in(comments.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br.$$.fragment, local);
			transition_out(comments.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h1);
			if (detaching) detach_dev(t1);
			destroy_component(br, detaching);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(div);
			destroy_component(comments);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3($$self, $$props, $$invalidate) {
	let { items } = $$props;
	const writable_props = ["items"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Comments> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Comments", $$slots, []);

	$$self.$set = $$props => {
		if ("items" in $$props) $$invalidate(0, items = $$props.items);
	};

	$$self.$capture_state = () => ({ Br, Comments, items });

	$$self.$inject_state = $$props => {
		if ("items" in $$props) $$invalidate(0, items = $$props.items);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [items];
}

class Comments_1 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3, create_fragment$3, safe_not_equal, { items: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Comments_1",
			options,
			id: create_fragment$3.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*items*/ ctx[0] === undefined && !("items" in props)) {
			console.warn("<Comments> was created without expected prop 'items'");
		}
	}

	get items() {
		throw new Error("<Comments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set items(value) {
		throw new Error("<Comments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/funds/components/_Donators.svelte generated by Svelte v3.24.0 */
const file$4 = "src/routes/funds/components/_Donators.svelte";

function create_fragment$4(ctx) {
	let h1;
	let t0;
	let t1;
	let br;
	let t2;
	let div;
	let donatorslist;
	let current;
	br = new Br({ props: { size: "20" }, $$inline: true });

	donatorslist = new DonatorsList({
			props: { items: /*items*/ ctx[0] },
			$$inline: true
		});

	const block = {
		c: function create() {
			h1 = element("h1");
			t0 = text("Наші піклувальники");
			t1 = space();
			create_component(br.$$.fragment);
			t2 = space();
			div = element("div");
			create_component(donatorslist.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			h1 = claim_element(nodes, "H1", {});
			var h1_nodes = children(h1);
			t0 = claim_text(h1_nodes, "Наші піклувальники");
			h1_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			claim_component(br.$$.fragment, nodes);
			t2 = claim_space(nodes);
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			claim_component(donatorslist.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(h1, file$4, 6, 0, 93);
			attr_dev(div, "class", "full-container");
			add_location(div, file$4, 8, 0, 137);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h1, anchor);
			append_dev(h1, t0);
			insert_dev(target, t1, anchor);
			mount_component(br, target, anchor);
			insert_dev(target, t2, anchor);
			insert_dev(target, div, anchor);
			mount_component(donatorslist, div, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const donatorslist_changes = {};
			if (dirty & /*items*/ 1) donatorslist_changes.items = /*items*/ ctx[0];
			donatorslist.$set(donatorslist_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(br.$$.fragment, local);
			transition_in(donatorslist.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br.$$.fragment, local);
			transition_out(donatorslist.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h1);
			if (detaching) detach_dev(t1);
			destroy_component(br, detaching);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(div);
			destroy_component(donatorslist);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4($$self, $$props, $$invalidate) {
	let { items } = $$props;
	const writable_props = ["items"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Donators> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Donators", $$slots, []);

	$$self.$set = $$props => {
		if ("items" in $$props) $$invalidate(0, items = $$props.items);
	};

	$$self.$capture_state = () => ({ Br, DonatorsList, items });

	$$self.$inject_state = $$props => {
		if ("items" in $$props) $$invalidate(0, items = $$props.items);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [items];
}

class Donators extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4, create_fragment$4, safe_not_equal, { items: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Donators",
			options,
			id: create_fragment$4.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*items*/ ctx[0] === undefined && !("items" in props)) {
			console.warn("<Donators> was created without expected prop 'items'");
		}
	}

	get items() {
		throw new Error("<Donators>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set items(value) {
		throw new Error("<Donators>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/funds/components/_HowToHelp.svelte generated by Svelte v3.24.0 */
const file$5 = "src/routes/funds/components/_HowToHelp.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[1] = list[i];
	return child_ctx;
}

// (19:4) {:else}
function create_else_block_1(ctx) {
	let li0;
	let span1;
	let span0;
	let t0;
	let t1;
	let loader0;
	let t2;
	let li1;
	let span3;
	let span2;
	let t3;
	let t4;
	let loader1;
	let t5;
	let li2;
	let span5;
	let span4;
	let t6;
	let t7;
	let loader2;
	let t8;
	let li3;
	let span7;
	let span6;
	let t9;
	let t10;
	let loader3;
	let current;

	loader0 = new Loader({
			props: { type: "h3", absolute: true },
			$$inline: true
		});

	loader1 = new Loader({
			props: { type: "h3", absolute: true },
			$$inline: true
		});

	loader2 = new Loader({
			props: { type: "h3", absolute: true },
			$$inline: true
		});

	loader3 = new Loader({
			props: { type: "h3", absolute: true },
			$$inline: true
		});

	const block = {
		c: function create() {
			li0 = element("li");
			span1 = element("span");
			span0 = element("span");
			t0 = text("Допомогти любим способом");
			t1 = space();
			create_component(loader0.$$.fragment);
			t2 = space();
			li1 = element("li");
			span3 = element("span");
			span2 = element("span");
			t3 = text("Допомогти любим способом");
			t4 = space();
			create_component(loader1.$$.fragment);
			t5 = space();
			li2 = element("li");
			span5 = element("span");
			span4 = element("span");
			t6 = text("Допомогти любим способом");
			t7 = space();
			create_component(loader2.$$.fragment);
			t8 = space();
			li3 = element("li");
			span7 = element("span");
			span6 = element("span");
			t9 = text("Допомогти любим способом");
			t10 = space();
			create_component(loader3.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			li0 = claim_element(nodes, "LI", { style: true });
			var li0_nodes = children(li0);
			span1 = claim_element(li0_nodes, "SPAN", { class: true });
			var span1_nodes = children(span1);
			span0 = claim_element(span1_nodes, "SPAN", { style: true });
			var span0_nodes = children(span0);
			t0 = claim_text(span0_nodes, "Допомогти любим способом");
			span0_nodes.forEach(detach_dev);
			t1 = claim_space(span1_nodes);
			claim_component(loader0.$$.fragment, span1_nodes);
			span1_nodes.forEach(detach_dev);
			li0_nodes.forEach(detach_dev);
			t2 = claim_space(nodes);
			li1 = claim_element(nodes, "LI", { style: true });
			var li1_nodes = children(li1);
			span3 = claim_element(li1_nodes, "SPAN", { class: true });
			var span3_nodes = children(span3);
			span2 = claim_element(span3_nodes, "SPAN", { style: true });
			var span2_nodes = children(span2);
			t3 = claim_text(span2_nodes, "Допомогти любим способом");
			span2_nodes.forEach(detach_dev);
			t4 = claim_space(span3_nodes);
			claim_component(loader1.$$.fragment, span3_nodes);
			span3_nodes.forEach(detach_dev);
			li1_nodes.forEach(detach_dev);
			t5 = claim_space(nodes);
			li2 = claim_element(nodes, "LI", { style: true });
			var li2_nodes = children(li2);
			span5 = claim_element(li2_nodes, "SPAN", { class: true });
			var span5_nodes = children(span5);
			span4 = claim_element(span5_nodes, "SPAN", { style: true });
			var span4_nodes = children(span4);
			t6 = claim_text(span4_nodes, "Допомогти любим способом");
			span4_nodes.forEach(detach_dev);
			t7 = claim_space(span5_nodes);
			claim_component(loader2.$$.fragment, span5_nodes);
			span5_nodes.forEach(detach_dev);
			li2_nodes.forEach(detach_dev);
			t8 = claim_space(nodes);
			li3 = claim_element(nodes, "LI", { style: true });
			var li3_nodes = children(li3);
			span7 = claim_element(li3_nodes, "SPAN", { class: true });
			var span7_nodes = children(span7);
			span6 = claim_element(span7_nodes, "SPAN", { style: true });
			var span6_nodes = children(span6);
			t9 = claim_text(span6_nodes, "Допомогти любим способом");
			span6_nodes.forEach(detach_dev);
			t10 = claim_space(span7_nodes);
			claim_component(loader3.$$.fragment, span7_nodes);
			span7_nodes.forEach(detach_dev);
			li3_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_style(span0, "visibility", "hidden");
			add_location(span0, file$5, 21, 16, 695);
			attr_dev(span1, "class", "font-secondary font-w-500 p relative");
			add_location(span1, file$5, 20, 12, 627);
			set_style(li0, "padding-bottom", "5px");
			add_location(li0, file$5, 19, 8, 582);
			set_style(span2, "visibility", "hidden");
			add_location(span2, file$5, 27, 16, 961);
			attr_dev(span3, "class", "font-secondary font-w-500 p relative");
			add_location(span3, file$5, 26, 12, 893);
			set_style(li1, "padding-bottom", "5px");
			add_location(li1, file$5, 25, 7, 848);
			set_style(span4, "visibility", "hidden");
			add_location(span4, file$5, 33, 16, 1227);
			attr_dev(span5, "class", "font-secondary font-w-500 p relative");
			add_location(span5, file$5, 32, 12, 1159);
			set_style(li2, "padding-bottom", "5px");
			add_location(li2, file$5, 31, 7, 1114);
			set_style(span6, "visibility", "hidden");
			add_location(span6, file$5, 39, 16, 1491);
			attr_dev(span7, "class", "font-secondary font-w-500 p relative");
			add_location(span7, file$5, 38, 12, 1423);
			set_style(li3, "padding-bottom", "5px");
			add_location(li3, file$5, 37, 7, 1378);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li0, anchor);
			append_dev(li0, span1);
			append_dev(span1, span0);
			append_dev(span0, t0);
			append_dev(span1, t1);
			mount_component(loader0, span1, null);
			insert_dev(target, t2, anchor);
			insert_dev(target, li1, anchor);
			append_dev(li1, span3);
			append_dev(span3, span2);
			append_dev(span2, t3);
			append_dev(span3, t4);
			mount_component(loader1, span3, null);
			insert_dev(target, t5, anchor);
			insert_dev(target, li2, anchor);
			append_dev(li2, span5);
			append_dev(span5, span4);
			append_dev(span4, t6);
			append_dev(span5, t7);
			mount_component(loader2, span5, null);
			insert_dev(target, t8, anchor);
			insert_dev(target, li3, anchor);
			append_dev(li3, span7);
			append_dev(span7, span6);
			append_dev(span6, t9);
			append_dev(span7, t10);
			mount_component(loader3, span7, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(loader0.$$.fragment, local);
			transition_in(loader1.$$.fragment, local);
			transition_in(loader2.$$.fragment, local);
			transition_in(loader3.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loader0.$$.fragment, local);
			transition_out(loader1.$$.fragment, local);
			transition_out(loader2.$$.fragment, local);
			transition_out(loader3.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li0);
			destroy_component(loader0);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(li1);
			destroy_component(loader1);
			if (detaching) detach_dev(t5);
			if (detaching) detach_dev(li2);
			destroy_component(loader2);
			if (detaching) detach_dev(t8);
			if (detaching) detach_dev(li3);
			destroy_component(loader3);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1.name,
		type: "else",
		source: "(19:4) {:else}",
		ctx
	});

	return block;
}

// (13:4) {#if data.how_to_help !== null}
function create_if_block_1(ctx) {
	let if_block_anchor;
	let if_block = typeof /*data*/ ctx[0].how_to_help === "string" && create_if_block_2(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (typeof /*data*/ ctx[0].how_to_help === "string") {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_2(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(13:4) {#if data.how_to_help !== null}",
		ctx
	});

	return block;
}

// (14:8) {#if typeof data.how_to_help === 'string'}
function create_if_block_2(ctx) {
	let each_1_anchor;
	let each_value = /*data*/ ctx[0].how_to_help.split(/\n?• /).filter(Boolean);
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*data, Boolean*/ 1) {
				each_value = /*data*/ ctx[0].how_to_help.split(/\n?• /).filter(Boolean);
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(14:8) {#if typeof data.how_to_help === 'string'}",
		ctx
	});

	return block;
}

// (15:12) {#each data.how_to_help.split(/\n?• /).filter(Boolean) as line}
function create_each_block(ctx) {
	let li;
	let t_value = /*line*/ ctx[1] + "";
	let t;

	const block = {
		c: function create() {
			li = element("li");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { style: true });
			var li_nodes = children(li);
			t = claim_text(li_nodes, t_value);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_style(li, "padding-bottom", "5px");
			add_location(li, file$5, 15, 16, 484);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*data*/ 1 && t_value !== (t_value = /*line*/ ctx[1] + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(15:12) {#each data.how_to_help.split(/\\n?• /).filter(Boolean) as line}",
		ctx
	});

	return block;
}

// (54:8) {:else}
function create_else_block(ctx) {
	let span;
	let loader;
	let current;
	loader = new Loader({ props: { type: "h2" }, $$inline: true });

	const block = {
		c: function create() {
			span = element("span");
			create_component(loader.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { style: true });
			var span_nodes = children(span);
			claim_component(loader.$$.fragment, span_nodes);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_style(span, "width", "240px");
			add_location(span, file$5, 54, 12, 1947);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			mount_component(loader, span, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(loader.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loader.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			destroy_component(loader);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(54:8) {:else}",
		ctx
	});

	return block;
}

// (52:8) {#if data.phone !== null}
function create_if_block(ctx) {
	let h2;
	let t_value = /*data*/ ctx[0].phone + "";
	let t;

	const block = {
		c: function create() {
			h2 = element("h2");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			h2 = claim_element(nodes, "H2", {});
			var h2_nodes = children(h2);
			t = claim_text(h2_nodes, t_value);
			h2_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(h2, file$5, 52, 12, 1897);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h2, anchor);
			append_dev(h2, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*data*/ 1 && t_value !== (t_value = /*data*/ ctx[0].phone + "")) set_data_dev(t, t_value);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(h2);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(52:8) {#if data.phone !== null}",
		ctx
	});

	return block;
}

function create_fragment$5(ctx) {
	let h1;
	let t0;
	let t1;
	let br0;
	let t2;
	let ul;
	let current_block_type_index;
	let if_block0;
	let t3;
	let br1;
	let t4;
	let div1;
	let div0;
	let icon;
	let t5;
	let s0;
	let t6;
	let s1;
	let t7;
	let current_block_type_index_1;
	let if_block1;
	let t8;
	let br2;
	let t9;
	let p;
	let t10;
	let current;
	br0 = new Br({ props: { size: "15" }, $$inline: true });
	const if_block_creators = [create_if_block_1, create_else_block_1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*data*/ ctx[0].how_to_help !== null) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	br1 = new Br({ props: { size: "30" }, $$inline: true });

	icon = new Icon({
			props: {
				size: "medium",
				type: "phone",
				class: "theme-svg-fill-opposite"
			},
			$$inline: true
		});

	const if_block_creators_1 = [create_if_block, create_else_block];
	const if_blocks_1 = [];

	function select_block_type_1(ctx, dirty) {
		if (/*data*/ ctx[0].phone !== null) return 0;
		return 1;
	}

	current_block_type_index_1 = select_block_type_1(ctx);
	if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
	br2 = new Br({ props: { size: "5" }, $$inline: true });

	const block = {
		c: function create() {
			h1 = element("h1");
			t0 = text("Як допомогти");
			t1 = space();
			create_component(br0.$$.fragment);
			t2 = space();
			ul = element("ul");
			if_block0.c();
			t3 = space();
			create_component(br1.$$.fragment);
			t4 = space();
			div1 = element("div");
			div0 = element("div");
			create_component(icon.$$.fragment);
			t5 = space();
			s0 = element("s");
			t6 = space();
			s1 = element("s");
			t7 = space();
			if_block1.c();
			t8 = space();
			create_component(br2.$$.fragment);
			t9 = space();
			p = element("p");
			t10 = text("Подзвоніть нам, допоможемо разом!");
			this.h();
		},
		l: function claim(nodes) {
			h1 = claim_element(nodes, "H1", {});
			var h1_nodes = children(h1);
			t0 = claim_text(h1_nodes, "Як допомогти");
			h1_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			claim_component(br0.$$.fragment, nodes);
			t2 = claim_space(nodes);
			ul = claim_element(nodes, "UL", { style: true, class: true });
			var ul_nodes = children(ul);
			if_block0.l(ul_nodes);
			ul_nodes.forEach(detach_dev);
			t3 = claim_space(nodes);
			claim_component(br1.$$.fragment, nodes);
			t4 = claim_space(nodes);
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			claim_component(icon.$$.fragment, div0_nodes);
			t5 = claim_space(div0_nodes);
			s0 = claim_element(div0_nodes, "S", {});
			children(s0).forEach(detach_dev);
			t6 = claim_space(div0_nodes);
			s1 = claim_element(div0_nodes, "S", {});
			children(s1).forEach(detach_dev);
			t7 = claim_space(div0_nodes);
			if_block1.l(div0_nodes);
			div0_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			t8 = claim_space(nodes);
			claim_component(br2.$$.fragment, nodes);
			t9 = claim_space(nodes);
			p = claim_element(nodes, "P", { class: true });
			var p_nodes = children(p);
			t10 = claim_text(p_nodes, "Подзвоніть нам, допоможемо разом!");
			p_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(h1, file$5, 9, 0, 150);
			set_style(ul, "list-style", "disc outside none");
			set_style(ul, "padding-left", "var(--screen-padding)");
			attr_dev(ul, "class", "h3 font-w-500 font-secondary");
			add_location(ul, file$5, 11, 0, 188);
			add_location(s0, file$5, 49, 8, 1827);
			add_location(s1, file$5, 50, 8, 1843);
			attr_dev(div0, "class", "flex flex-align-center font-secondary");
			add_location(div0, file$5, 47, 4, 1692);
			attr_dev(div1, "class", "flex");
			add_location(div1, file$5, 46, 0, 1669);
			attr_dev(p, "class", "font-w-300");
			add_location(p, file$5, 59, 0, 2048);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h1, anchor);
			append_dev(h1, t0);
			insert_dev(target, t1, anchor);
			mount_component(br0, target, anchor);
			insert_dev(target, t2, anchor);
			insert_dev(target, ul, anchor);
			if_blocks[current_block_type_index].m(ul, null);
			insert_dev(target, t3, anchor);
			mount_component(br1, target, anchor);
			insert_dev(target, t4, anchor);
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			mount_component(icon, div0, null);
			append_dev(div0, t5);
			append_dev(div0, s0);
			append_dev(div0, t6);
			append_dev(div0, s1);
			append_dev(div0, t7);
			if_blocks_1[current_block_type_index_1].m(div0, null);
			insert_dev(target, t8, anchor);
			mount_component(br2, target, anchor);
			insert_dev(target, t9, anchor);
			insert_dev(target, p, anchor);
			append_dev(p, t10);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block0 = if_blocks[current_block_type_index];

				if (!if_block0) {
					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block0.c();
				}

				transition_in(if_block0, 1);
				if_block0.m(ul, null);
			}

			let previous_block_index_1 = current_block_type_index_1;
			current_block_type_index_1 = select_block_type_1(ctx);

			if (current_block_type_index_1 === previous_block_index_1) {
				if_blocks_1[current_block_type_index_1].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
					if_blocks_1[previous_block_index_1] = null;
				});

				check_outros();
				if_block1 = if_blocks_1[current_block_type_index_1];

				if (!if_block1) {
					if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
					if_block1.c();
				}

				transition_in(if_block1, 1);
				if_block1.m(div0, null);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(br0.$$.fragment, local);
			transition_in(if_block0);
			transition_in(br1.$$.fragment, local);
			transition_in(icon.$$.fragment, local);
			transition_in(if_block1);
			transition_in(br2.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br0.$$.fragment, local);
			transition_out(if_block0);
			transition_out(br1.$$.fragment, local);
			transition_out(icon.$$.fragment, local);
			transition_out(if_block1);
			transition_out(br2.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h1);
			if (detaching) detach_dev(t1);
			destroy_component(br0, detaching);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(ul);
			if_blocks[current_block_type_index].d();
			if (detaching) detach_dev(t3);
			destroy_component(br1, detaching);
			if (detaching) detach_dev(t4);
			if (detaching) detach_dev(div1);
			destroy_component(icon);
			if_blocks_1[current_block_type_index_1].d();
			if (detaching) detach_dev(t8);
			destroy_component(br2, detaching);
			if (detaching) detach_dev(t9);
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$5.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$5($$self, $$props, $$invalidate) {
	let { data = { phone: null, how_to_help: null } } = $$props;
	const writable_props = ["data"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<HowToHelp> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("HowToHelp", $$slots, []);

	$$self.$set = $$props => {
		if ("data" in $$props) $$invalidate(0, data = $$props.data);
	};

	$$self.$capture_state = () => ({ Br, Icon, Loader, data });

	$$self.$inject_state = $$props => {
		if ("data" in $$props) $$invalidate(0, data = $$props.data);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [data];
}

class HowToHelp extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$5, create_fragment$5, safe_not_equal, { data: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "HowToHelp",
			options,
			id: create_fragment$5.name
		});
	}

	get data() {
		throw new Error("<HowToHelp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set data(value) {
		throw new Error("<HowToHelp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/funds/components/_Documents.svelte generated by Svelte v3.24.0 */
const file$6 = "src/routes/funds/components/_Documents.svelte";

function create_fragment$6(ctx) {
	let h1;
	let t0;
	let t1;
	let br;
	let t2;
	let div;
	let documents;
	let current;
	br = new Br({ props: { size: "5" }, $$inline: true });

	documents = new Documents$1({
			props: { items: /*items*/ ctx[0] },
			$$inline: true
		});

	const block = {
		c: function create() {
			h1 = element("h1");
			t0 = text("Документи");
			t1 = space();
			create_component(br.$$.fragment);
			t2 = space();
			div = element("div");
			create_component(documents.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			h1 = claim_element(nodes, "H1", {});
			var h1_nodes = children(h1);
			t0 = claim_text(h1_nodes, "Документи");
			h1_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			claim_component(br.$$.fragment, nodes);
			t2 = claim_space(nodes);
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			claim_component(documents.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(h1, file$6, 6, 0, 90);
			attr_dev(div, "class", "full-container");
			add_location(div, file$6, 8, 0, 124);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h1, anchor);
			append_dev(h1, t0);
			insert_dev(target, t1, anchor);
			mount_component(br, target, anchor);
			insert_dev(target, t2, anchor);
			insert_dev(target, div, anchor);
			mount_component(documents, div, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const documents_changes = {};
			if (dirty & /*items*/ 1) documents_changes.items = /*items*/ ctx[0];
			documents.$set(documents_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(br.$$.fragment, local);
			transition_in(documents.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br.$$.fragment, local);
			transition_out(documents.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h1);
			if (detaching) detach_dev(t1);
			destroy_component(br, detaching);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(div);
			destroy_component(documents);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$6.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$6($$self, $$props, $$invalidate) {
	let { items } = $$props;
	const writable_props = ["items"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Documents> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Documents", $$slots, []);

	$$self.$set = $$props => {
		if ("items" in $$props) $$invalidate(0, items = $$props.items);
	};

	$$self.$capture_state = () => ({ Br, Documents: Documents$1, items });

	$$self.$inject_state = $$props => {
		if ("items" in $$props) $$invalidate(0, items = $$props.items);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [items];
}

class Documents_1 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$6, create_fragment$6, safe_not_equal, { items: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Documents_1",
			options,
			id: create_fragment$6.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*items*/ ctx[0] === undefined && !("items" in props)) {
			console.warn("<Documents> was created without expected prop 'items'");
		}
	}

	get items() {
		throw new Error("<Documents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set items(value) {
		throw new Error("<Documents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/funds/components/_AnimalCard.svelte generated by Svelte v3.24.0 */
const file$7 = "src/routes/funds/components/_AnimalCard.svelte";

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[2] = list[i];
	child_ctx[4] = i;
	return child_ctx;
}

// (35:16) <section slot="box" class="flex full-width full-height" style="height: 100vw">
function create_box_slot(ctx) {
	let section;
	let div;
	let avatar;
	let current;

	avatar = new Avatar({
			props: {
				src: /*animal*/ ctx[0].avatar,
				srcBig: /*animal*/ ctx[0].avatar2x,
				alt: "Волтер"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			section = element("section");
			div = element("div");
			create_component(avatar.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { slot: true, class: true, style: true });
			var section_nodes = children(section);
			div = claim_element(section_nodes, "DIV", { class: true, style: true });
			var div_nodes = children(div);
			claim_component(avatar.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "flex flex-self-stretch flex-1 overflow-hidden flex-justify-stretch");
			set_style(div, "padding", "var(--screen-padding) 0");
			add_location(div, file$7, 35, 20, 1029);
			attr_dev(section, "slot", "box");
			attr_dev(section, "class", "flex full-width full-height");
			set_style(section, "height", "100vw");
			add_location(section, file$7, 34, 16, 930);
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			append_dev(section, div);
			mount_component(avatar, div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const avatar_changes = {};
			if (dirty & /*animal*/ 1) avatar_changes.src = /*animal*/ ctx[0].avatar;
			if (dirty & /*animal*/ 1) avatar_changes.srcBig = /*animal*/ ctx[0].avatar2x;
			avatar.$set(avatar_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(avatar.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(avatar.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			destroy_component(avatar);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_box_slot.name,
		type: "slot",
		source: "(35:16) <section slot=\\\"box\\\" class=\\\"flex full-width full-height\\\" style=\\\"height: 100vw\\\">",
		ctx
	});

	return block;
}

// (33:12) <FancyBox>
function create_default_slot_1$1(ctx) {
	let avatar;
	let t;
	let current;

	avatar = new Avatar({
			props: {
				src: /*animal*/ ctx[0].avatar,
				size: "big",
				alt: "Волтер"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(avatar.$$.fragment);
			t = space();
		},
		l: function claim(nodes) {
			claim_component(avatar.$$.fragment, nodes);
			t = claim_space(nodes);
		},
		m: function mount(target, anchor) {
			mount_component(avatar, target, anchor);
			insert_dev(target, t, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const avatar_changes = {};
			if (dirty & /*animal*/ 1) avatar_changes.src = /*animal*/ ctx[0].avatar;
			avatar.$set(avatar_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(avatar.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(avatar.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(avatar, detaching);
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$1.name,
		type: "slot",
		source: "(33:12) <FancyBox>",
		ctx
	});

	return block;
}

// (47:8) {:else}
function create_else_block_5(ctx) {
	let span;
	let loader;
	let current;
	loader = new Loader({ props: { type: "h2" }, $$inline: true });

	const block = {
		c: function create() {
			span = element("span");
			create_component(loader.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { style: true });
			var span_nodes = children(span);
			claim_component(loader.$$.fragment, span_nodes);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_style(span, "width", "40%");
			add_location(span, file$7, 47, 12, 1461);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			mount_component(loader, span, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(loader.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loader.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			destroy_component(loader);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_5.name,
		type: "else",
		source: "(47:8) {:else}",
		ctx
	});

	return block;
}

// (45:8) {#if animal.name !== null}
function create_if_block_11(ctx) {
	let h2;
	let t_value = /*animal*/ ctx[0].name + "";
	let t;

	const block = {
		c: function create() {
			h2 = element("h2");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			h2 = claim_element(nodes, "H2", {});
			var h2_nodes = children(h2);
			t = claim_text(h2_nodes, t_value);
			h2_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(h2, file$7, 45, 12, 1410);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h2, anchor);
			append_dev(h2, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*animal*/ 1 && t_value !== (t_value = /*animal*/ ctx[0].name + "")) set_data_dev(t, t_value);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(h2);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_11.name,
		type: "if",
		source: "(45:8) {#if animal.name !== null}",
		ctx
	});

	return block;
}

// (53:8) {:else}
function create_else_block_4(ctx) {
	let span;
	let loader;
	let current;
	loader = new Loader({ props: { type: "h3" }, $$inline: true });

	const block = {
		c: function create() {
			span = element("span");
			create_component(loader.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { style: true });
			var span_nodes = children(span);
			claim_component(loader.$$.fragment, span_nodes);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_style(span, "width", "60%");
			add_location(span, file$7, 53, 12, 1689);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			mount_component(loader, span, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(loader.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loader.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			destroy_component(loader);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_4.name,
		type: "else",
		source: "(53:8) {:else}",
		ctx
	});

	return block;
}

// (51:8) {#if animal.breed !== null}
function create_if_block_10(ctx) {
	let h3;
	let t_value = /*animal*/ ctx[0].breed + "";
	let t;

	const block = {
		c: function create() {
			h3 = element("h3");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			h3 = claim_element(nodes, "H3", { class: true, style: true });
			var h3_nodes = children(h3);
			t = claim_text(h3_nodes, t_value);
			h3_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(h3, "class", "font-w-500");
			set_style(h3, "opacity", ".7");
			add_location(h3, file$7, 51, 12, 1598);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h3, anchor);
			append_dev(h3, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*animal*/ 1 && t_value !== (t_value = /*animal*/ ctx[0].breed + "")) set_data_dev(t, t_value);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(h3);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_10.name,
		type: "if",
		source: "(51:8) {#if animal.breed !== null}",
		ctx
	});

	return block;
}

// (63:12) {#if animal.age !== null}
function create_if_block_9(ctx) {
	let div;
	let h40;
	let t0_value = /*animal*/ ctx[0].age + "";
	let t0;
	let t1;
	let h41;
	let t2;

	const block = {
		c: function create() {
			div = element("div");
			h40 = element("h4");
			t0 = text(t0_value);
			t1 = space();
			h41 = element("h4");
			t2 = text("Роки");
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			h40 = claim_element(div_nodes, "H4", { class: true });
			var h40_nodes = children(h40);
			t0 = claim_text(h40_nodes, t0_value);
			h40_nodes.forEach(detach_dev);
			t1 = claim_space(div_nodes);
			h41 = claim_element(div_nodes, "H4", { style: true });
			var h41_nodes = children(h41);
			t2 = claim_text(h41_nodes, "Роки");
			h41_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(h40, "class", "h1");
			add_location(h40, file$7, 64, 20, 2087);
			set_style(h41, "margin-top", "-8px");
			add_location(h41, file$7, 65, 20, 2140);
			attr_dev(div, "class", "text-white text-center absolute");
			add_location(div, file$7, 63, 16, 2021);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, h40);
			append_dev(h40, t0);
			append_dev(div, t1);
			append_dev(div, h41);
			append_dev(h41, t2);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*animal*/ 1 && t0_value !== (t0_value = /*animal*/ ctx[0].age + "")) set_data_dev(t0, t0_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_9.name,
		type: "if",
		source: "(63:12) {#if animal.age !== null}",
		ctx
	});

	return block;
}

// (74:12) {#if animal.sex !== null}
function create_if_block_6(ctx) {
	let div;
	let current_block_type_index;
	let if_block;
	let current;
	const if_block_creators = [create_if_block_7, create_if_block_8];
	const if_blocks = [];

	function select_block_type_2(ctx, dirty) {
		if (/*animal*/ ctx[0].sex === "male") return 0;
		if (/*animal*/ ctx[0].sex === "female") return 1;
		return -1;
	}

	if (~(current_block_type_index = select_block_type_2(ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true, style: true });
			var div_nodes = children(div);
			if (if_block) if_block.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "absolute flex");
			set_style(div, "width", "44px");
			set_style(div, "height", "44px");
			add_location(div, file$7, 74, 16, 2420);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_2(ctx);

			if (current_block_type_index !== previous_block_index) {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					}

					transition_in(if_block, 1);
					if_block.m(div, null);
				} else {
					if_block = null;
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d();
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_6.name,
		type: "if",
		source: "(74:12) {#if animal.sex !== null}",
		ctx
	});

	return block;
}

// (78:50) 
function create_if_block_8(ctx) {
	let icon;
	let current;

	icon = new Icon({
			props: { type: "female", is: "light" },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(icon.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_8.name,
		type: "if",
		source: "(78:50) ",
		ctx
	});

	return block;
}

// (76:16) {#if animal.sex === 'male'}
function create_if_block_7(ctx) {
	let icon;
	let current;

	icon = new Icon({
			props: { type: "male", is: "light" },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(icon.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_7.name,
		type: "if",
		source: "(76:16) {#if animal.sex === 'male'}",
		ctx
	});

	return block;
}

// (88:12) {#if animal.sterilization !== null}
function create_if_block_4(ctx) {
	let div;
	let current_block_type_index;
	let if_block;
	let t0;
	let span;
	let t1;
	let current;
	const if_block_creators = [create_if_block_5, create_else_block_3];
	const if_blocks = [];

	function select_block_type_3(ctx, dirty) {
		if (/*animal*/ ctx[0].sterilization) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_3(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			div = element("div");
			if_block.c();
			t0 = space();
			span = element("span");
			t1 = text("Cтерилізація");
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if_block.l(div_nodes);
			t0 = claim_space(div_nodes);
			span = claim_element(div_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t1 = claim_text(span_nodes, "Cтерилізація");
			span_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "text-white text-center h5");
			add_location(span, file$7, 94, 20, 3281);
			attr_dev(div, "class", "absolute flex flex-column flex-center");
			add_location(div, file$7, 88, 16, 2957);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if_blocks[current_block_type_index].m(div, null);
			append_dev(div, t0);
			append_dev(div, span);
			append_dev(span, t1);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_3(ctx);

			if (current_block_type_index !== previous_block_index) {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(div, t0);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if_blocks[current_block_type_index].d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4.name,
		type: "if",
		source: "(88:12) {#if animal.sterilization !== null}",
		ctx
	});

	return block;
}

// (92:20) {:else}
function create_else_block_3(ctx) {
	let icon;
	let current;

	icon = new Icon({
			props: {
				type: "cancel-circle",
				is: "light",
				size: "big"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(icon.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_3.name,
		type: "else",
		source: "(92:20) {:else}",
		ctx
	});

	return block;
}

// (90:20) {#if animal.sterilization}
function create_if_block_5(ctx) {
	let icon;
	let current;

	icon = new Icon({
			props: {
				type: "checked-circle",
				is: "light",
				size: "big"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(icon.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_5.name,
		type: "if",
		source: "(90:20) {#if animal.sterilization}",
		ctx
	});

	return block;
}

// (109:4) {:else}
function create_else_block_2(ctx) {
	let loader0;
	let t0;
	let loader1;
	let t1;
	let loader2;
	let t2;
	let loader3;
	let current;
	loader0 = new Loader({ props: { type: "p" }, $$inline: true });
	loader1 = new Loader({ props: { type: "p" }, $$inline: true });
	loader2 = new Loader({ props: { type: "p" }, $$inline: true });
	loader3 = new Loader({ props: { type: "p" }, $$inline: true });

	const block = {
		c: function create() {
			create_component(loader0.$$.fragment);
			t0 = space();
			create_component(loader1.$$.fragment);
			t1 = space();
			create_component(loader2.$$.fragment);
			t2 = space();
			create_component(loader3.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(loader0.$$.fragment, nodes);
			t0 = claim_space(nodes);
			claim_component(loader1.$$.fragment, nodes);
			t1 = claim_space(nodes);
			claim_component(loader2.$$.fragment, nodes);
			t2 = claim_space(nodes);
			claim_component(loader3.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(loader0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(loader1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(loader2, target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(loader3, target, anchor);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(loader0.$$.fragment, local);
			transition_in(loader1.$$.fragment, local);
			transition_in(loader2.$$.fragment, local);
			transition_in(loader3.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loader0.$$.fragment, local);
			transition_out(loader1.$$.fragment, local);
			transition_out(loader2.$$.fragment, local);
			transition_out(loader3.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(loader0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(loader1, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(loader2, detaching);
			if (detaching) detach_dev(t2);
			destroy_component(loader3, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_2.name,
		type: "else",
		source: "(109:4) {:else}",
		ctx
	});

	return block;
}

// (105:4) {#if animal.character !== null}
function create_if_block_3(ctx) {
	let p;
	let t_value = /*animal*/ ctx[0].character + "";
	let t;

	const block = {
		c: function create() {
			p = element("p");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			p = claim_element(nodes, "P", { class: true });
			var p_nodes = children(p);
			t = claim_text(p_nodes, t_value);
			p_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(p, "class", "font-w-300");
			add_location(p, file$7, 105, 8, 3574);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*animal*/ 1 && t_value !== (t_value = /*animal*/ ctx[0].character + "")) set_data_dev(t, t_value);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(105:4) {#if animal.character !== null}",
		ctx
	});

	return block;
}

// (142:8) {:else}
function create_else_block_1$1(ctx) {
	let li0;
	let loader0;
	let t0;
	let li1;
	let br0;
	let t1;
	let loader1;
	let t2;
	let li2;
	let br1;
	let t3;
	let loader2;
	let current;
	loader0 = new Loader({ props: { type: "p" }, $$inline: true });
	br0 = new Br({ props: { size: "10" }, $$inline: true });
	loader1 = new Loader({ props: { type: "p" }, $$inline: true });
	br1 = new Br({ props: { size: "10" }, $$inline: true });
	loader2 = new Loader({ props: { type: "p" }, $$inline: true });

	const block = {
		c: function create() {
			li0 = element("li");
			create_component(loader0.$$.fragment);
			t0 = space();
			li1 = element("li");
			create_component(br0.$$.fragment);
			t1 = space();
			create_component(loader1.$$.fragment);
			t2 = space();
			li2 = element("li");
			create_component(br1.$$.fragment);
			t3 = space();
			create_component(loader2.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			li0 = claim_element(nodes, "LI", { style: true });
			var li0_nodes = children(li0);
			claim_component(loader0.$$.fragment, li0_nodes);
			li0_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			li1 = claim_element(nodes, "LI", { style: true });
			var li1_nodes = children(li1);
			claim_component(br0.$$.fragment, li1_nodes);
			t1 = claim_space(li1_nodes);
			claim_component(loader1.$$.fragment, li1_nodes);
			li1_nodes.forEach(detach_dev);
			t2 = claim_space(nodes);
			li2 = claim_element(nodes, "LI", { style: true });
			var li2_nodes = children(li2);
			claim_component(br1.$$.fragment, li2_nodes);
			t3 = claim_space(li2_nodes);
			claim_component(loader2.$$.fragment, li2_nodes);
			li2_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_style(li0, "width", "40%");
			add_location(li0, file$7, 142, 12, 4769);
			set_style(li1, "width", "40%");
			add_location(li1, file$7, 145, 12, 4858);
			set_style(li2, "width", "40%");
			add_location(li2, file$7, 149, 12, 4979);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li0, anchor);
			mount_component(loader0, li0, null);
			insert_dev(target, t0, anchor);
			insert_dev(target, li1, anchor);
			mount_component(br0, li1, null);
			append_dev(li1, t1);
			mount_component(loader1, li1, null);
			insert_dev(target, t2, anchor);
			insert_dev(target, li2, anchor);
			mount_component(br1, li2, null);
			append_dev(li2, t3);
			mount_component(loader2, li2, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(loader0.$$.fragment, local);
			transition_in(br0.$$.fragment, local);
			transition_in(loader1.$$.fragment, local);
			transition_in(br1.$$.fragment, local);
			transition_in(loader2.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loader0.$$.fragment, local);
			transition_out(br0.$$.fragment, local);
			transition_out(loader1.$$.fragment, local);
			transition_out(br1.$$.fragment, local);
			transition_out(loader2.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li0);
			destroy_component(loader0);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(li1);
			destroy_component(br0);
			destroy_component(loader1);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(li2);
			destroy_component(br1);
			destroy_component(loader2);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1$1.name,
		type: "else",
		source: "(142:8) {:else}",
		ctx
	});

	return block;
}

// (123:8) {#if animal.vaccination !== null}
function create_if_block$1(ctx) {
	let each_1_anchor;
	let current;
	let each_value = /*getVactinations*/ ctx[1](/*animal*/ ctx[0].vaccination);
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty & /*getVactinations, animal*/ 3) {
				each_value = /*getVactinations*/ ctx[1](/*animal*/ ctx[0].vaccination);
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(123:8) {#if animal.vaccination !== null}",
		ctx
	});

	return block;
}

// (126:20) {#if i}
function create_if_block_2$1(ctx) {
	let br;
	let current;
	br = new Br({ props: { size: "10" }, $$inline: true });

	const block = {
		c: function create() {
			create_component(br.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(br.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(br, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(br.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(br, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$1.name,
		type: "if",
		source: "(126:20) {#if i}",
		ctx
	});

	return block;
}

// (132:24) {:else}
function create_else_block$1(ctx) {
	let icon;
	let current;

	icon = new Icon({
			props: {
				is: "danger",
				type: "cancel-circle",
				size: "medium"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(icon.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$1.name,
		type: "else",
		source: "(132:24) {:else}",
		ctx
	});

	return block;
}

// (130:24) {#if item.done}
function create_if_block_1$1(ctx) {
	let icon;
	let current;

	icon = new Icon({
			props: {
				is: "primary",
				type: "checked-circle",
				size: "medium"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(icon.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$1.name,
		type: "if",
		source: "(130:24) {#if item.done}",
		ctx
	});

	return block;
}

// (124:12) {#each getVactinations(animal.vaccination) as item, i}
function create_each_block$1(ctx) {
	let li;
	let t0;
	let span;
	let current_block_type_index;
	let if_block1;
	let t1;
	let s0;
	let t2;
	let s1;
	let t3;
	let s2;
	let t4;
	let t5_value = /*item*/ ctx[2].title + "";
	let t5;
	let t6;
	let current;
	let if_block0 = /*i*/ ctx[4] && create_if_block_2$1(ctx);
	const if_block_creators = [create_if_block_1$1, create_else_block$1];
	const if_blocks = [];

	function select_block_type_6(ctx, dirty) {
		if (/*item*/ ctx[2].done) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_6(ctx);
	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			li = element("li");
			if (if_block0) if_block0.c();
			t0 = space();
			span = element("span");
			if_block1.c();
			t1 = space();
			s0 = element("s");
			t2 = space();
			s1 = element("s");
			t3 = space();
			s2 = element("s");
			t4 = space();
			t5 = text(t5_value);
			t6 = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", {});
			var li_nodes = children(li);
			if (if_block0) if_block0.l(li_nodes);
			t0 = claim_space(li_nodes);
			span = claim_element(li_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			if_block1.l(span_nodes);
			t1 = claim_space(span_nodes);
			s0 = claim_element(span_nodes, "S", {});
			children(s0).forEach(detach_dev);
			t2 = claim_space(span_nodes);
			s1 = claim_element(span_nodes, "S", {});
			children(s1).forEach(detach_dev);
			t3 = claim_space(span_nodes);
			s2 = claim_element(span_nodes, "S", {});
			children(s2).forEach(detach_dev);
			t4 = claim_space(span_nodes);
			t5 = claim_text(span_nodes, t5_value);
			span_nodes.forEach(detach_dev);
			t6 = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(s0, file$7, 134, 24, 4562);
			add_location(s1, file$7, 135, 24, 4594);
			add_location(s2, file$7, 136, 24, 4626);
			attr_dev(span, "class", "flex flex-align-center font-w-300");
			add_location(span, file$7, 128, 20, 4219);
			add_location(li, file$7, 124, 16, 4100);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			if (if_block0) if_block0.m(li, null);
			append_dev(li, t0);
			append_dev(li, span);
			if_blocks[current_block_type_index].m(span, null);
			append_dev(span, t1);
			append_dev(span, s0);
			append_dev(span, t2);
			append_dev(span, s1);
			append_dev(span, t3);
			append_dev(span, s2);
			append_dev(span, t4);
			append_dev(span, t5);
			append_dev(li, t6);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_6(ctx);

			if (current_block_type_index !== previous_block_index) {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block1 = if_blocks[current_block_type_index];

				if (!if_block1) {
					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block1.c();
				}

				transition_in(if_block1, 1);
				if_block1.m(span, t1);
			}

			if ((!current || dirty & /*animal*/ 1) && t5_value !== (t5_value = /*item*/ ctx[2].title + "")) set_data_dev(t5, t5_value);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			if (if_block0) if_block0.d();
			if_blocks[current_block_type_index].d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$1.name,
		type: "each",
		source: "(124:12) {#each getVactinations(animal.vaccination) as item, i}",
		ctx
	});

	return block;
}

// (28:0) <Card class="container">
function create_default_slot$1(ctx) {
	let br0;
	let t0;
	let div0;
	let span;
	let fancybox;
	let t1;
	let br1;
	let t2;
	let current_block_type_index;
	let if_block0;
	let t3;
	let br2;
	let t4;
	let current_block_type_index_1;
	let if_block1;
	let t5;
	let br3;
	let t6;
	let section;
	let div1;
	let icon0;
	let t7;
	let t8;
	let div2;
	let icon1;
	let t9;
	let t10;
	let div3;
	let icon2;
	let t11;
	let t12;
	let br4;
	let t13;
	let h20;
	let t14;

	let t15_value = (/*animal*/ ctx[0].characterShort
	? /*animal*/ ctx[0].characterShort
	: "") + "";

	let t15;
	let t16;
	let br5;
	let t17;
	let current_block_type_index_2;
	let if_block5;
	let t18;
	let br6;
	let t19;
	let storylist;
	let t20;
	let br7;
	let t21;
	let h21;
	let t22;
	let t23;
	let br8;
	let t24;
	let ul;
	let current_block_type_index_3;
	let if_block6;
	let t25;
	let br9;
	let current;
	br0 = new Br({ props: { size: "30" }, $$inline: true });

	fancybox = new FancyBox({
			props: {
				$$slots: {
					default: [create_default_slot_1$1],
					box: [create_box_slot]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	br1 = new Br({ props: { size: "20" }, $$inline: true });
	const if_block_creators = [create_if_block_11, create_else_block_5];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*animal*/ ctx[0].name !== null) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	br2 = new Br({ props: { size: "5" }, $$inline: true });
	const if_block_creators_1 = [create_if_block_10, create_else_block_4];
	const if_blocks_1 = [];

	function select_block_type_1(ctx, dirty) {
		if (/*animal*/ ctx[0].breed !== null) return 0;
		return 1;
	}

	current_block_type_index_1 = select_block_type_1(ctx);
	if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
	br3 = new Br({ props: { size: "35" }, $$inline: true });

	icon0 = new Icon({
			props: { type: "polygon", is: "primary" },
			$$inline: true
		});

	let if_block2 = /*animal*/ ctx[0].age !== null && create_if_block_9(ctx);

	icon1 = new Icon({
			props: { type: "polygon", is: "info" },
			$$inline: true
		});

	let if_block3 = /*animal*/ ctx[0].sex !== null && create_if_block_6(ctx);

	icon2 = new Icon({
			props: { type: "polygon", is: "primary" },
			$$inline: true
		});

	let if_block4 = /*animal*/ ctx[0].sterilization !== null && create_if_block_4(ctx);
	br4 = new Br({ props: { size: "40" }, $$inline: true });
	br5 = new Br({ props: { size: "10" }, $$inline: true });
	const if_block_creators_2 = [create_if_block_3, create_else_block_2];
	const if_blocks_2 = [];

	function select_block_type_4(ctx, dirty) {
		if (/*animal*/ ctx[0].character !== null) return 0;
		return 1;
	}

	current_block_type_index_2 = select_block_type_4(ctx);
	if_block5 = if_blocks_2[current_block_type_index_2] = if_block_creators_2[current_block_type_index_2](ctx);
	br6 = new Br({ props: { size: "35" }, $$inline: true });

	storylist = new StoryList({
			props: {
				label: "Історія життя:",
				value: /*animal*/ ctx[0].lifestory,
				readonly: true
			},
			$$inline: true
		});

	br7 = new Br({ props: { size: "45" }, $$inline: true });
	br8 = new Br({ props: { size: "15" }, $$inline: true });
	const if_block_creators_3 = [create_if_block$1, create_else_block_1$1];
	const if_blocks_3 = [];

	function select_block_type_5(ctx, dirty) {
		if (/*animal*/ ctx[0].vaccination !== null) return 0;
		return 1;
	}

	current_block_type_index_3 = select_block_type_5(ctx);
	if_block6 = if_blocks_3[current_block_type_index_3] = if_block_creators_3[current_block_type_index_3](ctx);
	br9 = new Br({ props: { size: "35" }, $$inline: true });

	const block = {
		c: function create() {
			create_component(br0.$$.fragment);
			t0 = space();
			div0 = element("div");
			span = element("span");
			create_component(fancybox.$$.fragment);
			t1 = space();
			create_component(br1.$$.fragment);
			t2 = space();
			if_block0.c();
			t3 = space();
			create_component(br2.$$.fragment);
			t4 = space();
			if_block1.c();
			t5 = space();
			create_component(br3.$$.fragment);
			t6 = space();
			section = element("section");
			div1 = element("div");
			create_component(icon0.$$.fragment);
			t7 = space();
			if (if_block2) if_block2.c();
			t8 = space();
			div2 = element("div");
			create_component(icon1.$$.fragment);
			t9 = space();
			if (if_block3) if_block3.c();
			t10 = space();
			div3 = element("div");
			create_component(icon2.$$.fragment);
			t11 = space();
			if (if_block4) if_block4.c();
			t12 = space();
			create_component(br4.$$.fragment);
			t13 = space();
			h20 = element("h2");
			t14 = text("Характер: ");
			t15 = text(t15_value);
			t16 = space();
			create_component(br5.$$.fragment);
			t17 = space();
			if_block5.c();
			t18 = space();
			create_component(br6.$$.fragment);
			t19 = space();
			create_component(storylist.$$.fragment);
			t20 = space();
			create_component(br7.$$.fragment);
			t21 = space();
			h21 = element("h2");
			t22 = text("Вакцинації");
			t23 = space();
			create_component(br8.$$.fragment);
			t24 = space();
			ul = element("ul");
			if_block6.c();
			t25 = space();
			create_component(br9.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			claim_component(br0.$$.fragment, nodes);
			t0 = claim_space(nodes);
			div0 = claim_element(nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			span = claim_element(div0_nodes, "SPAN", {});
			var span_nodes = children(span);
			claim_component(fancybox.$$.fragment, span_nodes);
			span_nodes.forEach(detach_dev);
			t1 = claim_space(div0_nodes);
			claim_component(br1.$$.fragment, div0_nodes);
			t2 = claim_space(div0_nodes);
			if_block0.l(div0_nodes);
			t3 = claim_space(div0_nodes);
			claim_component(br2.$$.fragment, div0_nodes);
			t4 = claim_space(div0_nodes);
			if_block1.l(div0_nodes);
			div0_nodes.forEach(detach_dev);
			t5 = claim_space(nodes);
			claim_component(br3.$$.fragment, nodes);
			t6 = claim_space(nodes);
			section = claim_element(nodes, "SECTION", { class: true });
			var section_nodes = children(section);
			div1 = claim_element(section_nodes, "DIV", { class: true, style: true });
			var div1_nodes = children(div1);
			claim_component(icon0.$$.fragment, div1_nodes);
			t7 = claim_space(div1_nodes);
			if (if_block2) if_block2.l(div1_nodes);
			div1_nodes.forEach(detach_dev);
			t8 = claim_space(section_nodes);
			div2 = claim_element(section_nodes, "DIV", { class: true, style: true });
			var div2_nodes = children(div2);
			claim_component(icon1.$$.fragment, div2_nodes);
			t9 = claim_space(div2_nodes);
			if (if_block3) if_block3.l(div2_nodes);
			div2_nodes.forEach(detach_dev);
			t10 = claim_space(section_nodes);
			div3 = claim_element(section_nodes, "DIV", { class: true, style: true });
			var div3_nodes = children(div3);
			claim_component(icon2.$$.fragment, div3_nodes);
			t11 = claim_space(div3_nodes);
			if (if_block4) if_block4.l(div3_nodes);
			div3_nodes.forEach(detach_dev);
			section_nodes.forEach(detach_dev);
			t12 = claim_space(nodes);
			claim_component(br4.$$.fragment, nodes);
			t13 = claim_space(nodes);
			h20 = claim_element(nodes, "H2", {});
			var h20_nodes = children(h20);
			t14 = claim_text(h20_nodes, "Характер: ");
			t15 = claim_text(h20_nodes, t15_value);
			h20_nodes.forEach(detach_dev);
			t16 = claim_space(nodes);
			claim_component(br5.$$.fragment, nodes);
			t17 = claim_space(nodes);
			if_block5.l(nodes);
			t18 = claim_space(nodes);
			claim_component(br6.$$.fragment, nodes);
			t19 = claim_space(nodes);
			claim_component(storylist.$$.fragment, nodes);
			t20 = claim_space(nodes);
			claim_component(br7.$$.fragment, nodes);
			t21 = claim_space(nodes);
			h21 = claim_element(nodes, "H2", {});
			var h21_nodes = children(h21);
			t22 = claim_text(h21_nodes, "Вакцинації");
			h21_nodes.forEach(detach_dev);
			t23 = claim_space(nodes);
			claim_component(br8.$$.fragment, nodes);
			t24 = claim_space(nodes);
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);
			if_block6.l(ul_nodes);
			ul_nodes.forEach(detach_dev);
			t25 = claim_space(nodes);
			claim_component(br9.$$.fragment, nodes);
			this.h();
		},
		h: function hydrate() {
			add_location(span, file$7, 31, 8, 814);
			attr_dev(div0, "class", "flex flex-column flex-align-center");
			add_location(div0, file$7, 30, 4, 757);
			attr_dev(div1, "class", "flex flex-center relative");
			set_style(div1, "width", "120px");
			set_style(div1, "height", "120px");
			add_location(div1, file$7, 59, 8, 1842);
			attr_dev(div2, "class", "flex flex-center relative");
			set_style(div2, "width", "120px");
			set_style(div2, "height", "120px");
			add_location(div2, file$7, 70, 8, 2244);
			attr_dev(div3, "class", "flex flex-center relative");
			set_style(div3, "width", "120px");
			set_style(div3, "height", "120px");
			add_location(div3, file$7, 84, 8, 2768);
			attr_dev(section, "class", "flex flex-justify-center");
			add_location(section, file$7, 58, 4, 1791);
			add_location(h20, file$7, 101, 4, 3437);
			add_location(h21, file$7, 119, 4, 3891);
			attr_dev(ul, "class", "flex flex-column text-left");
			add_location(ul, file$7, 121, 4, 3935);
		},
		m: function mount(target, anchor) {
			mount_component(br0, target, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, div0, anchor);
			append_dev(div0, span);
			mount_component(fancybox, span, null);
			append_dev(div0, t1);
			mount_component(br1, div0, null);
			append_dev(div0, t2);
			if_blocks[current_block_type_index].m(div0, null);
			append_dev(div0, t3);
			mount_component(br2, div0, null);
			append_dev(div0, t4);
			if_blocks_1[current_block_type_index_1].m(div0, null);
			insert_dev(target, t5, anchor);
			mount_component(br3, target, anchor);
			insert_dev(target, t6, anchor);
			insert_dev(target, section, anchor);
			append_dev(section, div1);
			mount_component(icon0, div1, null);
			append_dev(div1, t7);
			if (if_block2) if_block2.m(div1, null);
			append_dev(section, t8);
			append_dev(section, div2);
			mount_component(icon1, div2, null);
			append_dev(div2, t9);
			if (if_block3) if_block3.m(div2, null);
			append_dev(section, t10);
			append_dev(section, div3);
			mount_component(icon2, div3, null);
			append_dev(div3, t11);
			if (if_block4) if_block4.m(div3, null);
			insert_dev(target, t12, anchor);
			mount_component(br4, target, anchor);
			insert_dev(target, t13, anchor);
			insert_dev(target, h20, anchor);
			append_dev(h20, t14);
			append_dev(h20, t15);
			insert_dev(target, t16, anchor);
			mount_component(br5, target, anchor);
			insert_dev(target, t17, anchor);
			if_blocks_2[current_block_type_index_2].m(target, anchor);
			insert_dev(target, t18, anchor);
			mount_component(br6, target, anchor);
			insert_dev(target, t19, anchor);
			mount_component(storylist, target, anchor);
			insert_dev(target, t20, anchor);
			mount_component(br7, target, anchor);
			insert_dev(target, t21, anchor);
			insert_dev(target, h21, anchor);
			append_dev(h21, t22);
			insert_dev(target, t23, anchor);
			mount_component(br8, target, anchor);
			insert_dev(target, t24, anchor);
			insert_dev(target, ul, anchor);
			if_blocks_3[current_block_type_index_3].m(ul, null);
			insert_dev(target, t25, anchor);
			mount_component(br9, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const fancybox_changes = {};

			if (dirty & /*$$scope, animal*/ 33) {
				fancybox_changes.$$scope = { dirty, ctx };
			}

			fancybox.$set(fancybox_changes);
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block0 = if_blocks[current_block_type_index];

				if (!if_block0) {
					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block0.c();
				}

				transition_in(if_block0, 1);
				if_block0.m(div0, t3);
			}

			let previous_block_index_1 = current_block_type_index_1;
			current_block_type_index_1 = select_block_type_1(ctx);

			if (current_block_type_index_1 === previous_block_index_1) {
				if_blocks_1[current_block_type_index_1].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
					if_blocks_1[previous_block_index_1] = null;
				});

				check_outros();
				if_block1 = if_blocks_1[current_block_type_index_1];

				if (!if_block1) {
					if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
					if_block1.c();
				}

				transition_in(if_block1, 1);
				if_block1.m(div0, null);
			}

			if (/*animal*/ ctx[0].age !== null) {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block_9(ctx);
					if_block2.c();
					if_block2.m(div1, null);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (/*animal*/ ctx[0].sex !== null) {
				if (if_block3) {
					if_block3.p(ctx, dirty);

					if (dirty & /*animal*/ 1) {
						transition_in(if_block3, 1);
					}
				} else {
					if_block3 = create_if_block_6(ctx);
					if_block3.c();
					transition_in(if_block3, 1);
					if_block3.m(div2, null);
				}
			} else if (if_block3) {
				group_outros();

				transition_out(if_block3, 1, 1, () => {
					if_block3 = null;
				});

				check_outros();
			}

			if (/*animal*/ ctx[0].sterilization !== null) {
				if (if_block4) {
					if_block4.p(ctx, dirty);

					if (dirty & /*animal*/ 1) {
						transition_in(if_block4, 1);
					}
				} else {
					if_block4 = create_if_block_4(ctx);
					if_block4.c();
					transition_in(if_block4, 1);
					if_block4.m(div3, null);
				}
			} else if (if_block4) {
				group_outros();

				transition_out(if_block4, 1, 1, () => {
					if_block4 = null;
				});

				check_outros();
			}

			if ((!current || dirty & /*animal*/ 1) && t15_value !== (t15_value = (/*animal*/ ctx[0].characterShort
			? /*animal*/ ctx[0].characterShort
			: "") + "")) set_data_dev(t15, t15_value);

			let previous_block_index_2 = current_block_type_index_2;
			current_block_type_index_2 = select_block_type_4(ctx);

			if (current_block_type_index_2 === previous_block_index_2) {
				if_blocks_2[current_block_type_index_2].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks_2[previous_block_index_2], 1, 1, () => {
					if_blocks_2[previous_block_index_2] = null;
				});

				check_outros();
				if_block5 = if_blocks_2[current_block_type_index_2];

				if (!if_block5) {
					if_block5 = if_blocks_2[current_block_type_index_2] = if_block_creators_2[current_block_type_index_2](ctx);
					if_block5.c();
				}

				transition_in(if_block5, 1);
				if_block5.m(t18.parentNode, t18);
			}

			const storylist_changes = {};
			if (dirty & /*animal*/ 1) storylist_changes.value = /*animal*/ ctx[0].lifestory;
			storylist.$set(storylist_changes);
			let previous_block_index_3 = current_block_type_index_3;
			current_block_type_index_3 = select_block_type_5(ctx);

			if (current_block_type_index_3 === previous_block_index_3) {
				if_blocks_3[current_block_type_index_3].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks_3[previous_block_index_3], 1, 1, () => {
					if_blocks_3[previous_block_index_3] = null;
				});

				check_outros();
				if_block6 = if_blocks_3[current_block_type_index_3];

				if (!if_block6) {
					if_block6 = if_blocks_3[current_block_type_index_3] = if_block_creators_3[current_block_type_index_3](ctx);
					if_block6.c();
				}

				transition_in(if_block6, 1);
				if_block6.m(ul, null);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(br0.$$.fragment, local);
			transition_in(fancybox.$$.fragment, local);
			transition_in(br1.$$.fragment, local);
			transition_in(if_block0);
			transition_in(br2.$$.fragment, local);
			transition_in(if_block1);
			transition_in(br3.$$.fragment, local);
			transition_in(icon0.$$.fragment, local);
			transition_in(icon1.$$.fragment, local);
			transition_in(if_block3);
			transition_in(icon2.$$.fragment, local);
			transition_in(if_block4);
			transition_in(br4.$$.fragment, local);
			transition_in(br5.$$.fragment, local);
			transition_in(if_block5);
			transition_in(br6.$$.fragment, local);
			transition_in(storylist.$$.fragment, local);
			transition_in(br7.$$.fragment, local);
			transition_in(br8.$$.fragment, local);
			transition_in(if_block6);
			transition_in(br9.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br0.$$.fragment, local);
			transition_out(fancybox.$$.fragment, local);
			transition_out(br1.$$.fragment, local);
			transition_out(if_block0);
			transition_out(br2.$$.fragment, local);
			transition_out(if_block1);
			transition_out(br3.$$.fragment, local);
			transition_out(icon0.$$.fragment, local);
			transition_out(icon1.$$.fragment, local);
			transition_out(if_block3);
			transition_out(icon2.$$.fragment, local);
			transition_out(if_block4);
			transition_out(br4.$$.fragment, local);
			transition_out(br5.$$.fragment, local);
			transition_out(if_block5);
			transition_out(br6.$$.fragment, local);
			transition_out(storylist.$$.fragment, local);
			transition_out(br7.$$.fragment, local);
			transition_out(br8.$$.fragment, local);
			transition_out(if_block6);
			transition_out(br9.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(br0, detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div0);
			destroy_component(fancybox);
			destroy_component(br1);
			if_blocks[current_block_type_index].d();
			destroy_component(br2);
			if_blocks_1[current_block_type_index_1].d();
			if (detaching) detach_dev(t5);
			destroy_component(br3, detaching);
			if (detaching) detach_dev(t6);
			if (detaching) detach_dev(section);
			destroy_component(icon0);
			if (if_block2) if_block2.d();
			destroy_component(icon1);
			if (if_block3) if_block3.d();
			destroy_component(icon2);
			if (if_block4) if_block4.d();
			if (detaching) detach_dev(t12);
			destroy_component(br4, detaching);
			if (detaching) detach_dev(t13);
			if (detaching) detach_dev(h20);
			if (detaching) detach_dev(t16);
			destroy_component(br5, detaching);
			if (detaching) detach_dev(t17);
			if_blocks_2[current_block_type_index_2].d(detaching);
			if (detaching) detach_dev(t18);
			destroy_component(br6, detaching);
			if (detaching) detach_dev(t19);
			destroy_component(storylist, detaching);
			if (detaching) detach_dev(t20);
			destroy_component(br7, detaching);
			if (detaching) detach_dev(t21);
			if (detaching) detach_dev(h21);
			if (detaching) detach_dev(t23);
			destroy_component(br8, detaching);
			if (detaching) detach_dev(t24);
			if (detaching) detach_dev(ul);
			if_blocks_3[current_block_type_index_3].d();
			if (detaching) detach_dev(t25);
			destroy_component(br9, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$1.name,
		type: "slot",
		source: "(28:0) <Card class=\\\"container\\\">",
		ctx
	});

	return block;
}

function create_fragment$7(ctx) {
	let card;
	let current;

	card = new Card({
			props: {
				class: "container",
				$$slots: { default: [create_default_slot$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(card.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(card.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(card, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const card_changes = {};

			if (dirty & /*$$scope, animal*/ 33) {
				card_changes.$$scope = { dirty, ctx };
			}

			card.$set(card_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(card.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(card.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(card, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$7.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$7($$self, $$props, $$invalidate) {
	let { animal = {
		avatar: null,
		avatar2x: null,
		name: null,
		breed: null,
		age: null,
		sex: null,
		sterilization: null,
		characterShort: null,
		character: null,
		lifestory: null,
		vaccination: null
	} } = $$props;

	function getVactinations(values) {
		return [].concat(values || []).map(value => ({
			done: true,
			title: (find(vaccinations, ["value", value]) || {}).text
		})).filter(v => v.title);
	}

	const writable_props = ["animal"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AnimalCard> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("AnimalCard", $$slots, []);

	$$self.$set = $$props => {
		if ("animal" in $$props) $$invalidate(0, animal = $$props.animal);
	};

	$$self.$capture_state = () => ({
		options,
		_,
		Card,
		Br,
		FancyBox,
		Avatar,
		Icon,
		Loader,
		StoryList,
		animal,
		getVactinations
	});

	$$self.$inject_state = $$props => {
		if ("animal" in $$props) $$invalidate(0, animal = $$props.animal);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [animal, getVactinations];
}

class AnimalCard extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$7, create_fragment$7, safe_not_equal, { animal: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "AnimalCard",
			options,
			id: create_fragment$7.name
		});
	}

	get animal() {
		throw new Error("<AnimalCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set animal(value) {
		throw new Error("<AnimalCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/funds/components/_Description.svelte generated by Svelte v3.24.0 */
const file$8 = "src/routes/funds/components/_Description.svelte";

// (10:0) {:else}
function create_else_block_1$2(ctx) {
	let div0;
	let loader0;
	let t;
	let div1;
	let loader1;
	let current;
	loader0 = new Loader({ props: { type: "h1" }, $$inline: true });
	loader1 = new Loader({ props: { type: "h1" }, $$inline: true });

	const block = {
		c: function create() {
			div0 = element("div");
			create_component(loader0.$$.fragment);
			t = space();
			div1 = element("div");
			create_component(loader1.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div0 = claim_element(nodes, "DIV", { style: true });
			var div0_nodes = children(div0);
			claim_component(loader0.$$.fragment, div0_nodes);
			div0_nodes.forEach(detach_dev);
			t = claim_space(nodes);
			div1 = claim_element(nodes, "DIV", { style: true });
			var div1_nodes = children(div1);
			claim_component(loader1.$$.fragment, div1_nodes);
			div1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_style(div0, "width", "85%");
			add_location(div0, file$8, 10, 4, 175);
			set_style(div1, "width", "85%");
			add_location(div1, file$8, 11, 4, 231);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div0, anchor);
			mount_component(loader0, div0, null);
			insert_dev(target, t, anchor);
			insert_dev(target, div1, anchor);
			mount_component(loader1, div1, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(loader0.$$.fragment, local);
			transition_in(loader1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loader0.$$.fragment, local);
			transition_out(loader1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div0);
			destroy_component(loader0);
			if (detaching) detach_dev(t);
			if (detaching) detach_dev(div1);
			destroy_component(loader1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1$2.name,
		type: "else",
		source: "(10:0) {:else}",
		ctx
	});

	return block;
}

// (8:0) {#if title !== null}
function create_if_block_1$2(ctx) {
	let h1;
	let t;

	const block = {
		c: function create() {
			h1 = element("h1");
			t = text(/*title*/ ctx[0]);
			this.h();
		},
		l: function claim(nodes) {
			h1 = claim_element(nodes, "H1", {});
			var h1_nodes = children(h1);
			t = claim_text(h1_nodes, /*title*/ ctx[0]);
			h1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(h1, file$8, 8, 4, 146);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h1, anchor);
			append_dev(h1, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*title*/ 1) set_data_dev(t, /*title*/ ctx[0]);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(h1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$2.name,
		type: "if",
		source: "(8:0) {#if title !== null}",
		ctx
	});

	return block;
}

// (20:0) {:else}
function create_else_block$2(ctx) {
	let loader0;
	let t0;
	let loader1;
	let t1;
	let loader2;
	let t2;
	let loader3;
	let t3;
	let loader4;
	let t4;
	let loader5;
	let t5;
	let loader6;
	let t6;
	let loader7;
	let t7;
	let loader8;
	let t8;
	let div;
	let loader9;
	let current;
	loader0 = new Loader({ props: { type: "pre" }, $$inline: true });
	loader1 = new Loader({ props: { type: "pre" }, $$inline: true });
	loader2 = new Loader({ props: { type: "pre" }, $$inline: true });
	loader3 = new Loader({ props: { type: "pre" }, $$inline: true });
	loader4 = new Loader({ props: { type: "pre" }, $$inline: true });
	loader5 = new Loader({ props: { type: "pre" }, $$inline: true });
	loader6 = new Loader({ props: { type: "pre" }, $$inline: true });
	loader7 = new Loader({ props: { type: "pre" }, $$inline: true });
	loader8 = new Loader({ props: { type: "pre" }, $$inline: true });
	loader9 = new Loader({ props: { type: "pre" }, $$inline: true });

	const block = {
		c: function create() {
			create_component(loader0.$$.fragment);
			t0 = space();
			create_component(loader1.$$.fragment);
			t1 = space();
			create_component(loader2.$$.fragment);
			t2 = space();
			create_component(loader3.$$.fragment);
			t3 = space();
			create_component(loader4.$$.fragment);
			t4 = space();
			create_component(loader5.$$.fragment);
			t5 = space();
			create_component(loader6.$$.fragment);
			t6 = space();
			create_component(loader7.$$.fragment);
			t7 = space();
			create_component(loader8.$$.fragment);
			t8 = space();
			div = element("div");
			create_component(loader9.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			claim_component(loader0.$$.fragment, nodes);
			t0 = claim_space(nodes);
			claim_component(loader1.$$.fragment, nodes);
			t1 = claim_space(nodes);
			claim_component(loader2.$$.fragment, nodes);
			t2 = claim_space(nodes);
			claim_component(loader3.$$.fragment, nodes);
			t3 = claim_space(nodes);
			claim_component(loader4.$$.fragment, nodes);
			t4 = claim_space(nodes);
			claim_component(loader5.$$.fragment, nodes);
			t5 = claim_space(nodes);
			claim_component(loader6.$$.fragment, nodes);
			t6 = claim_space(nodes);
			claim_component(loader7.$$.fragment, nodes);
			t7 = claim_space(nodes);
			claim_component(loader8.$$.fragment, nodes);
			t8 = claim_space(nodes);
			div = claim_element(nodes, "DIV", { style: true });
			var div_nodes = children(div);
			claim_component(loader9.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_style(div, "width", "60%");
			add_location(div, file$8, 29, 4, 625);
		},
		m: function mount(target, anchor) {
			mount_component(loader0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(loader1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(loader2, target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(loader3, target, anchor);
			insert_dev(target, t3, anchor);
			mount_component(loader4, target, anchor);
			insert_dev(target, t4, anchor);
			mount_component(loader5, target, anchor);
			insert_dev(target, t5, anchor);
			mount_component(loader6, target, anchor);
			insert_dev(target, t6, anchor);
			mount_component(loader7, target, anchor);
			insert_dev(target, t7, anchor);
			mount_component(loader8, target, anchor);
			insert_dev(target, t8, anchor);
			insert_dev(target, div, anchor);
			mount_component(loader9, div, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(loader0.$$.fragment, local);
			transition_in(loader1.$$.fragment, local);
			transition_in(loader2.$$.fragment, local);
			transition_in(loader3.$$.fragment, local);
			transition_in(loader4.$$.fragment, local);
			transition_in(loader5.$$.fragment, local);
			transition_in(loader6.$$.fragment, local);
			transition_in(loader7.$$.fragment, local);
			transition_in(loader8.$$.fragment, local);
			transition_in(loader9.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loader0.$$.fragment, local);
			transition_out(loader1.$$.fragment, local);
			transition_out(loader2.$$.fragment, local);
			transition_out(loader3.$$.fragment, local);
			transition_out(loader4.$$.fragment, local);
			transition_out(loader5.$$.fragment, local);
			transition_out(loader6.$$.fragment, local);
			transition_out(loader7.$$.fragment, local);
			transition_out(loader8.$$.fragment, local);
			transition_out(loader9.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(loader0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(loader1, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(loader2, detaching);
			if (detaching) detach_dev(t2);
			destroy_component(loader3, detaching);
			if (detaching) detach_dev(t3);
			destroy_component(loader4, detaching);
			if (detaching) detach_dev(t4);
			destroy_component(loader5, detaching);
			if (detaching) detach_dev(t5);
			destroy_component(loader6, detaching);
			if (detaching) detach_dev(t6);
			destroy_component(loader7, detaching);
			if (detaching) detach_dev(t7);
			destroy_component(loader8, detaching);
			if (detaching) detach_dev(t8);
			if (detaching) detach_dev(div);
			destroy_component(loader9);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$2.name,
		type: "else",
		source: "(20:0) {:else}",
		ctx
	});

	return block;
}

// (16:0) {#if text !== null}
function create_if_block$2(ctx) {
	let pre;
	let t;

	const block = {
		c: function create() {
			pre = element("pre");
			t = text(/*text*/ ctx[1]);
			this.h();
		},
		l: function claim(nodes) {
			pre = claim_element(nodes, "PRE", { class: true });
			var pre_nodes = children(pre);
			t = claim_text(pre_nodes, /*text*/ ctx[1]);
			pre_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(pre, "class", "font-w-300");
			add_location(pre, file$8, 16, 0, 327);
		},
		m: function mount(target, anchor) {
			insert_dev(target, pre, anchor);
			append_dev(pre, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*text*/ 2) set_data_dev(t, /*text*/ ctx[1]);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(pre);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$2.name,
		type: "if",
		source: "(16:0) {#if text !== null}",
		ctx
	});

	return block;
}

function create_fragment$8(ctx) {
	let current_block_type_index;
	let if_block0;
	let t0;
	let br;
	let t1;
	let current_block_type_index_1;
	let if_block1;
	let if_block1_anchor;
	let current;
	const if_block_creators = [create_if_block_1$2, create_else_block_1$2];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*title*/ ctx[0] !== null) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	br = new Br({ props: { size: "10" }, $$inline: true });
	const if_block_creators_1 = [create_if_block$2, create_else_block$2];
	const if_blocks_1 = [];

	function select_block_type_1(ctx, dirty) {
		if (/*text*/ ctx[1] !== null) return 0;
		return 1;
	}

	current_block_type_index_1 = select_block_type_1(ctx);
	if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);

	const block = {
		c: function create() {
			if_block0.c();
			t0 = space();
			create_component(br.$$.fragment);
			t1 = space();
			if_block1.c();
			if_block1_anchor = empty();
		},
		l: function claim(nodes) {
			if_block0.l(nodes);
			t0 = claim_space(nodes);
			claim_component(br.$$.fragment, nodes);
			t1 = claim_space(nodes);
			if_block1.l(nodes);
			if_block1_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(br, target, anchor);
			insert_dev(target, t1, anchor);
			if_blocks_1[current_block_type_index_1].m(target, anchor);
			insert_dev(target, if_block1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block0 = if_blocks[current_block_type_index];

				if (!if_block0) {
					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block0.c();
				}

				transition_in(if_block0, 1);
				if_block0.m(t0.parentNode, t0);
			}

			let previous_block_index_1 = current_block_type_index_1;
			current_block_type_index_1 = select_block_type_1(ctx);

			if (current_block_type_index_1 === previous_block_index_1) {
				if_blocks_1[current_block_type_index_1].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
					if_blocks_1[previous_block_index_1] = null;
				});

				check_outros();
				if_block1 = if_blocks_1[current_block_type_index_1];

				if (!if_block1) {
					if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
					if_block1.c();
				}

				transition_in(if_block1, 1);
				if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(br.$$.fragment, local);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(br.$$.fragment, local);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(t0);
			destroy_component(br, detaching);
			if (detaching) detach_dev(t1);
			if_blocks_1[current_block_type_index_1].d(detaching);
			if (detaching) detach_dev(if_block1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$8.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$8($$self, $$props, $$invalidate) {
	let { title = null } = $$props;
	let { text = null } = $$props;
	const writable_props = ["title", "text"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Description> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Description", $$slots, []);

	$$self.$set = $$props => {
		if ("title" in $$props) $$invalidate(0, title = $$props.title);
		if ("text" in $$props) $$invalidate(1, text = $$props.text);
	};

	$$self.$capture_state = () => ({ Br, Loader, title, text });

	$$self.$inject_state = $$props => {
		if ("title" in $$props) $$invalidate(0, title = $$props.title);
		if ("text" in $$props) $$invalidate(1, text = $$props.text);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [title, text];
}

class Description extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$8, create_fragment$8, safe_not_equal, { title: 0, text: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Description",
			options,
			id: create_fragment$8.name
		});
	}

	get title() {
		throw new Error("<Description>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<Description>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get text() {
		throw new Error("<Description>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set text(value) {
		throw new Error("<Description>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/funds/components/_TopCarousel.svelte generated by Svelte v3.24.0 */
const file$9 = "src/routes/funds/components/_TopCarousel.svelte";

function create_fragment$9(ctx) {
	let section;
	let carousel;
	let current;

	carousel = new Carousel({
			props: {
				items: /*items*/ ctx[0],
				dotsBelow: false
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			section = element("section");
			create_component(carousel.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { class: true, style: true });
			var section_nodes = children(section);
			claim_component(carousel.$$.fragment, section_nodes);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(section, "class", "flex");
			set_style(section, "height", "240px");
			add_location(section, file$9, 6, 0, 90);
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			mount_component(carousel, section, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const carousel_changes = {};
			if (dirty & /*items*/ 1) carousel_changes.items = /*items*/ ctx[0];
			carousel.$set(carousel_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(carousel.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(carousel.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			destroy_component(carousel);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$9.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$9($$self, $$props, $$invalidate) {
	let { items = [] } = $$props;
	const writable_props = ["items"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<TopCarousel> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("TopCarousel", $$slots, []);

	$$self.$set = $$props => {
		if ("items" in $$props) $$invalidate(0, items = $$props.items);
	};

	$$self.$capture_state = () => ({ Carousel, items });

	$$self.$inject_state = $$props => {
		if ("items" in $$props) $$invalidate(0, items = $$props.items);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [items];
}

class TopCarousel extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$9, create_fragment$9, safe_not_equal, { items: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "TopCarousel",
			options,
			id: create_fragment$9.name
		});
	}

	get items() {
		throw new Error("<TopCarousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set items(value) {
		throw new Error("<TopCarousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/funds/components/_QuickInfoCard.svelte generated by Svelte v3.24.0 */
const file$a = "src/routes/funds/components/_QuickInfoCard.svelte";

// (17:4) {:else}
function create_else_block_3$1(ctx) {
	let div0;
	let loader0;
	let t;
	let div1;
	let loader1;
	let current;
	loader0 = new Loader({ props: { type: "h2" }, $$inline: true });
	loader1 = new Loader({ props: { type: "h2" }, $$inline: true });

	const block = {
		c: function create() {
			div0 = element("div");
			create_component(loader0.$$.fragment);
			t = space();
			div1 = element("div");
			create_component(loader1.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div0 = claim_element(nodes, "DIV", { style: true });
			var div0_nodes = children(div0);
			claim_component(loader0.$$.fragment, div0_nodes);
			div0_nodes.forEach(detach_dev);
			t = claim_space(nodes);
			div1 = claim_element(nodes, "DIV", { style: true });
			var div1_nodes = children(div1);
			claim_component(loader1.$$.fragment, div1_nodes);
			div1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_style(div0, "width", "80%");
			add_location(div0, file$a, 17, 8, 343);
			set_style(div1, "width", "80%");
			add_location(div1, file$a, 18, 8, 401);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div0, anchor);
			mount_component(loader0, div0, null);
			insert_dev(target, t, anchor);
			insert_dev(target, div1, anchor);
			mount_component(loader1, div1, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(loader0.$$.fragment, local);
			transition_in(loader1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loader0.$$.fragment, local);
			transition_out(loader1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div0);
			destroy_component(loader0);
			if (detaching) detach_dev(t);
			if (detaching) detach_dev(div1);
			destroy_component(loader1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_3$1.name,
		type: "else",
		source: "(17:4) {:else}",
		ctx
	});

	return block;
}

// (15:4) {#if cardTop.title !== null}
function create_if_block_3$1(ctx) {
	let h2;
	let t_value = /*cardTop*/ ctx[0].title + "";
	let t;

	const block = {
		c: function create() {
			h2 = element("h2");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			h2 = claim_element(nodes, "H2", {});
			var h2_nodes = children(h2);
			t = claim_text(h2_nodes, t_value);
			h2_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(h2, file$a, 15, 8, 298);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h2, anchor);
			append_dev(h2, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*cardTop*/ 1 && t_value !== (t_value = /*cardTop*/ ctx[0].title + "")) set_data_dev(t, t_value);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(h2);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$1.name,
		type: "if",
		source: "(15:4) {#if cardTop.title !== null}",
		ctx
	});

	return block;
}

// (24:4) {:else}
function create_else_block_2$1(ctx) {
	let div0;
	let loader0;
	let t;
	let div1;
	let loader1;
	let current;
	loader0 = new Loader({ props: { type: "h3" }, $$inline: true });
	loader1 = new Loader({ props: { type: "h3" }, $$inline: true });

	const block = {
		c: function create() {
			div0 = element("div");
			create_component(loader0.$$.fragment);
			t = space();
			div1 = element("div");
			create_component(loader1.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div0 = claim_element(nodes, "DIV", { style: true });
			var div0_nodes = children(div0);
			claim_component(loader0.$$.fragment, div0_nodes);
			div0_nodes.forEach(detach_dev);
			t = claim_space(nodes);
			div1 = claim_element(nodes, "DIV", { style: true });
			var div1_nodes = children(div1);
			claim_component(loader1.$$.fragment, div1_nodes);
			div1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_style(div0, "width", "100%");
			add_location(div0, file$a, 24, 8, 596);
			set_style(div1, "width", "100%");
			add_location(div1, file$a, 25, 8, 655);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div0, anchor);
			mount_component(loader0, div0, null);
			insert_dev(target, t, anchor);
			insert_dev(target, div1, anchor);
			mount_component(loader1, div1, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(loader0.$$.fragment, local);
			transition_in(loader1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loader0.$$.fragment, local);
			transition_out(loader1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div0);
			destroy_component(loader0);
			if (detaching) detach_dev(t);
			if (detaching) detach_dev(div1);
			destroy_component(loader1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_2$1.name,
		type: "else",
		source: "(24:4) {:else}",
		ctx
	});

	return block;
}

// (22:4) {#if cardTop.subtitle !== null}
function create_if_block_2$2(ctx) {
	let h3;
	let t_value = /*cardTop*/ ctx[0].subtitle + "";
	let t;

	const block = {
		c: function create() {
			h3 = element("h3");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			h3 = claim_element(nodes, "H3", { class: true, style: true });
			var h3_nodes = children(h3);
			t = claim_text(h3_nodes, t_value);
			h3_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(h3, "class", "font-w-normal");
			set_style(h3, "opacity", ".7");
			add_location(h3, file$a, 22, 8, 506);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h3, anchor);
			append_dev(h3, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*cardTop*/ 1 && t_value !== (t_value = /*cardTop*/ ctx[0].subtitle + "")) set_data_dev(t, t_value);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(h3);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$2.name,
		type: "if",
		source: "(22:4) {#if cardTop.subtitle !== null}",
		ctx
	});

	return block;
}

// (33:8) {:else}
function create_else_block_1$3(ctx) {
	let div;
	let loader;
	let current;
	loader = new Loader({ props: { type: "h1" }, $$inline: true });

	const block = {
		c: function create() {
			div = element("div");
			create_component(loader.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { style: true });
			var div_nodes = children(div);
			claim_component(loader.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_style(div, "width", "50%");
			add_location(div, file$a, 33, 12, 947);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(loader, div, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(loader.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loader.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(loader);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1$3.name,
		type: "else",
		source: "(33:8) {:else}",
		ctx
	});

	return block;
}

// (31:8) {#if cardTop.current_sum !== null}
function create_if_block_1$3(ctx) {
	let span;
	let t0_value = /*cardTop*/ ctx[0].currency + "";
	let t0;
	let t1;
	let t2_value = /*cardTop*/ ctx[0].current_sum + "";
	let t2;

	const block = {
		c: function create() {
			span = element("span");
			t0 = text(t0_value);
			t1 = space();
			t2 = text(t2_value);
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t0 = claim_text(span_nodes, t0_value);
			t1 = claim_space(span_nodes);
			t2 = claim_text(span_nodes, t2_value);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "h1 font-w-500");
			add_location(span, file$a, 31, 12, 843);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t0);
			append_dev(span, t1);
			append_dev(span, t2);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*cardTop*/ 1 && t0_value !== (t0_value = /*cardTop*/ ctx[0].currency + "")) set_data_dev(t0, t0_value);
			if (dirty & /*cardTop*/ 1 && t2_value !== (t2_value = /*cardTop*/ ctx[0].current_sum + "")) set_data_dev(t2, t2_value);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$3.name,
		type: "if",
		source: "(31:8) {#if cardTop.current_sum !== null}",
		ctx
	});

	return block;
}

// (41:8) {:else}
function create_else_block$3(ctx) {
	let div;
	let loader;
	let current;
	loader = new Loader({ props: { type: "h3" }, $$inline: true });

	const block = {
		c: function create() {
			div = element("div");
			create_component(loader.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { style: true });
			var div_nodes = children(div);
			claim_component(loader.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_style(div, "width", "30%");
			set_style(div, "padding-bottom", "2px");
			add_location(div, file$a, 41, 12, 1171);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(loader, div, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(loader.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loader.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(loader);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$3.name,
		type: "else",
		source: "(41:8) {:else}",
		ctx
	});

	return block;
}

// (39:8) {#if cardTop.need_sum !== null}
function create_if_block$3(ctx) {
	let span;
	let t0;
	let t1_value = /*cardTop*/ ctx[0].currency + "";
	let t1;
	let t2;
	let t3_value = /*cardTop*/ ctx[0].need_sum + "";
	let t3;

	const block = {
		c: function create() {
			span = element("span");
			t0 = text("/ ");
			t1 = text(t1_value);
			t2 = space();
			t3 = text(t3_value);
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t0 = claim_text(span_nodes, "/ ");
			t1 = claim_text(span_nodes, t1_value);
			t2 = claim_space(span_nodes);
			t3 = claim_text(span_nodes, t3_value);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "h3");
			add_location(span, file$a, 39, 12, 1079);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t0);
			append_dev(span, t1);
			append_dev(span, t2);
			append_dev(span, t3);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*cardTop*/ 1 && t1_value !== (t1_value = /*cardTop*/ ctx[0].currency + "")) set_data_dev(t1, t1_value);
			if (dirty & /*cardTop*/ 1 && t3_value !== (t3_value = /*cardTop*/ ctx[0].need_sum + "")) set_data_dev(t3, t3_value);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$3.name,
		type: "if",
		source: "(39:8) {#if cardTop.need_sum !== null}",
		ctx
	});

	return block;
}

// (12:0) <Card class="container">
function create_default_slot$2(ctx) {
	let br0;
	let t0;
	let current_block_type_index;
	let if_block0;
	let t1;
	let current_block_type_index_1;
	let if_block1;
	let t2;
	let br1;
	let t3;
	let p;
	let current_block_type_index_2;
	let if_block2;
	let t4;
	let s;
	let t5;
	let current_block_type_index_3;
	let if_block3;
	let t6;
	let br2;
	let t7;
	let progress;
	let t8;
	let br3;
	let current;
	br0 = new Br({ props: { size: "20" }, $$inline: true });
	const if_block_creators = [create_if_block_3$1, create_else_block_3$1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*cardTop*/ ctx[0].title !== null) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	const if_block_creators_1 = [create_if_block_2$2, create_else_block_2$1];
	const if_blocks_1 = [];

	function select_block_type_1(ctx, dirty) {
		if (/*cardTop*/ ctx[0].subtitle !== null) return 0;
		return 1;
	}

	current_block_type_index_1 = select_block_type_1(ctx);
	if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
	br1 = new Br({ props: { size: "25" }, $$inline: true });
	const if_block_creators_2 = [create_if_block_1$3, create_else_block_1$3];
	const if_blocks_2 = [];

	function select_block_type_2(ctx, dirty) {
		if (/*cardTop*/ ctx[0].current_sum !== null) return 0;
		return 1;
	}

	current_block_type_index_2 = select_block_type_2(ctx);
	if_block2 = if_blocks_2[current_block_type_index_2] = if_block_creators_2[current_block_type_index_2](ctx);
	const if_block_creators_3 = [create_if_block$3, create_else_block$3];
	const if_blocks_3 = [];

	function select_block_type_3(ctx, dirty) {
		if (/*cardTop*/ ctx[0].need_sum !== null) return 0;
		return 1;
	}

	current_block_type_index_3 = select_block_type_3(ctx);
	if_block3 = if_blocks_3[current_block_type_index_3] = if_block_creators_3[current_block_type_index_3](ctx);
	br2 = new Br({ props: { size: "20" }, $$inline: true });

	progress = new Progress({
			props: {
				value: Math.floor(/*cardTop*/ ctx[0].current_sum / /*cardTop*/ ctx[0].need_sum * 100)
			},
			$$inline: true
		});

	br3 = new Br({ props: { size: "40" }, $$inline: true });

	const block = {
		c: function create() {
			create_component(br0.$$.fragment);
			t0 = space();
			if_block0.c();
			t1 = space();
			if_block1.c();
			t2 = space();
			create_component(br1.$$.fragment);
			t3 = space();
			p = element("p");
			if_block2.c();
			t4 = space();
			s = element("s");
			t5 = space();
			if_block3.c();
			t6 = space();
			create_component(br2.$$.fragment);
			t7 = space();
			create_component(progress.$$.fragment);
			t8 = space();
			create_component(br3.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			claim_component(br0.$$.fragment, nodes);
			t0 = claim_space(nodes);
			if_block0.l(nodes);
			t1 = claim_space(nodes);
			if_block1.l(nodes);
			t2 = claim_space(nodes);
			claim_component(br1.$$.fragment, nodes);
			t3 = claim_space(nodes);
			p = claim_element(nodes, "P", { class: true });
			var p_nodes = children(p);
			if_block2.l(p_nodes);
			t4 = claim_space(p_nodes);
			s = claim_element(p_nodes, "S", {});
			children(s).forEach(detach_dev);
			t5 = claim_space(p_nodes);
			if_block3.l(p_nodes);
			p_nodes.forEach(detach_dev);
			t6 = claim_space(nodes);
			claim_component(br2.$$.fragment, nodes);
			t7 = claim_space(nodes);
			claim_component(progress.$$.fragment, nodes);
			t8 = claim_space(nodes);
			claim_component(br3.$$.fragment, nodes);
			this.h();
		},
		h: function hydrate() {
			add_location(s, file$a, 36, 8, 1020);
			attr_dev(p, "class", "font-secondary flex flex-align-end");
			add_location(p, file$a, 29, 4, 741);
		},
		m: function mount(target, anchor) {
			mount_component(br0, target, anchor);
			insert_dev(target, t0, anchor);
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, t1, anchor);
			if_blocks_1[current_block_type_index_1].m(target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(br1, target, anchor);
			insert_dev(target, t3, anchor);
			insert_dev(target, p, anchor);
			if_blocks_2[current_block_type_index_2].m(p, null);
			append_dev(p, t4);
			append_dev(p, s);
			append_dev(p, t5);
			if_blocks_3[current_block_type_index_3].m(p, null);
			insert_dev(target, t6, anchor);
			mount_component(br2, target, anchor);
			insert_dev(target, t7, anchor);
			mount_component(progress, target, anchor);
			insert_dev(target, t8, anchor);
			mount_component(br3, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block0 = if_blocks[current_block_type_index];

				if (!if_block0) {
					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block0.c();
				}

				transition_in(if_block0, 1);
				if_block0.m(t1.parentNode, t1);
			}

			let previous_block_index_1 = current_block_type_index_1;
			current_block_type_index_1 = select_block_type_1(ctx);

			if (current_block_type_index_1 === previous_block_index_1) {
				if_blocks_1[current_block_type_index_1].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
					if_blocks_1[previous_block_index_1] = null;
				});

				check_outros();
				if_block1 = if_blocks_1[current_block_type_index_1];

				if (!if_block1) {
					if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
					if_block1.c();
				}

				transition_in(if_block1, 1);
				if_block1.m(t2.parentNode, t2);
			}

			let previous_block_index_2 = current_block_type_index_2;
			current_block_type_index_2 = select_block_type_2(ctx);

			if (current_block_type_index_2 === previous_block_index_2) {
				if_blocks_2[current_block_type_index_2].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks_2[previous_block_index_2], 1, 1, () => {
					if_blocks_2[previous_block_index_2] = null;
				});

				check_outros();
				if_block2 = if_blocks_2[current_block_type_index_2];

				if (!if_block2) {
					if_block2 = if_blocks_2[current_block_type_index_2] = if_block_creators_2[current_block_type_index_2](ctx);
					if_block2.c();
				}

				transition_in(if_block2, 1);
				if_block2.m(p, t4);
			}

			let previous_block_index_3 = current_block_type_index_3;
			current_block_type_index_3 = select_block_type_3(ctx);

			if (current_block_type_index_3 === previous_block_index_3) {
				if_blocks_3[current_block_type_index_3].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks_3[previous_block_index_3], 1, 1, () => {
					if_blocks_3[previous_block_index_3] = null;
				});

				check_outros();
				if_block3 = if_blocks_3[current_block_type_index_3];

				if (!if_block3) {
					if_block3 = if_blocks_3[current_block_type_index_3] = if_block_creators_3[current_block_type_index_3](ctx);
					if_block3.c();
				}

				transition_in(if_block3, 1);
				if_block3.m(p, null);
			}

			const progress_changes = {};
			if (dirty & /*cardTop*/ 1) progress_changes.value = Math.floor(/*cardTop*/ ctx[0].current_sum / /*cardTop*/ ctx[0].need_sum * 100);
			progress.$set(progress_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(br0.$$.fragment, local);
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(br1.$$.fragment, local);
			transition_in(if_block2);
			transition_in(if_block3);
			transition_in(br2.$$.fragment, local);
			transition_in(progress.$$.fragment, local);
			transition_in(br3.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br0.$$.fragment, local);
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(br1.$$.fragment, local);
			transition_out(if_block2);
			transition_out(if_block3);
			transition_out(br2.$$.fragment, local);
			transition_out(progress.$$.fragment, local);
			transition_out(br3.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(br0, detaching);
			if (detaching) detach_dev(t0);
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(t1);
			if_blocks_1[current_block_type_index_1].d(detaching);
			if (detaching) detach_dev(t2);
			destroy_component(br1, detaching);
			if (detaching) detach_dev(t3);
			if (detaching) detach_dev(p);
			if_blocks_2[current_block_type_index_2].d();
			if_blocks_3[current_block_type_index_3].d();
			if (detaching) detach_dev(t6);
			destroy_component(br2, detaching);
			if (detaching) detach_dev(t7);
			destroy_component(progress, detaching);
			if (detaching) detach_dev(t8);
			destroy_component(br3, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$2.name,
		type: "slot",
		source: "(12:0) <Card class=\\\"container\\\">",
		ctx
	});

	return block;
}

function create_fragment$a(ctx) {
	let card;
	let current;

	card = new Card({
			props: {
				class: "container",
				$$slots: { default: [create_default_slot$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(card.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(card.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(card, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const card_changes = {};

			if (dirty & /*$$scope, cardTop*/ 3) {
				card_changes.$$scope = { dirty, ctx };
			}

			card.$set(card_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(card.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(card.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(card, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$a.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$a($$self, $$props, $$invalidate) {
	let { cardTop = {
		title: null,
		subtitle: null,
		current_sum: null,
		need_sum: null
	} } = $$props;

	const writable_props = ["cardTop"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<QuickInfoCard> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("QuickInfoCard", $$slots, []);

	$$self.$set = $$props => {
		if ("cardTop" in $$props) $$invalidate(0, cardTop = $$props.cardTop);
	};

	$$self.$capture_state = () => ({ Br, Card, Progress, Loader, cardTop });

	$$self.$inject_state = $$props => {
		if ("cardTop" in $$props) $$invalidate(0, cardTop = $$props.cardTop);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [cardTop];
}

class QuickInfoCard extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$a, create_fragment$a, safe_not_equal, { cardTop: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "QuickInfoCard",
			options,
			id: create_fragment$a.name
		});
	}

	get cardTop() {
		throw new Error("<QuickInfoCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set cardTop(value) {
		throw new Error("<QuickInfoCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/funds/components/_OrganizationButton.svelte generated by Svelte v3.24.0 */
const file$b = "src/routes/funds/components/_OrganizationButton.svelte";

// (25:6) {:else}
function create_else_block$4(ctx) {
	let span;
	let loader;
	let current;
	loader = new Loader({ props: { type: "h3" }, $$inline: true });

	const block = {
		c: function create() {
			span = element("span");
			create_component(loader.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { style: true });
			var span_nodes = children(span);
			claim_component(loader.$$.fragment, span_nodes);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_style(span, "width", "80%");
			add_location(span, file$b, 25, 8, 638);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			mount_component(loader, span, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(loader.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loader.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			destroy_component(loader);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$4.name,
		type: "else",
		source: "(25:6) {:else}",
		ctx
	});

	return block;
}

// (21:6) {#if title !== null}
function create_if_block$4(ctx) {
	let s0;
	let t0;
	let s1;
	let t1;
	let h3;
	let t2;

	const block = {
		c: function create() {
			s0 = element("s");
			t0 = space();
			s1 = element("s");
			t1 = space();
			h3 = element("h3");
			t2 = text(/*title*/ ctx[2]);
			this.h();
		},
		l: function claim(nodes) {
			s0 = claim_element(nodes, "S", {});
			children(s0).forEach(detach_dev);
			t0 = claim_space(nodes);
			s1 = claim_element(nodes, "S", {});
			children(s1).forEach(detach_dev);
			t1 = claim_space(nodes);
			h3 = claim_element(nodes, "H3", {});
			var h3_nodes = children(h3);
			t2 = claim_text(h3_nodes, /*title*/ ctx[2]);
			h3_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(s0, file$b, 21, 8, 571);
			add_location(s1, file$b, 22, 8, 585);
			add_location(h3, file$b, 23, 8, 599);
		},
		m: function mount(target, anchor) {
			insert_dev(target, s0, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, s1, anchor);
			insert_dev(target, t1, anchor);
			insert_dev(target, h3, anchor);
			append_dev(h3, t2);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*title*/ 4) set_data_dev(t2, /*title*/ ctx[2]);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(s0);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(s1);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(h3);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$4.name,
		type: "if",
		source: "(21:6) {#if title !== null}",
		ctx
	});

	return block;
}

// (9:0) <Button rel="prefetch" href={id} class="white">
function create_default_slot$3(ctx) {
	let div2;
	let div1;
	let s0;
	let t0;
	let div0;
	let picture;
	let t1;
	let s1;
	let t2;
	let current_block_type_index;
	let if_block;
	let t3;
	let icon;
	let current;

	picture = new Picture({
			props: {
				src: /*src*/ ctx[1],
				size: "contain",
				alt: "якесь фото організації"
			},
			$$inline: true
		});

	const if_block_creators = [create_if_block$4, create_else_block$4];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*title*/ ctx[2] !== null) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	icon = new Icon({
			props: {
				type: "arrow-right",
				size: "medium",
				is: "dark"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div2 = element("div");
			div1 = element("div");
			s0 = element("s");
			t0 = space();
			div0 = element("div");
			create_component(picture.$$.fragment);
			t1 = space();
			s1 = element("s");
			t2 = space();
			if_block.c();
			t3 = space();
			create_component(icon.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div2 = claim_element(nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			s0 = claim_element(div1_nodes, "S", {});
			children(s0).forEach(detach_dev);
			t0 = claim_space(div1_nodes);
			div0 = claim_element(div1_nodes, "DIV", { class: true, style: true });
			var div0_nodes = children(div0);
			claim_component(picture.$$.fragment, div0_nodes);
			div0_nodes.forEach(detach_dev);
			t1 = claim_space(div1_nodes);
			s1 = claim_element(div1_nodes, "S", {});
			children(s1).forEach(detach_dev);
			t2 = claim_space(div1_nodes);
			if_block.l(div1_nodes);
			div1_nodes.forEach(detach_dev);
			t3 = claim_space(div2_nodes);
			claim_component(icon.$$.fragment, div2_nodes);
			div2_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(s0, file$b, 12, 6, 324);
			attr_dev(div0, "class", "flex");
			set_style(div0, "max-width", "45px");
			set_style(div0, "height", "40px");
			set_style(div0, "overflow", "hidden");
			add_location(div0, file$b, 13, 6, 336);
			add_location(s1, file$b, 19, 6, 530);
			attr_dev(div1, "class", "flex flex-align-center");
			add_location(div1, file$b, 11, 4, 281);
			attr_dev(div2, "class", "flex flex-align-center flex-justify-between full-width");
			add_location(div2, file$b, 9, 2, 207);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);
			append_dev(div2, div1);
			append_dev(div1, s0);
			append_dev(div1, t0);
			append_dev(div1, div0);
			mount_component(picture, div0, null);
			append_dev(div1, t1);
			append_dev(div1, s1);
			append_dev(div1, t2);
			if_blocks[current_block_type_index].m(div1, null);
			append_dev(div2, t3);
			mount_component(icon, div2, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const picture_changes = {};
			if (dirty & /*src*/ 2) picture_changes.src = /*src*/ ctx[1];
			picture.$set(picture_changes);
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(div1, null);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(picture.$$.fragment, local);
			transition_in(if_block);
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(picture.$$.fragment, local);
			transition_out(if_block);
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div2);
			destroy_component(picture);
			if_blocks[current_block_type_index].d();
			destroy_component(icon);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$3.name,
		type: "slot",
		source: "(9:0) <Button rel=\\\"prefetch\\\" href={id} class=\\\"white\\\">",
		ctx
	});

	return block;
}

function create_fragment$b(ctx) {
	let button;
	let current;

	button = new Button({
			props: {
				rel: "prefetch",
				href: /*id*/ ctx[0],
				class: "white",
				$$slots: { default: [create_default_slot$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(button.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(button.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const button_changes = {};
			if (dirty & /*id*/ 1) button_changes.href = /*id*/ ctx[0];

			if (dirty & /*$$scope, title, src*/ 14) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(button, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$b.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$b($$self, $$props, $$invalidate) {
	let { id = null } = $$props;
	let { src = null } = $$props;
	let { title = null } = $$props;
	const writable_props = ["id", "src", "title"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<OrganizationButton> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("OrganizationButton", $$slots, []);

	$$self.$set = $$props => {
		if ("id" in $$props) $$invalidate(0, id = $$props.id);
		if ("src" in $$props) $$invalidate(1, src = $$props.src);
		if ("title" in $$props) $$invalidate(2, title = $$props.title);
	};

	$$self.$capture_state = () => ({
		Picture,
		Button,
		Loader,
		Icon,
		id,
		src,
		title
	});

	$$self.$inject_state = $$props => {
		if ("id" in $$props) $$invalidate(0, id = $$props.id);
		if ("src" in $$props) $$invalidate(1, src = $$props.src);
		if ("title" in $$props) $$invalidate(2, title = $$props.title);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [id, src, title];
}

class OrganizationButton extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$b, create_fragment$b, safe_not_equal, { id: 0, src: 1, title: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "OrganizationButton",
			options,
			id: create_fragment$b.name
		});
	}

	get id() {
		throw new Error("<OrganizationButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<OrganizationButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get src() {
		throw new Error("<OrganizationButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set src(value) {
		throw new Error("<OrganizationButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get title() {
		throw new Error("<OrganizationButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<OrganizationButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/funds/components/_InteractionIndicators.svelte generated by Svelte v3.24.0 */
const file$c = "src/routes/funds/components/_InteractionIndicators.svelte";

// (15:8) {:else}
function create_else_block_1$4(ctx) {
	let span1;
	let span0;
	let t0;
	let t1;
	let loader;
	let current;

	loader = new Loader({
			props: { type: "h3", absolute: true },
			$$inline: true
		});

	const block = {
		c: function create() {
			span1 = element("span");
			span0 = element("span");
			t0 = text("199");
			t1 = space();
			create_component(loader.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			span1 = claim_element(nodes, "SPAN", { class: true });
			var span1_nodes = children(span1);
			span0 = claim_element(span1_nodes, "SPAN", { style: true });
			var span0_nodes = children(span0);
			t0 = claim_text(span0_nodes, "199");
			span0_nodes.forEach(detach_dev);
			t1 = claim_space(span1_nodes);
			claim_component(loader.$$.fragment, span1_nodes);
			span1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_style(span0, "visibility", "hidden");
			add_location(span0, file$c, 16, 16, 515);
			attr_dev(span1, "class", "font-secondary font-w-600 h3 relative");
			add_location(span1, file$c, 15, 12, 446);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span1, anchor);
			append_dev(span1, span0);
			append_dev(span0, t0);
			append_dev(span1, t1);
			mount_component(loader, span1, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(loader.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loader.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span1);
			destroy_component(loader);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1$4.name,
		type: "else",
		source: "(15:8) {:else}",
		ctx
	});

	return block;
}

// (13:8) {#if likes !== null}
function create_if_block_1$4(ctx) {
	let span;
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(/*likes*/ ctx[0]);
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t = claim_text(span_nodes, /*likes*/ ctx[0]);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "font-secondary font-w-600 h3");
			add_location(span, file$c, 13, 12, 360);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*likes*/ 1) set_data_dev(t, /*likes*/ ctx[0]);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$4.name,
		type: "if",
		source: "(13:8) {#if likes !== null}",
		ctx
	});

	return block;
}

// (28:8) {:else}
function create_else_block$5(ctx) {
	let span1;
	let span0;
	let t0;
	let t1;
	let loader;
	let current;

	loader = new Loader({
			props: { type: "h3", absolute: true },
			$$inline: true
		});

	const block = {
		c: function create() {
			span1 = element("span");
			span0 = element("span");
			t0 = text("199");
			t1 = space();
			create_component(loader.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			span1 = claim_element(nodes, "SPAN", { class: true });
			var span1_nodes = children(span1);
			span0 = claim_element(span1_nodes, "SPAN", { style: true });
			var span0_nodes = children(span0);
			t0 = claim_text(span0_nodes, "199");
			span0_nodes.forEach(detach_dev);
			t1 = claim_space(span1_nodes);
			claim_component(loader.$$.fragment, span1_nodes);
			span1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_style(span0, "visibility", "hidden");
			add_location(span0, file$c, 29, 16, 986);
			attr_dev(span1, "class", "font-secondary font-w-600 h3 relative");
			add_location(span1, file$c, 28, 12, 917);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span1, anchor);
			append_dev(span1, span0);
			append_dev(span0, t0);
			append_dev(span1, t1);
			mount_component(loader, span1, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(loader.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loader.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span1);
			destroy_component(loader);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$5.name,
		type: "else",
		source: "(28:8) {:else}",
		ctx
	});

	return block;
}

// (26:8) {#if views !== null}
function create_if_block$5(ctx) {
	let span;
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(/*views*/ ctx[1]);
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t = claim_text(span_nodes, /*views*/ ctx[1]);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "font-secondary font-w-600 h3");
			add_location(span, file$c, 26, 12, 831);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*views*/ 2) set_data_dev(t, /*views*/ ctx[1]);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$5.name,
		type: "if",
		source: "(26:8) {#if views !== null}",
		ctx
	});

	return block;
}

function create_fragment$c(ctx) {
	let p;
	let span0;
	let icon0;
	let t0;
	let s0;
	let t1;
	let s1;
	let t2;
	let current_block_type_index;
	let if_block0;
	let t3;
	let span1;
	let icon1;
	let t4;
	let s2;
	let t5;
	let s3;
	let t6;
	let current_block_type_index_1;
	let if_block1;
	let current;

	icon0 = new Icon({
			props: {
				is: "danger",
				type: "heart",
				size: "medium"
			},
			$$inline: true
		});

	const if_block_creators = [create_if_block_1$4, create_else_block_1$4];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*likes*/ ctx[0] !== null) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	icon1 = new Icon({
			props: {
				type: "eye",
				size: "medium",
				class: "theme-svg-fill"
			},
			$$inline: true
		});

	const if_block_creators_1 = [create_if_block$5, create_else_block$5];
	const if_blocks_1 = [];

	function select_block_type_1(ctx, dirty) {
		if (/*views*/ ctx[1] !== null) return 0;
		return 1;
	}

	current_block_type_index_1 = select_block_type_1(ctx);
	if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);

	const block = {
		c: function create() {
			p = element("p");
			span0 = element("span");
			create_component(icon0.$$.fragment);
			t0 = space();
			s0 = element("s");
			t1 = space();
			s1 = element("s");
			t2 = space();
			if_block0.c();
			t3 = space();
			span1 = element("span");
			create_component(icon1.$$.fragment);
			t4 = space();
			s2 = element("s");
			t5 = space();
			s3 = element("s");
			t6 = space();
			if_block1.c();
			this.h();
		},
		l: function claim(nodes) {
			p = claim_element(nodes, "P", { class: true });
			var p_nodes = children(p);
			span0 = claim_element(p_nodes, "SPAN", { class: true });
			var span0_nodes = children(span0);
			claim_component(icon0.$$.fragment, span0_nodes);
			t0 = claim_space(span0_nodes);
			s0 = claim_element(span0_nodes, "S", {});
			children(s0).forEach(detach_dev);
			t1 = claim_space(span0_nodes);
			s1 = claim_element(span0_nodes, "S", {});
			children(s1).forEach(detach_dev);
			t2 = claim_space(span0_nodes);
			if_block0.l(span0_nodes);
			span0_nodes.forEach(detach_dev);
			t3 = claim_space(p_nodes);
			span1 = claim_element(p_nodes, "SPAN", { class: true });
			var span1_nodes = children(span1);
			claim_component(icon1.$$.fragment, span1_nodes);
			t4 = claim_space(span1_nodes);
			s2 = claim_element(span1_nodes, "S", {});
			children(s2).forEach(detach_dev);
			t5 = claim_space(span1_nodes);
			s3 = claim_element(span1_nodes, "S", {});
			children(s3).forEach(detach_dev);
			t6 = claim_space(span1_nodes);
			if_block1.l(span1_nodes);
			span1_nodes.forEach(detach_dev);
			p_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(s0, file$c, 10, 8, 295);
			add_location(s1, file$c, 11, 8, 311);
			attr_dev(span0, "class", "flex flex-align-center");
			add_location(span0, file$c, 8, 4, 194);
			add_location(s2, file$c, 23, 8, 766);
			add_location(s3, file$c, 24, 8, 782);
			attr_dev(span1, "class", "flex flex-align-center");
			add_location(span1, file$c, 21, 4, 656);
			attr_dev(p, "class", "container flex flex-justify-between flex-align-center");
			add_location(p, file$c, 7, 0, 124);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, span0);
			mount_component(icon0, span0, null);
			append_dev(span0, t0);
			append_dev(span0, s0);
			append_dev(span0, t1);
			append_dev(span0, s1);
			append_dev(span0, t2);
			if_blocks[current_block_type_index].m(span0, null);
			append_dev(p, t3);
			append_dev(p, span1);
			mount_component(icon1, span1, null);
			append_dev(span1, t4);
			append_dev(span1, s2);
			append_dev(span1, t5);
			append_dev(span1, s3);
			append_dev(span1, t6);
			if_blocks_1[current_block_type_index_1].m(span1, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block0 = if_blocks[current_block_type_index];

				if (!if_block0) {
					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block0.c();
				}

				transition_in(if_block0, 1);
				if_block0.m(span0, null);
			}

			let previous_block_index_1 = current_block_type_index_1;
			current_block_type_index_1 = select_block_type_1(ctx);

			if (current_block_type_index_1 === previous_block_index_1) {
				if_blocks_1[current_block_type_index_1].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
					if_blocks_1[previous_block_index_1] = null;
				});

				check_outros();
				if_block1 = if_blocks_1[current_block_type_index_1];

				if (!if_block1) {
					if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
					if_block1.c();
				}

				transition_in(if_block1, 1);
				if_block1.m(span1, null);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon0.$$.fragment, local);
			transition_in(if_block0);
			transition_in(icon1.$$.fragment, local);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon0.$$.fragment, local);
			transition_out(if_block0);
			transition_out(icon1.$$.fragment, local);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
			destroy_component(icon0);
			if_blocks[current_block_type_index].d();
			destroy_component(icon1);
			if_blocks_1[current_block_type_index_1].d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$c.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$c($$self, $$props, $$invalidate) {
	let { likes = null } = $$props;
	let { views = null } = $$props;
	const writable_props = ["likes", "views"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<InteractionIndicators> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("InteractionIndicators", $$slots, []);

	$$self.$set = $$props => {
		if ("likes" in $$props) $$invalidate(0, likes = $$props.likes);
		if ("views" in $$props) $$invalidate(1, views = $$props.views);
	};

	$$self.$capture_state = () => ({ Icon, Loader, likes, views });

	$$self.$inject_state = $$props => {
		if ("likes" in $$props) $$invalidate(0, likes = $$props.likes);
		if ("views" in $$props) $$invalidate(1, views = $$props.views);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [likes, views];
}

class InteractionIndicators extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$c, create_fragment$c, safe_not_equal, { likes: 0, views: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "InteractionIndicators",
			options,
			id: create_fragment$c.name
		});
	}

	get likes() {
		throw new Error("<InteractionIndicators>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set likes(value) {
		throw new Error("<InteractionIndicators>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get views() {
		throw new Error("<InteractionIndicators>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set views(value) {
		throw new Error("<InteractionIndicators>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/funds/view/_Videos.svelte generated by Svelte v3.24.0 */

function create_fragment$d(ctx) {
	let media;
	let current;

	media = new Media({
			props: { items: /*items*/ ctx[0] },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(media.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(media.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(media, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const media_changes = {};
			if (dirty & /*items*/ 1) media_changes.items = /*items*/ ctx[0];
			media.$set(media_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(media.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(media.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(media, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$d.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$d($$self, $$props, $$invalidate) {
	let { items } = $$props;
	const writable_props = ["items"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Videos> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Videos", $$slots, []);

	$$self.$set = $$props => {
		if ("items" in $$props) $$invalidate(0, items = $$props.items);
	};

	$$self.$capture_state = () => ({ Media, items });

	$$self.$inject_state = $$props => {
		if ("items" in $$props) $$invalidate(0, items = $$props.items);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [items];
}

class Videos extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$d, create_fragment$d, safe_not_equal, { items: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Videos",
			options,
			id: create_fragment$d.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*items*/ ctx[0] === undefined && !("items" in props)) {
			console.warn("<Videos> was created without expected prop 'items'");
		}
	}

	get items() {
		throw new Error("<Videos>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set items(value) {
		throw new Error("<Videos>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/funds/view/_TopInfo.svelte generated by Svelte v3.24.0 */

function create_fragment$e(ctx) {
	let topcarousel;
	let t0;
	let br0;
	let t1;
	let organizationbutton;
	let t2;
	let br1;
	let t3;
	let quickinfocard;
	let current;

	topcarousel = new TopCarousel({
			props: { items: /*carouselTop*/ ctx[1] },
			$$inline: true
		});

	br0 = new Br({ props: { size: "40" }, $$inline: true });

	organizationbutton = new OrganizationButton({
			props: {
				id: /*organization*/ ctx[2].id,
				src: /*organization*/ ctx[2].avatar,
				title: /*organization*/ ctx[2].name
			},
			$$inline: true
		});

	br1 = new Br({ props: { size: "20" }, $$inline: true });

	quickinfocard = new QuickInfoCard({
			props: { cardTop: /*cardTop*/ ctx[0] },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(topcarousel.$$.fragment);
			t0 = space();
			create_component(br0.$$.fragment);
			t1 = space();
			create_component(organizationbutton.$$.fragment);
			t2 = space();
			create_component(br1.$$.fragment);
			t3 = space();
			create_component(quickinfocard.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(topcarousel.$$.fragment, nodes);
			t0 = claim_space(nodes);
			claim_component(br0.$$.fragment, nodes);
			t1 = claim_space(nodes);
			claim_component(organizationbutton.$$.fragment, nodes);
			t2 = claim_space(nodes);
			claim_component(br1.$$.fragment, nodes);
			t3 = claim_space(nodes);
			claim_component(quickinfocard.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(topcarousel, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(br0, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(organizationbutton, target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(br1, target, anchor);
			insert_dev(target, t3, anchor);
			mount_component(quickinfocard, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const topcarousel_changes = {};
			if (dirty & /*carouselTop*/ 2) topcarousel_changes.items = /*carouselTop*/ ctx[1];
			topcarousel.$set(topcarousel_changes);
			const organizationbutton_changes = {};
			if (dirty & /*organization*/ 4) organizationbutton_changes.id = /*organization*/ ctx[2].id;
			if (dirty & /*organization*/ 4) organizationbutton_changes.src = /*organization*/ ctx[2].avatar;
			if (dirty & /*organization*/ 4) organizationbutton_changes.title = /*organization*/ ctx[2].name;
			organizationbutton.$set(organizationbutton_changes);
			const quickinfocard_changes = {};
			if (dirty & /*cardTop*/ 1) quickinfocard_changes.cardTop = /*cardTop*/ ctx[0];
			quickinfocard.$set(quickinfocard_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(topcarousel.$$.fragment, local);
			transition_in(br0.$$.fragment, local);
			transition_in(organizationbutton.$$.fragment, local);
			transition_in(br1.$$.fragment, local);
			transition_in(quickinfocard.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(topcarousel.$$.fragment, local);
			transition_out(br0.$$.fragment, local);
			transition_out(organizationbutton.$$.fragment, local);
			transition_out(br1.$$.fragment, local);
			transition_out(quickinfocard.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(topcarousel, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(br0, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(organizationbutton, detaching);
			if (detaching) detach_dev(t2);
			destroy_component(br1, detaching);
			if (detaching) detach_dev(t3);
			destroy_component(quickinfocard, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$e.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$e($$self, $$props, $$invalidate) {
	let { cardTop } = $$props;
	let { carouselTop } = $$props;
	let { organization } = $$props;
	const writable_props = ["cardTop", "carouselTop", "organization"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<TopInfo> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("TopInfo", $$slots, []);

	$$self.$set = $$props => {
		if ("cardTop" in $$props) $$invalidate(0, cardTop = $$props.cardTop);
		if ("carouselTop" in $$props) $$invalidate(1, carouselTop = $$props.carouselTop);
		if ("organization" in $$props) $$invalidate(2, organization = $$props.organization);
	};

	$$self.$capture_state = () => ({
		Br,
		TopCarousel,
		QuickInfoCard,
		OrganizationButton,
		cardTop,
		carouselTop,
		organization
	});

	$$self.$inject_state = $$props => {
		if ("cardTop" in $$props) $$invalidate(0, cardTop = $$props.cardTop);
		if ("carouselTop" in $$props) $$invalidate(1, carouselTop = $$props.carouselTop);
		if ("organization" in $$props) $$invalidate(2, organization = $$props.organization);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [cardTop, carouselTop, organization];
}

class TopInfo extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$e, create_fragment$e, safe_not_equal, {
			cardTop: 0,
			carouselTop: 1,
			organization: 2
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "TopInfo",
			options,
			id: create_fragment$e.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*cardTop*/ ctx[0] === undefined && !("cardTop" in props)) {
			console.warn("<TopInfo> was created without expected prop 'cardTop'");
		}

		if (/*carouselTop*/ ctx[1] === undefined && !("carouselTop" in props)) {
			console.warn("<TopInfo> was created without expected prop 'carouselTop'");
		}

		if (/*organization*/ ctx[2] === undefined && !("organization" in props)) {
			console.warn("<TopInfo> was created without expected prop 'organization'");
		}
	}

	get cardTop() {
		throw new Error("<TopInfo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set cardTop(value) {
		throw new Error("<TopInfo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get carouselTop() {
		throw new Error("<TopInfo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set carouselTop(value) {
		throw new Error("<TopInfo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get organization() {
		throw new Error("<TopInfo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set organization(value) {
		throw new Error("<TopInfo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/funds/view/_Documents.svelte generated by Svelte v3.24.0 */

function create_fragment$f(ctx) {
	let documents;
	let current;

	documents = new Documents_1({
			props: { items: /*items*/ ctx[0] },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(documents.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(documents.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(documents, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const documents_changes = {};
			if (dirty & /*items*/ 1) documents_changes.items = /*items*/ ctx[0];
			documents.$set(documents_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(documents.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(documents.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(documents, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$f.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$f($$self, $$props, $$invalidate) {
	let { items } = $$props;
	const writable_props = ["items"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Documents> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Documents", $$slots, []);

	$$self.$set = $$props => {
		if ("items" in $$props) $$invalidate(0, items = $$props.items);
	};

	$$self.$capture_state = () => ({ Documents: Documents_1, items });

	$$self.$inject_state = $$props => {
		if ("items" in $$props) $$invalidate(0, items = $$props.items);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [items];
}

class Documents_1$1 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$f, create_fragment$f, safe_not_equal, { items: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Documents_1",
			options,
			id: create_fragment$f.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*items*/ ctx[0] === undefined && !("items" in props)) {
			console.warn("<Documents> was created without expected prop 'items'");
		}
	}

	get items() {
		throw new Error("<Documents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set items(value) {
		throw new Error("<Documents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/funds/view/_HowToHelp.svelte generated by Svelte v3.24.0 */

function create_fragment$g(ctx) {
	let howtohelp;
	let current;

	howtohelp = new HowToHelp({
			props: { data: /*data*/ ctx[0] },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(howtohelp.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(howtohelp.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(howtohelp, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const howtohelp_changes = {};
			if (dirty & /*data*/ 1) howtohelp_changes.data = /*data*/ ctx[0];
			howtohelp.$set(howtohelp_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(howtohelp.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(howtohelp.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(howtohelp, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$g.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$g($$self, $$props, $$invalidate) {
	let { data } = $$props;
	const writable_props = ["data"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<HowToHelp> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("HowToHelp", $$slots, []);

	$$self.$set = $$props => {
		if ("data" in $$props) $$invalidate(0, data = $$props.data);
	};

	$$self.$capture_state = () => ({ HowToHelp, data });

	$$self.$inject_state = $$props => {
		if ("data" in $$props) $$invalidate(0, data = $$props.data);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [data];
}

class HowToHelp_1 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$g, create_fragment$g, safe_not_equal, { data: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "HowToHelp_1",
			options,
			id: create_fragment$g.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*data*/ ctx[0] === undefined && !("data" in props)) {
			console.warn("<HowToHelp> was created without expected prop 'data'");
		}
	}

	get data() {
		throw new Error("<HowToHelp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set data(value) {
		throw new Error("<HowToHelp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/funds/view/_AnimalCard.svelte generated by Svelte v3.24.0 */

function create_fragment$h(ctx) {
	let animalcard;
	let current;

	animalcard = new AnimalCard({
			props: { animal: /*animal*/ ctx[0] },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(animalcard.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(animalcard.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(animalcard, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const animalcard_changes = {};
			if (dirty & /*animal*/ 1) animalcard_changes.animal = /*animal*/ ctx[0];
			animalcard.$set(animalcard_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(animalcard.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(animalcard.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(animalcard, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$h.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$h($$self, $$props, $$invalidate) {
	let { animal = undefined } = $$props;
	const writable_props = ["animal"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AnimalCard> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("AnimalCard", $$slots, []);

	$$self.$set = $$props => {
		if ("animal" in $$props) $$invalidate(0, animal = $$props.animal);
	};

	$$self.$capture_state = () => ({ AnimalCard, animal });

	$$self.$inject_state = $$props => {
		if ("animal" in $$props) $$invalidate(0, animal = $$props.animal);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [animal];
}

class AnimalCard_1 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$h, create_fragment$h, safe_not_equal, { animal: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "AnimalCard_1",
			options,
			id: create_fragment$h.name
		});
	}

	get animal() {
		throw new Error("<AnimalCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set animal(value) {
		throw new Error("<AnimalCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/funds/view/_Description.svelte generated by Svelte v3.24.0 */

function create_fragment$i(ctx) {
	let description;
	let current;

	description = new Description({
			props: {
				title: /*title*/ ctx[0],
				text: /*text*/ ctx[1]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(description.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(description.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(description, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const description_changes = {};
			if (dirty & /*title*/ 1) description_changes.title = /*title*/ ctx[0];
			if (dirty & /*text*/ 2) description_changes.text = /*text*/ ctx[1];
			description.$set(description_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(description.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(description.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(description, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$i.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$i($$self, $$props, $$invalidate) {
	let { title = undefined } = $$props;
	let { text = undefined } = $$props;
	const writable_props = ["title", "text"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Description> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Description", $$slots, []);

	$$self.$set = $$props => {
		if ("title" in $$props) $$invalidate(0, title = $$props.title);
		if ("text" in $$props) $$invalidate(1, text = $$props.text);
	};

	$$self.$capture_state = () => ({ Description, title, text });

	$$self.$inject_state = $$props => {
		if ("title" in $$props) $$invalidate(0, title = $$props.title);
		if ("text" in $$props) $$invalidate(1, text = $$props.text);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [title, text];
}

class Description_1 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$i, create_fragment$i, safe_not_equal, { title: 0, text: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Description_1",
			options,
			id: create_fragment$i.name
		});
	}

	get title() {
		throw new Error("<Description>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<Description>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get text() {
		throw new Error("<Description>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set text(value) {
		throw new Error("<Description>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/funds/edit/_Videos.svelte generated by Svelte v3.24.0 */

// (59:0) <EditCard form="videos-form" on:cancel={onCancel}>
function create_default_slot$4(ctx) {
	let formbuilder;
	let current;

	formbuilder = new FormBuilder({
			props: {
				id: "videos-form",
				items: /*formFields*/ ctx[2],
				data: /*formValues*/ ctx[0],
				errors: /*formErrors*/ ctx[1],
				submit: /*onSubmit*/ ctx[3]
			},
			$$inline: true
		});

	formbuilder.$on("change", /*onChange*/ ctx[4]);

	const block = {
		c: function create() {
			create_component(formbuilder.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(formbuilder.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(formbuilder, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const formbuilder_changes = {};
			if (dirty & /*formFields*/ 4) formbuilder_changes.items = /*formFields*/ ctx[2];
			if (dirty & /*formValues*/ 1) formbuilder_changes.data = /*formValues*/ ctx[0];
			if (dirty & /*formErrors*/ 2) formbuilder_changes.errors = /*formErrors*/ ctx[1];
			formbuilder.$set(formbuilder_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(formbuilder.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(formbuilder.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(formbuilder, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$4.name,
		type: "slot",
		source: "(59:0) <EditCard form=\\\"videos-form\\\" on:cancel={onCancel}>",
		ctx
	});

	return block;
}

function create_fragment$j(ctx) {
	let editcard;
	let current;

	editcard = new EditCard({
			props: {
				form: "videos-form",
				$$slots: { default: [create_default_slot$4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	editcard.$on("cancel", /*onCancel*/ ctx[5]);

	const block = {
		c: function create() {
			create_component(editcard.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(editcard.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(editcard, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const editcard_changes = {};

			if (dirty & /*$$scope, formFields, formValues, formErrors*/ 8199) {
				editcard_changes.$$scope = { dirty, ctx };
			}

			editcard.$set(editcard_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(editcard.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(editcard.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(editcard, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$j.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$j($$self, $$props, $$invalidate) {
	let { data = undefined } = $$props;

	let { submit = async () => {
		
	} } = $$props;

	const dispatch = createEventDispatcher();

	const defaultField = {
		label: "Відео 1:",
		type: "url",
		name: "videos[0].src",
		meta: {
			placeholder: "https://www.youtube.com/watch?v=oUcAUwptos4&t"
		}
	};

	async function onSubmit(e) {
		await submit(e);
	}

	function shiftValues(values) {
		return {
			...values,
			videos: safeGet(() => values.videos.filter(v => v.src), [])
		};
	}

	function onChange({ detail: { values } }) {
		$$invalidate(8, currentValues = shiftValues(values));

		if (safeGet(() => currentValues.videos.length) !== safeGet(() => formValues.videos.length)) {
			$$invalidate(0, formValues = currentValues);
		}

		dispatch("change", values);
	}

	function onCancel() {
		$$invalidate(8, currentValues = data);
		$$invalidate(0, formValues = data);
		dispatch("cancel");
	}

	const writable_props = ["data", "submit"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Videos> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Videos", $$slots, []);

	$$self.$set = $$props => {
		if ("data" in $$props) $$invalidate(6, data = $$props.data);
		if ("submit" in $$props) $$invalidate(7, submit = $$props.submit);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		safeGet,
		EditCard,
		FormBuilder,
		data,
		submit,
		dispatch,
		defaultField,
		onSubmit,
		shiftValues,
		onChange,
		onCancel,
		currentValues,
		formValues,
		formErrors,
		fieldsAmount,
		formFields
	});

	$$self.$inject_state = $$props => {
		if ("data" in $$props) $$invalidate(6, data = $$props.data);
		if ("submit" in $$props) $$invalidate(7, submit = $$props.submit);
		if ("currentValues" in $$props) $$invalidate(8, currentValues = $$props.currentValues);
		if ("formValues" in $$props) $$invalidate(0, formValues = $$props.formValues);
		if ("formErrors" in $$props) $$invalidate(1, formErrors = $$props.formErrors);
		if ("fieldsAmount" in $$props) $$invalidate(9, fieldsAmount = $$props.fieldsAmount);
		if ("formFields" in $$props) $$invalidate(2, formFields = $$props.formFields);
	};

	let currentValues;
	let formValues;
	let formErrors;
	let fieldsAmount;
	let formFields;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*data*/ 64) {
			 $$invalidate(8, currentValues = data || {});
		}

		if ($$self.$$.dirty & /*data*/ 64) {
			 $$invalidate(0, formValues = data || {});
		}

		if ($$self.$$.dirty & /*currentValues*/ 256) {
			 $$invalidate(9, fieldsAmount = safeGet(() => currentValues.videos.filter(v => v.src).length, 0, true));
		}

		if ($$self.$$.dirty & /*fieldsAmount*/ 512) {
			 $$invalidate(2, formFields = Array.from(new Array(Math.max(2, fieldsAmount + 1))).map((f, i) => ({
				...defaultField,
				label: `Відео ${i + 1}:`,
				name: `videos[${i}].src`
			})));
		}
	};

	 $$invalidate(1, formErrors = {});
	return [formValues, formErrors, formFields, onSubmit, onChange, onCancel, data, submit];
}

class Videos$1 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$j, create_fragment$j, safe_not_equal, { data: 6, submit: 7 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Videos",
			options,
			id: create_fragment$j.name
		});
	}

	get data() {
		throw new Error("<Videos>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set data(value) {
		throw new Error("<Videos>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get submit() {
		throw new Error("<Videos>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set submit(value) {
		throw new Error("<Videos>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/funds/edit/_TopInfo.svelte generated by Svelte v3.24.0 */

// (84:0) <EditCard form="top-info-form" on:cancel={onCancel}>
function create_default_slot$5(ctx) {
	let formbuilder;
	let current;

	formbuilder = new FormBuilder({
			props: {
				id: "top-info-form",
				items: /*formFields*/ ctx[2],
				data: /*formValues*/ ctx[0],
				errors: /*formErrors*/ ctx[1],
				submit: /*onSubmit*/ ctx[3]
			},
			$$inline: true
		});

	formbuilder.$on("change", /*change_handler*/ ctx[7]);

	const block = {
		c: function create() {
			create_component(formbuilder.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(formbuilder.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(formbuilder, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const formbuilder_changes = {};
			if (dirty & /*formValues*/ 1) formbuilder_changes.data = /*formValues*/ ctx[0];
			if (dirty & /*formErrors*/ 2) formbuilder_changes.errors = /*formErrors*/ ctx[1];
			formbuilder.$set(formbuilder_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(formbuilder.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(formbuilder.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(formbuilder, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$5.name,
		type: "slot",
		source: "(84:0) <EditCard form=\\\"top-info-form\\\" on:cancel={onCancel}>",
		ctx
	});

	return block;
}

function create_fragment$k(ctx) {
	let editcard;
	let current;

	editcard = new EditCard({
			props: {
				form: "top-info-form",
				$$slots: { default: [create_default_slot$5] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	editcard.$on("cancel", /*onCancel*/ ctx[4]);

	const block = {
		c: function create() {
			create_component(editcard.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(editcard.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(editcard, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const editcard_changes = {};

			if (dirty & /*$$scope, formValues, formErrors*/ 515) {
				editcard_changes.$$scope = { dirty, ctx };
			}

			editcard.$set(editcard_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(editcard.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(editcard.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(editcard, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$k.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$k($$self, $$props, $$invalidate) {
	let { data = undefined } = $$props;

	let { submit = async () => {
		
	} } = $$props;

	const dispatch = createEventDispatcher();

	let formFields = [
		{
			label: "Фотогалерея:",
			type: "files",
			name: "photos",
			meta: { multiple: true }
		},
		{
			label: "Організація:",
			type: "select",
			name: "organization.id",
			meta: {
				placeholder: "Вибрати...",
				options: [
					{ value: "org1", label: "Організація 1" },
					{ value: "id", label: "Організація 2" },
					{ value: "org3", label: "Організація 3" }
				]
			}
		},
		{
			label: "Назва фонду:",
			type: "text",
			name: "title",
			meta: {
				placeholder: "Врятуємо її...",
				maxlength: 20
			}
		},
		{
			label: "Ціль фонду:",
			type: "text",
			name: "subtitle",
			meta: {
				placeholder: "Тільки спільними силами...",
				maxlength: 25
			}
		},
		{
			label: "Потрібно зібрати:",
			type: "number",
			name: "need_sum",
			meta: { placeholder: 10, min: 10, max: 100000000 }
		}
	];

	async function onSubmit(e) {
		await submit(e);
	}

	function onCancel() {
		$$invalidate(0, formValues = data);
		dispatch("cancel");
	}

	const writable_props = ["data", "submit"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<TopInfo> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("TopInfo", $$slots, []);

	function change_handler(event) {
		bubble($$self, event);
	}

	$$self.$set = $$props => {
		if ("data" in $$props) $$invalidate(5, data = $$props.data);
		if ("submit" in $$props) $$invalidate(6, submit = $$props.submit);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		EditCard,
		FormBuilder,
		data,
		submit,
		dispatch,
		formFields,
		onSubmit,
		onCancel,
		formValues,
		formErrors
	});

	$$self.$inject_state = $$props => {
		if ("data" in $$props) $$invalidate(5, data = $$props.data);
		if ("submit" in $$props) $$invalidate(6, submit = $$props.submit);
		if ("formFields" in $$props) $$invalidate(2, formFields = $$props.formFields);
		if ("formValues" in $$props) $$invalidate(0, formValues = $$props.formValues);
		if ("formErrors" in $$props) $$invalidate(1, formErrors = $$props.formErrors);
	};

	let formValues;
	let formErrors;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*data*/ 32) {
			 $$invalidate(0, formValues = data || {});
		}
	};

	 $$invalidate(1, formErrors = {});

	return [
		formValues,
		formErrors,
		formFields,
		onSubmit,
		onCancel,
		data,
		submit,
		change_handler
	];
}

class TopInfo$1 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$k, create_fragment$k, safe_not_equal, { data: 5, submit: 6 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "TopInfo",
			options,
			id: create_fragment$k.name
		});
	}

	get data() {
		throw new Error("<TopInfo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set data(value) {
		throw new Error("<TopInfo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get submit() {
		throw new Error("<TopInfo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set submit(value) {
		throw new Error("<TopInfo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/funds/edit/_Documents.svelte generated by Svelte v3.24.0 */

// (35:0) <EditCard form="documents-form" on:cancel={onCancel}>
function create_default_slot$6(ctx) {
	let formbuilder;
	let current;

	formbuilder = new FormBuilder({
			props: {
				id: "documents-form",
				items: /*formFields*/ ctx[2],
				data: /*formValues*/ ctx[0],
				errors: /*formErrors*/ ctx[1],
				submit: /*onSubmit*/ ctx[3]
			},
			$$inline: true
		});

	formbuilder.$on("change", /*change_handler*/ ctx[7]);

	const block = {
		c: function create() {
			create_component(formbuilder.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(formbuilder.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(formbuilder, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const formbuilder_changes = {};
			if (dirty & /*formValues*/ 1) formbuilder_changes.data = /*formValues*/ ctx[0];
			if (dirty & /*formErrors*/ 2) formbuilder_changes.errors = /*formErrors*/ ctx[1];
			formbuilder.$set(formbuilder_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(formbuilder.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(formbuilder.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(formbuilder, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$6.name,
		type: "slot",
		source: "(35:0) <EditCard form=\\\"documents-form\\\" on:cancel={onCancel}>",
		ctx
	});

	return block;
}

function create_fragment$l(ctx) {
	let editcard;
	let current;

	editcard = new EditCard({
			props: {
				form: "documents-form",
				$$slots: { default: [create_default_slot$6] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	editcard.$on("cancel", /*onCancel*/ ctx[4]);

	const block = {
		c: function create() {
			create_component(editcard.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(editcard.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(editcard, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const editcard_changes = {};

			if (dirty & /*$$scope, formValues, formErrors*/ 515) {
				editcard_changes.$$scope = { dirty, ctx };
			}

			editcard.$set(editcard_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(editcard.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(editcard.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(editcard, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$l.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$l($$self, $$props, $$invalidate) {
	let { data = undefined } = $$props;

	let { submit = async () => {
		
	} } = $$props;

	const dispatch = createEventDispatcher();

	let formFields = [
		{
			label: "Документи:",
			type: "files",
			name: "documents",
			meta: {
				multiple: true,
				accept: "image/jpeg,image/png,application/pdf"
			}
		}
	];

	async function onSubmit(e) {
		await submit(e);
	}

	function onCancel() {
		$$invalidate(0, formValues = data);
		dispatch("cancel");
	}

	const writable_props = ["data", "submit"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Documents> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Documents", $$slots, []);

	function change_handler(event) {
		bubble($$self, event);
	}

	$$self.$set = $$props => {
		if ("data" in $$props) $$invalidate(5, data = $$props.data);
		if ("submit" in $$props) $$invalidate(6, submit = $$props.submit);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		EditCard,
		FormBuilder,
		data,
		submit,
		dispatch,
		formFields,
		onSubmit,
		onCancel,
		formValues,
		formErrors
	});

	$$self.$inject_state = $$props => {
		if ("data" in $$props) $$invalidate(5, data = $$props.data);
		if ("submit" in $$props) $$invalidate(6, submit = $$props.submit);
		if ("formFields" in $$props) $$invalidate(2, formFields = $$props.formFields);
		if ("formValues" in $$props) $$invalidate(0, formValues = $$props.formValues);
		if ("formErrors" in $$props) $$invalidate(1, formErrors = $$props.formErrors);
	};

	let formValues;
	let formErrors;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*data*/ 32) {
			 $$invalidate(0, formValues = data || {});
		}
	};

	 $$invalidate(1, formErrors = {});

	return [
		formValues,
		formErrors,
		formFields,
		onSubmit,
		onCancel,
		data,
		submit,
		change_handler
	];
}

class Documents extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$l, create_fragment$l, safe_not_equal, { data: 5, submit: 6 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Documents",
			options,
			id: create_fragment$l.name
		});
	}

	get data() {
		throw new Error("<Documents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set data(value) {
		throw new Error("<Documents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get submit() {
		throw new Error("<Documents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set submit(value) {
		throw new Error("<Documents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/funds/edit/_HowToHelp.svelte generated by Svelte v3.24.0 */

// (41:0) <EditCard form="howtohelp-form" on:cancel={onCancel}>
function create_default_slot$7(ctx) {
	let formbuilder;
	let current;

	formbuilder = new FormBuilder({
			props: {
				id: "howtohelp-form",
				items: /*formFields*/ ctx[2],
				data: /*formValues*/ ctx[0],
				errors: /*formErrors*/ ctx[1],
				submit: /*onSubmit*/ ctx[3],
				beforeChange: /*beforeFormChange*/ ctx[5]
			},
			$$inline: true
		});

	formbuilder.$on("change", /*change_handler*/ ctx[8]);

	const block = {
		c: function create() {
			create_component(formbuilder.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(formbuilder.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(formbuilder, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const formbuilder_changes = {};
			if (dirty & /*formValues*/ 1) formbuilder_changes.data = /*formValues*/ ctx[0];
			if (dirty & /*formErrors*/ 2) formbuilder_changes.errors = /*formErrors*/ ctx[1];
			formbuilder.$set(formbuilder_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(formbuilder.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(formbuilder.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(formbuilder, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$7.name,
		type: "slot",
		source: "(41:0) <EditCard form=\\\"howtohelp-form\\\" on:cancel={onCancel}>",
		ctx
	});

	return block;
}

function create_fragment$m(ctx) {
	let editcard;
	let current;

	editcard = new EditCard({
			props: {
				form: "howtohelp-form",
				$$slots: { default: [create_default_slot$7] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	editcard.$on("cancel", /*onCancel*/ ctx[4]);

	const block = {
		c: function create() {
			create_component(editcard.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(editcard.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(editcard, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const editcard_changes = {};

			if (dirty & /*$$scope, formValues, formErrors*/ 1027) {
				editcard_changes.$$scope = { dirty, ctx };
			}

			editcard.$set(editcard_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(editcard.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(editcard.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(editcard, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$m.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$m($$self, $$props, $$invalidate) {
	let { data = undefined } = $$props;

	let { submit = async () => {
		
	} } = $$props;

	const dispatch = createEventDispatcher();

	let formFields = [
		{
			label: "Як можна допомогти:",
			type: "textarea",
			name: "how_to_help",
			meta: { placeholder: "· Привести корм", rows: 6 }
		}
	];

	async function onSubmit(e) {
		await submit(e);
	}

	function onCancel() {
		$$invalidate(0, formValues = data);
		dispatch("cancel");
	}

	function beforeFormChange(values) {
		values.how_to_help = formatTextToBullets(values.how_to_help);
		return values;
	}

	const writable_props = ["data", "submit"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<HowToHelp> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("HowToHelp", $$slots, []);

	function change_handler(event) {
		bubble($$self, event);
	}

	$$self.$set = $$props => {
		if ("data" in $$props) $$invalidate(6, data = $$props.data);
		if ("submit" in $$props) $$invalidate(7, submit = $$props.submit);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		formatTextToBullets,
		EditCard,
		FormBuilder,
		data,
		submit,
		dispatch,
		formFields,
		onSubmit,
		onCancel,
		beforeFormChange,
		formValues,
		formErrors
	});

	$$self.$inject_state = $$props => {
		if ("data" in $$props) $$invalidate(6, data = $$props.data);
		if ("submit" in $$props) $$invalidate(7, submit = $$props.submit);
		if ("formFields" in $$props) $$invalidate(2, formFields = $$props.formFields);
		if ("formValues" in $$props) $$invalidate(0, formValues = $$props.formValues);
		if ("formErrors" in $$props) $$invalidate(1, formErrors = $$props.formErrors);
	};

	let formValues;
	let formErrors;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*data*/ 64) {
			 $$invalidate(0, formValues = data || {});
		}
	};

	 $$invalidate(1, formErrors = {});

	return [
		formValues,
		formErrors,
		formFields,
		onSubmit,
		onCancel,
		beforeFormChange,
		data,
		submit,
		change_handler
	];
}

class HowToHelp$1 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$m, create_fragment$m, safe_not_equal, { data: 6, submit: 7 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "HowToHelp",
			options,
			id: create_fragment$m.name
		});
	}

	get data() {
		throw new Error("<HowToHelp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set data(value) {
		throw new Error("<HowToHelp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get submit() {
		throw new Error("<HowToHelp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set submit(value) {
		throw new Error("<HowToHelp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/funds/edit/_AnimalCard.svelte generated by Svelte v3.24.0 */

const file$d = "src/routes/funds/edit/_AnimalCard.svelte";

// (192:51) 
function create_if_block_1$5(ctx) {
	let section;
	let storylist;
	let current;

	const storylist_spread_levels = [
		/*item*/ ctx[9].meta,
		{ value: /*value*/ ctx[10] },
		{ name: /*item*/ ctx[9].name },
		{ label: /*item*/ ctx[9].label }
	];

	let storylist_props = {};

	for (let i = 0; i < storylist_spread_levels.length; i += 1) {
		storylist_props = assign(storylist_props, storylist_spread_levels[i]);
	}

	storylist = new StoryList({ props: storylist_props, $$inline: true });

	storylist.$on("change", function () {
		if (is_function(/*onChange*/ ctx[11])) /*onChange*/ ctx[11].apply(this, arguments);
	});

	const block = {
		c: function create() {
			section = element("section");
			create_component(storylist.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", {});
			var section_nodes = children(section);
			claim_component(storylist.$$.fragment, section_nodes);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(section, file$d, 192, 12, 5323);
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			mount_component(storylist, section, null);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			const storylist_changes = (dirty & /*item, value*/ 1536)
			? get_spread_update(storylist_spread_levels, [
					dirty & /*item*/ 512 && get_spread_object(/*item*/ ctx[9].meta),
					dirty & /*value*/ 1024 && { value: /*value*/ ctx[10] },
					dirty & /*item*/ 512 && { name: /*item*/ ctx[9].name },
					dirty & /*item*/ 512 && { label: /*item*/ ctx[9].label }
				])
			: {};

			storylist.$set(storylist_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(storylist.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(storylist.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			destroy_component(storylist);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$5.name,
		type: "if",
		source: "(192:51) ",
		ctx
	});

	return block;
}

// (166:8) {#if item.type === 'custom-character'}
function create_if_block$6(ctx) {
	let section;
	let h2;
	let t0_value = /*item*/ ctx[9].label + "";
	let t0;
	let t1;
	let br;
	let t2;
	let div;
	let radiorect;
	let current;
	br = new Br({ props: { size: "10" }, $$inline: true });

	const radiorect_spread_levels = [
		/*item*/ ctx[9].meta,
		{ value: /*value*/ ctx[10] },
		{ name: /*item*/ ctx[9].name }
	];

	let radiorect_props = {
		$$slots: {
			default: [
				create_default_slot_2,
				({ item: radio }) => ({ 12: radio }),
				({ item: radio }) => radio ? 4096 : 0
			]
		},
		$$scope: { ctx }
	};

	for (let i = 0; i < radiorect_spread_levels.length; i += 1) {
		radiorect_props = assign(radiorect_props, radiorect_spread_levels[i]);
	}

	radiorect = new RadioRect({ props: radiorect_props, $$inline: true });

	radiorect.$on("change", function () {
		if (is_function(/*onChange*/ ctx[11])) /*onChange*/ ctx[11].apply(this, arguments);
	});

	const block = {
		c: function create() {
			section = element("section");
			h2 = element("h2");
			t0 = text(t0_value);
			t1 = space();
			create_component(br.$$.fragment);
			t2 = space();
			div = element("div");
			create_component(radiorect.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", {});
			var section_nodes = children(section);
			h2 = claim_element(section_nodes, "H2", { class: true });
			var h2_nodes = children(h2);
			t0 = claim_text(h2_nodes, t0_value);
			t1 = claim_space(h2_nodes);
			claim_component(br.$$.fragment, h2_nodes);
			h2_nodes.forEach(detach_dev);
			t2 = claim_space(section_nodes);
			div = claim_element(section_nodes, "DIV", { class: true });
			var div_nodes = children(div);
			claim_component(radiorect.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(h2, "class", "text-left");
			add_location(h2, file$d, 167, 16, 4272);
			attr_dev(div, "class", "flex flex-justify-center");
			add_location(div, file$d, 171, 16, 4404);
			add_location(section, file$d, 166, 12, 4246);
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			append_dev(section, h2);
			append_dev(h2, t0);
			append_dev(h2, t1);
			mount_component(br, h2, null);
			append_dev(section, t2);
			append_dev(section, div);
			mount_component(radiorect, div, null);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if ((!current || dirty & /*item*/ 512) && t0_value !== (t0_value = /*item*/ ctx[9].label + "")) set_data_dev(t0, t0_value);

			const radiorect_changes = (dirty & /*item, value*/ 1536)
			? get_spread_update(radiorect_spread_levels, [
					dirty & /*item*/ 512 && get_spread_object(/*item*/ ctx[9].meta),
					dirty & /*value*/ 1024 && { value: /*value*/ ctx[10] },
					dirty & /*item*/ 512 && { name: /*item*/ ctx[9].name }
				])
			: {};

			if (dirty & /*$$scope, radio*/ 12288) {
				radiorect_changes.$$scope = { dirty, ctx };
			}

			radiorect.$set(radiorect_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(br.$$.fragment, local);
			transition_in(radiorect.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br.$$.fragment, local);
			transition_out(radiorect.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			destroy_component(br);
			destroy_component(radiorect);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$6.name,
		type: "if",
		source: "(166:8) {#if item.type === 'custom-character'}",
		ctx
	});

	return block;
}

// (180:24) <Square                              style="width: calc(40px + (50 - 40) * ((100vw - 320px) / (375 - 320))); max-width: 50px"                             class="flex flex-align-center flex-justify-center"                         >
function create_default_slot_3(ctx) {
	let span;
	let t_value = /*radio*/ ctx[12].label + "";
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t = claim_text(span_nodes, t_value);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "max-full-height h1 flex-1 flex flex-align-center flex-justify-center");
			add_location(span, file$d, 183, 28, 4977);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*radio*/ 4096 && t_value !== (t_value = /*radio*/ ctx[12].label + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3.name,
		type: "slot",
		source: "(180:24) <Square                              style=\\\"width: calc(40px + (50 - 40) * ((100vw - 320px) / (375 - 320))); max-width: 50px\\\"                             class=\\\"flex flex-align-center flex-justify-center\\\"                         >",
		ctx
	});

	return block;
}

// (173:20) <RadioRect                         {...item.meta}                         {value}                         name={item.name}                         let:item={radio}                         on:change={onChange}                     >
function create_default_slot_2(ctx) {
	let square;
	let current;

	square = new Square({
			props: {
				style: "width: calc(40px + (50 - 40) * ((100vw - 320px) / (375 - 320))); max-width: 50px",
				class: "flex flex-align-center flex-justify-center",
				$$slots: { default: [create_default_slot_3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(square.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(square.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(square, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const square_changes = {};

			if (dirty & /*$$scope, radio*/ 12288) {
				square_changes.$$scope = { dirty, ctx };
			}

			square.$set(square_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(square.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(square.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(square, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2.name,
		type: "slot",
		source: "(173:20) <RadioRect                         {...item.meta}                         {value}                         name={item.name}                         let:item={radio}                         on:change={onChange}                     >",
		ctx
	});

	return block;
}

// (155:4) <FormBuilder          id="animal-form"         items={formFields}         data={formValues}         errors={formErrors}         submit={onSubmit}         on:change         let:item={item}         let:value={value}         let:onChange={onChange}     >
function create_default_slot_1$2(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$6, create_if_block_1$5];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*item*/ ctx[9].type === "custom-character") return 0;
		if (/*item*/ ctx[9].type === "custom-lifestory") return 1;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(target, anchor);
			}

			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				} else {
					if_block = null;
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d(detaching);
			}

			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$2.name,
		type: "slot",
		source: "(155:4) <FormBuilder          id=\\\"animal-form\\\"         items={formFields}         data={formValues}         errors={formErrors}         submit={onSubmit}         on:change         let:item={item}         let:value={value}         let:onChange={onChange}     >",
		ctx
	});

	return block;
}

// (154:0) <EditCard form="animal-form" on:cancel={onCancel}>
function create_default_slot$8(ctx) {
	let formbuilder;
	let current;

	formbuilder = new FormBuilder({
			props: {
				id: "animal-form",
				items: /*formFields*/ ctx[2],
				data: /*formValues*/ ctx[0],
				errors: /*formErrors*/ ctx[1],
				submit: /*onSubmit*/ ctx[3],
				$$slots: {
					default: [
						create_default_slot_1$2,
						({ item, value, onChange }) => ({ 9: item, 10: value, 11: onChange }),
						({ item, value, onChange }) => (item ? 512 : 0) | (value ? 1024 : 0) | (onChange ? 2048 : 0)
					]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	formbuilder.$on("change", /*change_handler*/ ctx[7]);

	const block = {
		c: function create() {
			create_component(formbuilder.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(formbuilder.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(formbuilder, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const formbuilder_changes = {};
			if (dirty & /*formValues*/ 1) formbuilder_changes.data = /*formValues*/ ctx[0];
			if (dirty & /*formErrors*/ 2) formbuilder_changes.errors = /*formErrors*/ ctx[1];

			if (dirty & /*$$scope, item, value, onChange*/ 11776) {
				formbuilder_changes.$$scope = { dirty, ctx };
			}

			formbuilder.$set(formbuilder_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(formbuilder.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(formbuilder.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(formbuilder, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$8.name,
		type: "slot",
		source: "(154:0) <EditCard form=\\\"animal-form\\\" on:cancel={onCancel}>",
		ctx
	});

	return block;
}

function create_fragment$n(ctx) {
	let editcard;
	let current;

	editcard = new EditCard({
			props: {
				form: "animal-form",
				$$slots: { default: [create_default_slot$8] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	editcard.$on("cancel", /*onCancel*/ ctx[4]);

	const block = {
		c: function create() {
			create_component(editcard.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(editcard.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(editcard, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const editcard_changes = {};

			if (dirty & /*$$scope, formValues, formErrors*/ 8195) {
				editcard_changes.$$scope = { dirty, ctx };
			}

			editcard.$set(editcard_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(editcard.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(editcard.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(editcard, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$n.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$n($$self, $$props, $$invalidate) {
	let { data = undefined } = $$props;

	let { submit = async () => {
		
	} } = $$props;

	const dispatch = createEventDispatcher();

	let formFields = [
		{
			type: "avatar",
			name: "avatar",
			meta: { accept: "image/jpeg,image/png" }
		},
		{
			label: "Кличка:",
			type: "text",
			name: "name",
			meta: { placeholder: "Локі...", maxlength: 20 }
		},
		{
			label: "Порода:",
			type: "text",
			name: "breed",
			meta: {
				placeholder: "Лабрадор...",
				maxlength: 20
			}
		},
		{
			label: "День народження:",
			type: "date",
			name: "birth",
			meta: { placeholder: "18.03.2019..." }
		},
		{
			label: "Стать:",
			type: "radio-rect",
			name: "sex",
			meta: {
				options: [
					{
						label: "Він",
						value: "male",
						preIcon: "check-flag"
					},
					{
						label: "Вона",
						value: "female",
						preIcon: "check-flag"
					}
				]
			}
		},
		{
			label: "Стерилізація?",
			type: "radio-rect",
			name: "sterilization",
			meta: {
				options: [
					{
						label: "Так",
						value: true,
						preIcon: "check-flag"
					},
					{
						label: "Ні",
						value: false,
						preIcon: "close"
					}
				]
			}
		},
		{
			label: "Характер:",
			type: "custom-character",
			name: "character_short",
			meta: {
				options: [
					{ label: "😃", value: "😃" },
					{ label: "😇", value: "😇" },
					{ label: "😜", value: "😜" },
					{ label: "😎", value: "😎" },
					{ label: "😝", value: "😝" }
				]
			}
		},
		{
			label: "Опис характеру:",
			type: "textarea",
			name: "character",
			meta: {
				rows: 6,
				maxlength: 75,
				placeholder: "Грайливий та веселий песик..."
			}
		},
		{
			label: "Історія життя:",
			type: "custom-lifestory",
			name: "lifestory",
			meta: { max: 100, maxlength: 75 }
		},
		{
			label: "Вакцинація:",
			type: "checkbox",
			name: "vaccination",
			meta: { options: vaccinations }
		}
	];

	async function onSubmit(e) {
		await submit(e);
	}

	function onCancel() {
		$$invalidate(0, formValues = data);
		dispatch("cancel");
	}

	const writable_props = ["data", "submit"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AnimalCard> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("AnimalCard", $$slots, []);

	function change_handler(event) {
		bubble($$self, event);
	}

	$$self.$set = $$props => {
		if ("data" in $$props) $$invalidate(5, data = $$props.data);
		if ("submit" in $$props) $$invalidate(6, submit = $$props.submit);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		options,
		Br,
		Square,
		RadioRect,
		StoryList,
		EditCard,
		FormBuilder,
		data,
		submit,
		dispatch,
		formFields,
		onSubmit,
		onCancel,
		formValues,
		formErrors
	});

	$$self.$inject_state = $$props => {
		if ("data" in $$props) $$invalidate(5, data = $$props.data);
		if ("submit" in $$props) $$invalidate(6, submit = $$props.submit);
		if ("formFields" in $$props) $$invalidate(2, formFields = $$props.formFields);
		if ("formValues" in $$props) $$invalidate(0, formValues = $$props.formValues);
		if ("formErrors" in $$props) $$invalidate(1, formErrors = $$props.formErrors);
	};

	let formValues;
	let formErrors;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*data*/ 32) {
			 $$invalidate(0, formValues = data || {});
		}
	};

	 $$invalidate(1, formErrors = {});

	return [
		formValues,
		formErrors,
		formFields,
		onSubmit,
		onCancel,
		data,
		submit,
		change_handler
	];
}

class AnimalCard$1 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$n, create_fragment$n, safe_not_equal, { data: 5, submit: 6 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "AnimalCard",
			options,
			id: create_fragment$n.name
		});
	}

	get data() {
		throw new Error("<AnimalCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set data(value) {
		throw new Error("<AnimalCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get submit() {
		throw new Error("<AnimalCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set submit(value) {
		throw new Error("<AnimalCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/funds/edit/_Description.svelte generated by Svelte v3.24.0 */

// (46:0) <EditCard form="description-form" on:cancel={onCancel}>
function create_default_slot$9(ctx) {
	let formbuilder;
	let current;

	formbuilder = new FormBuilder({
			props: {
				id: "description-form",
				items: /*formFields*/ ctx[2],
				data: /*formValues*/ ctx[0],
				errors: /*formErrors*/ ctx[1],
				submit: /*onSubmit*/ ctx[3]
			},
			$$inline: true
		});

	formbuilder.$on("change", /*change_handler*/ ctx[7]);

	const block = {
		c: function create() {
			create_component(formbuilder.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(formbuilder.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(formbuilder, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const formbuilder_changes = {};
			if (dirty & /*formValues*/ 1) formbuilder_changes.data = /*formValues*/ ctx[0];
			if (dirty & /*formErrors*/ 2) formbuilder_changes.errors = /*formErrors*/ ctx[1];
			formbuilder.$set(formbuilder_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(formbuilder.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(formbuilder.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(formbuilder, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$9.name,
		type: "slot",
		source: "(46:0) <EditCard form=\\\"description-form\\\" on:cancel={onCancel}>",
		ctx
	});

	return block;
}

function create_fragment$o(ctx) {
	let editcard;
	let current;

	editcard = new EditCard({
			props: {
				form: "description-form",
				$$slots: { default: [create_default_slot$9] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	editcard.$on("cancel", /*onCancel*/ ctx[4]);

	const block = {
		c: function create() {
			create_component(editcard.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(editcard.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(editcard, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const editcard_changes = {};

			if (dirty & /*$$scope, formValues, formErrors*/ 515) {
				editcard_changes.$$scope = { dirty, ctx };
			}

			editcard.$set(editcard_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(editcard.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(editcard.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(editcard, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$o.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$o($$self, $$props, $$invalidate) {
	let { data = undefined } = $$props;

	let { submit = async () => {
		
	} } = $$props;

	const dispatch = createEventDispatcher();

	let formFields = [
		{
			label: "Ціль фонду:",
			type: "text",
			name: "title",
			meta: {
				disabled: true,
				placeholder: "Тільки спільними силами...",
				maxlength: 25
			}
		},
		{
			label: "Опис фонду:",
			type: "textarea",
			name: "description",
			meta: {
				rows: 6,
				placeholder: "У нас добра мета...",
				max: 250
			}
		}
	];

	async function onSubmit(e) {
		await submit(e);
	}

	function onCancel() {
		$$invalidate(0, formValues = data);
		dispatch("cancel");
	}

	const writable_props = ["data", "submit"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Description> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Description", $$slots, []);

	function change_handler(event) {
		bubble($$self, event);
	}

	$$self.$set = $$props => {
		if ("data" in $$props) $$invalidate(5, data = $$props.data);
		if ("submit" in $$props) $$invalidate(6, submit = $$props.submit);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		EditCard,
		FormBuilder,
		data,
		submit,
		dispatch,
		formFields,
		onSubmit,
		onCancel,
		formValues,
		formErrors
	});

	$$self.$inject_state = $$props => {
		if ("data" in $$props) $$invalidate(5, data = $$props.data);
		if ("submit" in $$props) $$invalidate(6, submit = $$props.submit);
		if ("formFields" in $$props) $$invalidate(2, formFields = $$props.formFields);
		if ("formValues" in $$props) $$invalidate(0, formValues = $$props.formValues);
		if ("formErrors" in $$props) $$invalidate(1, formErrors = $$props.formErrors);
	};

	let formValues;
	let formErrors;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*data*/ 32) {
			 $$invalidate(0, formValues = data || {});
		}
	};

	 $$invalidate(1, formErrors = {});

	return [
		formValues,
		formErrors,
		formFields,
		onSubmit,
		onCancel,
		data,
		submit,
		change_handler
	];
}

class Description$1 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$o, create_fragment$o, safe_not_equal, { data: 5, submit: 6 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Description",
			options,
			id: create_fragment$o.name
		});
	}

	get data() {
		throw new Error("<Description>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set data(value) {
		throw new Error("<Description>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get submit() {
		throw new Error("<Description>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set submit(value) {
		throw new Error("<Description>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/funds/[id].svelte generated by Svelte v3.24.0 */

const { console: console_1 } = globals;

const file$e = "src/routes/funds/[id].svelte";

// (171:16) {#if !isEditMode}
function create_if_block$7(ctx) {
	let icon;
	let current;

	icon = new Icon({
			props: { type: "edit", size: "small", is: "light" },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(icon.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$7.name,
		type: "if",
		source: "(171:16) {#if !isEditMode}",
		ctx
	});

	return block;
}

// (166:8) <Button size="small" is="info" on:click={onToggleMode}>
function create_default_slot_22(ctx) {
	let span;
	let t0_value = (/*isEditMode*/ ctx[0] ? "Зберегти" : "Редагувати") + "";
	let t0;
	let t1;
	let s0;
	let t2;
	let s1;
	let t3;
	let current;
	let if_block = !/*isEditMode*/ ctx[0] && create_if_block$7(ctx);

	const block = {
		c: function create() {
			span = element("span");
			t0 = text(t0_value);
			t1 = space();
			s0 = element("s");
			t2 = space();
			s1 = element("s");
			t3 = space();
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t0 = claim_text(span_nodes, t0_value);
			t1 = claim_space(span_nodes);
			s0 = claim_element(span_nodes, "S", {});
			children(s0).forEach(detach_dev);
			t2 = claim_space(span_nodes);
			s1 = claim_element(span_nodes, "S", {});
			children(s1).forEach(detach_dev);
			t3 = claim_space(span_nodes);
			if (if_block) if_block.l(span_nodes);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(s0, file$e, 168, 16, 4704);
			add_location(s1, file$e, 169, 16, 4728);
			attr_dev(span, "class", "h3 font-secondary font-w-500 flex flex-align-center");
			add_location(span, file$e, 166, 12, 4564);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t0);
			append_dev(span, t1);
			append_dev(span, s0);
			append_dev(span, t2);
			append_dev(span, s1);
			append_dev(span, t3);
			if (if_block) if_block.m(span, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty & /*isEditMode*/ 1) && t0_value !== (t0_value = (/*isEditMode*/ ctx[0] ? "Зберегти" : "Редагувати") + "")) set_data_dev(t0, t0_value);

			if (!/*isEditMode*/ ctx[0]) {
				if (if_block) {
					if (dirty & /*isEditMode*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$7(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(span, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			if (if_block) if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_22.name,
		type: "slot",
		source: "(166:8) <Button size=\\\"small\\\" is=\\\"info\\\" on:click={onToggleMode}>",
		ctx
	});

	return block;
}

// (180:4) <LazyToggle active={isEdit.topInfo}>
function create_default_slot_21(ctx) {
	let br;
	let t;
	let topinfoedit;
	let current;
	br = new Br({ props: { size: "30" }, $$inline: true });

	topinfoedit = new TopInfo$1({
			props: {
				data: {
					.../*cardTop*/ ctx[4],
					organization: /*organization*/ ctx[3],
					photos: /*carouselTop*/ ctx[2]
				},
				submit: /*onSubmit*/ ctx[15].bind(null, "topInfo")
			},
			$$inline: true
		});

	topinfoedit.$on("cancel", /*onCancel*/ ctx[16].bind(null, "topInfo"));

	const block = {
		c: function create() {
			create_component(br.$$.fragment);
			t = space();
			create_component(topinfoedit.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(br.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(topinfoedit.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(br, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(topinfoedit, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const topinfoedit_changes = {};

			if (dirty & /*cardTop, organization, carouselTop*/ 28) topinfoedit_changes.data = {
				.../*cardTop*/ ctx[4],
				organization: /*organization*/ ctx[3],
				photos: /*carouselTop*/ ctx[2]
			};

			topinfoedit.$set(topinfoedit_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(br.$$.fragment, local);
			transition_in(topinfoedit.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br.$$.fragment, local);
			transition_out(topinfoedit.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(br, detaching);
			if (detaching) detach_dev(t);
			destroy_component(topinfoedit, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_21.name,
		type: "slot",
		source: "(180:4) <LazyToggle active={isEdit.topInfo}>",
		ctx
	});

	return block;
}

// (189:8) <EditArea on:click={() => isEdit.topInfo = !isEdit.topInfo} off={!isEditMode}>
function create_default_slot_20(ctx) {
	let br;
	let t;
	let topinfoview;
	let current;
	br = new Br({ props: { size: "30" }, $$inline: true });

	topinfoview = new TopInfo({
			props: {
				cardTop: /*cardTop*/ ctx[4],
				carouselTop: /*carouselTop*/ ctx[2],
				organization: /*organization*/ ctx[3]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(br.$$.fragment);
			t = space();
			create_component(topinfoview.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(br.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(topinfoview.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(br, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(topinfoview, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const topinfoview_changes = {};
			if (dirty & /*cardTop*/ 16) topinfoview_changes.cardTop = /*cardTop*/ ctx[4];
			if (dirty & /*carouselTop*/ 4) topinfoview_changes.carouselTop = /*carouselTop*/ ctx[2];
			if (dirty & /*organization*/ 8) topinfoview_changes.organization = /*organization*/ ctx[3];
			topinfoview.$set(topinfoview_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(br.$$.fragment, local);
			transition_in(topinfoview.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br.$$.fragment, local);
			transition_out(topinfoview.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(br, detaching);
			if (detaching) detach_dev(t);
			destroy_component(topinfoview, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_20.name,
		type: "slot",
		source: "(189:8) <EditArea on:click={() => isEdit.topInfo = !isEdit.topInfo} off={!isEditMode}>",
		ctx
	});

	return block;
}

// (188:4) <LazyToggle active={!isEdit.topInfo} mounted class="full-container">
function create_default_slot_19(ctx) {
	let editarea;
	let current;

	editarea = new EditArea({
			props: {
				off: !/*isEditMode*/ ctx[0],
				$$slots: { default: [create_default_slot_20] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	editarea.$on("click", /*click_handler*/ ctx[18]);

	const block = {
		c: function create() {
			create_component(editarea.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(editarea.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(editarea, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const editarea_changes = {};
			if (dirty & /*isEditMode*/ 1) editarea_changes.off = !/*isEditMode*/ ctx[0];

			if (dirty & /*$$scope, cardTop, carouselTop, organization*/ 268435484) {
				editarea_changes.$$scope = { dirty, ctx };
			}

			editarea.$set(editarea_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(editarea.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(editarea.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(editarea, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_19.name,
		type: "slot",
		source: "(188:4) <LazyToggle active={!isEdit.topInfo} mounted class=\\\"full-container\\\">",
		ctx
	});

	return block;
}

// (197:4) <LazyToggle active={!isEditMode} mounted>
function create_default_slot_18(ctx) {
	let interactionindicators;
	let current;

	interactionindicators = new InteractionIndicators({
			props: {
				likes: /*iconsLine*/ ctx[5].likes,
				views: /*iconsLine*/ ctx[5].views
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(interactionindicators.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(interactionindicators.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(interactionindicators, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const interactionindicators_changes = {};
			if (dirty & /*iconsLine*/ 32) interactionindicators_changes.likes = /*iconsLine*/ ctx[5].likes;
			if (dirty & /*iconsLine*/ 32) interactionindicators_changes.views = /*iconsLine*/ ctx[5].views;
			interactionindicators.$set(interactionindicators_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(interactionindicators.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(interactionindicators.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(interactionindicators, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_18.name,
		type: "slot",
		source: "(197:4) <LazyToggle active={!isEditMode} mounted>",
		ctx
	});

	return block;
}

// (203:4) <LazyToggle active={isEdit.description}>
function create_default_slot_17(ctx) {
	let descriptionedit;
	let current;

	descriptionedit = new Description$1({
			props: {
				data: /*descriptionBlock*/ ctx[7],
				submit: /*onSubmit*/ ctx[15].bind(null, "description")
			},
			$$inline: true
		});

	descriptionedit.$on("cancel", /*onCancel*/ ctx[16].bind(null, "description"));

	const block = {
		c: function create() {
			create_component(descriptionedit.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(descriptionedit.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(descriptionedit, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const descriptionedit_changes = {};
			if (dirty & /*descriptionBlock*/ 128) descriptionedit_changes.data = /*descriptionBlock*/ ctx[7];
			descriptionedit.$set(descriptionedit_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(descriptionedit.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(descriptionedit.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(descriptionedit, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_17.name,
		type: "slot",
		source: "(203:4) <LazyToggle active={isEdit.description}>",
		ctx
	});

	return block;
}

// (211:8) <EditArea on:click={() => isEdit.description = !isEdit.description} off={!isEditMode}>
function create_default_slot_16(ctx) {
	let br;
	let t;
	let descriptionview;
	let current;
	br = new Br({ props: { size: "30" }, $$inline: true });

	descriptionview = new Description_1({
			props: {
				title: /*descriptionBlock*/ ctx[7].title,
				text: /*descriptionBlock*/ ctx[7].description
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(br.$$.fragment);
			t = space();
			create_component(descriptionview.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(br.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(descriptionview.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(br, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(descriptionview, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const descriptionview_changes = {};
			if (dirty & /*descriptionBlock*/ 128) descriptionview_changes.title = /*descriptionBlock*/ ctx[7].title;
			if (dirty & /*descriptionBlock*/ 128) descriptionview_changes.text = /*descriptionBlock*/ ctx[7].description;
			descriptionview.$set(descriptionview_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(br.$$.fragment, local);
			transition_in(descriptionview.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br.$$.fragment, local);
			transition_out(descriptionview.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(br, detaching);
			if (detaching) detach_dev(t);
			destroy_component(descriptionview, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_16.name,
		type: "slot",
		source: "(211:8) <EditArea on:click={() => isEdit.description = !isEdit.description} off={!isEditMode}>",
		ctx
	});

	return block;
}

// (210:4) <LazyToggle active={!isEdit.description} mounted class="full-container">
function create_default_slot_15(ctx) {
	let editarea;
	let current;

	editarea = new EditArea({
			props: {
				off: !/*isEditMode*/ ctx[0],
				$$slots: { default: [create_default_slot_16] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	editarea.$on("click", /*click_handler_1*/ ctx[19]);

	const block = {
		c: function create() {
			create_component(editarea.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(editarea.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(editarea, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const editarea_changes = {};
			if (dirty & /*isEditMode*/ 1) editarea_changes.off = !/*isEditMode*/ ctx[0];

			if (dirty & /*$$scope, descriptionBlock*/ 268435584) {
				editarea_changes.$$scope = { dirty, ctx };
			}

			editarea.$set(editarea_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(editarea.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(editarea.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(editarea, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_15.name,
		type: "slot",
		source: "(210:4) <LazyToggle active={!isEdit.description} mounted class=\\\"full-container\\\">",
		ctx
	});

	return block;
}

// (219:4) <LazyToggle active={!isEditMode} mounted>
function create_default_slot_14(ctx) {
	let share;
	let t0;
	let br;
	let t1;
	let trust_1;
	let current;
	share = new Share({ $$inline: true });
	br = new Br({ props: { size: "45" }, $$inline: true });

	trust_1 = new Trust({
			props: { active: /*trust*/ ctx[6].isLiked },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(share.$$.fragment);
			t0 = space();
			create_component(br.$$.fragment);
			t1 = space();
			create_component(trust_1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(share.$$.fragment, nodes);
			t0 = claim_space(nodes);
			claim_component(br.$$.fragment, nodes);
			t1 = claim_space(nodes);
			claim_component(trust_1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(share, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(br, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(trust_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const trust_1_changes = {};
			if (dirty & /*trust*/ 64) trust_1_changes.active = /*trust*/ ctx[6].isLiked;
			trust_1.$set(trust_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(share.$$.fragment, local);
			transition_in(br.$$.fragment, local);
			transition_in(trust_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(share.$$.fragment, local);
			transition_out(br.$$.fragment, local);
			transition_out(trust_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(share, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(br, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(trust_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_14.name,
		type: "slot",
		source: "(219:4) <LazyToggle active={!isEditMode} mounted>",
		ctx
	});

	return block;
}

// (227:4) <LazyToggle active={isEdit.animalCard}>
function create_default_slot_13(ctx) {
	let animalcardedit;
	let current;

	animalcardedit = new AnimalCard$1({
			props: {
				data: /*animal*/ ctx[8],
				submit: /*onSubmit*/ ctx[15].bind(null, "animalCard")
			},
			$$inline: true
		});

	animalcardedit.$on("cancel", /*onCancel*/ ctx[16].bind(null, "animalCard"));

	const block = {
		c: function create() {
			create_component(animalcardedit.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(animalcardedit.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(animalcardedit, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const animalcardedit_changes = {};
			if (dirty & /*animal*/ 256) animalcardedit_changes.data = /*animal*/ ctx[8];
			animalcardedit.$set(animalcardedit_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(animalcardedit.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(animalcardedit.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(animalcardedit, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_13.name,
		type: "slot",
		source: "(227:4) <LazyToggle active={isEdit.animalCard}>",
		ctx
	});

	return block;
}

// (235:8) <EditArea on:click={() => isEdit.animalCard = !isEdit.animalCard} off={!isEditMode}>
function create_default_slot_12(ctx) {
	let br;
	let t;
	let animalcardview;
	let current;
	br = new Br({ props: { size: "30" }, $$inline: true });

	animalcardview = new AnimalCard_1({
			props: { animal: /*animal*/ ctx[8] },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(br.$$.fragment);
			t = space();
			create_component(animalcardview.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(br.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(animalcardview.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(br, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(animalcardview, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const animalcardview_changes = {};
			if (dirty & /*animal*/ 256) animalcardview_changes.animal = /*animal*/ ctx[8];
			animalcardview.$set(animalcardview_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(br.$$.fragment, local);
			transition_in(animalcardview.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br.$$.fragment, local);
			transition_out(animalcardview.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(br, detaching);
			if (detaching) detach_dev(t);
			destroy_component(animalcardview, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_12.name,
		type: "slot",
		source: "(235:8) <EditArea on:click={() => isEdit.animalCard = !isEdit.animalCard} off={!isEditMode}>",
		ctx
	});

	return block;
}

// (234:4) <LazyToggle active={!isEdit.animalCard} mounted class="full-container">
function create_default_slot_11(ctx) {
	let editarea;
	let current;

	editarea = new EditArea({
			props: {
				off: !/*isEditMode*/ ctx[0],
				$$slots: { default: [create_default_slot_12] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	editarea.$on("click", /*click_handler_2*/ ctx[20]);

	const block = {
		c: function create() {
			create_component(editarea.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(editarea.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(editarea, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const editarea_changes = {};
			if (dirty & /*isEditMode*/ 1) editarea_changes.off = !/*isEditMode*/ ctx[0];

			if (dirty & /*$$scope, animal*/ 268435712) {
				editarea_changes.$$scope = { dirty, ctx };
			}

			editarea.$set(editarea_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(editarea.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(editarea.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(editarea, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_11.name,
		type: "slot",
		source: "(234:4) <LazyToggle active={!isEdit.animalCard} mounted class=\\\"full-container\\\">",
		ctx
	});

	return block;
}

// (243:4) <LazyToggle active={!isEditMode} mounted>
function create_default_slot_10(ctx) {
	let donators_1;
	let t;
	let br;
	let current;

	donators_1 = new Donators({
			props: { items: /*donators*/ ctx[9] },
			$$inline: true
		});

	br = new Br({ props: { size: "60" }, $$inline: true });

	const block = {
		c: function create() {
			create_component(donators_1.$$.fragment);
			t = space();
			create_component(br.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(donators_1.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(br.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(donators_1, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(br, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const donators_1_changes = {};
			if (dirty & /*donators*/ 512) donators_1_changes.items = /*donators*/ ctx[9];
			donators_1.$set(donators_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(donators_1.$$.fragment, local);
			transition_in(br.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(donators_1.$$.fragment, local);
			transition_out(br.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(donators_1, detaching);
			if (detaching) detach_dev(t);
			destroy_component(br, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_10.name,
		type: "slot",
		source: "(243:4) <LazyToggle active={!isEditMode} mounted>",
		ctx
	});

	return block;
}

// (249:4) <LazyToggle active={isEdit.documents}>
function create_default_slot_9(ctx) {
	let documentsedit;
	let current;

	documentsedit = new Documents({
			props: {
				data: { documents: /*documents*/ ctx[10] },
				submit: /*onSubmit*/ ctx[15].bind(null, "documents")
			},
			$$inline: true
		});

	documentsedit.$on("cancel", /*onCancel*/ ctx[16].bind(null, "documents"));

	const block = {
		c: function create() {
			create_component(documentsedit.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(documentsedit.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(documentsedit, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const documentsedit_changes = {};
			if (dirty & /*documents*/ 1024) documentsedit_changes.data = { documents: /*documents*/ ctx[10] };
			documentsedit.$set(documentsedit_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(documentsedit.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(documentsedit.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(documentsedit, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_9.name,
		type: "slot",
		source: "(249:4) <LazyToggle active={isEdit.documents}>",
		ctx
	});

	return block;
}

// (257:8) <EditArea on:click={() => isEdit.documents = !isEdit.documents} off={!isEditMode}>
function create_default_slot_8(ctx) {
	let br;
	let t;
	let documentsview;
	let current;
	br = new Br({ props: { size: "30" }, $$inline: true });

	documentsview = new Documents_1$1({
			props: { items: /*documents*/ ctx[10] },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(br.$$.fragment);
			t = space();
			create_component(documentsview.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(br.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(documentsview.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(br, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(documentsview, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const documentsview_changes = {};
			if (dirty & /*documents*/ 1024) documentsview_changes.items = /*documents*/ ctx[10];
			documentsview.$set(documentsview_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(br.$$.fragment, local);
			transition_in(documentsview.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br.$$.fragment, local);
			transition_out(documentsview.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(br, detaching);
			if (detaching) detach_dev(t);
			destroy_component(documentsview, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_8.name,
		type: "slot",
		source: "(257:8) <EditArea on:click={() => isEdit.documents = !isEdit.documents} off={!isEditMode}>",
		ctx
	});

	return block;
}

// (256:4) <LazyToggle active={!isEdit.documents} mounted class="full-container">
function create_default_slot_7(ctx) {
	let editarea;
	let current;

	editarea = new EditArea({
			props: {
				off: !/*isEditMode*/ ctx[0],
				$$slots: { default: [create_default_slot_8] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	editarea.$on("click", /*click_handler_3*/ ctx[21]);

	const block = {
		c: function create() {
			create_component(editarea.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(editarea.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(editarea, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const editarea_changes = {};
			if (dirty & /*isEditMode*/ 1) editarea_changes.off = !/*isEditMode*/ ctx[0];

			if (dirty & /*$$scope, documents*/ 268436480) {
				editarea_changes.$$scope = { dirty, ctx };
			}

			editarea.$set(editarea_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(editarea.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(editarea.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(editarea, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_7.name,
		type: "slot",
		source: "(256:4) <LazyToggle active={!isEdit.documents} mounted class=\\\"full-container\\\">",
		ctx
	});

	return block;
}

// (267:4) <LazyToggle active={isEdit.videos}>
function create_default_slot_6(ctx) {
	let videosedit;
	let current;

	videosedit = new Videos$1({
			props: {
				data: { videos: /*media*/ ctx[11] },
				submit: /*onSubmit*/ ctx[15].bind(null, "videos")
			},
			$$inline: true
		});

	videosedit.$on("cancel", /*onCancel*/ ctx[16].bind(null, "videos"));

	const block = {
		c: function create() {
			create_component(videosedit.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(videosedit.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(videosedit, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const videosedit_changes = {};
			if (dirty & /*media*/ 2048) videosedit_changes.data = { videos: /*media*/ ctx[11] };
			videosedit.$set(videosedit_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(videosedit.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(videosedit.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(videosedit, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_6.name,
		type: "slot",
		source: "(267:4) <LazyToggle active={isEdit.videos}>",
		ctx
	});

	return block;
}

// (275:8) <EditArea on:click={() => isEdit.videos = !isEdit.videos} off={!isEditMode}>
function create_default_slot_5(ctx) {
	let br;
	let t;
	let videosview;
	let current;
	br = new Br({ props: { size: "30" }, $$inline: true });

	videosview = new Videos({
			props: { items: /*media*/ ctx[11] },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(br.$$.fragment);
			t = space();
			create_component(videosview.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(br.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(videosview.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(br, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(videosview, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const videosview_changes = {};
			if (dirty & /*media*/ 2048) videosview_changes.items = /*media*/ ctx[11];
			videosview.$set(videosview_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(br.$$.fragment, local);
			transition_in(videosview.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br.$$.fragment, local);
			transition_out(videosview.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(br, detaching);
			if (detaching) detach_dev(t);
			destroy_component(videosview, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_5.name,
		type: "slot",
		source: "(275:8) <EditArea on:click={() => isEdit.videos = !isEdit.videos} off={!isEditMode}>",
		ctx
	});

	return block;
}

// (274:4) <LazyToggle active={!isEdit.videos} mounted class="full-container">
function create_default_slot_4(ctx) {
	let editarea;
	let current;

	editarea = new EditArea({
			props: {
				off: !/*isEditMode*/ ctx[0],
				$$slots: { default: [create_default_slot_5] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	editarea.$on("click", /*click_handler_4*/ ctx[22]);

	const block = {
		c: function create() {
			create_component(editarea.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(editarea.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(editarea, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const editarea_changes = {};
			if (dirty & /*isEditMode*/ 1) editarea_changes.off = !/*isEditMode*/ ctx[0];

			if (dirty & /*$$scope, media*/ 268437504) {
				editarea_changes.$$scope = { dirty, ctx };
			}

			editarea.$set(editarea_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(editarea.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(editarea.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(editarea, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4.name,
		type: "slot",
		source: "(274:4) <LazyToggle active={!isEdit.videos} mounted class=\\\"full-container\\\">",
		ctx
	});

	return block;
}

// (285:4) <LazyToggle active={isEdit.howToHelp}>
function create_default_slot_3$1(ctx) {
	let howtohelpedit;
	let current;

	howtohelpedit = new HowToHelp$1({
			props: {
				data: /*howToHelp*/ ctx[12],
				submit: /*onSubmit*/ ctx[15].bind(null, "howToHelp")
			},
			$$inline: true
		});

	howtohelpedit.$on("cancel", /*onCancel*/ ctx[16].bind(null, "howToHelp"));

	const block = {
		c: function create() {
			create_component(howtohelpedit.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(howtohelpedit.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(howtohelpedit, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const howtohelpedit_changes = {};
			if (dirty & /*howToHelp*/ 4096) howtohelpedit_changes.data = /*howToHelp*/ ctx[12];
			howtohelpedit.$set(howtohelpedit_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(howtohelpedit.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(howtohelpedit.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(howtohelpedit, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3$1.name,
		type: "slot",
		source: "(285:4) <LazyToggle active={isEdit.howToHelp}>",
		ctx
	});

	return block;
}

// (293:8) <EditArea on:click={() => isEdit.howToHelp = !isEdit.howToHelp} off={!isEditMode}>
function create_default_slot_2$1(ctx) {
	let br;
	let t;
	let howtohelpview;
	let current;
	br = new Br({ props: { size: "30" }, $$inline: true });

	howtohelpview = new HowToHelp_1({
			props: { data: /*howToHelp*/ ctx[12] },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(br.$$.fragment);
			t = space();
			create_component(howtohelpview.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(br.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(howtohelpview.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(br, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(howtohelpview, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const howtohelpview_changes = {};
			if (dirty & /*howToHelp*/ 4096) howtohelpview_changes.data = /*howToHelp*/ ctx[12];
			howtohelpview.$set(howtohelpview_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(br.$$.fragment, local);
			transition_in(howtohelpview.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(br.$$.fragment, local);
			transition_out(howtohelpview.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(br, detaching);
			if (detaching) detach_dev(t);
			destroy_component(howtohelpview, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$1.name,
		type: "slot",
		source: "(293:8) <EditArea on:click={() => isEdit.howToHelp = !isEdit.howToHelp} off={!isEditMode}>",
		ctx
	});

	return block;
}

// (292:4) <LazyToggle active={!isEdit.howToHelp} mounted class="full-container">
function create_default_slot_1$3(ctx) {
	let editarea;
	let current;

	editarea = new EditArea({
			props: {
				off: !/*isEditMode*/ ctx[0],
				$$slots: { default: [create_default_slot_2$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	editarea.$on("click", /*click_handler_5*/ ctx[23]);

	const block = {
		c: function create() {
			create_component(editarea.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(editarea.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(editarea, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const editarea_changes = {};
			if (dirty & /*isEditMode*/ 1) editarea_changes.off = !/*isEditMode*/ ctx[0];

			if (dirty & /*$$scope, howToHelp*/ 268439552) {
				editarea_changes.$$scope = { dirty, ctx };
			}

			editarea.$set(editarea_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(editarea.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(editarea.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(editarea, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$3.name,
		type: "slot",
		source: "(292:4) <LazyToggle active={!isEdit.howToHelp} mounted class=\\\"full-container\\\">",
		ctx
	});

	return block;
}

// (301:4) <LazyToggle active={!isEditMode} mounted>
function create_default_slot$a(ctx) {
	let comments_1;
	let t;
	let br;
	let current;

	comments_1 = new Comments_1({
			props: { items: /*commentsData*/ ctx[13].comments },
			$$inline: true
		});

	br = new Br({ props: { size: "60" }, $$inline: true });

	const block = {
		c: function create() {
			create_component(comments_1.$$.fragment);
			t = space();
			create_component(br.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(comments_1.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(br.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(comments_1, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(br, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const comments_1_changes = {};
			if (dirty & /*commentsData*/ 8192) comments_1_changes.items = /*commentsData*/ ctx[13].comments;
			comments_1.$set(comments_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(comments_1.$$.fragment, local);
			transition_in(br.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(comments_1.$$.fragment, local);
			transition_out(br.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(comments_1, detaching);
			if (detaching) detach_dev(t);
			destroy_component(br, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$a.name,
		type: "slot",
		source: "(301:4) <LazyToggle active={!isEditMode} mounted>",
		ctx
	});

	return block;
}

function create_fragment$p(ctx) {
	let t0;
	let donationbutton;
	let t1;
	let section;
	let br0;
	let t2;
	let div0;
	let br1;
	let t3;
	let button;
	let t4;
	let br2;
	let t5;
	let lazytoggle0;
	let t6;
	let lazytoggle1;
	let t7;
	let br3;
	let t8;
	let lazytoggle2;
	let t9;
	let br4;
	let t10;
	let lazytoggle3;
	let t11;
	let lazytoggle4;
	let t12;
	let br5;
	let t13;
	let lazytoggle5;
	let t14;
	let br6;
	let t15;
	let lazytoggle6;
	let t16;
	let lazytoggle7;
	let t17;
	let br7;
	let t18;
	let lazytoggle8;
	let t19;
	let lazytoggle9;
	let t20;
	let lazytoggle10;
	let t21;
	let br8;
	let t22;
	let lazytoggle11;
	let t23;
	let lazytoggle12;
	let t24;
	let br9;
	let t25;
	let lazytoggle13;
	let t26;
	let lazytoggle14;
	let t27;
	let br10;
	let t28;
	let lazytoggle15;
	let t29;
	let div1;
	let footer;
	let t30;
	let br11;
	let current;
	donationbutton = new DonationButton({ $$inline: true });

	br0 = new Br({
			props: { size: "var(--header-height)" },
			$$inline: true
		});

	br1 = new Br({ props: { size: "30" }, $$inline: true });

	button = new Button({
			props: {
				size: "small",
				is: "info",
				$$slots: { default: [create_default_slot_22] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button.$on("click", /*onToggleMode*/ ctx[17]);
	br2 = new Br({ props: { size: "30" }, $$inline: true });

	lazytoggle0 = new LazyToggle({
			props: {
				active: /*isEdit*/ ctx[1].topInfo,
				$$slots: { default: [create_default_slot_21] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	lazytoggle1 = new LazyToggle({
			props: {
				active: !/*isEdit*/ ctx[1].topInfo,
				mounted: true,
				class: "full-container",
				$$slots: { default: [create_default_slot_19] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	br3 = new Br({ props: { size: "20" }, $$inline: true });

	lazytoggle2 = new LazyToggle({
			props: {
				active: !/*isEditMode*/ ctx[0],
				mounted: true,
				$$slots: { default: [create_default_slot_18] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	br4 = new Br({ props: { size: "50" }, $$inline: true });

	lazytoggle3 = new LazyToggle({
			props: {
				active: /*isEdit*/ ctx[1].description,
				$$slots: { default: [create_default_slot_17] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	lazytoggle4 = new LazyToggle({
			props: {
				active: !/*isEdit*/ ctx[1].description,
				mounted: true,
				class: "full-container",
				$$slots: { default: [create_default_slot_15] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	br5 = new Br({ props: { size: "10" }, $$inline: true });

	lazytoggle5 = new LazyToggle({
			props: {
				active: !/*isEditMode*/ ctx[0],
				mounted: true,
				$$slots: { default: [create_default_slot_14] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	br6 = new Br({ props: { size: "60" }, $$inline: true });

	lazytoggle6 = new LazyToggle({
			props: {
				active: /*isEdit*/ ctx[1].animalCard,
				$$slots: { default: [create_default_slot_13] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	lazytoggle7 = new LazyToggle({
			props: {
				active: !/*isEdit*/ ctx[1].animalCard,
				mounted: true,
				class: "full-container",
				$$slots: { default: [create_default_slot_11] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	br7 = new Br({ props: { size: "60" }, $$inline: true });

	lazytoggle8 = new LazyToggle({
			props: {
				active: !/*isEditMode*/ ctx[0],
				mounted: true,
				$$slots: { default: [create_default_slot_10] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	lazytoggle9 = new LazyToggle({
			props: {
				active: /*isEdit*/ ctx[1].documents,
				$$slots: { default: [create_default_slot_9] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	lazytoggle10 = new LazyToggle({
			props: {
				active: !/*isEdit*/ ctx[1].documents,
				mounted: true,
				class: "full-container",
				$$slots: { default: [create_default_slot_7] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	br8 = new Br({ props: { size: "60" }, $$inline: true });

	lazytoggle11 = new LazyToggle({
			props: {
				active: /*isEdit*/ ctx[1].videos,
				$$slots: { default: [create_default_slot_6] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	lazytoggle12 = new LazyToggle({
			props: {
				active: !/*isEdit*/ ctx[1].videos,
				mounted: true,
				class: "full-container",
				$$slots: { default: [create_default_slot_4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	br9 = new Br({ props: { size: "60" }, $$inline: true });

	lazytoggle13 = new LazyToggle({
			props: {
				active: /*isEdit*/ ctx[1].howToHelp,
				$$slots: { default: [create_default_slot_3$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	lazytoggle14 = new LazyToggle({
			props: {
				active: !/*isEdit*/ ctx[1].howToHelp,
				mounted: true,
				class: "full-container",
				$$slots: { default: [create_default_slot_1$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	br10 = new Br({ props: { size: "60" }, $$inline: true });

	lazytoggle15 = new LazyToggle({
			props: {
				active: !/*isEditMode*/ ctx[0],
				mounted: true,
				$$slots: { default: [create_default_slot$a] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	footer = new Footer({ $$inline: true });
	br11 = new Br({ props: { size: "70" }, $$inline: true });

	const block = {
		c: function create() {
			t0 = space();
			create_component(donationbutton.$$.fragment);
			t1 = space();
			section = element("section");
			create_component(br0.$$.fragment);
			t2 = space();
			div0 = element("div");
			create_component(br1.$$.fragment);
			t3 = space();
			create_component(button.$$.fragment);
			t4 = space();
			create_component(br2.$$.fragment);
			t5 = space();
			create_component(lazytoggle0.$$.fragment);
			t6 = space();
			create_component(lazytoggle1.$$.fragment);
			t7 = space();
			create_component(br3.$$.fragment);
			t8 = space();
			create_component(lazytoggle2.$$.fragment);
			t9 = space();
			create_component(br4.$$.fragment);
			t10 = space();
			create_component(lazytoggle3.$$.fragment);
			t11 = space();
			create_component(lazytoggle4.$$.fragment);
			t12 = space();
			create_component(br5.$$.fragment);
			t13 = space();
			create_component(lazytoggle5.$$.fragment);
			t14 = space();
			create_component(br6.$$.fragment);
			t15 = space();
			create_component(lazytoggle6.$$.fragment);
			t16 = space();
			create_component(lazytoggle7.$$.fragment);
			t17 = space();
			create_component(br7.$$.fragment);
			t18 = space();
			create_component(lazytoggle8.$$.fragment);
			t19 = space();
			create_component(lazytoggle9.$$.fragment);
			t20 = space();
			create_component(lazytoggle10.$$.fragment);
			t21 = space();
			create_component(br8.$$.fragment);
			t22 = space();
			create_component(lazytoggle11.$$.fragment);
			t23 = space();
			create_component(lazytoggle12.$$.fragment);
			t24 = space();
			create_component(br9.$$.fragment);
			t25 = space();
			create_component(lazytoggle13.$$.fragment);
			t26 = space();
			create_component(lazytoggle14.$$.fragment);
			t27 = space();
			create_component(br10.$$.fragment);
			t28 = space();
			create_component(lazytoggle15.$$.fragment);
			t29 = space();
			div1 = element("div");
			create_component(footer.$$.fragment);
			t30 = space();
			create_component(br11.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			const head_nodes = query_selector_all("[data-svelte=\"svelte-3g9mo4\"]", document.head);
			head_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			claim_component(donationbutton.$$.fragment, nodes);
			t1 = claim_space(nodes);
			section = claim_element(nodes, "SECTION", { class: true });
			var section_nodes = children(section);
			claim_component(br0.$$.fragment, section_nodes);
			t2 = claim_space(section_nodes);
			div0 = claim_element(section_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			claim_component(br1.$$.fragment, div0_nodes);
			t3 = claim_space(div0_nodes);
			claim_component(button.$$.fragment, div0_nodes);
			t4 = claim_space(div0_nodes);
			claim_component(br2.$$.fragment, div0_nodes);
			div0_nodes.forEach(detach_dev);
			t5 = claim_space(section_nodes);
			claim_component(lazytoggle0.$$.fragment, section_nodes);
			t6 = claim_space(section_nodes);
			claim_component(lazytoggle1.$$.fragment, section_nodes);
			t7 = claim_space(section_nodes);
			claim_component(br3.$$.fragment, section_nodes);
			t8 = claim_space(section_nodes);
			claim_component(lazytoggle2.$$.fragment, section_nodes);
			t9 = claim_space(section_nodes);
			claim_component(br4.$$.fragment, section_nodes);
			t10 = claim_space(section_nodes);
			claim_component(lazytoggle3.$$.fragment, section_nodes);
			t11 = claim_space(section_nodes);
			claim_component(lazytoggle4.$$.fragment, section_nodes);
			t12 = claim_space(section_nodes);
			claim_component(br5.$$.fragment, section_nodes);
			t13 = claim_space(section_nodes);
			claim_component(lazytoggle5.$$.fragment, section_nodes);
			t14 = claim_space(section_nodes);
			claim_component(br6.$$.fragment, section_nodes);
			t15 = claim_space(section_nodes);
			claim_component(lazytoggle6.$$.fragment, section_nodes);
			t16 = claim_space(section_nodes);
			claim_component(lazytoggle7.$$.fragment, section_nodes);
			t17 = claim_space(section_nodes);
			claim_component(br7.$$.fragment, section_nodes);
			t18 = claim_space(section_nodes);
			claim_component(lazytoggle8.$$.fragment, section_nodes);
			t19 = claim_space(section_nodes);
			claim_component(lazytoggle9.$$.fragment, section_nodes);
			t20 = claim_space(section_nodes);
			claim_component(lazytoggle10.$$.fragment, section_nodes);
			t21 = claim_space(section_nodes);
			claim_component(br8.$$.fragment, section_nodes);
			t22 = claim_space(section_nodes);
			claim_component(lazytoggle11.$$.fragment, section_nodes);
			t23 = claim_space(section_nodes);
			claim_component(lazytoggle12.$$.fragment, section_nodes);
			t24 = claim_space(section_nodes);
			claim_component(br9.$$.fragment, section_nodes);
			t25 = claim_space(section_nodes);
			claim_component(lazytoggle13.$$.fragment, section_nodes);
			t26 = claim_space(section_nodes);
			claim_component(lazytoggle14.$$.fragment, section_nodes);
			t27 = claim_space(section_nodes);
			claim_component(br10.$$.fragment, section_nodes);
			t28 = claim_space(section_nodes);
			claim_component(lazytoggle15.$$.fragment, section_nodes);
			t29 = claim_space(section_nodes);
			div1 = claim_element(section_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			claim_component(footer.$$.fragment, div1_nodes);
			div1_nodes.forEach(detach_dev);
			t30 = claim_space(section_nodes);
			claim_component(br11.$$.fragment, section_nodes);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			document.title = "Charitify - Charity page and donate.";
			attr_dev(div0, "class", "overflow-hidden");
			add_location(div0, file$e, 163, 4, 4434);
			attr_dev(div1, "class", "full-container");
			add_location(div1, file$e, 305, 4, 9212);
			attr_dev(section, "class", "container theme-bg-color-secondary");
			add_location(section, file$e, 160, 0, 4338);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			mount_component(donationbutton, target, anchor);
			insert_dev(target, t1, anchor);
			insert_dev(target, section, anchor);
			mount_component(br0, section, null);
			append_dev(section, t2);
			append_dev(section, div0);
			mount_component(br1, div0, null);
			append_dev(div0, t3);
			mount_component(button, div0, null);
			append_dev(div0, t4);
			mount_component(br2, div0, null);
			append_dev(section, t5);
			mount_component(lazytoggle0, section, null);
			append_dev(section, t6);
			mount_component(lazytoggle1, section, null);
			append_dev(section, t7);
			mount_component(br3, section, null);
			append_dev(section, t8);
			mount_component(lazytoggle2, section, null);
			append_dev(section, t9);
			mount_component(br4, section, null);
			append_dev(section, t10);
			mount_component(lazytoggle3, section, null);
			append_dev(section, t11);
			mount_component(lazytoggle4, section, null);
			append_dev(section, t12);
			mount_component(br5, section, null);
			append_dev(section, t13);
			mount_component(lazytoggle5, section, null);
			append_dev(section, t14);
			mount_component(br6, section, null);
			append_dev(section, t15);
			mount_component(lazytoggle6, section, null);
			append_dev(section, t16);
			mount_component(lazytoggle7, section, null);
			append_dev(section, t17);
			mount_component(br7, section, null);
			append_dev(section, t18);
			mount_component(lazytoggle8, section, null);
			append_dev(section, t19);
			mount_component(lazytoggle9, section, null);
			append_dev(section, t20);
			mount_component(lazytoggle10, section, null);
			append_dev(section, t21);
			mount_component(br8, section, null);
			append_dev(section, t22);
			mount_component(lazytoggle11, section, null);
			append_dev(section, t23);
			mount_component(lazytoggle12, section, null);
			append_dev(section, t24);
			mount_component(br9, section, null);
			append_dev(section, t25);
			mount_component(lazytoggle13, section, null);
			append_dev(section, t26);
			mount_component(lazytoggle14, section, null);
			append_dev(section, t27);
			mount_component(br10, section, null);
			append_dev(section, t28);
			mount_component(lazytoggle15, section, null);
			append_dev(section, t29);
			append_dev(section, div1);
			mount_component(footer, div1, null);
			append_dev(section, t30);
			mount_component(br11, section, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const button_changes = {};

			if (dirty & /*$$scope, isEditMode*/ 268435457) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
			const lazytoggle0_changes = {};
			if (dirty & /*isEdit*/ 2) lazytoggle0_changes.active = /*isEdit*/ ctx[1].topInfo;

			if (dirty & /*$$scope, cardTop, organization, carouselTop*/ 268435484) {
				lazytoggle0_changes.$$scope = { dirty, ctx };
			}

			lazytoggle0.$set(lazytoggle0_changes);
			const lazytoggle1_changes = {};
			if (dirty & /*isEdit*/ 2) lazytoggle1_changes.active = !/*isEdit*/ ctx[1].topInfo;

			if (dirty & /*$$scope, isEditMode, isEdit, cardTop, carouselTop, organization*/ 268435487) {
				lazytoggle1_changes.$$scope = { dirty, ctx };
			}

			lazytoggle1.$set(lazytoggle1_changes);
			const lazytoggle2_changes = {};
			if (dirty & /*isEditMode*/ 1) lazytoggle2_changes.active = !/*isEditMode*/ ctx[0];

			if (dirty & /*$$scope, iconsLine*/ 268435488) {
				lazytoggle2_changes.$$scope = { dirty, ctx };
			}

			lazytoggle2.$set(lazytoggle2_changes);
			const lazytoggle3_changes = {};
			if (dirty & /*isEdit*/ 2) lazytoggle3_changes.active = /*isEdit*/ ctx[1].description;

			if (dirty & /*$$scope, descriptionBlock*/ 268435584) {
				lazytoggle3_changes.$$scope = { dirty, ctx };
			}

			lazytoggle3.$set(lazytoggle3_changes);
			const lazytoggle4_changes = {};
			if (dirty & /*isEdit*/ 2) lazytoggle4_changes.active = !/*isEdit*/ ctx[1].description;

			if (dirty & /*$$scope, isEditMode, isEdit, descriptionBlock*/ 268435587) {
				lazytoggle4_changes.$$scope = { dirty, ctx };
			}

			lazytoggle4.$set(lazytoggle4_changes);
			const lazytoggle5_changes = {};
			if (dirty & /*isEditMode*/ 1) lazytoggle5_changes.active = !/*isEditMode*/ ctx[0];

			if (dirty & /*$$scope, trust*/ 268435520) {
				lazytoggle5_changes.$$scope = { dirty, ctx };
			}

			lazytoggle5.$set(lazytoggle5_changes);
			const lazytoggle6_changes = {};
			if (dirty & /*isEdit*/ 2) lazytoggle6_changes.active = /*isEdit*/ ctx[1].animalCard;

			if (dirty & /*$$scope, animal*/ 268435712) {
				lazytoggle6_changes.$$scope = { dirty, ctx };
			}

			lazytoggle6.$set(lazytoggle6_changes);
			const lazytoggle7_changes = {};
			if (dirty & /*isEdit*/ 2) lazytoggle7_changes.active = !/*isEdit*/ ctx[1].animalCard;

			if (dirty & /*$$scope, isEditMode, isEdit, animal*/ 268435715) {
				lazytoggle7_changes.$$scope = { dirty, ctx };
			}

			lazytoggle7.$set(lazytoggle7_changes);
			const lazytoggle8_changes = {};
			if (dirty & /*isEditMode*/ 1) lazytoggle8_changes.active = !/*isEditMode*/ ctx[0];

			if (dirty & /*$$scope, donators*/ 268435968) {
				lazytoggle8_changes.$$scope = { dirty, ctx };
			}

			lazytoggle8.$set(lazytoggle8_changes);
			const lazytoggle9_changes = {};
			if (dirty & /*isEdit*/ 2) lazytoggle9_changes.active = /*isEdit*/ ctx[1].documents;

			if (dirty & /*$$scope, documents*/ 268436480) {
				lazytoggle9_changes.$$scope = { dirty, ctx };
			}

			lazytoggle9.$set(lazytoggle9_changes);
			const lazytoggle10_changes = {};
			if (dirty & /*isEdit*/ 2) lazytoggle10_changes.active = !/*isEdit*/ ctx[1].documents;

			if (dirty & /*$$scope, isEditMode, isEdit, documents*/ 268436483) {
				lazytoggle10_changes.$$scope = { dirty, ctx };
			}

			lazytoggle10.$set(lazytoggle10_changes);
			const lazytoggle11_changes = {};
			if (dirty & /*isEdit*/ 2) lazytoggle11_changes.active = /*isEdit*/ ctx[1].videos;

			if (dirty & /*$$scope, media*/ 268437504) {
				lazytoggle11_changes.$$scope = { dirty, ctx };
			}

			lazytoggle11.$set(lazytoggle11_changes);
			const lazytoggle12_changes = {};
			if (dirty & /*isEdit*/ 2) lazytoggle12_changes.active = !/*isEdit*/ ctx[1].videos;

			if (dirty & /*$$scope, isEditMode, isEdit, media*/ 268437507) {
				lazytoggle12_changes.$$scope = { dirty, ctx };
			}

			lazytoggle12.$set(lazytoggle12_changes);
			const lazytoggle13_changes = {};
			if (dirty & /*isEdit*/ 2) lazytoggle13_changes.active = /*isEdit*/ ctx[1].howToHelp;

			if (dirty & /*$$scope, howToHelp*/ 268439552) {
				lazytoggle13_changes.$$scope = { dirty, ctx };
			}

			lazytoggle13.$set(lazytoggle13_changes);
			const lazytoggle14_changes = {};
			if (dirty & /*isEdit*/ 2) lazytoggle14_changes.active = !/*isEdit*/ ctx[1].howToHelp;

			if (dirty & /*$$scope, isEditMode, isEdit, howToHelp*/ 268439555) {
				lazytoggle14_changes.$$scope = { dirty, ctx };
			}

			lazytoggle14.$set(lazytoggle14_changes);
			const lazytoggle15_changes = {};
			if (dirty & /*isEditMode*/ 1) lazytoggle15_changes.active = !/*isEditMode*/ ctx[0];

			if (dirty & /*$$scope, commentsData*/ 268443648) {
				lazytoggle15_changes.$$scope = { dirty, ctx };
			}

			lazytoggle15.$set(lazytoggle15_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(donationbutton.$$.fragment, local);
			transition_in(br0.$$.fragment, local);
			transition_in(br1.$$.fragment, local);
			transition_in(button.$$.fragment, local);
			transition_in(br2.$$.fragment, local);
			transition_in(lazytoggle0.$$.fragment, local);
			transition_in(lazytoggle1.$$.fragment, local);
			transition_in(br3.$$.fragment, local);
			transition_in(lazytoggle2.$$.fragment, local);
			transition_in(br4.$$.fragment, local);
			transition_in(lazytoggle3.$$.fragment, local);
			transition_in(lazytoggle4.$$.fragment, local);
			transition_in(br5.$$.fragment, local);
			transition_in(lazytoggle5.$$.fragment, local);
			transition_in(br6.$$.fragment, local);
			transition_in(lazytoggle6.$$.fragment, local);
			transition_in(lazytoggle7.$$.fragment, local);
			transition_in(br7.$$.fragment, local);
			transition_in(lazytoggle8.$$.fragment, local);
			transition_in(lazytoggle9.$$.fragment, local);
			transition_in(lazytoggle10.$$.fragment, local);
			transition_in(br8.$$.fragment, local);
			transition_in(lazytoggle11.$$.fragment, local);
			transition_in(lazytoggle12.$$.fragment, local);
			transition_in(br9.$$.fragment, local);
			transition_in(lazytoggle13.$$.fragment, local);
			transition_in(lazytoggle14.$$.fragment, local);
			transition_in(br10.$$.fragment, local);
			transition_in(lazytoggle15.$$.fragment, local);
			transition_in(footer.$$.fragment, local);
			transition_in(br11.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(donationbutton.$$.fragment, local);
			transition_out(br0.$$.fragment, local);
			transition_out(br1.$$.fragment, local);
			transition_out(button.$$.fragment, local);
			transition_out(br2.$$.fragment, local);
			transition_out(lazytoggle0.$$.fragment, local);
			transition_out(lazytoggle1.$$.fragment, local);
			transition_out(br3.$$.fragment, local);
			transition_out(lazytoggle2.$$.fragment, local);
			transition_out(br4.$$.fragment, local);
			transition_out(lazytoggle3.$$.fragment, local);
			transition_out(lazytoggle4.$$.fragment, local);
			transition_out(br5.$$.fragment, local);
			transition_out(lazytoggle5.$$.fragment, local);
			transition_out(br6.$$.fragment, local);
			transition_out(lazytoggle6.$$.fragment, local);
			transition_out(lazytoggle7.$$.fragment, local);
			transition_out(br7.$$.fragment, local);
			transition_out(lazytoggle8.$$.fragment, local);
			transition_out(lazytoggle9.$$.fragment, local);
			transition_out(lazytoggle10.$$.fragment, local);
			transition_out(br8.$$.fragment, local);
			transition_out(lazytoggle11.$$.fragment, local);
			transition_out(lazytoggle12.$$.fragment, local);
			transition_out(br9.$$.fragment, local);
			transition_out(lazytoggle13.$$.fragment, local);
			transition_out(lazytoggle14.$$.fragment, local);
			transition_out(br10.$$.fragment, local);
			transition_out(lazytoggle15.$$.fragment, local);
			transition_out(footer.$$.fragment, local);
			transition_out(br11.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			destroy_component(donationbutton, detaching);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(section);
			destroy_component(br0);
			destroy_component(br1);
			destroy_component(button);
			destroy_component(br2);
			destroy_component(lazytoggle0);
			destroy_component(lazytoggle1);
			destroy_component(br3);
			destroy_component(lazytoggle2);
			destroy_component(br4);
			destroy_component(lazytoggle3);
			destroy_component(lazytoggle4);
			destroy_component(br5);
			destroy_component(lazytoggle5);
			destroy_component(br6);
			destroy_component(lazytoggle6);
			destroy_component(lazytoggle7);
			destroy_component(br7);
			destroy_component(lazytoggle8);
			destroy_component(lazytoggle9);
			destroy_component(lazytoggle10);
			destroy_component(br8);
			destroy_component(lazytoggle11);
			destroy_component(lazytoggle12);
			destroy_component(br9);
			destroy_component(lazytoggle13);
			destroy_component(lazytoggle14);
			destroy_component(br10);
			destroy_component(lazytoggle15);
			destroy_component(footer);
			destroy_component(br11);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$p.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$p($$self, $$props, $$invalidate) {
	let $page;
	const { page } = stores$1();
	validate_store(page, "page");
	component_subscribe($$self, page, value => $$invalidate(26, $page = value));
	let charityId = $page.params.id;
	let isEditMode = false;

	let isEdit = {
		topInfo: false,
		description: false,
		videos: false,
		documents: false,
		howToHelp: false,
		animalCard: false
	};

	// Entities
	let charity;

	let comments;

	onMount(async () => {
		await delay(5000);
		$$invalidate(24, charity = await API.getFund(charityId));
		$$invalidate(25, comments = await API.getComments());
	});

	async function onSubmit(section, values) {
		$$invalidate(1, isEdit[section] = false, isEdit);
		console.log(values);
	}

	function onCancel(section) {
		$$invalidate(1, isEdit[section] = false, isEdit);
	}

	function onToggleMode() {
		$$invalidate(0, isEditMode = !isEditMode);

		if (!isEditMode) {
			$$invalidate(1, isEdit = {
				topInfo: false,
				description: false,
				videos: false,
				documents: false,
				howToHelp: false,
				animalCard: false
			});
		}
	}

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<U5Bidu5D> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("U5Bidu5D", $$slots, []);
	const click_handler = () => $$invalidate(1, isEdit.topInfo = !isEdit.topInfo, isEdit);
	const click_handler_1 = () => $$invalidate(1, isEdit.description = !isEdit.description, isEdit);
	const click_handler_2 = () => $$invalidate(1, isEdit.animalCard = !isEdit.animalCard, isEdit);
	const click_handler_3 = () => $$invalidate(1, isEdit.documents = !isEdit.documents, isEdit);
	const click_handler_4 = () => $$invalidate(1, isEdit.videos = !isEdit.videos, isEdit);
	const click_handler_5 = () => $$invalidate(1, isEdit.howToHelp = !isEdit.howToHelp, isEdit);

	$$self.$capture_state = () => ({
		stores: stores$1,
		onMount,
		API,
		delay,
		safeGet,
		_,
		Br,
		Icon,
		Footer,
		Button,
		EditArea,
		LazyToggle,
		DonationButton,
		Trust,
		Share,
		Comments: Comments_1,
		Donators,
		InteractionIndicators,
		VideosView: Videos,
		TopInfoView: TopInfo,
		DocumentsView: Documents_1$1,
		HowToHelpView: HowToHelp_1,
		AnimalCardView: AnimalCard_1,
		DescriptionView: Description_1,
		VideosEdit: Videos$1,
		TopInfoEdit: TopInfo$1,
		DocumentsEdit: Documents,
		HowToHelpEdit: HowToHelp$1,
		AnimalCardEdit: AnimalCard$1,
		DescriptionEdit: Description$1,
		page,
		charityId,
		isEditMode,
		isEdit,
		charity,
		comments,
		onSubmit,
		onCancel,
		onToggleMode,
		$page,
		carouselTop,
		organization,
		cardTop,
		iconsLine,
		trust,
		descriptionBlock,
		animal,
		donators,
		documents,
		media,
		howToHelp,
		commentsData
	});

	$$self.$inject_state = $$props => {
		if ("charityId" in $$props) charityId = $$props.charityId;
		if ("isEditMode" in $$props) $$invalidate(0, isEditMode = $$props.isEditMode);
		if ("isEdit" in $$props) $$invalidate(1, isEdit = $$props.isEdit);
		if ("charity" in $$props) $$invalidate(24, charity = $$props.charity);
		if ("comments" in $$props) $$invalidate(25, comments = $$props.comments);
		if ("carouselTop" in $$props) $$invalidate(2, carouselTop = $$props.carouselTop);
		if ("organization" in $$props) $$invalidate(3, organization = $$props.organization);
		if ("cardTop" in $$props) $$invalidate(4, cardTop = $$props.cardTop);
		if ("iconsLine" in $$props) $$invalidate(5, iconsLine = $$props.iconsLine);
		if ("trust" in $$props) $$invalidate(6, trust = $$props.trust);
		if ("descriptionBlock" in $$props) $$invalidate(7, descriptionBlock = $$props.descriptionBlock);
		if ("animal" in $$props) $$invalidate(8, animal = $$props.animal);
		if ("donators" in $$props) $$invalidate(9, donators = $$props.donators);
		if ("documents" in $$props) $$invalidate(10, documents = $$props.documents);
		if ("media" in $$props) $$invalidate(11, media = $$props.media);
		if ("howToHelp" in $$props) $$invalidate(12, howToHelp = $$props.howToHelp);
		if ("commentsData" in $$props) $$invalidate(13, commentsData = $$props.commentsData);
	};

	let carouselTop;
	let organization;
	let cardTop;
	let iconsLine;
	let trust;
	let descriptionBlock;
	let animal;
	let donators;
	let documents;
	let media;
	let howToHelp;
	let commentsData;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*charity*/ 16777216) {
			 $$invalidate(2, carouselTop = safeGet(() => charity.avatars.map((a, i) => ({
				src: a.src,
				srcBig: a.src2x,
				alt: a.title
			}))));
		}

		if ($$self.$$.dirty & /*charity*/ 16777216) {
			 $$invalidate(3, organization = safeGet(() => charity.organization, {}));
		}

		if ($$self.$$.dirty & /*charity*/ 16777216) {
			 $$invalidate(4, cardTop = safeGet(() => ({
				title: charity.title,
				subtitle: charity.subtitle,
				current_sum: charity.current_sum,
				need_sum: charity.need_sum,
				currency: charity.currency
			})));
		}

		if ($$self.$$.dirty & /*charity*/ 16777216) {
			 $$invalidate(5, iconsLine = {
				likes: safeGet(() => charity.likes),
				views: safeGet(() => charity.views)
			});
		}

		if ($$self.$$.dirty & /*charity*/ 16777216) {
			 $$invalidate(6, trust = { isLiked: safeGet(() => charity.is_liked) });
		}

		if ($$self.$$.dirty & /*charity*/ 16777216) {
			 $$invalidate(7, descriptionBlock = {
				title: safeGet(() => charity.title),
				description: safeGet(() => charity.description)
			});
		}

		if ($$self.$$.dirty & /*charity*/ 16777216) {
			 $$invalidate(8, animal = safeGet(() => ({
				avatar: charity.animal.avatars[0].src,
				name: charity.animal.name,
				breed: charity.animal.breed,
				birth: charity.animal.birth,
				age: new Date().getFullYear() - new Date(charity.animal.birth).getFullYear(),
				sex: charity.animal.sex,
				sterilization: charity.animal.sterilization,
				character: charity.animal.character,
				character_short: charity.animal.character_short,
				lifestory: charity.animal.lifestory.map(l => ({
					...l,
					date: new Date(l.date).toLocaleDateString()
				})),
				vaccination: charity.animal.vaccination
			})));
		}

		if ($$self.$$.dirty & /*charity*/ 16777216) {
			 $$invalidate(9, donators = safeGet(() => charity.donators.map(d => ({
				id: d.id,
				title: `${d.currency} ${d.amount}`,
				subtitle: d.name,
				src: d.avatar,
				src2x: d.avatar2x
			}))));
		}

		if ($$self.$$.dirty & /*charity*/ 16777216) {
			 $$invalidate(10, documents = safeGet(() => charity.documents.map(d => ({
				id: d.id,
				title: d.title,
				src: d.src,
				src2x: d.src2x
			}))));
		}

		if ($$self.$$.dirty & /*charity*/ 16777216) {
			 $$invalidate(11, media = safeGet(
				() => charity.media.map(d => ({
					id: d.id,
					alt: d.title,
					src: d.src,
					srcBig: d.src2x,
					description: d.description
				})),
				[],
				true
			));
		}

		if ($$self.$$.dirty & /*charity*/ 16777216) {
			 $$invalidate(12, howToHelp = safeGet(() => ({
				phone: charity.organization.phone,
				how_to_help: charity.how_to_help
			})));
		}

		if ($$self.$$.dirty & /*comments*/ 33554432) {
			 $$invalidate(13, commentsData = {
				comments: safeGet(() => comments.map(c => ({
					likes: c.likes,
					avatar: c["author.avatar"],
					author: c["author.name"],
					comment: c.comment,
					checked: c.checked,
					reply_to: c.reply_to,
					created_at: c.created_at
				})))
			});
		}
	};

	return [
		isEditMode,
		isEdit,
		carouselTop,
		organization,
		cardTop,
		iconsLine,
		trust,
		descriptionBlock,
		animal,
		donators,
		documents,
		media,
		howToHelp,
		commentsData,
		page,
		onSubmit,
		onCancel,
		onToggleMode,
		click_handler,
		click_handler_1,
		click_handler_2,
		click_handler_3,
		click_handler_4,
		click_handler_5
	];
}

class U5Bidu5D extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$p, create_fragment$p, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "U5Bidu5D",
			options,
			id: create_fragment$p.name
		});
	}
}

export default U5Bidu5D;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiW2lkXS45NWVmZWE0Ni5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL3JvdXRlcy9mdW5kcy9jb21wb25lbnRzL19NZWRpYS5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvcm91dGVzL2Z1bmRzL2NvbXBvbmVudHMvX1RydXN0LnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9yb3V0ZXMvZnVuZHMvY29tcG9uZW50cy9fQ29tbWVudHMuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy9mdW5kcy9jb21wb25lbnRzL19Eb25hdG9ycy5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvcm91dGVzL2Z1bmRzL2NvbXBvbmVudHMvX0hvd1RvSGVscC5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvcm91dGVzL2Z1bmRzL2NvbXBvbmVudHMvX0RvY3VtZW50cy5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvcm91dGVzL2Z1bmRzL2NvbXBvbmVudHMvX0FuaW1hbENhcmQuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy9mdW5kcy9jb21wb25lbnRzL19EZXNjcmlwdGlvbi5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvcm91dGVzL2Z1bmRzL2NvbXBvbmVudHMvX1RvcENhcm91c2VsLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9yb3V0ZXMvZnVuZHMvY29tcG9uZW50cy9fUXVpY2tJbmZvQ2FyZC5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvcm91dGVzL2Z1bmRzL2NvbXBvbmVudHMvX09yZ2FuaXphdGlvbkJ1dHRvbi5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvcm91dGVzL2Z1bmRzL2NvbXBvbmVudHMvX0ludGVyYWN0aW9uSW5kaWNhdG9ycy5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvcm91dGVzL2Z1bmRzL3ZpZXcvX1ZpZGVvcy5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvcm91dGVzL2Z1bmRzL3ZpZXcvX1RvcEluZm8uc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy9mdW5kcy92aWV3L19Eb2N1bWVudHMuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy9mdW5kcy92aWV3L19Ib3dUb0hlbHAuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy9mdW5kcy92aWV3L19BbmltYWxDYXJkLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9yb3V0ZXMvZnVuZHMvdmlldy9fRGVzY3JpcHRpb24uc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy9mdW5kcy9lZGl0L19WaWRlb3Muc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy9mdW5kcy9lZGl0L19Ub3BJbmZvLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9yb3V0ZXMvZnVuZHMvZWRpdC9fRG9jdW1lbnRzLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9yb3V0ZXMvZnVuZHMvZWRpdC9fSG93VG9IZWxwLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9yb3V0ZXMvZnVuZHMvZWRpdC9fQW5pbWFsQ2FyZC5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvcm91dGVzL2Z1bmRzL2VkaXQvX0Rlc2NyaXB0aW9uLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9yb3V0ZXMvZnVuZHMvW2lkXS5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBCciwgQ2Fyb3VzZWwgfSBmcm9tICdAY29tcG9uZW50cydcblxuICAgIGV4cG9ydCBsZXQgaXRlbXMgPSBbXVxuPC9zY3JpcHQ+XG5cbjxoMT7QktGW0LTQtdC+INC/0YDQviDQktC+0LvRgtC10YDQsDwvaDE+XG48QnIgc2l6ZT1cIjIwXCIvPlxuPHNlY3Rpb24gY2xhc3M9XCJmbGV4XCIgc3R5bGU9XCJoZWlnaHQ6IDI4MHB4XCI+XG4gICAgPENhcm91c2VsIHtpdGVtc30vPlxuPC9zZWN0aW9uPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBjcmVhdGVFdmVudERpc3BhdGNoZXIgfSBmcm9tICdzdmVsdGUnXG4gICAgaW1wb3J0IHsgVHJ1c3RCdXR0b24sIEJyIH0gZnJvbSAnQGNvbXBvbmVudHMnXG5cbiAgICBjb25zdCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpXG5cbiAgICBleHBvcnQgbGV0IGFjdGl2ZSA9IGZhbHNlXG48L3NjcmlwdD5cblxuPHNlY3Rpb24gY2xhc3M9XCJmbGV4IGZsZXgtY29sdW1uIGZsZXgtYWxpZ24tY2VudGVyIGZsZXgtanVzdGlmeS1jZW50ZXJcIj5cbiAgICA8ZGl2IHN0eWxlPVwid2lkdGg6IDEwMHB4OyBtYXgtd2lkdGg6IDEwMCVcIj5cbiAgICAgICAgPFRydXN0QnV0dG9uIGlzQWN0aXZlPXthY3RpdmV9IG9uOmNsaWNrPXtlID0+IGRpc3BhdGNoKCdjbGljaycsICFhY3RpdmUpfS8+XG4gICAgPC9kaXY+XG4gICAgPEJyIHNpemU9XCIxMFwiLz5cbiAgICA8aDI+0K8g0LTQvtCy0ZbRgNGP0Y48L2gyPlxuPC9zZWN0aW9uPlxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBCciwgQ29tbWVudHMgfSBmcm9tICdAY29tcG9uZW50cydcblxuICAgIGV4cG9ydCBsZXQgaXRlbXNcbjwvc2NyaXB0PlxuXG48aDE+0JrQvtC80LXQvdGC0LDRgNGWPC9oMT5cbjxCciBzaXplPVwiNVwiLz5cbjxkaXYgY2xhc3M9XCJmdWxsLWNvbnRhaW5lclwiPlxuICAgIDxDb21tZW50cyBpdGVtcz17aXRlbXN9Lz5cbjwvZGl2PiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgQnIsIERvbmF0b3JzTGlzdCB9IGZyb20gJ0Bjb21wb25lbnRzJ1xuXG4gICAgZXhwb3J0IGxldCBpdGVtc1xuPC9zY3JpcHQ+XG5cbjxoMT7QndCw0YjRliDQv9GW0LrQu9GD0LLQsNC70YzQvdC40LrQuDwvaDE+XG48QnIgc2l6ZT1cIjIwXCIvPlxuPGRpdiBjbGFzcz1cImZ1bGwtY29udGFpbmVyXCI+XG4gICAgPERvbmF0b3JzTGlzdCBpdGVtcz17aXRlbXN9Lz5cbjwvZGl2PiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgQnIsIEljb24sIExvYWRlciB9IGZyb20gJ0Bjb21wb25lbnRzJ1xuXG4gICAgZXhwb3J0IGxldCBkYXRhID0ge1xuICAgICAgICBwaG9uZTogbnVsbCxcbiAgICAgICAgaG93X3RvX2hlbHA6IG51bGwsXG4gICAgfVxuPC9zY3JpcHQ+XG5cbjxoMT7Qr9C6INC00L7Qv9C+0LzQvtCz0YLQuDwvaDE+XG48QnIgc2l6ZT1cIjE1XCIvPlxuPHVsIHN0eWxlPVwibGlzdC1zdHlsZTogZGlzYyBvdXRzaWRlIG5vbmU7IHBhZGRpbmctbGVmdDogdmFyKC0tc2NyZWVuLXBhZGRpbmcpXCIgY2xhc3M9XCJoMyBmb250LXctNTAwIGZvbnQtc2Vjb25kYXJ5XCI+XG4gICAgeyNpZiBkYXRhLmhvd190b19oZWxwICE9PSBudWxsfVxuICAgICAgICB7I2lmIHR5cGVvZiBkYXRhLmhvd190b19oZWxwID09PSAnc3RyaW5nJ31cbiAgICAgICAgICAgIHsjZWFjaCBkYXRhLmhvd190b19oZWxwLnNwbGl0KC9cXG4/4oCiIC8pLmZpbHRlcihCb29sZWFuKSBhcyBsaW5lfVxuICAgICAgICAgICAgICAgIDxsaSBzdHlsZT1cInBhZGRpbmctYm90dG9tOiA1cHhcIj57bGluZX08L2xpPlxuICAgICAgICAgICAgey9lYWNofVxuICAgICAgICB7L2lmfVxuICAgIHs6ZWxzZX1cbiAgICAgICAgPGxpIHN0eWxlPVwicGFkZGluZy1ib3R0b206IDVweFwiPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJmb250LXNlY29uZGFyeSBmb250LXctNTAwIHAgcmVsYXRpdmVcIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBzdHlsZT1cInZpc2liaWxpdHk6IGhpZGRlblwiPtCU0L7Qv9C+0LzQvtCz0YLQuCDQu9GO0LHQuNC8INGB0L/QvtGB0L7QsdC+0Lw8L3NwYW4+XG4gICAgICAgICAgICAgICAgPExvYWRlciB0eXBlPVwiaDNcIiBhYnNvbHV0ZS8+XG4gICAgICAgICAgICA8L3NwYW4+ICBcbiAgICAgICAgPC9saT5cbiAgICAgICA8bGkgc3R5bGU9XCJwYWRkaW5nLWJvdHRvbTogNXB4XCI+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImZvbnQtc2Vjb25kYXJ5IGZvbnQtdy01MDAgcCByZWxhdGl2ZVwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIHN0eWxlPVwidmlzaWJpbGl0eTogaGlkZGVuXCI+0JTQvtC/0L7QvNC+0LPRgtC4INC70Y7QsdC40Lwg0YHQv9C+0YHQvtCx0L7QvDwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8TG9hZGVyIHR5cGU9XCJoM1wiIGFic29sdXRlLz5cbiAgICAgICAgICAgIDwvc3Bhbj4gIFxuICAgICAgICA8L2xpPlxuICAgICAgIDxsaSBzdHlsZT1cInBhZGRpbmctYm90dG9tOiA1cHhcIj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZm9udC1zZWNvbmRhcnkgZm9udC13LTUwMCBwIHJlbGF0aXZlXCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gc3R5bGU9XCJ2aXNpYmlsaXR5OiBoaWRkZW5cIj7QlNC+0L/QvtC80L7Qs9GC0Lgg0LvRjtCx0LjQvCDRgdC/0L7RgdC+0LHQvtC8PC9zcGFuPlxuICAgICAgICAgICAgICAgIDxMb2FkZXIgdHlwZT1cImgzXCIgYWJzb2x1dGUvPlxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICA8L2xpPlxuICAgICAgIDxsaSBzdHlsZT1cInBhZGRpbmctYm90dG9tOiA1cHhcIj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZm9udC1zZWNvbmRhcnkgZm9udC13LTUwMCBwIHJlbGF0aXZlXCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gc3R5bGU9XCJ2aXNpYmlsaXR5OiBoaWRkZW5cIj7QlNC+0L/QvtC80L7Qs9GC0Lgg0LvRjtCx0LjQvCDRgdC/0L7RgdC+0LHQvtC8PC9zcGFuPlxuICAgICAgICAgICAgICAgIDxMb2FkZXIgdHlwZT1cImgzXCIgYWJzb2x1dGUvPlxuICAgICAgICAgICAgPC9zcGFuPiAgXG4gICAgICAgIDwvbGk+XG4gICAgey9pZn1cbjwvdWw+XG48QnIgc2l6ZT1cIjMwXCIvPlxuPGRpdiBjbGFzcz1cImZsZXhcIj5cbiAgICA8ZGl2IGNsYXNzPVwiZmxleCBmbGV4LWFsaWduLWNlbnRlciBmb250LXNlY29uZGFyeVwiPlxuICAgICAgICA8SWNvbiBzaXplPVwibWVkaXVtXCIgdHlwZT1cInBob25lXCIgY2xhc3M9XCJ0aGVtZS1zdmctZmlsbC1vcHBvc2l0ZVwiLz5cbiAgICAgICAgPHM+PC9zPlxuICAgICAgICA8cz48L3M+XG4gICAgICAgIHsjaWYgZGF0YS5waG9uZSAhPT0gbnVsbH1cbiAgICAgICAgICAgIDxoMj57ZGF0YS5waG9uZX08L2gyPlxuICAgICAgICB7OmVsc2V9XG4gICAgICAgICAgICA8c3BhbiBzdHlsZT1cIndpZHRoOiAyNDBweFwiPjxMb2FkZXIgdHlwZT1cImgyXCIvPjwvc3Bhbj5cbiAgICAgICAgey9pZn1cbiAgICA8L2Rpdj5cbjwvZGl2PlxuPEJyIHNpemU9XCI1XCIvPlxuPHAgY2xhc3M9XCJmb250LXctMzAwXCI+0J/QvtC00LfQstC+0L3RltGC0Ywg0L3QsNC8LCDQtNC+0L/QvtC80L7QttC10LzQviDRgNCw0LfQvtC8ITwvcD5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgQnIsIERvY3VtZW50cyB9IGZyb20gJ0Bjb21wb25lbnRzJ1xuXG4gICAgZXhwb3J0IGxldCBpdGVtc1xuPC9zY3JpcHQ+XG5cbjxoMT7QlNC+0LrRg9C80LXQvdGC0Lg8L2gxPlxuPEJyIHNpemU9XCI1XCIvPlxuPGRpdiBjbGFzcz1cImZ1bGwtY29udGFpbmVyXCI+XG4gICAgPERvY3VtZW50cyBpdGVtcz17aXRlbXN9Lz5cbjwvZGl2PiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgb3B0aW9ucyB9IGZyb20gJ0Bjb25maWcnXG4gICAgaW1wb3J0IHsgXyB9IGZyb20gJ0B1dGlscydcbiAgICBpbXBvcnQgeyBDYXJkLCBCciwgRmFuY3lCb3gsIEF2YXRhciwgSWNvbiwgTG9hZGVyLCBTdG9yeUxpc3QgfSBmcm9tICdAY29tcG9uZW50cydcblxuICAgIGV4cG9ydCBsZXQgYW5pbWFsID0ge1xuICAgICAgICBhdmF0YXI6IG51bGwsXG4gICAgICAgIGF2YXRhcjJ4OiBudWxsLFxuICAgICAgICBuYW1lOiBudWxsLFxuICAgICAgICBicmVlZDogbnVsbCxcbiAgICAgICAgYWdlOiBudWxsLFxuICAgICAgICBzZXg6IG51bGwsXG4gICAgICAgIHN0ZXJpbGl6YXRpb246IG51bGwsXG4gICAgICAgIGNoYXJhY3RlclNob3J0OiBudWxsLFxuICAgICAgICBjaGFyYWN0ZXI6IG51bGwsXG4gICAgICAgIGxpZmVzdG9yeTogbnVsbCxcbiAgICAgICAgdmFjY2luYXRpb246IG51bGwsXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0VmFjdGluYXRpb25zKHZhbHVlcykge1xuICAgICAgICByZXR1cm4gW10uY29uY2F0KHZhbHVlcyB8fCBbXSkubWFwKHZhbHVlID0+ICh7XG4gICAgICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICAgICAgdGl0bGU6IChfLmZpbmQob3B0aW9ucy52YWNjaW5hdGlvbnMsIFsndmFsdWUnLCB2YWx1ZV0pIHx8IHt9KS50ZXh0LFxuICAgICAgICB9KSkuZmlsdGVyKHYgPT4gdi50aXRsZSlcbiAgICB9XG48L3NjcmlwdD5cblxuPENhcmQgY2xhc3M9XCJjb250YWluZXJcIj5cbiAgICA8QnIgc2l6ZT1cIjMwXCIvPlxuXG4gICAgPGRpdiBjbGFzcz1cImZsZXggZmxleC1jb2x1bW4gZmxleC1hbGlnbi1jZW50ZXJcIj5cbiAgICAgICAgPHNwYW4+XG4gICAgICAgICAgICA8RmFuY3lCb3g+XG4gICAgICAgICAgICAgICAgPEF2YXRhciBzcmM9e2FuaW1hbC5hdmF0YXJ9IHNpemU9XCJiaWdcIiBhbHQ9XCLQktC+0LvRgtC10YBcIi8+XG4gICAgICAgICAgICAgICAgPHNlY3Rpb24gc2xvdD1cImJveFwiIGNsYXNzPVwiZmxleCBmdWxsLXdpZHRoIGZ1bGwtaGVpZ2h0XCIgc3R5bGU9XCJoZWlnaHQ6IDEwMHZ3XCI+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmbGV4IGZsZXgtc2VsZi1zdHJldGNoIGZsZXgtMSBvdmVyZmxvdy1oaWRkZW4gZmxleC1qdXN0aWZ5LXN0cmV0Y2hcIiBzdHlsZT1cInBhZGRpbmc6IHZhcigtLXNjcmVlbi1wYWRkaW5nKSAwXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8QXZhdGFyIHNyYz17YW5pbWFsLmF2YXRhcn0gc3JjQmlnPXthbmltYWwuYXZhdGFyMnh9IGFsdD1cItCS0L7Qu9GC0LXRgFwiLz5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9zZWN0aW9uPlxuICAgICAgICAgICAgPC9GYW5jeUJveD5cbiAgICAgICAgPC9zcGFuPlxuXG4gICAgICAgIDxCciBzaXplPVwiMjBcIi8+XG5cbiAgICAgICAgeyNpZiBhbmltYWwubmFtZSAhPT0gbnVsbH1cbiAgICAgICAgICAgIDxoMj57YW5pbWFsLm5hbWV9PC9oMj5cbiAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgPHNwYW4gc3R5bGU9XCJ3aWR0aDogNDAlXCI+PExvYWRlciB0eXBlPVwiaDJcIi8+PC9zcGFuPlxuICAgICAgICB7L2lmfVxuICAgICAgICA8QnIgc2l6ZT1cIjVcIi8+XG4gICAgICAgIHsjaWYgYW5pbWFsLmJyZWVkICE9PSBudWxsfVxuICAgICAgICAgICAgPGgzIGNsYXNzPVwiZm9udC13LTUwMFwiIHN0eWxlPVwib3BhY2l0eTogLjdcIj57YW5pbWFsLmJyZWVkfTwvaDM+XG4gICAgICAgIHs6ZWxzZX1cbiAgICAgICAgICAgIDxzcGFuIHN0eWxlPVwid2lkdGg6IDYwJVwiPjxMb2FkZXIgdHlwZT1cImgzXCIvPjwvc3Bhbj5cbiAgICAgICAgey9pZn1cbiAgICA8L2Rpdj5cbiAgICA8QnIgc2l6ZT1cIjM1XCIvPlxuXG4gICAgPHNlY3Rpb24gY2xhc3M9XCJmbGV4IGZsZXgtanVzdGlmeS1jZW50ZXJcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImZsZXggZmxleC1jZW50ZXIgcmVsYXRpdmVcIiBzdHlsZT1cIndpZHRoOiAxMjBweDsgaGVpZ2h0OiAxMjBweFwiPlxuICAgICAgICAgICAgPEljb24gdHlwZT1cInBvbHlnb25cIiBpcz1cInByaW1hcnlcIi8+XG5cbiAgICAgICAgICAgIHsjaWYgYW5pbWFsLmFnZSAhPT0gbnVsbH1cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidGV4dC13aGl0ZSB0ZXh0LWNlbnRlciBhYnNvbHV0ZVwiPlxuICAgICAgICAgICAgICAgICAgICA8aDQgY2xhc3M9XCJoMVwiPnthbmltYWwuYWdlfTwvaDQ+XG4gICAgICAgICAgICAgICAgICAgIDxoNCBzdHlsZT1cIm1hcmdpbi10b3A6IC04cHhcIj7QoNC+0LrQuDwvaDQ+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICB7L2lmfVxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8ZGl2IGNsYXNzPVwiZmxleCBmbGV4LWNlbnRlciByZWxhdGl2ZVwiIHN0eWxlPVwid2lkdGg6IDEyMHB4OyBoZWlnaHQ6IDEyMHB4XCI+XG4gICAgICAgICAgICA8SWNvbiB0eXBlPVwicG9seWdvblwiIGlzPVwiaW5mb1wiLz5cblxuICAgICAgICAgICAgeyNpZiBhbmltYWwuc2V4ICE9PSBudWxsfVxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJhYnNvbHV0ZSBmbGV4XCIgc3R5bGU9XCJ3aWR0aDogNDRweDsgaGVpZ2h0OiA0NHB4XCI+XG4gICAgICAgICAgICAgICAgeyNpZiBhbmltYWwuc2V4ID09PSAnbWFsZSd9XG4gICAgICAgICAgICAgICAgICAgIDxJY29uIHR5cGU9XCJtYWxlXCIgaXM9XCJsaWdodFwiLz5cbiAgICAgICAgICAgICAgICB7OmVsc2UgaWYgYW5pbWFsLnNleCA9PT0gJ2ZlbWFsZSd9XG4gICAgICAgICAgICAgICAgICAgIDxJY29uIHR5cGU9XCJmZW1hbGVcIiBpcz1cImxpZ2h0XCIvPlxuICAgICAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICB7L2lmfVxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8ZGl2IGNsYXNzPVwiZmxleCBmbGV4LWNlbnRlciByZWxhdGl2ZVwiIHN0eWxlPVwid2lkdGg6IDEyMHB4OyBoZWlnaHQ6IDEyMHB4XCI+XG4gICAgICAgICAgICA8SWNvbiB0eXBlPVwicG9seWdvblwiIGlzPVwicHJpbWFyeVwiLz5cblxuICAgICAgICAgICAgeyNpZiBhbmltYWwuc3RlcmlsaXphdGlvbiAhPT0gbnVsbH1cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiYWJzb2x1dGUgZmxleCBmbGV4LWNvbHVtbiBmbGV4LWNlbnRlclwiPlxuICAgICAgICAgICAgICAgICAgICB7I2lmIGFuaW1hbC5zdGVyaWxpemF0aW9ufVxuICAgICAgICAgICAgICAgICAgICAgICAgPEljb24gdHlwZT1cImNoZWNrZWQtY2lyY2xlXCIgaXM9XCJsaWdodFwiIHNpemU9XCJiaWdcIi8+XG4gICAgICAgICAgICAgICAgICAgIHs6ZWxzZX1cbiAgICAgICAgICAgICAgICAgICAgICAgIDxJY29uIHR5cGU9XCJjYW5jZWwtY2lyY2xlXCIgaXM9XCJsaWdodFwiIHNpemU9XCJiaWdcIi8+XG4gICAgICAgICAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwidGV4dC13aGl0ZSB0ZXh0LWNlbnRlciBoNVwiPkPRgtC10YDQuNC70ZbQt9Cw0YbRltGPPC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgey9pZn1cbiAgICAgICAgPC9kaXY+XG4gICAgPC9zZWN0aW9uPlxuICAgIDxCciBzaXplPVwiNDBcIi8+XG5cbiAgICA8aDI+0KXQsNGA0LDQutGC0LXRgDoge2FuaW1hbC5jaGFyYWN0ZXJTaG9ydCA/IGFuaW1hbC5jaGFyYWN0ZXJTaG9ydCA6ICcnfTwvaDI+XG4gICAgPEJyIHNpemU9XCIxMFwiLz5cblxuICAgIHsjaWYgYW5pbWFsLmNoYXJhY3RlciAhPT0gbnVsbH1cbiAgICAgICAgPHAgY2xhc3M9XCJmb250LXctMzAwXCI+XG4gICAgICAgICAgICB7YW5pbWFsLmNoYXJhY3Rlcn1cbiAgICAgICAgPC9wPlxuICAgIHs6ZWxzZX1cbiAgICAgICAgPExvYWRlciB0eXBlPVwicFwiLz5cbiAgICAgICAgPExvYWRlciB0eXBlPVwicFwiLz5cbiAgICAgICAgPExvYWRlciB0eXBlPVwicFwiLz5cbiAgICAgICAgPExvYWRlciB0eXBlPVwicFwiLz5cbiAgICB7L2lmfVxuICAgIDxCciBzaXplPVwiMzVcIi8+XG5cbiAgICA8U3RvcnlMaXN0IGxhYmVsPVwi0IbRgdGC0L7RgNGW0Y8g0LbQuNGC0YLRjzpcIiB2YWx1ZT17YW5pbWFsLmxpZmVzdG9yeX0gcmVhZG9ubHkvPlxuICAgIDxCciBzaXplPVwiNDVcIi8+XG5cbiAgICA8aDI+0JLQsNC60YbQuNC90LDRhtGW0Zc8L2gyPlxuICAgIDxCciBzaXplPVwiMTVcIi8+XG4gICAgPHVsIGNsYXNzPVwiZmxleCBmbGV4LWNvbHVtbiB0ZXh0LWxlZnRcIj5cbiAgICAgICAgeyNpZiBhbmltYWwudmFjY2luYXRpb24gIT09IG51bGx9XG4gICAgICAgICAgICB7I2VhY2ggZ2V0VmFjdGluYXRpb25zKGFuaW1hbC52YWNjaW5hdGlvbikgYXMgaXRlbSwgaX1cbiAgICAgICAgICAgICAgICA8bGk+XG4gICAgICAgICAgICAgICAgICAgIHsjaWYgaX1cbiAgICAgICAgICAgICAgICAgICAgICAgIDxCciBzaXplPVwiMTBcIi8+XG4gICAgICAgICAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZmxleCBmbGV4LWFsaWduLWNlbnRlciBmb250LXctMzAwXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICB7I2lmIGl0ZW0uZG9uZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8SWNvbiBpcz1cInByaW1hcnlcIiB0eXBlPVwiY2hlY2tlZC1jaXJjbGVcIiBzaXplPVwibWVkaXVtXCIvPlxuICAgICAgICAgICAgICAgICAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxJY29uIGlzPVwiZGFuZ2VyXCIgdHlwZT1cImNhbmNlbC1jaXJjbGVcIiBzaXplPVwibWVkaXVtXCIvPlxuICAgICAgICAgICAgICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzPjwvcz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzPjwvcz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzPjwvcz5cbiAgICAgICAgICAgICAgICAgICAgICAgIHtpdGVtLnRpdGxlfVxuICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgIHsvZWFjaH1cbiAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgPGxpIHN0eWxlPVwid2lkdGg6IDQwJVwiPlxuICAgICAgICAgICAgICAgIDxMb2FkZXIgdHlwZT1cInBcIi8+XG4gICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgPGxpIHN0eWxlPVwid2lkdGg6IDQwJVwiPlxuICAgICAgICAgICAgICAgIDxCciBzaXplPVwiMTBcIi8+XG4gICAgICAgICAgICAgICAgPExvYWRlciB0eXBlPVwicFwiLz5cbiAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICA8bGkgc3R5bGU9XCJ3aWR0aDogNDAlXCI+XG4gICAgICAgICAgICAgICAgPEJyIHNpemU9XCIxMFwiLz5cbiAgICAgICAgICAgICAgICA8TG9hZGVyIHR5cGU9XCJwXCIvPlxuICAgICAgICAgICAgPC9saT5cbiAgICAgICAgey9pZn1cbiAgICA8L3VsPlxuXG4gICAgPEJyIHNpemU9XCIzNVwiLz5cbjwvQ2FyZD5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgQnIsIExvYWRlciB9IGZyb20gJ0Bjb21wb25lbnRzJ1xuXG4gICAgZXhwb3J0IGxldCB0aXRsZSA9IG51bGxcbiAgICBleHBvcnQgbGV0IHRleHQgPSBudWxsXG48L3NjcmlwdD5cblxueyNpZiB0aXRsZSAhPT0gbnVsbH1cbiAgICA8aDE+e3RpdGxlfTwvaDE+XG57OmVsc2V9XG4gICAgPGRpdiBzdHlsZT1cIndpZHRoOiA4NSVcIj48TG9hZGVyIHR5cGU9XCJoMVwiLz4gIDwvZGl2PlxuICAgIDxkaXYgc3R5bGU9XCJ3aWR0aDogODUlXCI+PExvYWRlciB0eXBlPVwiaDFcIi8+ICA8L2Rpdj5cbnsvaWZ9XG48QnIgc2l6ZT1cIjEwXCIgLz5cblxueyNpZiB0ZXh0ICE9PSBudWxsfVxuPHByZSBjbGFzcz1cImZvbnQtdy0zMDBcIj5cbiAgICB7dGV4dH1cbjwvcHJlPlxuezplbHNlfVxuICAgIDxMb2FkZXIgdHlwZT1cInByZVwiLz4gIFxuICAgIDxMb2FkZXIgdHlwZT1cInByZVwiLz4gIFxuICAgIDxMb2FkZXIgdHlwZT1cInByZVwiLz4gIFxuICAgIDxMb2FkZXIgdHlwZT1cInByZVwiLz4gIFxuICAgIDxMb2FkZXIgdHlwZT1cInByZVwiLz4gIFxuICAgIDxMb2FkZXIgdHlwZT1cInByZVwiLz4gIFxuICAgIDxMb2FkZXIgdHlwZT1cInByZVwiLz4gIFxuICAgIDxMb2FkZXIgdHlwZT1cInByZVwiLz4gIFxuICAgIDxMb2FkZXIgdHlwZT1cInByZVwiLz4gIFxuICAgIDxkaXYgc3R5bGU9XCJ3aWR0aDogNjAlXCI+PExvYWRlciB0eXBlPVwicHJlXCIvPjwvZGl2Plxuey9pZn0iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IENhcm91c2VsIH0gZnJvbSAnQGNvbXBvbmVudHMnXG5cbiAgICBleHBvcnQgbGV0IGl0ZW1zID0gW11cbjwvc2NyaXB0PlxuXG48c2VjdGlvbiBjbGFzcz1cImZsZXhcIiBzdHlsZT1cImhlaWdodDogMjQwcHhcIj5cbiAgICA8Q2Fyb3VzZWwgaXRlbXM9e2l0ZW1zfSBkb3RzQmVsb3c9e2ZhbHNlfS8+XG48L3NlY3Rpb24+IiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBCciwgQ2FyZCwgUHJvZ3Jlc3MsIExvYWRlciB9IGZyb20gJ0Bjb21wb25lbnRzJ1xuXG4gICAgZXhwb3J0IGxldCBjYXJkVG9wID0ge1xuICAgICAgICB0aXRsZTogbnVsbCxcbiAgICAgICAgc3VidGl0bGU6IG51bGwsXG4gICAgICAgIGN1cnJlbnRfc3VtOiBudWxsLFxuICAgICAgICBuZWVkX3N1bTogbnVsbCxcbiAgICB9XG48L3NjcmlwdD5cblxuPENhcmQgY2xhc3M9XCJjb250YWluZXJcIj5cbiAgICA8QnIgc2l6ZT1cIjIwXCIvPlxuXG4gICAgeyNpZiBjYXJkVG9wLnRpdGxlICE9PSBudWxsfVxuICAgICAgICA8aDI+e2NhcmRUb3AudGl0bGV9PC9oMj5cbiAgICB7OmVsc2V9XG4gICAgICAgIDxkaXYgc3R5bGU9XCJ3aWR0aDogODAlXCI+PExvYWRlciB0eXBlPVwiaDJcIi8+PC9kaXY+XG4gICAgICAgIDxkaXYgc3R5bGU9XCJ3aWR0aDogODAlXCI+PExvYWRlciB0eXBlPVwiaDJcIi8+PC9kaXY+XG4gICAgey9pZn1cblxuICAgIHsjaWYgY2FyZFRvcC5zdWJ0aXRsZSAhPT0gbnVsbH1cbiAgICAgICAgPGgzIGNsYXNzPVwiZm9udC13LW5vcm1hbFwiIHN0eWxlPVwib3BhY2l0eTogLjdcIj57Y2FyZFRvcC5zdWJ0aXRsZX08L2gzPlxuICAgIHs6ZWxzZX1cbiAgICAgICAgPGRpdiBzdHlsZT1cIndpZHRoOiAxMDAlXCI+PExvYWRlciB0eXBlPVwiaDNcIi8+PC9kaXY+XG4gICAgICAgIDxkaXYgc3R5bGU9XCJ3aWR0aDogMTAwJVwiPjxMb2FkZXIgdHlwZT1cImgzXCIvPjwvZGl2PlxuICAgIHsvaWZ9XG5cbiAgICA8QnIgc2l6ZT1cIjI1XCIvPlxuICAgIDxwIGNsYXNzPVwiZm9udC1zZWNvbmRhcnkgZmxleCBmbGV4LWFsaWduLWVuZFwiPlxuICAgICAgICB7I2lmIGNhcmRUb3AuY3VycmVudF9zdW0gIT09IG51bGx9XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImgxIGZvbnQtdy01MDBcIj57Y2FyZFRvcC5jdXJyZW5jeX0ge2NhcmRUb3AuY3VycmVudF9zdW19PC9zcGFuPlxuICAgICAgICB7OmVsc2V9XG4gICAgICAgICAgICA8ZGl2IHN0eWxlPVwid2lkdGg6IDUwJVwiPjxMb2FkZXIgdHlwZT1cImgxXCIvPjwvZGl2PlxuICAgICAgICB7L2lmfVxuXG4gICAgICAgIDxzIC8+XG5cbiAgICAgICAgeyNpZiBjYXJkVG9wLm5lZWRfc3VtICE9PSBudWxsfVxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJoM1wiPi8ge2NhcmRUb3AuY3VycmVuY3l9IHtjYXJkVG9wLm5lZWRfc3VtfTwvc3Bhbj5cbiAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgPGRpdiBzdHlsZT1cIndpZHRoOiAzMCU7IHBhZGRpbmctYm90dG9tOiAycHhcIj48TG9hZGVyIHR5cGU9XCJoM1wiLz48L2Rpdj5cbiAgICAgICAgey9pZn1cbiAgICA8L3A+XG4gICAgPEJyIHNpemU9XCIyMFwiLz5cblxuICAgIDxQcm9ncmVzcyB2YWx1ZT17TWF0aC5mbG9vcihjYXJkVG9wLmN1cnJlbnRfc3VtIC8gY2FyZFRvcC5uZWVkX3N1bSAqIDEwMCl9Lz5cblxuICAgIDxCciBzaXplPVwiNDBcIi8+XG48L0NhcmQ+IiwiPHNjcmlwdD5cbiAgaW1wb3J0IHsgUGljdHVyZSwgQnV0dG9uLCBMb2FkZXIsIEljb24gfSBmcm9tIFwiQGNvbXBvbmVudHNcIjtcblxuICBleHBvcnQgbGV0IGlkID0gbnVsbFxuICBleHBvcnQgbGV0IHNyYyA9IG51bGxcbiAgZXhwb3J0IGxldCB0aXRsZSA9IG51bGxcbjwvc2NyaXB0PlxuXG48QnV0dG9uIHJlbD1cInByZWZldGNoXCIgaHJlZj17aWR9IGNsYXNzPVwid2hpdGVcIj5cbiAgPGRpdiBjbGFzcz1cImZsZXggZmxleC1hbGlnbi1jZW50ZXIgZmxleC1qdXN0aWZ5LWJldHdlZW4gZnVsbC13aWR0aFwiPlxuXG4gICAgPGRpdiBjbGFzcz1cImZsZXggZmxleC1hbGlnbi1jZW50ZXJcIj5cbiAgICAgIDxzIC8+XG4gICAgICA8ZGl2IGNsYXNzPVwiZmxleFwiIHN0eWxlPVwibWF4LXdpZHRoOiA0NXB4OyBoZWlnaHQ6IDQwcHg7IG92ZXJmbG93OiBoaWRkZW5cIj5cbiAgICAgICAgPFBpY3R1cmVcbiAgICAgICAgICB7c3JjfVxuICAgICAgICAgIHNpemU9XCJjb250YWluXCJcbiAgICAgICAgICBhbHQ9XCLRj9C60LXRgdGMINGE0L7RgtC+INC+0YDQs9Cw0L3RltC30LDRhtGW0ZdcIiAvPlxuICAgICAgPC9kaXY+XG4gICAgICA8cyAvPlxuICAgICAgeyNpZiB0aXRsZSAhPT0gbnVsbH1cbiAgICAgICAgPHMgLz5cbiAgICAgICAgPHMgLz5cbiAgICAgICAgPGgzPnt0aXRsZX08L2gzPlxuICAgICAgezplbHNlfVxuICAgICAgICA8c3BhbiBzdHlsZT1cIndpZHRoOiA4MCVcIj48TG9hZGVyIHR5cGU9XCJoM1wiLz48L3NwYW4+XG4gICAgICB7L2lmfVxuICAgIDwvZGl2PlxuICAgIFxuICAgIDxJY29uIHR5cGU9XCJhcnJvdy1yaWdodFwiIHNpemU9XCJtZWRpdW1cIiBpcz1cImRhcmtcIi8+XG4gIDwvZGl2PlxuPC9CdXR0b24+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IEljb24sIExvYWRlciB9IGZyb20gJ0Bjb21wb25lbnRzJ1xuXG4gICAgZXhwb3J0IGxldCBsaWtlcyA9IG51bGxcbiAgICBleHBvcnQgbGV0IHZpZXdzID0gbnVsbFxuPC9zY3JpcHQ+XG5cbjxwIGNsYXNzPVwiY29udGFpbmVyIGZsZXggZmxleC1qdXN0aWZ5LWJldHdlZW4gZmxleC1hbGlnbi1jZW50ZXJcIj5cbiAgICA8c3BhbiBjbGFzcz1cImZsZXggZmxleC1hbGlnbi1jZW50ZXJcIj5cbiAgICAgICAgPEljb24gaXM9XCJkYW5nZXJcIiB0eXBlPVwiaGVhcnRcIiBzaXplPVwibWVkaXVtXCIvPlxuICAgICAgICA8cz48L3M+XG4gICAgICAgIDxzPjwvcz5cbiAgICAgICAgeyNpZiBsaWtlcyAhPT0gbnVsbH1cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZm9udC1zZWNvbmRhcnkgZm9udC13LTYwMCBoM1wiPntsaWtlc308L3NwYW4+XG4gICAgICAgIHs6ZWxzZX1cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZm9udC1zZWNvbmRhcnkgZm9udC13LTYwMCBoMyByZWxhdGl2ZVwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIHN0eWxlPVwidmlzaWJpbGl0eTogaGlkZGVuXCI+MTk5PC9zcGFuPlxuICAgICAgICAgICAgICAgIDxMb2FkZXIgdHlwZT1cImgzXCIgYWJzb2x1dGUvPlxuICAgICAgICAgICAgPC9zcGFuPiAgXG4gICAgICAgIHsvaWZ9XG4gICAgPC9zcGFuPlxuICAgIDxzcGFuIGNsYXNzPVwiZmxleCBmbGV4LWFsaWduLWNlbnRlclwiPlxuICAgICAgICA8SWNvbiB0eXBlPVwiZXllXCIgc2l6ZT1cIm1lZGl1bVwiIGNsYXNzPVwidGhlbWUtc3ZnLWZpbGxcIi8+XG4gICAgICAgIDxzPjwvcz5cbiAgICAgICAgPHM+PC9zPlxuICAgICAgICB7I2lmIHZpZXdzICE9PSBudWxsfVxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJmb250LXNlY29uZGFyeSBmb250LXctNjAwIGgzXCI+e3ZpZXdzfTwvc3Bhbj5cbiAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJmb250LXNlY29uZGFyeSBmb250LXctNjAwIGgzIHJlbGF0aXZlXCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gc3R5bGU9XCJ2aXNpYmlsaXR5OiBoaWRkZW5cIj4xOTk8L3NwYW4+XG4gICAgICAgICAgICAgICAgPExvYWRlciB0eXBlPVwiaDNcIiBhYnNvbHV0ZS8+XG4gICAgICAgICAgICA8L3NwYW4+ICBcbiAgICAgICAgey9pZn1cbiAgICA8L3NwYW4+XG48L3A+XG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IE1lZGlhIH0gZnJvbSAnLi4vY29tcG9uZW50cydcblxuICAgIGV4cG9ydCBsZXQgaXRlbXNcbjwvc2NyaXB0PlxuXG48TWVkaWEge2l0ZW1zfS8+XG5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgQnIgfSBmcm9tICdAY29tcG9uZW50cydcbiAgICBpbXBvcnQge1xuICAgICAgICBUb3BDYXJvdXNlbCxcbiAgICAgICAgUXVpY2tJbmZvQ2FyZCxcbiAgICAgICAgT3JnYW5pemF0aW9uQnV0dG9uLFxuICAgIH0gZnJvbSAnLi4vY29tcG9uZW50cydcblxuICAgIGV4cG9ydCBsZXQgY2FyZFRvcFxuICAgIGV4cG9ydCBsZXQgY2Fyb3VzZWxUb3BcbiAgICBleHBvcnQgbGV0IG9yZ2FuaXphdGlvblxuPC9zY3JpcHQ+XG5cbjxUb3BDYXJvdXNlbCBpdGVtcz17Y2Fyb3VzZWxUb3B9Lz5cbjxCciBzaXplPVwiNDBcIi8+XG5cbjxPcmdhbml6YXRpb25CdXR0b24gaWQ9e29yZ2FuaXphdGlvbi5pZH0gc3JjPXtvcmdhbml6YXRpb24uYXZhdGFyfSB0aXRsZT17b3JnYW5pemF0aW9uLm5hbWV9Lz5cbjxCciBzaXplPVwiMjBcIi8+XG5cbjxRdWlja0luZm9DYXJkIHtjYXJkVG9wfS8+IiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBEb2N1bWVudHMgfSBmcm9tICcuLi9jb21wb25lbnRzJ1xuXG4gICAgZXhwb3J0IGxldCBpdGVtc1xuPC9zY3JpcHQ+XG5cbjxEb2N1bWVudHMge2l0ZW1zfS8+XG5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgSG93VG9IZWxwIH0gZnJvbSAnLi4vY29tcG9uZW50cydcblxuICAgIGV4cG9ydCBsZXQgZGF0YVxuPC9zY3JpcHQ+XG5cbjxIb3dUb0hlbHAge2RhdGF9Lz5cblxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBBbmltYWxDYXJkIH0gZnJvbSAnLi4vY29tcG9uZW50cydcblxuICAgIGV4cG9ydCBsZXQgYW5pbWFsID0gdW5kZWZpbmVkXG48L3NjcmlwdD5cblxuPEFuaW1hbENhcmQge2FuaW1hbH0vPlxuXG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IERlc2NyaXB0aW9uIH0gZnJvbSAnLi4vY29tcG9uZW50cydcblxuICAgIGV4cG9ydCBsZXQgdGl0bGUgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IHRleHQgPSB1bmRlZmluZWRcbjwvc2NyaXB0PlxuXG48RGVzY3JpcHRpb24ge3RpdGxlfSB7dGV4dH0vPlxuXG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJ3N2ZWx0ZSdcbiAgICBpbXBvcnQgeyBzYWZlR2V0IH0gZnJvbSAnQHV0aWxzJ1xuICAgIGltcG9ydCB7IEVkaXRDYXJkLCBGb3JtQnVpbGRlciB9IGZyb20gJ0Bjb21wb25lbnRzJ1xuXG4gICAgZXhwb3J0IGxldCBkYXRhID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCBzdWJtaXQgPSBhc3luYyAoKSA9PiB7fVxuXG4gICAgY29uc3QgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXIoKVxuXG4gICAgY29uc3QgZGVmYXVsdEZpZWxkID0ge1xuICAgICAgICBsYWJlbDogJ9CS0ZbQtNC10L4gMTonLFxuICAgICAgICB0eXBlOiAndXJsJyxcbiAgICAgICAgbmFtZTogJ3ZpZGVvc1swXS5zcmMnLFxuICAgICAgICBtZXRhOiB7XG4gICAgICAgICAgICBwbGFjZWhvbGRlcjogJ2h0dHBzOi8vd3d3LnlvdXR1YmUuY29tL3dhdGNoP3Y9b1VjQVV3cHRvczQmdCcsXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAkOiBjdXJyZW50VmFsdWVzID0gZGF0YSB8fCB7fVxuICAgICQ6IGZvcm1WYWx1ZXMgPSBkYXRhIHx8IHt9XG4gICAgJDogZm9ybUVycm9ycyA9IHt9XG4gICAgJDogZmllbGRzQW1vdW50ID0gc2FmZUdldCgoKSA9PiBjdXJyZW50VmFsdWVzLnZpZGVvcy5maWx0ZXIodiA9PiB2LnNyYykubGVuZ3RoLCAwLCB0cnVlKVxuICAgICQ6IGZvcm1GaWVsZHMgPSBBcnJheS5mcm9tKG5ldyBBcnJheShNYXRoLm1heCgyLCBmaWVsZHNBbW91bnQgKyAxKSkpLm1hcCgoZiwgaSkgPT4gKHtcbiAgICAgICAgLi4uZGVmYXVsdEZpZWxkLFxuICAgICAgICBsYWJlbDogYNCS0ZbQtNC10L4gJHtpICsgMX06YCxcbiAgICAgICAgbmFtZTogYHZpZGVvc1ske2l9XS5zcmNgLFxuICAgIH0pKVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gb25TdWJtaXQoZSkge1xuICAgICAgICBhd2FpdCBzdWJtaXQoZSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzaGlmdFZhbHVlcyh2YWx1ZXMpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4udmFsdWVzLFxuICAgICAgICAgIHZpZGVvczogc2FmZUdldCgoKSA9PiB2YWx1ZXMudmlkZW9zLmZpbHRlcih2ID0+IHYuc3JjKSwgW10pXG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25DaGFuZ2UoeyBkZXRhaWw6IHsgdmFsdWVzIH0gfSkge1xuICAgICAgICBjdXJyZW50VmFsdWVzID0gc2hpZnRWYWx1ZXModmFsdWVzKVxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBzYWZlR2V0KCgpID0+IGN1cnJlbnRWYWx1ZXMudmlkZW9zLmxlbmd0aCkgIT09XG4gICAgICAgICAgICBzYWZlR2V0KCgpID0+IGZvcm1WYWx1ZXMudmlkZW9zLmxlbmd0aClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBmb3JtVmFsdWVzID0gY3VycmVudFZhbHVlc1xuICAgICAgICB9XG4gICAgICAgIGRpc3BhdGNoKCdjaGFuZ2UnLCB2YWx1ZXMpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25DYW5jZWwoKSB7XG4gICAgICAgIGN1cnJlbnRWYWx1ZXMgPSBkYXRhXG4gICAgICAgIGZvcm1WYWx1ZXMgPSBkYXRhXG4gICAgICAgIGRpc3BhdGNoKCdjYW5jZWwnKVxuICAgIH1cbjwvc2NyaXB0PlxuXG48RWRpdENhcmQgZm9ybT1cInZpZGVvcy1mb3JtXCIgb246Y2FuY2VsPXtvbkNhbmNlbH0+XG4gICAgPEZvcm1CdWlsZGVyIFxuICAgICAgICBpZD1cInZpZGVvcy1mb3JtXCJcbiAgICAgICAgaXRlbXM9e2Zvcm1GaWVsZHN9XG4gICAgICAgIGRhdGE9e2Zvcm1WYWx1ZXN9XG4gICAgICAgIGVycm9ycz17Zm9ybUVycm9yc31cbiAgICAgICAgc3VibWl0PXtvblN1Ym1pdH1cbiAgICAgICAgb246Y2hhbmdlPXtvbkNoYW5nZX1cbiAgICAvPlxuPC9FZGl0Q2FyZD5cblxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBjcmVhdGVFdmVudERpc3BhdGNoZXIgfSBmcm9tICdzdmVsdGUnXG4gICAgaW1wb3J0IHsgRWRpdENhcmQsIEZvcm1CdWlsZGVyIH0gZnJvbSAnQGNvbXBvbmVudHMnXG5cbiAgICBleHBvcnQgbGV0IGRhdGEgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IHN1Ym1pdCA9IGFzeW5jICgpID0+IHt9XG5cbiAgICBjb25zdCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpXG5cbiAgICBsZXQgZm9ybUZpZWxkcyA9IFtcbiAgICAgICAge1xuICAgICAgICAgICAgbGFiZWw6ICfQpNC+0YLQvtCz0LDQu9C10YDQtdGPOicsXG4gICAgICAgICAgICB0eXBlOiAnZmlsZXMnLFxuICAgICAgICAgICAgbmFtZTogJ3Bob3RvcycsXG4gICAgICAgICAgICBtZXRhOiB7XG4gICAgICAgICAgICAgICAgbXVsdGlwbGU6IHRydWUsXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxhYmVsOiAn0J7RgNCz0LDQvdGW0LfQsNGG0ZbRjzonLFxuICAgICAgICAgICAgdHlwZTogJ3NlbGVjdCcsXG4gICAgICAgICAgICBuYW1lOiAnb3JnYW5pemF0aW9uLmlkJyxcbiAgICAgICAgICAgIG1ldGE6IHtcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogJ9CS0LjQsdGA0LDRgtC4Li4uJyxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiAnb3JnMScsXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogJ9Ce0YDQs9Cw0L3RltC30LDRhtGW0Y8gMScsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiAnaWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICfQntGA0LPQsNC90ZbQt9Cw0YbRltGPIDInLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogJ29yZzMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICfQntGA0LPQsNC90ZbQt9Cw0YbRltGPIDMnLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBsYWJlbDogJ9Cd0LDQt9Cy0LAg0YTQvtC90LTRgzonLFxuICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgbmFtZTogJ3RpdGxlJyxcbiAgICAgICAgICAgIG1ldGE6IHtcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogJ9CS0YDRj9GC0YPRlNC80L4g0ZfRly4uLicsXG4gICAgICAgICAgICAgICAgbWF4bGVuZ3RoOiAyMCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxhYmVsOiAn0KbRltC70Ywg0YTQvtC90LTRgzonLFxuICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgbmFtZTogJ3N1YnRpdGxlJyxcbiAgICAgICAgICAgIG1ldGE6IHtcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogJ9Ci0ZbQu9GM0LrQuCDRgdC/0ZbQu9GM0L3QuNC80Lgg0YHQuNC70LDQvNC4Li4uJyxcbiAgICAgICAgICAgICAgICBtYXhsZW5ndGg6IDI1LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbGFiZWw6ICfQn9C+0YLRgNGW0LHQvdC+INC30ZbQsdGA0LDRgtC4OicsXG4gICAgICAgICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgICAgICAgIG5hbWU6ICduZWVkX3N1bScsXG4gICAgICAgICAgICBtZXRhOiB7XG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6IDEwLFxuICAgICAgICAgICAgICAgIG1pbjogMTAsXG4gICAgICAgICAgICAgICAgbWF4OiAxMDAwMDAwMDAsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIF1cblxuICAgICQ6IGZvcm1WYWx1ZXMgPSBkYXRhIHx8IHt9XG4gICAgJDogZm9ybUVycm9ycyA9IHt9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBvblN1Ym1pdChlKSB7XG4gICAgICAgIGF3YWl0IHN1Ym1pdChlKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uQ2FuY2VsKCkge1xuICAgICAgICBmb3JtVmFsdWVzID0gZGF0YVxuICAgICAgICBkaXNwYXRjaCgnY2FuY2VsJylcbiAgICB9XG48L3NjcmlwdD5cblxuPEVkaXRDYXJkIGZvcm09XCJ0b3AtaW5mby1mb3JtXCIgb246Y2FuY2VsPXtvbkNhbmNlbH0+XG4gICAgPEZvcm1CdWlsZGVyIFxuICAgICAgICBpZD1cInRvcC1pbmZvLWZvcm1cIlxuICAgICAgICBpdGVtcz17Zm9ybUZpZWxkc31cbiAgICAgICAgZGF0YT17Zm9ybVZhbHVlc31cbiAgICAgICAgZXJyb3JzPXtmb3JtRXJyb3JzfVxuICAgICAgICBzdWJtaXQ9e29uU3VibWl0fVxuICAgICAgICBvbjpjaGFuZ2VcbiAgICAvPlxuPC9FZGl0Q2FyZD4gICBcblxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBjcmVhdGVFdmVudERpc3BhdGNoZXIgfSBmcm9tICdzdmVsdGUnXG4gICAgaW1wb3J0IHsgRWRpdENhcmQsIEZvcm1CdWlsZGVyIH0gZnJvbSAnQGNvbXBvbmVudHMnXG5cbiAgICBleHBvcnQgbGV0IGRhdGEgPSB1bmRlZmluZWRcbiAgICBleHBvcnQgbGV0IHN1Ym1pdCA9IGFzeW5jICgpID0+IHt9XG5cbiAgICBjb25zdCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpXG5cbiAgICBsZXQgZm9ybUZpZWxkcyA9IFtcbiAgICAgICAge1xuICAgICAgICAgICAgbGFiZWw6ICfQlNC+0LrRg9C80LXQvdGC0Lg6JyxcbiAgICAgICAgICAgIHR5cGU6ICdmaWxlcycsXG4gICAgICAgICAgICBuYW1lOiAnZG9jdW1lbnRzJyxcbiAgICAgICAgICAgIG1ldGE6IHtcbiAgICAgICAgICAgICAgICBtdWx0aXBsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBhY2NlcHQ6ICdpbWFnZS9qcGVnLGltYWdlL3BuZyxhcHBsaWNhdGlvbi9wZGYnLFxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIF1cblxuICAgICQ6IGZvcm1WYWx1ZXMgPSBkYXRhIHx8IHt9XG4gICAgJDogZm9ybUVycm9ycyA9IHt9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBvblN1Ym1pdChlKSB7XG4gICAgICAgIGF3YWl0IHN1Ym1pdChlKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uQ2FuY2VsKCkge1xuICAgICAgICBmb3JtVmFsdWVzID0gZGF0YVxuICAgICAgICBkaXNwYXRjaCgnY2FuY2VsJylcbiAgICB9XG48L3NjcmlwdD5cblxuPEVkaXRDYXJkIGZvcm09XCJkb2N1bWVudHMtZm9ybVwiIG9uOmNhbmNlbD17b25DYW5jZWx9PlxuICAgIDxGb3JtQnVpbGRlciBcbiAgICAgICAgaWQ9XCJkb2N1bWVudHMtZm9ybVwiXG4gICAgICAgIGl0ZW1zPXtmb3JtRmllbGRzfVxuICAgICAgICBkYXRhPXtmb3JtVmFsdWVzfVxuICAgICAgICBlcnJvcnM9e2Zvcm1FcnJvcnN9XG4gICAgICAgIHN1Ym1pdD17b25TdWJtaXR9XG4gICAgICAgIG9uOmNoYW5nZVxuICAgIC8+XG48L0VkaXRDYXJkPiBcblxuXG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJ3N2ZWx0ZSdcbiAgICBpbXBvcnQgeyBmb3JtYXRUZXh0VG9CdWxsZXRzIH0gZnJvbSAnQHV0aWxzJ1xuICAgIGltcG9ydCB7IEVkaXRDYXJkLCBGb3JtQnVpbGRlciB9IGZyb20gJ0Bjb21wb25lbnRzJ1xuXG4gICAgZXhwb3J0IGxldCBkYXRhID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCBzdWJtaXQgPSBhc3luYyAoKSA9PiB7fVxuXG4gICAgY29uc3QgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXIoKVxuXG4gICAgbGV0IGZvcm1GaWVsZHMgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxhYmVsOiAn0K/QuiDQvNC+0LbQvdCwINC00L7Qv9C+0LzQvtCz0YLQuDonLFxuICAgICAgICAgICAgdHlwZTogJ3RleHRhcmVhJyxcbiAgICAgICAgICAgIG5hbWU6ICdob3dfdG9faGVscCcsXG4gICAgICAgICAgICBtZXRhOiB7XG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6ICfCtyDQn9GA0LjQstC10YHRgtC4INC60L7RgNC8JyxcbiAgICAgICAgICAgICAgICByb3dzOiA2LFxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIF1cblxuICAgICQ6IGZvcm1WYWx1ZXMgPSBkYXRhIHx8IHt9XG4gICAgJDogZm9ybUVycm9ycyA9IHt9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBvblN1Ym1pdChlKSB7XG4gICAgICAgIGF3YWl0IHN1Ym1pdChlKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uQ2FuY2VsKCkge1xuICAgICAgICBmb3JtVmFsdWVzID0gZGF0YVxuICAgICAgICBkaXNwYXRjaCgnY2FuY2VsJylcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBiZWZvcmVGb3JtQ2hhbmdlKHZhbHVlcykge1xuICAgICAgICB2YWx1ZXMuaG93X3RvX2hlbHAgPSBmb3JtYXRUZXh0VG9CdWxsZXRzKHZhbHVlcy5ob3dfdG9faGVscClcbiAgICAgICAgcmV0dXJuIHZhbHVlc1xuICAgIH1cbjwvc2NyaXB0PlxuXG48RWRpdENhcmQgZm9ybT1cImhvd3RvaGVscC1mb3JtXCIgb246Y2FuY2VsPXtvbkNhbmNlbH0+XG4gICAgPEZvcm1CdWlsZGVyIFxuICAgICAgICBpZD1cImhvd3RvaGVscC1mb3JtXCJcbiAgICAgICAgaXRlbXM9e2Zvcm1GaWVsZHN9XG4gICAgICAgIGRhdGE9e2Zvcm1WYWx1ZXN9XG4gICAgICAgIGVycm9ycz17Zm9ybUVycm9yc31cbiAgICAgICAgc3VibWl0PXtvblN1Ym1pdH1cbiAgICAgICAgYmVmb3JlQ2hhbmdlPXtiZWZvcmVGb3JtQ2hhbmdlfVxuICAgICAgICBvbjpjaGFuZ2VcbiAgICAvPlxuPC9FZGl0Q2FyZD4gXG5cblxuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBjcmVhdGVFdmVudERpc3BhdGNoZXIgfSBmcm9tICdzdmVsdGUnXG4gICAgaW1wb3J0IHsgb3B0aW9ucyB9IGZyb20gJ0Bjb25maWcnXG4gICAgaW1wb3J0IHsgQnIsIFNxdWFyZSwgUmFkaW9SZWN0LCBTdG9yeUxpc3QsIEVkaXRDYXJkLCBGb3JtQnVpbGRlciB9IGZyb20gJ0Bjb21wb25lbnRzJ1xuXG4gICAgZXhwb3J0IGxldCBkYXRhID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCBzdWJtaXQgPSBhc3luYyAoKSA9PiB7fVxuXG4gICAgY29uc3QgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXIoKVxuXG4gICAgbGV0IGZvcm1GaWVsZHMgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6ICdhdmF0YXInLFxuICAgICAgICAgICAgbmFtZTogJ2F2YXRhcicsXG4gICAgICAgICAgICBtZXRhOiB7XG4gICAgICAgICAgICAgICAgYWNjZXB0OiAnaW1hZ2UvanBlZyxpbWFnZS9wbmcnLFxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBsYWJlbDogJ9Ca0LvQuNGH0LrQsDonLFxuICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgbmFtZTogJ25hbWUnLFxuICAgICAgICAgICAgbWV0YToge1xuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiAn0JvQvtC60ZYuLi4nLFxuICAgICAgICAgICAgICAgIG1heGxlbmd0aDogMjAsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBsYWJlbDogJ9Cf0L7RgNC+0LTQsDonLFxuICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgbmFtZTogJ2JyZWVkJyxcbiAgICAgICAgICAgIG1ldGE6IHtcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogJ9Cb0LDQsdGA0LDQtNC+0YAuLi4nLFxuICAgICAgICAgICAgICAgIG1heGxlbmd0aDogMjAsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBsYWJlbDogJ9CU0LXQvdGMINC90LDRgNC+0LTQttC10L3QvdGPOicsXG4gICAgICAgICAgICB0eXBlOiAnZGF0ZScsXG4gICAgICAgICAgICBuYW1lOiAnYmlydGgnLFxuICAgICAgICAgICAgbWV0YToge1xuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiAnMTguMDMuMjAxOS4uLicsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBsYWJlbDogJ9Ch0YLQsNGC0Yw6JyxcbiAgICAgICAgICAgIHR5cGU6ICdyYWRpby1yZWN0JyxcbiAgICAgICAgICAgIG5hbWU6ICdzZXgnLFxuICAgICAgICAgICAgbWV0YToge1xuICAgICAgICAgICAgICAgIG9wdGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICfQktGW0L0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICdtYWxlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZUljb246ICdjaGVjay1mbGFnJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICfQktC+0L3QsCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogJ2ZlbWFsZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVJY29uOiAnY2hlY2stZmxhZycsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBsYWJlbDogJ9Ch0YLQtdGA0LjQu9GW0LfQsNGG0ZbRjz8nLFxuICAgICAgICAgICAgdHlwZTogJ3JhZGlvLXJlY3QnLFxuICAgICAgICAgICAgbmFtZTogJ3N0ZXJpbGl6YXRpb24nLFxuICAgICAgICAgICAgbWV0YToge1xuICAgICAgICAgICAgICAgIG9wdGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICfQotCw0LonLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVJY29uOiAnY2hlY2stZmxhZycsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiAn0J3RlicsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVJY29uOiAnY2xvc2UnLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbGFiZWw6ICfQpdCw0YDQsNC60YLQtdGAOicsXG4gICAgICAgICAgICB0eXBlOiAnY3VzdG9tLWNoYXJhY3RlcicsXG4gICAgICAgICAgICBuYW1lOiAnY2hhcmFjdGVyX3Nob3J0JyxcbiAgICAgICAgICAgIG1ldGE6IHtcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiAn8J+YgycsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogJ/CfmIMnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogJ/CfmIcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICfwn5iHJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICfwn5icJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiAn8J+YnCcsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiAn8J+YjicsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogJ/CfmI4nLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogJ/CfmJ0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICfwn5idJyxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxhYmVsOiAn0J7Qv9C40YEg0YXQsNGA0LDQutGC0LXRgNGDOicsXG4gICAgICAgICAgICB0eXBlOiAndGV4dGFyZWEnLFxuICAgICAgICAgICAgbmFtZTogJ2NoYXJhY3RlcicsXG4gICAgICAgICAgICBtZXRhOiB7XG4gICAgICAgICAgICAgICAgcm93czogNixcbiAgICAgICAgICAgICAgICBtYXhsZW5ndGg6IDc1LFxuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiAn0JPRgNCw0LnQu9C40LLQuNC5INGC0LAg0LLQtdGB0LXQu9C40Lkg0L/QtdGB0LjQui4uLicsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBsYWJlbDogJ9CG0YHRgtC+0YDRltGPINC20LjRgtGC0Y86JyxcbiAgICAgICAgICAgIHR5cGU6ICdjdXN0b20tbGlmZXN0b3J5JyxcbiAgICAgICAgICAgIG5hbWU6ICdsaWZlc3RvcnknLFxuICAgICAgICAgICAgbWV0YToge1xuICAgICAgICAgICAgICAgIG1heDogMTAwLFxuICAgICAgICAgICAgICAgIG1heGxlbmd0aDogNzUsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBsYWJlbDogJ9CS0LDQutGG0LjQvdCw0YbRltGPOicsXG4gICAgICAgICAgICB0eXBlOiAnY2hlY2tib3gnLFxuICAgICAgICAgICAgbmFtZTogJ3ZhY2NpbmF0aW9uJyxcbiAgICAgICAgICAgIG1ldGE6IHtcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zLnZhY2NpbmF0aW9uc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICBdXG5cbiAgICAkOiBmb3JtVmFsdWVzID0gZGF0YSB8fCB7fVxuICAgICQ6IGZvcm1FcnJvcnMgPSB7fVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gb25TdWJtaXQoZSkge1xuICAgICAgICBhd2FpdCBzdWJtaXQoZSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkNhbmNlbCgpIHtcbiAgICAgICAgZm9ybVZhbHVlcyA9IGRhdGFcbiAgICAgICAgZGlzcGF0Y2goJ2NhbmNlbCcpXG4gICAgfVxuPC9zY3JpcHQ+XG5cbjxFZGl0Q2FyZCBmb3JtPVwiYW5pbWFsLWZvcm1cIiBvbjpjYW5jZWw9e29uQ2FuY2VsfT5cbiAgICA8Rm9ybUJ1aWxkZXIgXG4gICAgICAgIGlkPVwiYW5pbWFsLWZvcm1cIlxuICAgICAgICBpdGVtcz17Zm9ybUZpZWxkc31cbiAgICAgICAgZGF0YT17Zm9ybVZhbHVlc31cbiAgICAgICAgZXJyb3JzPXtmb3JtRXJyb3JzfVxuICAgICAgICBzdWJtaXQ9e29uU3VibWl0fVxuICAgICAgICBvbjpjaGFuZ2VcbiAgICAgICAgbGV0Oml0ZW09e2l0ZW19XG4gICAgICAgIGxldDp2YWx1ZT17dmFsdWV9XG4gICAgICAgIGxldDpvbkNoYW5nZT17b25DaGFuZ2V9XG4gICAgPlxuICAgICAgICB7I2lmIGl0ZW0udHlwZSA9PT0gJ2N1c3RvbS1jaGFyYWN0ZXInfVxuICAgICAgICAgICAgPHNlY3Rpb24+XG4gICAgICAgICAgICAgICAgPGgyIGNsYXNzPVwidGV4dC1sZWZ0XCI+XG4gICAgICAgICAgICAgICAgICAgIHsgaXRlbS5sYWJlbCB9XG4gICAgICAgICAgICAgICAgICAgIDxCciBzaXplPVwiMTBcIi8+XG4gICAgICAgICAgICAgICAgPC9oMj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZmxleCBmbGV4LWp1c3RpZnktY2VudGVyXCI+XG4gICAgICAgICAgICAgICAgICAgIDxSYWRpb1JlY3RcbiAgICAgICAgICAgICAgICAgICAgICAgIHsuLi5pdGVtLm1ldGF9XG4gICAgICAgICAgICAgICAgICAgICAgICB7dmFsdWV9XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lPXtpdGVtLm5hbWV9XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQ6aXRlbT17cmFkaW99XG4gICAgICAgICAgICAgICAgICAgICAgICBvbjpjaGFuZ2U9e29uQ2hhbmdlfVxuICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICA8U3F1YXJlIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPVwid2lkdGg6IGNhbGMoNDBweCArICg1MCAtIDQwKSAqICgoMTAwdncgLSAzMjBweCkgLyAoMzc1IC0gMzIwKSkpOyBtYXgtd2lkdGg6IDUwcHhcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiZmxleCBmbGV4LWFsaWduLWNlbnRlciBmbGV4LWp1c3RpZnktY2VudGVyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cIm1heC1mdWxsLWhlaWdodCBoMSBmbGV4LTEgZmxleCBmbGV4LWFsaWduLWNlbnRlciBmbGV4LWp1c3RpZnktY2VudGVyXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgcmFkaW8ubGFiZWwgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvU3F1YXJlPlxuICAgICAgICAgICAgICAgICAgICA8L1JhZGlvUmVjdD5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvc2VjdGlvbj5cblxuICAgICAgICB7OmVsc2UgaWYgaXRlbS50eXBlID09PSAnY3VzdG9tLWxpZmVzdG9yeSd9XG4gICAgICAgICAgICA8c2VjdGlvbj5cbiAgICAgICAgICAgICAgICA8U3RvcnlMaXN0XG4gICAgICAgICAgICAgICAgICAgIHsuLi5pdGVtLm1ldGF9XG4gICAgICAgICAgICAgICAgICAgIHt2YWx1ZX1cbiAgICAgICAgICAgICAgICAgICAgbmFtZT17aXRlbS5uYW1lfVxuICAgICAgICAgICAgICAgICAgICBsYWJlbD17aXRlbS5sYWJlbH1cbiAgICAgICAgICAgICAgICAgICAgb246Y2hhbmdlPXtvbkNoYW5nZX1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgPC9zZWN0aW9uPlxuICAgICAgICB7L2lmfVxuICAgIDwvRm9ybUJ1aWxkZXI+XG48L0VkaXRDYXJkPlxuXG5cbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgY3JlYXRlRXZlbnREaXNwYXRjaGVyIH0gZnJvbSAnc3ZlbHRlJ1xuICAgIGltcG9ydCB7IEVkaXRDYXJkLCBGb3JtQnVpbGRlciB9IGZyb20gJ0Bjb21wb25lbnRzJ1xuXG4gICAgZXhwb3J0IGxldCBkYXRhID0gdW5kZWZpbmVkXG4gICAgZXhwb3J0IGxldCBzdWJtaXQgPSBhc3luYyAoKSA9PiB7fVxuXG4gICAgY29uc3QgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXIoKVxuXG4gICAgbGV0IGZvcm1GaWVsZHMgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxhYmVsOiAn0KbRltC70Ywg0YTQvtC90LTRgzonLFxuICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgbmFtZTogJ3RpdGxlJyxcbiAgICAgICAgICAgIG1ldGE6IHtcbiAgICAgICAgICAgICAgICBkaXNhYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogJ9Ci0ZbQu9GM0LrQuCDRgdC/0ZbQu9GM0L3QuNC80Lgg0YHQuNC70LDQvNC4Li4uJyxcbiAgICAgICAgICAgICAgICBtYXhsZW5ndGg6IDI1LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbGFiZWw6ICfQntC/0LjRgSDRhNC+0L3QtNGDOicsXG4gICAgICAgICAgICB0eXBlOiAndGV4dGFyZWEnLFxuICAgICAgICAgICAgbmFtZTogJ2Rlc2NyaXB0aW9uJyxcbiAgICAgICAgICAgIG1ldGE6IHtcbiAgICAgICAgICAgICAgICByb3dzOiA2LFxuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiAn0KMg0L3QsNGBINC00L7QsdGA0LAg0LzQtdGC0LAuLi4nLFxuICAgICAgICAgICAgICAgIG1heDogMjUwLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICBdXG5cbiAgICAkOiBmb3JtVmFsdWVzID0gZGF0YSB8fCB7fVxuICAgICQ6IGZvcm1FcnJvcnMgPSB7fVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gb25TdWJtaXQoZSkge1xuICAgICAgICBhd2FpdCBzdWJtaXQoZSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkNhbmNlbCgpIHtcbiAgICAgICAgZm9ybVZhbHVlcyA9IGRhdGFcbiAgICAgICAgZGlzcGF0Y2goJ2NhbmNlbCcpXG4gICAgfVxuPC9zY3JpcHQ+XG5cbjxFZGl0Q2FyZCBmb3JtPVwiZGVzY3JpcHRpb24tZm9ybVwiIG9uOmNhbmNlbD17b25DYW5jZWx9PlxuICAgIDxGb3JtQnVpbGRlciBcbiAgICAgICAgaWQ9XCJkZXNjcmlwdGlvbi1mb3JtXCJcbiAgICAgICAgaXRlbXM9e2Zvcm1GaWVsZHN9XG4gICAgICAgIGRhdGE9e2Zvcm1WYWx1ZXN9XG4gICAgICAgIGVycm9ycz17Zm9ybUVycm9yc31cbiAgICAgICAgc3VibWl0PXtvblN1Ym1pdH1cbiAgICAgICAgb246Y2hhbmdlXG4gICAgLz5cbjwvRWRpdENhcmQ+ICBcblxuXG4iLCI8c2NyaXB0PlxuICAgIGltcG9ydCB7IHN0b3JlcyB9IGZyb20gJ0BzYXBwZXIvYXBwJ1xuICAgIGltcG9ydCB7IG9uTW91bnQgfSBmcm9tICdzdmVsdGUnXG4gICAgaW1wb3J0IHsgQVBJIH0gZnJvbSAnQHNlcnZpY2VzJ1xuICAgIGltcG9ydCB7IGRlbGF5LCBzYWZlR2V0LCBfIH0gZnJvbSAnQHV0aWxzJ1xuICAgIGltcG9ydCB7IFxuICAgICAgICBCciwgXG4gICAgICAgIEljb24sIFxuICAgICAgICBGb290ZXIsIFxuICAgICAgICBCdXR0b24sIFxuICAgICAgICBFZGl0QXJlYSwgXG4gICAgICAgIExhenlUb2dnbGUsXG4gICAgICAgIERvbmF0aW9uQnV0dG9uLFxuICAgIH0gZnJvbSAnQGNvbXBvbmVudHMnXG4gICAgaW1wb3J0IHtcbiAgICAgICAgVHJ1c3QsXG4gICAgICAgIFNoYXJlLFxuICAgICAgICBDb21tZW50cyxcbiAgICAgICAgRG9uYXRvcnMsXG4gICAgICAgIEludGVyYWN0aW9uSW5kaWNhdG9ycyxcbiAgICB9IGZyb20gJy4vY29tcG9uZW50cydcbiAgICBpbXBvcnQgeyBcbiAgICAgICAgVmlkZW9zVmlldyxcbiAgICAgICAgVG9wSW5mb1ZpZXcsXG4gICAgICAgIERvY3VtZW50c1ZpZXcsXG4gICAgICAgIEhvd1RvSGVscFZpZXcsXG4gICAgICAgIEFuaW1hbENhcmRWaWV3LFxuICAgICAgICBEZXNjcmlwdGlvblZpZXcsXG4gICAgfSBmcm9tICcuL3ZpZXcnXG4gICAgaW1wb3J0IHsgXG4gICAgICAgIFZpZGVvc0VkaXQsXG4gICAgICAgIFRvcEluZm9FZGl0LFxuICAgICAgICBEb2N1bWVudHNFZGl0LFxuICAgICAgICBIb3dUb0hlbHBFZGl0LFxuICAgICAgICBBbmltYWxDYXJkRWRpdCxcbiAgICAgICAgRGVzY3JpcHRpb25FZGl0LFxuICAgIH0gZnJvbSAnLi9lZGl0J1xuXG4gICAgY29uc3QgeyBwYWdlIH0gPSBzdG9yZXMoKVxuXG4gICAgbGV0IGNoYXJpdHlJZCA9ICRwYWdlLnBhcmFtcy5pZFxuICAgIGxldCBpc0VkaXRNb2RlID0gZmFsc2VcbiAgICBsZXQgaXNFZGl0ID0ge1xuICAgICAgICB0b3BJbmZvOiBmYWxzZSxcbiAgICAgICAgZGVzY3JpcHRpb246IGZhbHNlLFxuICAgICAgICB2aWRlb3M6IGZhbHNlLFxuICAgICAgICBkb2N1bWVudHM6IGZhbHNlLFxuICAgICAgICBob3dUb0hlbHA6IGZhbHNlLFxuICAgICAgICBhbmltYWxDYXJkOiBmYWxzZSxcbiAgICB9XG5cbiAgICAvLyBFbnRpdGllc1xuICAgIGxldCBjaGFyaXR5XG4gICAgbGV0IGNvbW1lbnRzXG4gICAgXG4gICAgJDogY2Fyb3VzZWxUb3AgPSBzYWZlR2V0KCgpID0+IGNoYXJpdHkuYXZhdGFycy5tYXAoKGEsIGkpID0+ICh7IHNyYzogYS5zcmMsIHNyY0JpZzogYS5zcmMyeCwgYWx0OiBhLnRpdGxlIH0pKSk7XG4gICAgJDogb3JnYW5pemF0aW9uID0gc2FmZUdldCgoKSA9PiBjaGFyaXR5Lm9yZ2FuaXphdGlvbiwge30pO1xuICAgICQ6IGNhcmRUb3AgPSBzYWZlR2V0KCgpID0+ICh7XG4gICAgICAgIHRpdGxlOiBjaGFyaXR5LnRpdGxlLFxuICAgICAgICBzdWJ0aXRsZTogY2hhcml0eS5zdWJ0aXRsZSxcbiAgICAgICAgY3VycmVudF9zdW06IGNoYXJpdHkuY3VycmVtdF9zdW0sXG4gICAgICAgIG5lZWRfc3VtOiBjaGFyaXR5Lm5lZWRfc3VtLFxuICAgICAgICBjdXJyZW5jeTogY2hhcml0eS5jdXJyZW5jeSxcbiAgICB9KSk7XG4gICAgJDogaWNvbnNMaW5lID0ge1xuICAgICAgICBsaWtlczogc2FmZUdldCgoKSA9PiBjaGFyaXR5Lmxpa2VzKSxcbiAgICAgICAgdmlld3M6IHNhZmVHZXQoKCkgPT4gY2hhcml0eS52aWV3cyksXG4gICAgfTtcbiAgICAkOiB0cnVzdCA9IHtcbiAgICAgICAgaXNMaWtlZDogc2FmZUdldCgoKSA9PiBjaGFyaXR5LmlzX2xpa2VkKSxcbiAgICB9O1xuICAgICQ6IGRlc2NyaXB0aW9uQmxvY2sgPSB7XG4gICAgICAgIHRpdGxlOiBzYWZlR2V0KCgpID0+IGNoYXJpdHkudGl0bGUpLFxuICAgICAgICBkZXNjcmlwdGlvbjogc2FmZUdldCgoKSA9PiBjaGFyaXR5LmRlc2NyaXB0aW9uKSxcbiAgICB9O1xuICAgICQ6IGFuaW1hbCA9IHNhZmVHZXQoKCkgPT4gKHtcbiAgICAgICAgYXZhdGFyOiBjaGFyaXR5LmFuaW1hbC5hdmF0YXJzWzBdLnNyYyxcbiAgICAgICAgbmFtZTogY2hhcml0eS5hbmltYWwubmFtZSxcbiAgICAgICAgYnJlZWQ6IGNoYXJpdHkuYW5pbWFsLmJyZWVkLFxuICAgICAgICBiaXJ0aDogY2hhcml0eS5hbmltYWwuYmlydGgsXG4gICAgICAgIGFnZTogKG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKSkgLSAobmV3IERhdGUoY2hhcml0eS5hbmltYWwuYmlydGgpLmdldEZ1bGxZZWFyKCkpLFxuICAgICAgICBzZXg6IGNoYXJpdHkuYW5pbWFsLnNleCxcbiAgICAgICAgc3RlcmlsaXphdGlvbjogY2hhcml0eS5hbmltYWwuc3RlcmlsaXphdGlvbixcbiAgICAgICAgY2hhcmFjdGVyOiBjaGFyaXR5LmFuaW1hbC5jaGFyYWN0ZXIsXG4gICAgICAgIGNoYXJhY3Rlcl9zaG9ydDogY2hhcml0eS5hbmltYWwuY2hhcmFjdGVyX3Nob3J0LFxuICAgICAgICBsaWZlc3Rvcnk6IGNoYXJpdHkuYW5pbWFsLmxpZmVzdG9yeS5tYXAobCA9PiAoeyAuLi5sLCBkYXRlOiBuZXcgRGF0ZShsLmRhdGUpLnRvTG9jYWxlRGF0ZVN0cmluZygpIH0pKSxcbiAgICAgICAgdmFjY2luYXRpb246IGNoYXJpdHkuYW5pbWFsLnZhY2NpbmF0aW9uLFxuICAgIH0pKTtcbiAgICAkOiBkb25hdG9ycyA9IHNhZmVHZXQoKCkgPT4gY2hhcml0eS5kb25hdG9ycy5tYXAoZCA9PiAoe1xuICAgICAgICBpZDogZC5pZCxcbiAgICAgICAgdGl0bGU6IGAke2QuY3VycmVuY3l9ICR7ZC5hbW91bnR9YCxcbiAgICAgICAgc3VidGl0bGU6IGQubmFtZSxcbiAgICAgICAgc3JjOiBkLmF2YXRhcixcbiAgICAgICAgc3JjMng6IGQuYXZhdGFyMngsXG4gICAgfSkpKTtcbiAgICAkOiBkb2N1bWVudHMgPSBzYWZlR2V0KCgpID0+IGNoYXJpdHkuZG9jdW1lbnRzLm1hcChkID0+ICh7XG4gICAgICAgIGlkOiBkLmlkLFxuICAgICAgICB0aXRsZTogZC50aXRsZSxcbiAgICAgICAgc3JjOiBkLnNyYyxcbiAgICAgICAgc3JjMng6IGQuc3JjMngsXG4gICAgfSkpKTtcbiAgICAkOiBtZWRpYSA9IHNhZmVHZXQoKCkgPT4gY2hhcml0eS5tZWRpYS5tYXAoZCA9PiAoe1xuICAgICAgICBpZDogZC5pZCxcbiAgICAgICAgYWx0OiBkLnRpdGxlLFxuICAgICAgICBzcmM6IGQuc3JjLFxuICAgICAgICBzcmNCaWc6IGQuc3JjMngsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBkLmRlc2NyaXB0aW9uLFxuICAgIH0pKSwgW10sIHRydWUpO1xuICAgICQ6IGhvd1RvSGVscCA9IHNhZmVHZXQoKCkgPT4gKHtcbiAgICAgICAgcGhvbmU6IGNoYXJpdHkub3JnYW5pemF0aW9uLnBob25lLFxuICAgICAgICBob3dfdG9faGVscDogY2hhcml0eS5ob3dfdG9faGVscCxcbiAgICB9KSk7XG4gICAgJDogY29tbWVudHNEYXRhID0ge1xuICAgICAgICBjb21tZW50czogc2FmZUdldCgoKSA9PiBjb21tZW50cy5tYXAoYyA9PiAoe1xuICAgICAgICAgICAgbGlrZXM6IGMubGlrZXMsXG4gICAgICAgICAgICBhdmF0YXI6IGNbJ2F1dGhvci5hdmF0YXInXSxcbiAgICAgICAgICAgIGF1dGhvcjogY1snYXV0aG9yLm5hbWUnXSxcbiAgICAgICAgICAgIGNvbW1lbnQ6IGMuY29tbWVudCxcbiAgICAgICAgICAgIGNoZWNrZWQ6IGMuY2hlY2tlZCxcbiAgICAgICAgICAgIHJlcGx5X3RvOiBjLnJlcGx5X3RvLFxuICAgICAgICAgICAgY3JlYXRlZF9hdDogYy5jcmVhdGVkX2F0LFxuICAgICAgICB9KSkpLFxuICAgIH07XG5cbiAgICBvbk1vdW50KGFzeW5jICgpID0+IHtcbiAgICAgICAgYXdhaXQgZGVsYXkoNTAwMClcbiAgICAgICAgY2hhcml0eSA9IGF3YWl0IEFQSS5nZXRGdW5kKGNoYXJpdHlJZClcbiAgICAgICAgY29tbWVudHMgPSBhd2FpdCBBUEkuZ2V0Q29tbWVudHMoKVxuICAgIH0pXG5cbiAgICBhc3luYyBmdW5jdGlvbiBvblN1Ym1pdChzZWN0aW9uLCB2YWx1ZXMpIHtcbiAgICAgICAgaXNFZGl0W3NlY3Rpb25dID0gZmFsc2VcbiAgICAgICAgY29uc29sZS5sb2codmFsdWVzKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uQ2FuY2VsKHNlY3Rpb24pIHtcbiAgICAgICAgaXNFZGl0W3NlY3Rpb25dID0gZmFsc2VcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvblRvZ2dsZU1vZGUoKSB7XG4gICAgICAgIGlzRWRpdE1vZGUgPSAhaXNFZGl0TW9kZVxuICAgICAgICBpZiAoIWlzRWRpdE1vZGUpIHtcbiAgICAgICAgICAgIGlzRWRpdCA9IHtcbiAgICAgICAgICAgICAgICB0b3BJbmZvOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogZmFsc2UsXG4gICAgICAgICAgICAgICAgdmlkZW9zOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBkb2N1bWVudHM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGhvd1RvSGVscDogZmFsc2UsXG4gICAgICAgICAgICAgICAgYW5pbWFsQ2FyZDogZmFsc2UsXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG48L3NjcmlwdD5cblxuPHN2ZWx0ZTpoZWFkPlxuICAgIDx0aXRsZT5DaGFyaXRpZnkgLSBDaGFyaXR5IHBhZ2UgYW5kIGRvbmF0ZS48L3RpdGxlPlxuPC9zdmVsdGU6aGVhZD5cblxuPERvbmF0aW9uQnV0dG9uLz5cblxuPHNlY3Rpb24gY2xhc3M9XCJjb250YWluZXIgdGhlbWUtYmctY29sb3Itc2Vjb25kYXJ5XCI+XG4gICAgPEJyIHNpemU9XCJ2YXIoLS1oZWFkZXItaGVpZ2h0KVwiLz5cblxuICAgIDxkaXYgY2xhc3M9XCJvdmVyZmxvdy1oaWRkZW5cIj5cbiAgICAgICAgPEJyIHNpemU9XCIzMFwiLz5cbiAgICAgICAgPEJ1dHRvbiBzaXplPVwic21hbGxcIiBpcz1cImluZm9cIiBvbjpjbGljaz17b25Ub2dnbGVNb2RlfT5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaDMgZm9udC1zZWNvbmRhcnkgZm9udC13LTUwMCBmbGV4IGZsZXgtYWxpZ24tY2VudGVyXCI+XG4gICAgICAgICAgICAgICAge2lzRWRpdE1vZGUgPyAn0JfQsdC10YDQtdCz0YLQuCcgOiAn0KDQtdC00LDQs9GD0LLQsNGC0LgnfVxuICAgICAgICAgICAgICAgIDxzPjwvcz5cbiAgICAgICAgICAgICAgICA8cz48L3M+XG4gICAgICAgICAgICAgICAgeyNpZiAhaXNFZGl0TW9kZX1cbiAgICAgICAgICAgICAgICAgICAgPEljb24gdHlwZT1cImVkaXRcIiBzaXplPVwic21hbGxcIiBpcz1cImxpZ2h0XCIvPlxuICAgICAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgIDwvQnV0dG9uPlxuICAgICAgICA8QnIgc2l6ZT1cIjMwXCIvPlxuICAgIDwvZGl2PlxuXG4gICAgPCEtLSBUb3AgaW5mbyAtLT5cbiAgICA8TGF6eVRvZ2dsZSBhY3RpdmU9e2lzRWRpdC50b3BJbmZvfT5cbiAgICAgICAgPEJyIHNpemU9XCIzMFwiLz5cbiAgICAgICAgPFRvcEluZm9FZGl0IFxuICAgICAgICAgICAgZGF0YT17eyAuLi5jYXJkVG9wLCBvcmdhbml6YXRpb24sIHBob3RvczogY2Fyb3VzZWxUb3AgfX1cbiAgICAgICAgICAgIHN1Ym1pdD17b25TdWJtaXQuYmluZChudWxsLCAndG9wSW5mbycpfSBcbiAgICAgICAgICAgIG9uOmNhbmNlbD17b25DYW5jZWwuYmluZChudWxsLCAndG9wSW5mbycpfSBcbiAgICAgICAgLz5cbiAgICA8L0xhenlUb2dnbGU+XG4gICAgPExhenlUb2dnbGUgYWN0aXZlPXshaXNFZGl0LnRvcEluZm99IG1vdW50ZWQgY2xhc3M9XCJmdWxsLWNvbnRhaW5lclwiPlxuICAgICAgICA8RWRpdEFyZWEgb246Y2xpY2s9eygpID0+IGlzRWRpdC50b3BJbmZvID0gIWlzRWRpdC50b3BJbmZvfSBvZmY9eyFpc0VkaXRNb2RlfT4gICAgXG4gICAgICAgICAgICA8QnIgc2l6ZT1cIjMwXCIvPlxuICAgICAgICAgICAgPFRvcEluZm9WaWV3IHtjYXJkVG9wfSB7Y2Fyb3VzZWxUb3B9IHtvcmdhbml6YXRpb259Lz5cbiAgICAgICAgPC9FZGl0QXJlYT5cbiAgICA8L0xhenlUb2dnbGU+XG4gICAgPCEtLSBFTkQ6IFRvcCBpbmZvIC0tPlxuXG4gICAgPEJyIHNpemU9XCIyMFwiLz5cbiAgICA8TGF6eVRvZ2dsZSBhY3RpdmU9eyFpc0VkaXRNb2RlfSBtb3VudGVkPlxuICAgICAgICA8SW50ZXJhY3Rpb25JbmRpY2F0b3JzIGxpa2VzPXtpY29uc0xpbmUubGlrZXN9IHZpZXdzPXtpY29uc0xpbmUudmlld3N9Lz5cbiAgICA8L0xhenlUb2dnbGU+XG4gICAgPEJyIHNpemU9XCI1MFwiLz5cblxuICAgIDwhLS0gRGVzY3JpcHRpb24gLS0+XG4gICAgPExhenlUb2dnbGUgYWN0aXZlPXtpc0VkaXQuZGVzY3JpcHRpb259PlxuICAgICAgICA8RGVzY3JpcHRpb25FZGl0IFxuICAgICAgICAgICAgZGF0YT17ZGVzY3JpcHRpb25CbG9ja31cbiAgICAgICAgICAgIHN1Ym1pdD17b25TdWJtaXQuYmluZChudWxsLCAnZGVzY3JpcHRpb24nKX1cbiAgICAgICAgICAgIG9uOmNhbmNlbD17b25DYW5jZWwuYmluZChudWxsLCAnZGVzY3JpcHRpb24nKX0gXG4gICAgICAgIC8+XG4gICAgPC9MYXp5VG9nZ2xlPlxuICAgIDxMYXp5VG9nZ2xlIGFjdGl2ZT17IWlzRWRpdC5kZXNjcmlwdGlvbn0gbW91bnRlZCBjbGFzcz1cImZ1bGwtY29udGFpbmVyXCI+XG4gICAgICAgIDxFZGl0QXJlYSBvbjpjbGljaz17KCkgPT4gaXNFZGl0LmRlc2NyaXB0aW9uID0gIWlzRWRpdC5kZXNjcmlwdGlvbn0gb2ZmPXshaXNFZGl0TW9kZX0+ICAgIFxuICAgICAgICAgICAgPEJyIHNpemU9XCIzMFwiLz5cbiAgICAgICAgICAgIDxEZXNjcmlwdGlvblZpZXcgdGl0bGU9e2Rlc2NyaXB0aW9uQmxvY2sudGl0bGV9IHRleHQ9e2Rlc2NyaXB0aW9uQmxvY2suZGVzY3JpcHRpb259Lz5cbiAgICAgICAgPC9FZGl0QXJlYT5cbiAgICA8L0xhenlUb2dnbGU+XG4gICAgPCEtLSBFTkQ6IERlc2NyaXB0aW9uIC0tPlxuXG4gICAgPEJyIHNpemU9XCIxMFwiLz5cbiAgICA8TGF6eVRvZ2dsZSBhY3RpdmU9eyFpc0VkaXRNb2RlfSBtb3VudGVkPlxuICAgICAgICA8U2hhcmUgLz5cbiAgICAgICAgPEJyIHNpemU9XCI0NVwiLz5cbiAgICAgICAgPFRydXN0IGFjdGl2ZT17dHJ1c3QuaXNMaWtlZH0vPlxuICAgIDwvTGF6eVRvZ2dsZT5cbiAgICA8QnIgc2l6ZT1cIjYwXCIvPlxuXG4gICAgPCEtLSBBbmltYWwgLS0+XG4gICAgPExhenlUb2dnbGUgYWN0aXZlPXtpc0VkaXQuYW5pbWFsQ2FyZH0+XG4gICAgICAgIDxBbmltYWxDYXJkRWRpdFxuICAgICAgICAgICAgZGF0YT17YW5pbWFsfVxuICAgICAgICAgICAgc3VibWl0PXtvblN1Ym1pdC5iaW5kKG51bGwsICdhbmltYWxDYXJkJyl9XG4gICAgICAgICAgICBvbjpjYW5jZWw9e29uQ2FuY2VsLmJpbmQobnVsbCwgJ2FuaW1hbENhcmQnKX0gXG4gICAgICAgIC8+XG4gICAgPC9MYXp5VG9nZ2xlPlxuICAgIDxMYXp5VG9nZ2xlIGFjdGl2ZT17IWlzRWRpdC5hbmltYWxDYXJkfSBtb3VudGVkIGNsYXNzPVwiZnVsbC1jb250YWluZXJcIj5cbiAgICAgICAgPEVkaXRBcmVhIG9uOmNsaWNrPXsoKSA9PiBpc0VkaXQuYW5pbWFsQ2FyZCA9ICFpc0VkaXQuYW5pbWFsQ2FyZH0gb2ZmPXshaXNFZGl0TW9kZX0+ICAgIFxuICAgICAgICAgICAgPEJyIHNpemU9XCIzMFwiLz5cbiAgICAgICAgICAgIDxBbmltYWxDYXJkVmlldyB7YW5pbWFsfS8+XG4gICAgICAgIDwvRWRpdEFyZWE+XG4gICAgPC9MYXp5VG9nZ2xlPlxuICAgIDwhLS0gRU5EOiBBbmltYWwgLS0+XG5cbiAgICA8QnIgc2l6ZT1cIjYwXCIvPlxuICAgIDxMYXp5VG9nZ2xlIGFjdGl2ZT17IWlzRWRpdE1vZGV9IG1vdW50ZWQ+XG4gICAgICAgIDxEb25hdG9ycyBpdGVtcz17ZG9uYXRvcnN9Lz5cbiAgICAgICAgPEJyIHNpemU9XCI2MFwiLz5cbiAgICA8L0xhenlUb2dnbGU+XG5cbiAgICA8IS0tIERvY3VtZW50cyAtLT5cbiAgICA8TGF6eVRvZ2dsZSBhY3RpdmU9e2lzRWRpdC5kb2N1bWVudHN9PlxuICAgICAgICA8RG9jdW1lbnRzRWRpdFxuICAgICAgICAgICAgZGF0YT17eyBkb2N1bWVudHMgfX1cbiAgICAgICAgICAgIHN1Ym1pdD17b25TdWJtaXQuYmluZChudWxsLCAnZG9jdW1lbnRzJyl9XG4gICAgICAgICAgICBvbjpjYW5jZWw9e29uQ2FuY2VsLmJpbmQobnVsbCwgJ2RvY3VtZW50cycpfSBcbiAgICAgICAgLz5cbiAgICA8L0xhenlUb2dnbGU+XG4gICAgPExhenlUb2dnbGUgYWN0aXZlPXshaXNFZGl0LmRvY3VtZW50c30gbW91bnRlZCBjbGFzcz1cImZ1bGwtY29udGFpbmVyXCI+XG4gICAgICAgIDxFZGl0QXJlYSBvbjpjbGljaz17KCkgPT4gaXNFZGl0LmRvY3VtZW50cyA9ICFpc0VkaXQuZG9jdW1lbnRzfSBvZmY9eyFpc0VkaXRNb2RlfT4gICAgXG4gICAgICAgICAgICA8QnIgc2l6ZT1cIjMwXCIvPlxuICAgICAgICAgICAgPERvY3VtZW50c1ZpZXcgaXRlbXM9e2RvY3VtZW50c30vPlxuICAgICAgICA8L0VkaXRBcmVhPlxuICAgIDwvTGF6eVRvZ2dsZT5cbiAgICA8IS0tIEVORDogRG9jdW1lbnRzIC0tPlxuICAgIFxuICAgIDxCciBzaXplPVwiNjBcIi8+IFxuICAgIFxuICAgIDwhLS0gVmlkZW9zIC0tPlxuICAgIDxMYXp5VG9nZ2xlIGFjdGl2ZT17aXNFZGl0LnZpZGVvc30+XG4gICAgICAgIDxWaWRlb3NFZGl0IFxuICAgICAgICAgICAgZGF0YT17eyB2aWRlb3M6IG1lZGlhIH19XG4gICAgICAgICAgICBzdWJtaXQ9e29uU3VibWl0LmJpbmQobnVsbCwgJ3ZpZGVvcycpfVxuICAgICAgICAgICAgb246Y2FuY2VsPXtvbkNhbmNlbC5iaW5kKG51bGwsICd2aWRlb3MnKX0gXG4gICAgICAgIC8+XG4gICAgPC9MYXp5VG9nZ2xlPlxuICAgIDxMYXp5VG9nZ2xlIGFjdGl2ZT17IWlzRWRpdC52aWRlb3N9IG1vdW50ZWQgY2xhc3M9XCJmdWxsLWNvbnRhaW5lclwiPlxuICAgICAgICA8RWRpdEFyZWEgb246Y2xpY2s9eygpID0+IGlzRWRpdC52aWRlb3MgPSAhaXNFZGl0LnZpZGVvc30gb2ZmPXshaXNFZGl0TW9kZX0+ICAgIFxuICAgICAgICAgICAgPEJyIHNpemU9XCIzMFwiLz5cbiAgICAgICAgICAgIDxWaWRlb3NWaWV3IGl0ZW1zPXttZWRpYX0vPlxuICAgICAgICA8L0VkaXRBcmVhPlxuICAgIDwvTGF6eVRvZ2dsZT5cbiAgICA8IS0tIEVORDogVmlkZW9zIC0tPlxuICAgIFxuICAgIDxCciBzaXplPVwiNjBcIi8+XG5cbiAgICA8IS0tIEhvdyB0byBoZWxwIC0tPlxuICAgIDxMYXp5VG9nZ2xlIGFjdGl2ZT17aXNFZGl0Lmhvd1RvSGVscH0+XG4gICAgICAgIDxIb3dUb0hlbHBFZGl0IFxuICAgICAgICAgICAgZGF0YT17aG93VG9IZWxwfVxuICAgICAgICAgICAgc3VibWl0PXtvblN1Ym1pdC5iaW5kKG51bGwsICdob3dUb0hlbHAnKX1cbiAgICAgICAgICAgIG9uOmNhbmNlbD17b25DYW5jZWwuYmluZChudWxsLCAnaG93VG9IZWxwJyl9IFxuICAgICAgICAvPlxuICAgIDwvTGF6eVRvZ2dsZT5cbiAgICA8TGF6eVRvZ2dsZSBhY3RpdmU9eyFpc0VkaXQuaG93VG9IZWxwfSBtb3VudGVkIGNsYXNzPVwiZnVsbC1jb250YWluZXJcIj5cbiAgICAgICAgPEVkaXRBcmVhIG9uOmNsaWNrPXsoKSA9PiBpc0VkaXQuaG93VG9IZWxwID0gIWlzRWRpdC5ob3dUb0hlbHB9IG9mZj17IWlzRWRpdE1vZGV9PiAgICBcbiAgICAgICAgICAgIDxCciBzaXplPVwiMzBcIi8+XG4gICAgICAgICAgICA8SG93VG9IZWxwVmlldyBkYXRhPXtob3dUb0hlbHB9Lz5cbiAgICAgICAgPC9FZGl0QXJlYT5cbiAgICA8L0xhenlUb2dnbGU+XG4gICAgPCEtLSBFTkQ6IEhvdyB0byBoZWxwIC0tPlxuXG4gICAgPEJyIHNpemU9XCI2MFwiLz5cbiAgICA8TGF6eVRvZ2dsZSBhY3RpdmU9eyFpc0VkaXRNb2RlfSBtb3VudGVkPlxuICAgICAgICA8Q29tbWVudHMgaXRlbXM9e2NvbW1lbnRzRGF0YS5jb21tZW50c30vPlxuICAgICAgICA8QnIgc2l6ZT1cIjYwXCIvPlxuICAgIDwvTGF6eVRvZ2dsZT5cblxuICAgIDxkaXYgY2xhc3M9XCJmdWxsLWNvbnRhaW5lclwiPlxuICAgICAgICA8Rm9vdGVyLz5cbiAgICA8L2Rpdj5cbiAgICA8QnIgc2l6ZT1cIjcwXCIvPlxuPC9zZWN0aW9uPlxuIl0sIm5hbWVzIjpbIl8uZmluZCIsIm9wdGlvbnMudmFjY2luYXRpb25zIiwic3RvcmVzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BR2UsS0FBSzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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Ozs7Ozs7MEJBTTRCLEdBQU0sSUFBQyxLQUFLOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztpRUFBWixHQUFNLElBQUMsS0FBSzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzJCQWFoQyxHQUFNLElBQUMsR0FBRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O21FQUFWLEdBQU0sSUFBQyxHQUFHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2lCQVd6QixHQUFNLElBQUMsR0FBRyxLQUFLLE1BQU07aUJBRWhCLEdBQU0sSUFBQyxHQUFHLEtBQUssUUFBUTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7aUJBWXhCLEdBQU0sSUFBQyxhQUFhOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MEJBaUJoQyxHQUFNLElBQUMsU0FBUzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztpRUFBaEIsR0FBTSxJQUFDLFNBQVM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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
